// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// LBListenerRuleSpec defines the desired state of LBListenerRule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "elbv2.aws.upbound.io",
    version = "v1beta2",
    kind = "LBListenerRule",
    plural = "lblistenerrules"
)]
#[kube(status = "LBListenerRuleStatus")]
pub struct LBListenerRuleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<LBListenerRuleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: LBListenerRuleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<LBListenerRuleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<LBListenerRuleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<LBListenerRulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<LBListenerRuleWriteConnectionSecretToRef>,
}

/// LBListenerRuleSpec defines the desired state of LBListenerRule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProvider {
    /// An Action block. Action blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<Vec<LBListenerRuleForProviderAction>>,
    /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub condition: Option<Vec<LBListenerRuleForProviderCondition>>,
    /// The ARN of the listener to which to attach the rule.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn: Option<String>,
    /// Reference to a LBListener in elbv2 to populate listenerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn_ref: Option<LBListenerRuleForProviderListenerArnRef>,
    /// Selector for a LBListener in elbv2 to populate listenerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn_selector: Option<LBListenerRuleForProviderListenerArnSelector>,
    /// The priority for the rule between 1 and 50000. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderAction {
    /// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateCognito"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_cognito: Option<LBListenerRuleForProviderActionAuthenticateCognito>,
    /// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateOidc"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_oidc: Option<LBListenerRuleForProviderActionAuthenticateOidc>,
    /// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fixedResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub fixed_response: Option<LBListenerRuleForProviderActionFixedResponse>,
    /// Configuration block for creating an action that distributes requests among one or more target groups.
    /// Specify only if type is forward.
    /// Cannot be specified with target_group_arn.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub forward: Option<LBListenerRuleForProviderActionForward>,
    /// Order for the action.
    /// The action with the lowest value for order is performed first.
    /// Valid values are between 1 and 50000.
    /// Defaults to the position in the list of actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub order: Option<f64>,
    /// Information for creating a redirect action. Required if type is redirect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub redirect: Option<LBListenerRuleForProviderActionRedirect>,
    /// ARN of the Target Group to which to route traffic.
    /// Specify only if type is forward and you want to route to a single target group.
    /// To route to one or more target groups, use a forward block instead.
    /// Cannot be specified with forward.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn_ref: Option<LBListenerRuleForProviderActionTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn_selector: Option<LBListenerRuleForProviderActionTargetGroupArnSelector>,
    /// The type of routing action. Valid values are forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognito {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The ARN of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArn"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn: Option<String>,
    /// Reference to a UserPool in cognitoidp to populate userPoolArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn_ref: Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRef>,
    /// Selector for a UserPool in cognitoidp to populate userPoolArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn_selector:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelector>,
    /// The ID of the Cognito user pool client.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientId"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id: Option<String>,
    /// Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id_ref:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRef>,
    /// Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id_selector:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelector>,
    /// The domain prefix or fully-qualified domain name of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain: Option<String>,
    /// Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomainRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain_ref:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRef>,
    /// Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomainSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain_selector:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelector>,
}

/// Reference to a UserPool in cognitoidp to populate userPoolArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPool in cognitoidp to populate userPoolArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateOidc {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The authorization endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authorizationEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub authorization_endpoint: Option<String>,
    /// The OAuth 2.0 client identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    #[builder(default, setter(strip_option))]
    pub client_id: Option<String>,
    /// The OAuth 2.0 client secret.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSecretSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub client_secret_secret_ref:
        Option<LBListenerRuleForProviderActionAuthenticateOidcClientSecretSecretRef>,
    /// The OIDC issuer identifier of the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub issuer: Option<String>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The token endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tokenEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub token_endpoint: Option<String>,
    /// The user info endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userInfoEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub user_info_endpoint: Option<String>,
}

/// The OAuth 2.0 client secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionAuthenticateOidcClientSecretSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionFixedResponse {
    /// The content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentType"
    )]
    #[builder(default, setter(strip_option))]
    pub content_type: Option<String>,
    /// The message body.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageBody"
    )]
    #[builder(default, setter(strip_option))]
    pub message_body: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

/// Configuration block for creating an action that distributes requests among one or more target groups.
/// Specify only if type is forward.
/// Cannot be specified with target_group_arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForward {
    /// The target group stickiness for the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub stickiness: Option<LBListenerRuleForProviderActionForwardStickiness>,
    /// One or more target group blocks.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group: Option<Vec<LBListenerRuleForProviderActionForwardTargetGroup>>,
}

/// The target group stickiness for the rule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardStickiness {
    /// The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub duration: Option<f64>,
    /// Indicates whether target group stickiness is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardTargetGroup {
    /// The Amazon Resource Name (ARN) of the target group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<LBListenerRuleForProviderActionForwardTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<LBListenerRuleForProviderActionForwardTargetGroupArnSelector>,
    /// The weight. The range is 0 to 999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a LBTargetGroup in elbv2 to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionForwardTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionForwardTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information for creating a redirect action. Required if type is redirect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionRedirect {
    /// The hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub host: Option<String>,
    /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// The port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<String>,
    /// The protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub query: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

/// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleForProviderActionTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderActionTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderActionTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderActionTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleForProviderActionTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderActionTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderActionTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderCondition {
    /// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub host_header: Option<LBListenerRuleForProviderConditionHostHeader>,
    /// HTTP headers to match. HTTP Header block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header: Option<LBListenerRuleForProviderConditionHttpHeader>,
    /// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRequestMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_request_method: Option<LBListenerRuleForProviderConditionHttpRequestMethod>,
    /// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pathPattern"
    )]
    #[builder(default, setter(strip_option))]
    pub path_pattern: Option<LBListenerRuleForProviderConditionPathPattern>,
    /// Query strings to match. Query String block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryString"
    )]
    #[builder(default, setter(strip_option))]
    pub query_string: Option<Vec<LBListenerRuleForProviderConditionQueryString>>,
    /// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    #[builder(default, setter(strip_option))]
    pub source_ip: Option<LBListenerRuleForProviderConditionSourceIp>,
}

/// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionHostHeader {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// HTTP headers to match. HTTP Header block fields documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionHttpHeader {
    /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a host-header condition instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaderName"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header_name: Option<String>,
    /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionHttpRequestMethod {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionPathPattern {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionQueryString {
    /// Query string key pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Query string value pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderConditionSourceIp {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Reference to a LBListener in elbv2 to populate listenerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderListenerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderListenerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderListenerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleForProviderListenerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderListenerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderListenerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderListenerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBListener in elbv2 to populate listenerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderListenerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleForProviderListenerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleForProviderListenerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleForProviderListenerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleForProviderListenerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderListenerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleForProviderListenerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProvider {
    /// An Action block. Action blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<Vec<LBListenerRuleInitProviderAction>>,
    /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub condition: Option<Vec<LBListenerRuleInitProviderCondition>>,
    /// The ARN of the listener to which to attach the rule.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn: Option<String>,
    /// Reference to a LBListener in elbv2 to populate listenerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn_ref: Option<LBListenerRuleInitProviderListenerArnRef>,
    /// Selector for a LBListener in elbv2 to populate listenerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn_selector: Option<LBListenerRuleInitProviderListenerArnSelector>,
    /// The priority for the rule between 1 and 50000. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderAction {
    /// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateCognito"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_cognito: Option<LBListenerRuleInitProviderActionAuthenticateCognito>,
    /// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateOidc"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_oidc: Option<LBListenerRuleInitProviderActionAuthenticateOidc>,
    /// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fixedResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub fixed_response: Option<LBListenerRuleInitProviderActionFixedResponse>,
    /// Configuration block for creating an action that distributes requests among one or more target groups.
    /// Specify only if type is forward.
    /// Cannot be specified with target_group_arn.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub forward: Option<LBListenerRuleInitProviderActionForward>,
    /// Order for the action.
    /// The action with the lowest value for order is performed first.
    /// Valid values are between 1 and 50000.
    /// Defaults to the position in the list of actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub order: Option<f64>,
    /// Information for creating a redirect action. Required if type is redirect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub redirect: Option<LBListenerRuleInitProviderActionRedirect>,
    /// ARN of the Target Group to which to route traffic.
    /// Specify only if type is forward and you want to route to a single target group.
    /// To route to one or more target groups, use a forward block instead.
    /// Cannot be specified with forward.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn_ref: Option<LBListenerRuleInitProviderActionTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn_selector: Option<LBListenerRuleInitProviderActionTargetGroupArnSelector>,
    /// The type of routing action. Valid values are forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognito {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The ARN of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArn"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn: Option<String>,
    /// Reference to a UserPool in cognitoidp to populate userPoolArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn_ref:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRef>,
    /// Selector for a UserPool in cognitoidp to populate userPoolArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn_selector:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelector>,
    /// The ID of the Cognito user pool client.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientId"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id: Option<String>,
    /// Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id_ref:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRef>,
    /// Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id_selector:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelector>,
    /// The domain prefix or fully-qualified domain name of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain: Option<String>,
    /// Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomainRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain_ref:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRef>,
    /// Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomainSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain_selector:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelector>,
}

/// Reference to a UserPool in cognitoidp to populate userPoolArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPool in cognitoidp to populate userPoolArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateOidc {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The authorization endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authorizationEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub authorization_endpoint: Option<String>,
    /// The OAuth 2.0 client identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    #[builder(default, setter(strip_option))]
    pub client_id: Option<String>,
    /// The OAuth 2.0 client secret.
    #[serde(rename = "clientSecretSecretRef")]
    pub client_secret_secret_ref:
        LBListenerRuleInitProviderActionAuthenticateOidcClientSecretSecretRef,
    /// The OIDC issuer identifier of the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub issuer: Option<String>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The token endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tokenEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub token_endpoint: Option<String>,
    /// The user info endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userInfoEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub user_info_endpoint: Option<String>,
}

/// The OAuth 2.0 client secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionAuthenticateOidcClientSecretSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionFixedResponse {
    /// The content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentType"
    )]
    #[builder(default, setter(strip_option))]
    pub content_type: Option<String>,
    /// The message body.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageBody"
    )]
    #[builder(default, setter(strip_option))]
    pub message_body: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

/// Configuration block for creating an action that distributes requests among one or more target groups.
/// Specify only if type is forward.
/// Cannot be specified with target_group_arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForward {
    /// The target group stickiness for the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub stickiness: Option<LBListenerRuleInitProviderActionForwardStickiness>,
    /// One or more target group blocks.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group: Option<Vec<LBListenerRuleInitProviderActionForwardTargetGroup>>,
}

/// The target group stickiness for the rule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardStickiness {
    /// The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub duration: Option<f64>,
    /// Indicates whether target group stickiness is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardTargetGroup {
    /// The Amazon Resource Name (ARN) of the target group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnSelector>,
    /// The weight. The range is 0 to 999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a LBTargetGroup in elbv2 to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionForwardTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionForwardTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information for creating a redirect action. Required if type is redirect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionRedirect {
    /// The hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub host: Option<String>,
    /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// The port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<String>,
    /// The protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub query: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

/// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleInitProviderActionTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderActionTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderActionTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderCondition {
    /// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub host_header: Option<LBListenerRuleInitProviderConditionHostHeader>,
    /// HTTP headers to match. HTTP Header block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header: Option<LBListenerRuleInitProviderConditionHttpHeader>,
    /// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRequestMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_request_method: Option<LBListenerRuleInitProviderConditionHttpRequestMethod>,
    /// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pathPattern"
    )]
    #[builder(default, setter(strip_option))]
    pub path_pattern: Option<LBListenerRuleInitProviderConditionPathPattern>,
    /// Query strings to match. Query String block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryString"
    )]
    #[builder(default, setter(strip_option))]
    pub query_string: Option<Vec<LBListenerRuleInitProviderConditionQueryString>>,
    /// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    #[builder(default, setter(strip_option))]
    pub source_ip: Option<LBListenerRuleInitProviderConditionSourceIp>,
}

/// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionHostHeader {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// HTTP headers to match. HTTP Header block fields documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionHttpHeader {
    /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a host-header condition instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaderName"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header_name: Option<String>,
    /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionHttpRequestMethod {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionPathPattern {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionQueryString {
    /// Query string key pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Query string value pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderConditionSourceIp {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Reference to a LBListener in elbv2 to populate listenerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderListenerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderListenerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderListenerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleInitProviderListenerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderListenerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderListenerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderListenerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBListener in elbv2 to populate listenerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderListenerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleInitProviderListenerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleInitProviderListenerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleInitProviderListenerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleInitProviderListenerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderListenerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleInitProviderListenerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRuleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRuleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRuleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRuleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<LBListenerRulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<LBListenerRulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBListenerRulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBListenerRulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBListenerRulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBListenerRulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// LBListenerRuleStatus defines the observed state of LBListenerRule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<LBListenerRuleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProvider {
    /// An Action block. Action blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<Vec<LBListenerRuleStatusAtProviderAction>>,
    /// The ARN of the rule (matches id)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub condition: Option<Vec<LBListenerRuleStatusAtProviderCondition>>,
    /// The ARN of the rule (matches arn)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The ARN of the listener to which to attach the rule.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "listenerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub listener_arn: Option<String>,
    /// The priority for the rule between 1 and 50000. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderAction {
    /// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateCognito"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_cognito: Option<LBListenerRuleStatusAtProviderActionAuthenticateCognito>,
    /// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticateOidc"
    )]
    #[builder(default, setter(strip_option))]
    pub authenticate_oidc: Option<LBListenerRuleStatusAtProviderActionAuthenticateOidc>,
    /// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fixedResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub fixed_response: Option<LBListenerRuleStatusAtProviderActionFixedResponse>,
    /// Configuration block for creating an action that distributes requests among one or more target groups.
    /// Specify only if type is forward.
    /// Cannot be specified with target_group_arn.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub forward: Option<LBListenerRuleStatusAtProviderActionForward>,
    /// Order for the action.
    /// The action with the lowest value for order is performed first.
    /// Valid values are between 1 and 50000.
    /// Defaults to the position in the list of actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub order: Option<f64>,
    /// Information for creating a redirect action. Required if type is redirect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub redirect: Option<LBListenerRuleStatusAtProviderActionRedirect>,
    /// ARN of the Target Group to which to route traffic.
    /// Specify only if type is forward and you want to route to a single target group.
    /// To route to one or more target groups, use a forward block instead.
    /// Cannot be specified with forward.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group_arn: Option<String>,
    /// The type of routing action. Valid values are forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionAuthenticateCognito {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The ARN of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolArn"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_arn: Option<String>,
    /// The ID of the Cognito user pool client.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolClientId"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_client_id: Option<String>,
    /// The domain prefix or fully-qualified domain name of the Cognito user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_domain: Option<String>,
}

/// Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionAuthenticateOidc {
    /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationRequestExtraParams"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_request_extra_params: Option<BTreeMap<String, String>>,
    /// The authorization endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authorizationEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub authorization_endpoint: Option<String>,
    /// The OAuth 2.0 client identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    #[builder(default, setter(strip_option))]
    pub client_id: Option<String>,
    /// The OIDC issuer identifier of the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub issuer: Option<String>,
    /// The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onUnauthenticatedRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub on_unauthenticated_request: Option<String>,
    /// The set of user claims to be requested from the IdP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The name of the cookie used to maintain session information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionCookieName"
    )]
    #[builder(default, setter(strip_option))]
    pub session_cookie_name: Option<String>,
    /// The maximum duration of the authentication session, in seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub session_timeout: Option<f64>,
    /// The token endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tokenEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub token_endpoint: Option<String>,
    /// The user info endpoint of the IdP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userInfoEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub user_info_endpoint: Option<String>,
}

/// Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionFixedResponse {
    /// The content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentType"
    )]
    #[builder(default, setter(strip_option))]
    pub content_type: Option<String>,
    /// The message body.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageBody"
    )]
    #[builder(default, setter(strip_option))]
    pub message_body: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

/// Configuration block for creating an action that distributes requests among one or more target groups.
/// Specify only if type is forward.
/// Cannot be specified with target_group_arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionForward {
    /// The target group stickiness for the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub stickiness: Option<LBListenerRuleStatusAtProviderActionForwardStickiness>,
    /// One or more target group blocks.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub target_group: Option<Vec<LBListenerRuleStatusAtProviderActionForwardTargetGroup>>,
}

/// The target group stickiness for the rule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionForwardStickiness {
    /// The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub duration: Option<f64>,
    /// Indicates whether target group stickiness is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionForwardTargetGroup {
    /// The Amazon Resource Name (ARN) of the target group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The weight. The range is 0 to 999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Information for creating a redirect action. Required if type is redirect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderActionRedirect {
    /// The hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub host: Option<String>,
    /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// The port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<String>,
    /// The protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub query: Option<String>,
    /// The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderCondition {
    /// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub host_header: Option<LBListenerRuleStatusAtProviderConditionHostHeader>,
    /// HTTP headers to match. HTTP Header block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header: Option<LBListenerRuleStatusAtProviderConditionHttpHeader>,
    /// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRequestMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_request_method: Option<LBListenerRuleStatusAtProviderConditionHttpRequestMethod>,
    /// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pathPattern"
    )]
    #[builder(default, setter(strip_option))]
    pub path_pattern: Option<LBListenerRuleStatusAtProviderConditionPathPattern>,
    /// Query strings to match. Query String block fields documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryString"
    )]
    #[builder(default, setter(strip_option))]
    pub query_string: Option<Vec<LBListenerRuleStatusAtProviderConditionQueryString>>,
    /// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    #[builder(default, setter(strip_option))]
    pub source_ip: Option<LBListenerRuleStatusAtProviderConditionSourceIp>,
}

/// Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionHostHeader {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// HTTP headers to match. HTTP Header block fields documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionHttpHeader {
    /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a host-header condition instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaderName"
    )]
    #[builder(default, setter(strip_option))]
    pub http_header_name: Option<String>,
    /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionHttpRequestMethod {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionPathPattern {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionQueryString {
    /// Query string key pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Query string value pattern to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBListenerRuleStatusAtProviderConditionSourceIp {
    /// Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}
