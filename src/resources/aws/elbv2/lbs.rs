// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// LBSpec defines the desired state of LB
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "elbv2.aws.upbound.io",
    version = "v1beta2",
    kind = "LB",
    plural = "lbs"
)]
#[kube(status = "LBStatus")]
pub struct LBSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<LBDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: LBForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<LBInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<LBProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<LBPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<LBWriteConnectionSecretToRef>,
}

/// LBSpec defines the desired state of LB
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProvider {
    /// Access Logs block. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub access_logs: Option<LBForProviderAccessLogs>,
    /// Client keep alive value in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientKeepAlive"
    )]
    #[builder(default, setter(strip_option))]
    pub client_keep_alive: Option<f64>,
    /// Connection Logs block. See below. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_logs: Option<LBForProviderConnectionLogs>,
    /// ID of the customer owned ipv4 pool to use for this load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerOwnedIpv4Pool"
    )]
    #[builder(default, setter(strip_option))]
    pub customer_owned_ipv4_pool: Option<String>,
    /// How the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are monitor, defensive (default), strictest.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "desyncMitigationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub desync_mitigation_mode: Option<String>,
    /// How traffic is distributed among the load balancer Availability Zones. Possible values are any_availability_zone (default), availability_zone_affinity, or partial_availability_zone_affinity. See   Availability Zone DNS affinity for additional details. Only valid for network type load balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordClientRoutingPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_client_routing_policy: Option<String>,
    /// Whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dropInvalidHeaderFields"
    )]
    #[builder(default, setter(strip_option))]
    pub drop_invalid_header_fields: Option<bool>,
    /// If true, cross-zone load balancing of the load balancer will be enabled. For network and gateway type load balancers, this feature is disabled by default (false). For application load balancer this feature is always enabled (true) and cannot be disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableCrossZoneLoadBalancing"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_cross_zone_load_balancing: Option<bool>,
    /// If true, deletion of the load balancer will be disabled via the AWS API. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableDeletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_deletion_protection: Option<bool>,
    /// Whether HTTP/2 is enabled in application load balancers. Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttp2"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http2: Option<bool>,
    /// Whether the two headers (x-amzn-tls-version and x-amzn-tls-cipher-suite), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type application. Defaults to false
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableTlsVersionAndCipherSuiteHeaders"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_tls_version_and_cipher_suite_headers: Option<bool>,
    /// Whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableWafFailOpen"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_waf_fail_open: Option<bool>,
    /// Whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in application load balancers. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableXffClientPort"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_xff_client_port: Option<bool>,
    /// Whether zonal shift is enabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableZonalShift"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_zonal_shift: Option<bool>,
    /// Whether inbound security group rules are enforced for traffic originating from a PrivateLink. Only valid for Load Balancers of type network. The possible values are on and off.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic"
    )]
    #[builder(default, setter(strip_option))]
    pub enforce_security_group_inbound_rules_on_private_link_traffic: Option<String>,
    /// Time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type application. Default: 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idleTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub idle_timeout: Option<f64>,
    /// If true, the LB will be internal. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub internal: Option<bool>,
    /// Type of IP addresses used by the subnets for your load balancer. The possible values depend upon the load balancer type: ipv4 (all load balancer types), dualstack (all load balancer types), and dualstack-without-public-ipv4 (type application only).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// Type of load balancer to create. Possible values are application, gateway, or network. The default value is application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loadBalancerType"
    )]
    #[builder(default, setter(strip_option))]
    pub load_balancer_type: Option<String>,
    /// Name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveHostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_host_header: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs: Option<Vec<LBForProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector: Option<LBForProviderSecurityGroupSelector>,
    /// List of security group IDs to assign to the LB. Only valid for Load Balancers of type application or network. For load balancers of type network security groups cannot be added if none are currently present, and cannot all be removed once added. If either of these conditions are met, this will force a recreation of the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Subnet mapping block. See below. For Load Balancers of type network subnet mappings can only be added.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_mapping: Option<Vec<LBForProviderSubnetMapping>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_refs: Option<Vec<LBForProviderSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_selector: Option<LBForProviderSubnetSelector>,
    /// List of subnet IDs to attach to the LB. For Load Balancers of type network subnets can only be added (see Availability Zones), deleting a subnet for load balancers of type network will force a recreation of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Determines how the load balancer modifies the X-Forwarded-For header in the HTTP request before sending the request to the target. The possible values are append, preserve, and remove. Only valid for Load Balancers of type application. The default is append.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "xffHeaderProcessingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub xff_header_processing_mode: Option<String>,
}

/// Access Logs block. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderAccessLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<LBForProviderAccessLogsBucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<LBForProviderAccessLogsBucketSelector>,
    /// Boolean to enable / disable access_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderAccessLogsBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderAccessLogsBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderAccessLogsBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderAccessLogsBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderAccessLogsBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderAccessLogsBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderAccessLogsBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderAccessLogsBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderAccessLogsBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderAccessLogsBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderAccessLogsBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderAccessLogsBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderAccessLogsBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderAccessLogsBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Connection Logs block. See below. Only valid for Load Balancers of type application.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderConnectionLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Boolean to enable / disable connection_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetMapping {
    /// Allocation ID of the Elastic IP address for an internet-facing load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationId"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_id: Option<String>,
    /// IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Address"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address: Option<String>,
    /// Private IPv4 address for an internal load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpv4Address"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ipv4_address: Option<String>,
    /// ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<LBForProviderSubnetMappingSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<LBForProviderSubnetMappingSubnetIdSelector>,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetMappingSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSubnetMappingSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetMappingSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSubnetMappingSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSubnetMappingSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetMappingSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetMappingSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetMappingSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSubnetMappingSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetMappingSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSubnetMappingSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSubnetMappingSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetMappingSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetMappingSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBForProviderSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBForProviderSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBForProviderSubnetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBForProviderSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBForProviderSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProvider {
    /// Access Logs block. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub access_logs: Option<LBInitProviderAccessLogs>,
    /// Client keep alive value in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientKeepAlive"
    )]
    #[builder(default, setter(strip_option))]
    pub client_keep_alive: Option<f64>,
    /// Connection Logs block. See below. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_logs: Option<LBInitProviderConnectionLogs>,
    /// ID of the customer owned ipv4 pool to use for this load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerOwnedIpv4Pool"
    )]
    #[builder(default, setter(strip_option))]
    pub customer_owned_ipv4_pool: Option<String>,
    /// How the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are monitor, defensive (default), strictest.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "desyncMitigationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub desync_mitigation_mode: Option<String>,
    /// How traffic is distributed among the load balancer Availability Zones. Possible values are any_availability_zone (default), availability_zone_affinity, or partial_availability_zone_affinity. See   Availability Zone DNS affinity for additional details. Only valid for network type load balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordClientRoutingPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_client_routing_policy: Option<String>,
    /// Whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dropInvalidHeaderFields"
    )]
    #[builder(default, setter(strip_option))]
    pub drop_invalid_header_fields: Option<bool>,
    /// If true, cross-zone load balancing of the load balancer will be enabled. For network and gateway type load balancers, this feature is disabled by default (false). For application load balancer this feature is always enabled (true) and cannot be disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableCrossZoneLoadBalancing"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_cross_zone_load_balancing: Option<bool>,
    /// If true, deletion of the load balancer will be disabled via the AWS API. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableDeletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_deletion_protection: Option<bool>,
    /// Whether HTTP/2 is enabled in application load balancers. Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttp2"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http2: Option<bool>,
    /// Whether the two headers (x-amzn-tls-version and x-amzn-tls-cipher-suite), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type application. Defaults to false
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableTlsVersionAndCipherSuiteHeaders"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_tls_version_and_cipher_suite_headers: Option<bool>,
    /// Whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableWafFailOpen"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_waf_fail_open: Option<bool>,
    /// Whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in application load balancers. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableXffClientPort"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_xff_client_port: Option<bool>,
    /// Whether zonal shift is enabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableZonalShift"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_zonal_shift: Option<bool>,
    /// Whether inbound security group rules are enforced for traffic originating from a PrivateLink. Only valid for Load Balancers of type network. The possible values are on and off.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic"
    )]
    #[builder(default, setter(strip_option))]
    pub enforce_security_group_inbound_rules_on_private_link_traffic: Option<String>,
    /// Time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type application. Default: 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idleTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub idle_timeout: Option<f64>,
    /// If true, the LB will be internal. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub internal: Option<bool>,
    /// Type of IP addresses used by the subnets for your load balancer. The possible values depend upon the load balancer type: ipv4 (all load balancer types), dualstack (all load balancer types), and dualstack-without-public-ipv4 (type application only).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// Type of load balancer to create. Possible values are application, gateway, or network. The default value is application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loadBalancerType"
    )]
    #[builder(default, setter(strip_option))]
    pub load_balancer_type: Option<String>,
    /// Name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveHostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_host_header: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs: Option<Vec<LBInitProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector: Option<LBInitProviderSecurityGroupSelector>,
    /// List of security group IDs to assign to the LB. Only valid for Load Balancers of type application or network. For load balancers of type network security groups cannot be added if none are currently present, and cannot all be removed once added. If either of these conditions are met, this will force a recreation of the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Subnet mapping block. See below. For Load Balancers of type network subnet mappings can only be added.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_mapping: Option<Vec<LBInitProviderSubnetMapping>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_refs: Option<Vec<LBInitProviderSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_selector: Option<LBInitProviderSubnetSelector>,
    /// List of subnet IDs to attach to the LB. For Load Balancers of type network subnets can only be added (see Availability Zones), deleting a subnet for load balancers of type network will force a recreation of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Determines how the load balancer modifies the X-Forwarded-For header in the HTTP request before sending the request to the target. The possible values are append, preserve, and remove. Only valid for Load Balancers of type application. The default is append.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "xffHeaderProcessingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub xff_header_processing_mode: Option<String>,
}

/// Access Logs block. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderAccessLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<LBInitProviderAccessLogsBucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<LBInitProviderAccessLogsBucketSelector>,
    /// Boolean to enable / disable access_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderAccessLogsBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderAccessLogsBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderAccessLogsBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderAccessLogsBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderAccessLogsBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderAccessLogsBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderAccessLogsBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderAccessLogsBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderAccessLogsBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderAccessLogsBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderAccessLogsBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderAccessLogsBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderAccessLogsBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderAccessLogsBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Connection Logs block. See below. Only valid for Load Balancers of type application.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderConnectionLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Boolean to enable / disable connection_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetMapping {
    /// Allocation ID of the Elastic IP address for an internet-facing load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationId"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_id: Option<String>,
    /// IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Address"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address: Option<String>,
    /// Private IPv4 address for an internal load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpv4Address"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ipv4_address: Option<String>,
    /// ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<LBInitProviderSubnetMappingSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<LBInitProviderSubnetMappingSubnetIdSelector>,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetMappingSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSubnetMappingSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetMappingSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSubnetMappingSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSubnetMappingSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetMappingSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetMappingSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetMappingSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSubnetMappingSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetMappingSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSubnetMappingSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSubnetMappingSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetMappingSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetMappingSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBInitProviderSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBInitProviderSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBInitProviderSubnetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBInitProviderSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBInitProviderSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<LBPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<LBPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LBPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LBPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LBPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LBPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// LBStatus defines the observed state of LB.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<LBStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBStatusAtProvider {
    /// Access Logs block. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub access_logs: Option<LBStatusAtProviderAccessLogs>,
    /// ARN of the load balancer (matches id).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// ARN suffix for use with CloudWatch Metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnSuffix")]
    #[builder(default, setter(strip_option))]
    pub arn_suffix: Option<String>,
    /// Client keep alive value in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientKeepAlive"
    )]
    #[builder(default, setter(strip_option))]
    pub client_keep_alive: Option<f64>,
    /// Connection Logs block. See below. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_logs: Option<LBStatusAtProviderConnectionLogs>,
    /// ID of the customer owned ipv4 pool to use for this load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerOwnedIpv4Pool"
    )]
    #[builder(default, setter(strip_option))]
    pub customer_owned_ipv4_pool: Option<String>,
    /// How the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are monitor, defensive (default), strictest.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "desyncMitigationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub desync_mitigation_mode: Option<String>,
    /// DNS name of the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default, setter(strip_option))]
    pub dns_name: Option<String>,
    /// How traffic is distributed among the load balancer Availability Zones. Possible values are any_availability_zone (default), availability_zone_affinity, or partial_availability_zone_affinity. See   Availability Zone DNS affinity for additional details. Only valid for network type load balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordClientRoutingPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_client_routing_policy: Option<String>,
    /// Whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dropInvalidHeaderFields"
    )]
    #[builder(default, setter(strip_option))]
    pub drop_invalid_header_fields: Option<bool>,
    /// If true, cross-zone load balancing of the load balancer will be enabled. For network and gateway type load balancers, this feature is disabled by default (false). For application load balancer this feature is always enabled (true) and cannot be disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableCrossZoneLoadBalancing"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_cross_zone_load_balancing: Option<bool>,
    /// If true, deletion of the load balancer will be disabled via the AWS API. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableDeletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_deletion_protection: Option<bool>,
    /// Whether HTTP/2 is enabled in application load balancers. Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttp2"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http2: Option<bool>,
    /// Whether the two headers (x-amzn-tls-version and x-amzn-tls-cipher-suite), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type application. Defaults to false
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableTlsVersionAndCipherSuiteHeaders"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_tls_version_and_cipher_suite_headers: Option<bool>,
    /// Whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableWafFailOpen"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_waf_fail_open: Option<bool>,
    /// Whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in application load balancers. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableXffClientPort"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_xff_client_port: Option<bool>,
    /// Whether zonal shift is enabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableZonalShift"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_zonal_shift: Option<bool>,
    /// Whether inbound security group rules are enforced for traffic originating from a PrivateLink. Only valid for Load Balancers of type network. The possible values are on and off.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic"
    )]
    #[builder(default, setter(strip_option))]
    pub enforce_security_group_inbound_rules_on_private_link_traffic: Option<String>,
    /// ARN of the load balancer (matches arn).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type application. Default: 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idleTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub idle_timeout: Option<f64>,
    /// If true, the LB will be internal. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub internal: Option<bool>,
    /// Type of IP addresses used by the subnets for your load balancer. The possible values depend upon the load balancer type: ipv4 (all load balancer types), dualstack (all load balancer types), and dualstack-without-public-ipv4 (type application only).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// Type of load balancer to create. Possible values are application, gateway, or network. The default value is application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loadBalancerType"
    )]
    #[builder(default, setter(strip_option))]
    pub load_balancer_type: Option<String>,
    /// Name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveHostHeader"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_host_header: Option<bool>,
    /// List of security group IDs to assign to the LB. Only valid for Load Balancers of type application or network. For load balancers of type network security groups cannot be added if none are currently present, and cannot all be removed once added. If either of these conditions are met, this will force a recreation of the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Subnet mapping block. See below. For Load Balancers of type network subnet mappings can only be added.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_mapping: Option<Vec<LBStatusAtProviderSubnetMapping>>,
    /// List of subnet IDs to attach to the LB. For Load Balancers of type network subnets can only be added (see Availability Zones), deleting a subnet for load balancers of type network will force a recreation of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// ARN of the load balancer (matches arn).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// Determines how the load balancer modifies the X-Forwarded-For header in the HTTP request before sending the request to the target. The possible values are append, preserve, and remove. Only valid for Load Balancers of type application. The default is append.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "xffHeaderProcessingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub xff_header_processing_mode: Option<String>,
    /// Canonical hosted zone ID of the load balancer (to be used in a Route 53 Alias record).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default, setter(strip_option))]
    pub zone_id: Option<String>,
}

/// Access Logs block. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBStatusAtProviderAccessLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Boolean to enable / disable access_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// Connection Logs block. See below. Only valid for Load Balancers of type application.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBStatusAtProviderConnectionLogs {
    /// S3 bucket name to store the logs in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Boolean to enable / disable connection_logs. Defaults to false, even when bucket is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// S3 bucket prefix. Logs are stored in the root if not configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LBStatusAtProviderSubnetMapping {
    /// Allocation ID of the Elastic IP address for an internet-facing load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationId"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_id: Option<String>,
    /// IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Address"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address: Option<String>,
    /// ID of the Outpost containing the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outpostId")]
    #[builder(default, setter(strip_option))]
    pub outpost_id: Option<String>,
    /// Private IPv4 address for an internal load balancer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpv4Address"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ipv4_address: Option<String>,
    /// ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
}
