// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// GrantSpec defines the desired state of Grant
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "kms.aws.upbound.io",
    version = "v1beta1",
    kind = "Grant",
    plural = "grants"
)]
#[kube(status = "GrantStatus")]
pub struct GrantSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<GrantDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: GrantForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<GrantInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<GrantProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<GrantPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<GrantWriteConnectionSecretToRef>,
}

/// GrantSpec defines the desired state of Grant
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProvider {
    /// A structure that you can use to allow certain operations in the grant only when the desired encryption context is present. For more information about encryption context, see Encryption Context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub constraints: Option<Vec<GrantForProviderConstraints>>,
    /// A list of grant tokens to be used when creating the grant. See Grant Tokens for more information about grant tokens.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grantCreationTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub grant_creation_tokens: Option<Vec<String>>,
    /// The principal that is given permission to perform the operations that the grant permits in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal: Option<String>,
    /// Reference to a Role in iam to populate granteePrincipal.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipalRef"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal_ref: Option<GrantForProviderGranteePrincipalRef>,
    /// Selector for a Role in iam to populate granteePrincipal.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipalSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal_selector: Option<GrantForProviderGranteePrincipalSelector>,
    /// The unique identifier for the customer master key (CMK) that the grant applies to. Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a different AWS account, you must use the key ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyId")]
    #[builder(default, setter(strip_option))]
    pub key_id: Option<String>,
    /// Reference to a Key in kms to populate keyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyIdRef")]
    #[builder(default, setter(strip_option))]
    pub key_id_ref: Option<GrantForProviderKeyIdRef>,
    /// Selector for a Key in kms to populate keyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "keyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub key_id_selector: Option<GrantForProviderKeyIdSelector>,
    /// A friendly name for identifying the grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of operations that the grant permits. The permitted values are: Decrypt, Encrypt, GenerateDataKey, GenerateDataKeyWithoutPlaintext, ReEncryptFrom, ReEncryptTo, Sign, Verify, GetPublicKey, CreateGrant, RetireGrant, DescribeKey, GenerateDataKeyPair, or GenerateDataKeyPairWithoutPlaintext.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub operations: Option<Vec<String>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// (Defaults to false, Forces new resources) If set to false (the default) the grants will be revoked upon deletion, and if set to true the grants will try to be retired upon deletion. Note that retiring grants requires special permissions, hence why we default to revoking grants.
    /// See RetireGrant for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retireOnDelete"
    )]
    #[builder(default, setter(strip_option))]
    pub retire_on_delete: Option<bool>,
    /// The principal that is given permission to retire the grant by using RetireGrant operation in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retiringPrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub retiring_principal: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderConstraints {
    /// A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with encryption_context_subset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextEquals"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_equals: Option<BTreeMap<String, String>>,
    /// A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with encryption_context_equals.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextSubset"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_subset: Option<BTreeMap<String, String>>,
}

/// Reference to a Role in iam to populate granteePrincipal.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderGranteePrincipalRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantForProviderGranteePrincipalRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderGranteePrincipalRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantForProviderGranteePrincipalRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantForProviderGranteePrincipalRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderGranteePrincipalRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderGranteePrincipalRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate granteePrincipal.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderGranteePrincipalSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantForProviderGranteePrincipalSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderGranteePrincipalSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantForProviderGranteePrincipalSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantForProviderGranteePrincipalSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderGranteePrincipalSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderGranteePrincipalSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate keyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantForProviderKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantForProviderKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantForProviderKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate keyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantForProviderKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantForProviderKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantForProviderKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantForProviderKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantForProviderKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProvider {
    /// A structure that you can use to allow certain operations in the grant only when the desired encryption context is present. For more information about encryption context, see Encryption Context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub constraints: Option<Vec<GrantInitProviderConstraints>>,
    /// A list of grant tokens to be used when creating the grant. See Grant Tokens for more information about grant tokens.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grantCreationTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub grant_creation_tokens: Option<Vec<String>>,
    /// The principal that is given permission to perform the operations that the grant permits in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal: Option<String>,
    /// Reference to a Role in iam to populate granteePrincipal.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipalRef"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal_ref: Option<GrantInitProviderGranteePrincipalRef>,
    /// Selector for a Role in iam to populate granteePrincipal.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipalSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal_selector: Option<GrantInitProviderGranteePrincipalSelector>,
    /// The unique identifier for the customer master key (CMK) that the grant applies to. Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a different AWS account, you must use the key ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyId")]
    #[builder(default, setter(strip_option))]
    pub key_id: Option<String>,
    /// Reference to a Key in kms to populate keyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyIdRef")]
    #[builder(default, setter(strip_option))]
    pub key_id_ref: Option<GrantInitProviderKeyIdRef>,
    /// Selector for a Key in kms to populate keyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "keyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub key_id_selector: Option<GrantInitProviderKeyIdSelector>,
    /// A friendly name for identifying the grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of operations that the grant permits. The permitted values are: Decrypt, Encrypt, GenerateDataKey, GenerateDataKeyWithoutPlaintext, ReEncryptFrom, ReEncryptTo, Sign, Verify, GetPublicKey, CreateGrant, RetireGrant, DescribeKey, GenerateDataKeyPair, or GenerateDataKeyPairWithoutPlaintext.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub operations: Option<Vec<String>>,
    /// (Defaults to false, Forces new resources) If set to false (the default) the grants will be revoked upon deletion, and if set to true the grants will try to be retired upon deletion. Note that retiring grants requires special permissions, hence why we default to revoking grants.
    /// See RetireGrant for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retireOnDelete"
    )]
    #[builder(default, setter(strip_option))]
    pub retire_on_delete: Option<bool>,
    /// The principal that is given permission to retire the grant by using RetireGrant operation in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retiringPrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub retiring_principal: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderConstraints {
    /// A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with encryption_context_subset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextEquals"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_equals: Option<BTreeMap<String, String>>,
    /// A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with encryption_context_equals.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextSubset"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_subset: Option<BTreeMap<String, String>>,
}

/// Reference to a Role in iam to populate granteePrincipal.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderGranteePrincipalRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantInitProviderGranteePrincipalRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderGranteePrincipalRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantInitProviderGranteePrincipalRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantInitProviderGranteePrincipalRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderGranteePrincipalRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderGranteePrincipalRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate granteePrincipal.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderGranteePrincipalSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantInitProviderGranteePrincipalSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderGranteePrincipalSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantInitProviderGranteePrincipalSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantInitProviderGranteePrincipalSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderGranteePrincipalSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderGranteePrincipalSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate keyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantInitProviderKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantInitProviderKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantInitProviderKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate keyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantInitProviderKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantInitProviderKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantInitProviderKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantInitProviderKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantInitProviderKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<GrantPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<GrantPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<GrantPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<GrantPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<GrantPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum GrantPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// GrantStatus defines the observed state of Grant.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<GrantStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantStatusAtProvider {
    /// A structure that you can use to allow certain operations in the grant only when the desired encryption context is present. For more information about encryption context, see Encryption Context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub constraints: Option<Vec<GrantStatusAtProviderConstraints>>,
    /// A list of grant tokens to be used when creating the grant. See Grant Tokens for more information about grant tokens.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grantCreationTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub grant_creation_tokens: Option<Vec<String>>,
    /// The unique identifier for the grant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grantId")]
    #[builder(default, setter(strip_option))]
    pub grant_id: Option<String>,
    /// The principal that is given permission to perform the operations that the grant permits in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "granteePrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub grantee_principal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The unique identifier for the customer master key (CMK) that the grant applies to. Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a different AWS account, you must use the key ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyId")]
    #[builder(default, setter(strip_option))]
    pub key_id: Option<String>,
    /// A friendly name for identifying the grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of operations that the grant permits. The permitted values are: Decrypt, Encrypt, GenerateDataKey, GenerateDataKeyWithoutPlaintext, ReEncryptFrom, ReEncryptTo, Sign, Verify, GetPublicKey, CreateGrant, RetireGrant, DescribeKey, GenerateDataKeyPair, or GenerateDataKeyPairWithoutPlaintext.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub operations: Option<Vec<String>>,
    /// (Defaults to false, Forces new resources) If set to false (the default) the grants will be revoked upon deletion, and if set to true the grants will try to be retired upon deletion. Note that retiring grants requires special permissions, hence why we default to revoking grants.
    /// See RetireGrant for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retireOnDelete"
    )]
    #[builder(default, setter(strip_option))]
    pub retire_on_delete: Option<bool>,
    /// The principal that is given permission to retire the grant by using RetireGrant operation in ARN format.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retiringPrincipal"
    )]
    #[builder(default, setter(strip_option))]
    pub retiring_principal: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct GrantStatusAtProviderConstraints {
    /// A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with encryption_context_subset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextEquals"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_equals: Option<BTreeMap<String, String>>,
    /// A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with encryption_context_equals.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionContextSubset"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_context_subset: Option<BTreeMap<String, String>>,
}
