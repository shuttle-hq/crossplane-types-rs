// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// PermissionsSpec defines the desired state of Permissions
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "lakeformation.aws.upbound.io",
    version = "v1beta2",
    kind = "Permissions",
    plural = "permissions"
)]
#[kube(status = "PermissionsStatus")]
pub struct PermissionsSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<PermissionsDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: PermissionsForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<PermissionsInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<PermissionsProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<PermissionsPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<PermissionsWriteConnectionSecretToRef>,
}

/// PermissionsSpec defines the desired state of Permissions
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProvider {
    /// –  Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Whether the permissions are to be granted for the Data Catalog. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogResource"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_resource: Option<bool>,
    /// Configuration block for a data cells filter resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataCellsFilter"
    )]
    #[builder(default, setter(strip_option))]
    pub data_cells_filter: Option<PermissionsForProviderDataCellsFilter>,
    /// Configuration block for a data location resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataLocation"
    )]
    #[builder(default, setter(strip_option))]
    pub data_location: Option<PermissionsForProviderDataLocation>,
    /// Configuration block for a database resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub database: Option<PermissionsForProviderDatabase>,
    /// Configuration block for an LF-tag resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lfTag")]
    #[builder(default, setter(strip_option))]
    pub lf_tag: Option<PermissionsForProviderLfTag>,
    /// Configuration block for an LF-tag policy resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lfTagPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub lf_tag_policy: Option<PermissionsForProviderLfTagPolicy>,
    /// –  List of permissions granted to the principal. Valid values may include ALL, ALTER, ASSOCIATE, CREATE_DATABASE, CREATE_TABLE, DATA_LOCATION_ACCESS, DELETE, DESCRIBE, DROP, INSERT, and SELECT. For details on each permission, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub permissions: Option<Vec<String>>,
    /// Subset of permissions which the principal can pass.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissionsWithGrantOption"
    )]
    #[builder(default, setter(strip_option))]
    pub permissions_with_grant_option: Option<Vec<String>>,
    /// account permissions. For more information, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub principal: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Configuration block for a table resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub table: Option<PermissionsForProviderTable>,
    /// Configuration block for a table with columns resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableWithColumns"
    )]
    #[builder(default, setter(strip_option))]
    pub table_with_columns: Option<PermissionsForProviderTableWithColumns>,
}

/// Configuration block for a data cells filter resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataCellsFilter {
    /// The name of the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The name of the data cells filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// The ID of the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableCatalogId"
    )]
    #[builder(default, setter(strip_option))]
    pub table_catalog_id: Option<String>,
    /// The name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    #[builder(default, setter(strip_option))]
    pub table_name: Option<String>,
}

/// Configuration block for a data location resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataLocation {
    /// –  Amazon Resource Name (ARN) that uniquely identifies the data location resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a Resource in lakeformation to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<PermissionsForProviderDataLocationArnRef>,
    /// Selector for a Resource in lakeformation to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<PermissionsForProviderDataLocationArnSelector>,
    /// Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
}

/// Reference to a Resource in lakeformation to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderDataLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderDataLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderDataLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDataLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDataLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Resource in lakeformation to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderDataLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDataLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderDataLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderDataLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDataLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDataLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for a database resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDatabase {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database resource. Unique to the Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<PermissionsForProviderDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<PermissionsForProviderDatabaseNameSelector>,
}

/// Reference to a CatalogDatabase in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for an LF-tag resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderLfTag {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// name for the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values an attribute can take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for an LF-tag policy resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderLfTagPolicy {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See expression below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<Vec<PermissionsForProviderLfTagPolicyExpression>>,
    /// –  The resource type for which the tag policy applies. Valid values are DATABASE and TABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderLfTagPolicyExpression {
    /// name of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for a table resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTable {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database for the table. Unique to a Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether to use a wildcard representing every table under a database. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}

/// Configuration block for a table with columns resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTableWithColumns {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Set of column names for the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "columnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub column_names: Option<Vec<String>>,
    /// –  Name of the database for the table with columns resource. Unique to the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Set of column names for the table to exclude.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedColumnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_column_names: Option<Vec<String>>,
    /// –  Name of the table resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a CatalogTable in glue to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<PermissionsForProviderTableWithColumnsNameRef>,
    /// Selector for a CatalogTable in glue to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<PermissionsForProviderTableWithColumnsNameSelector>,
    /// Whether to use a column wildcard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}

/// Reference to a CatalogTable in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTableWithColumnsNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderTableWithColumnsNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTableWithColumnsNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderTableWithColumnsNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderTableWithColumnsNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderTableWithColumnsNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderTableWithColumnsNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogTable in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTableWithColumnsNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsForProviderTableWithColumnsNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsForProviderTableWithColumnsNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsForProviderTableWithColumnsNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsForProviderTableWithColumnsNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderTableWithColumnsNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsForProviderTableWithColumnsNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProvider {
    /// –  Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Whether the permissions are to be granted for the Data Catalog. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogResource"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_resource: Option<bool>,
    /// Configuration block for a data cells filter resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataCellsFilter"
    )]
    #[builder(default, setter(strip_option))]
    pub data_cells_filter: Option<PermissionsInitProviderDataCellsFilter>,
    /// Configuration block for a data location resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataLocation"
    )]
    #[builder(default, setter(strip_option))]
    pub data_location: Option<PermissionsInitProviderDataLocation>,
    /// Configuration block for a database resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub database: Option<PermissionsInitProviderDatabase>,
    /// Configuration block for an LF-tag resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lfTag")]
    #[builder(default, setter(strip_option))]
    pub lf_tag: Option<PermissionsInitProviderLfTag>,
    /// Configuration block for an LF-tag policy resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lfTagPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub lf_tag_policy: Option<PermissionsInitProviderLfTagPolicy>,
    /// –  List of permissions granted to the principal. Valid values may include ALL, ALTER, ASSOCIATE, CREATE_DATABASE, CREATE_TABLE, DATA_LOCATION_ACCESS, DELETE, DESCRIBE, DROP, INSERT, and SELECT. For details on each permission, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub permissions: Option<Vec<String>>,
    /// Subset of permissions which the principal can pass.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissionsWithGrantOption"
    )]
    #[builder(default, setter(strip_option))]
    pub permissions_with_grant_option: Option<Vec<String>>,
    /// account permissions. For more information, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub principal: Option<String>,
    /// Configuration block for a table resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub table: Option<PermissionsInitProviderTable>,
    /// Configuration block for a table with columns resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableWithColumns"
    )]
    #[builder(default, setter(strip_option))]
    pub table_with_columns: Option<PermissionsInitProviderTableWithColumns>,
}

/// Configuration block for a data cells filter resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataCellsFilter {
    /// The name of the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The name of the data cells filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// The ID of the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableCatalogId"
    )]
    #[builder(default, setter(strip_option))]
    pub table_catalog_id: Option<String>,
    /// The name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    #[builder(default, setter(strip_option))]
    pub table_name: Option<String>,
}

/// Configuration block for a data location resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataLocation {
    /// –  Amazon Resource Name (ARN) that uniquely identifies the data location resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a Resource in lakeformation to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<PermissionsInitProviderDataLocationArnRef>,
    /// Selector for a Resource in lakeformation to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<PermissionsInitProviderDataLocationArnSelector>,
    /// Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
}

/// Reference to a Resource in lakeformation to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderDataLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderDataLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderDataLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDataLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDataLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Resource in lakeformation to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderDataLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDataLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderDataLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderDataLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDataLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDataLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for a database resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDatabase {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database resource. Unique to the Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<PermissionsInitProviderDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<PermissionsInitProviderDatabaseNameSelector>,
}

/// Reference to a CatalogDatabase in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for an LF-tag resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderLfTag {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// name for the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values an attribute can take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for an LF-tag policy resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderLfTagPolicy {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See expression below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<Vec<PermissionsInitProviderLfTagPolicyExpression>>,
    /// –  The resource type for which the tag policy applies. Valid values are DATABASE and TABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderLfTagPolicyExpression {
    /// name of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for a table resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTable {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database for the table. Unique to a Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether to use a wildcard representing every table under a database. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}

/// Configuration block for a table with columns resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTableWithColumns {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Set of column names for the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "columnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub column_names: Option<Vec<String>>,
    /// –  Name of the database for the table with columns resource. Unique to the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Set of column names for the table to exclude.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedColumnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_column_names: Option<Vec<String>>,
    /// –  Name of the table resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a CatalogTable in glue to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<PermissionsInitProviderTableWithColumnsNameRef>,
    /// Selector for a CatalogTable in glue to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<PermissionsInitProviderTableWithColumnsNameSelector>,
    /// Whether to use a column wildcard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}

/// Reference to a CatalogTable in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTableWithColumnsNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderTableWithColumnsNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTableWithColumnsNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderTableWithColumnsNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderTableWithColumnsNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderTableWithColumnsNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderTableWithColumnsNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogTable in glue to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTableWithColumnsNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsInitProviderTableWithColumnsNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsInitProviderTableWithColumnsNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsInitProviderTableWithColumnsNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsInitProviderTableWithColumnsNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderTableWithColumnsNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsInitProviderTableWithColumnsNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<PermissionsPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<PermissionsPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<PermissionsPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<PermissionsPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<PermissionsPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PermissionsPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// PermissionsStatus defines the observed state of Permissions.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<PermissionsStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProvider {
    /// –  Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Whether the permissions are to be granted for the Data Catalog. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogResource"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_resource: Option<bool>,
    /// Configuration block for a data cells filter resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataCellsFilter"
    )]
    #[builder(default, setter(strip_option))]
    pub data_cells_filter: Option<PermissionsStatusAtProviderDataCellsFilter>,
    /// Configuration block for a data location resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataLocation"
    )]
    #[builder(default, setter(strip_option))]
    pub data_location: Option<PermissionsStatusAtProviderDataLocation>,
    /// Configuration block for a database resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub database: Option<PermissionsStatusAtProviderDatabase>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block for an LF-tag resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lfTag")]
    #[builder(default, setter(strip_option))]
    pub lf_tag: Option<PermissionsStatusAtProviderLfTag>,
    /// Configuration block for an LF-tag policy resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lfTagPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub lf_tag_policy: Option<PermissionsStatusAtProviderLfTagPolicy>,
    /// –  List of permissions granted to the principal. Valid values may include ALL, ALTER, ASSOCIATE, CREATE_DATABASE, CREATE_TABLE, DATA_LOCATION_ACCESS, DELETE, DESCRIBE, DROP, INSERT, and SELECT. For details on each permission, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub permissions: Option<Vec<String>>,
    /// Subset of permissions which the principal can pass.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissionsWithGrantOption"
    )]
    #[builder(default, setter(strip_option))]
    pub permissions_with_grant_option: Option<Vec<String>>,
    /// account permissions. For more information, see Lake Formation Permissions Reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub principal: Option<String>,
    /// Configuration block for a table resource. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub table: Option<PermissionsStatusAtProviderTable>,
    /// Configuration block for a table with columns resource. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableWithColumns"
    )]
    #[builder(default, setter(strip_option))]
    pub table_with_columns: Option<PermissionsStatusAtProviderTableWithColumns>,
}

/// Configuration block for a data cells filter resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderDataCellsFilter {
    /// The name of the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The name of the data cells filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// The ID of the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableCatalogId"
    )]
    #[builder(default, setter(strip_option))]
    pub table_catalog_id: Option<String>,
    /// The name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    #[builder(default, setter(strip_option))]
    pub table_name: Option<String>,
}

/// Configuration block for a data location resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderDataLocation {
    /// –  Amazon Resource Name (ARN) that uniquely identifies the data location resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
}

/// Configuration block for a database resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderDatabase {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database resource. Unique to the Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Configuration block for an LF-tag resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderLfTag {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// name for the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values an attribute can take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for an LF-tag policy resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderLfTagPolicy {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See expression below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<Vec<PermissionsStatusAtProviderLfTagPolicyExpression>>,
    /// –  The resource type for which the tag policy applies. Valid values are DATABASE and TABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderLfTagPolicyExpression {
    /// name of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// A list of possible values of an LF-Tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub values: Option<Vec<String>>,
}

/// Configuration block for a table resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderTable {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// –  Name of the database for the table. Unique to a Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Name of the table.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether to use a wildcard representing every table under a database. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}

/// Configuration block for a table with columns resource. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct PermissionsStatusAtProviderTableWithColumns {
    /// Identifier for the Data Catalog. By default, it is the account ID of the caller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catalogId")]
    #[builder(default, setter(strip_option))]
    pub catalog_id: Option<String>,
    /// Set of column names for the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "columnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub column_names: Option<Vec<String>>,
    /// –  Name of the database for the table with columns resource. Unique to the Data Catalog.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Set of column names for the table to exclude.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedColumnNames"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_column_names: Option<Vec<String>>,
    /// –  Name of the table resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Whether to use a column wildcard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub wildcard: Option<bool>,
}
