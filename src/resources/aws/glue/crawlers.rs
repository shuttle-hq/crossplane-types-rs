// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// CrawlerSpec defines the desired state of Crawler
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "glue.aws.upbound.io",
    version = "v1beta2",
    kind = "Crawler",
    plural = "crawlers"
)]
#[kube(status = "CrawlerStatus")]
pub struct CrawlerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<CrawlerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: CrawlerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<CrawlerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<CrawlerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<CrawlerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<CrawlerWriteConnectionSecretToRef>,
}

/// CrawlerSpec defines the desired state of Crawler
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProvider {
    /// List of nested AWS Glue Data Catalog target arguments. See Catalog Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_target: Option<Vec<CrawlerForProviderCatalogTarget>>,
    /// List of custom classifiers. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub classifiers: Option<Vec<String>>,
    /// JSON string of configuration information. For more details see Setting Crawler Configuration Options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_ref: Option<CrawlerForProviderDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_selector: Option<CrawlerForProviderDatabaseNameSelector>,
    /// List of nested Delta Lake target arguments. See Delta Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_target: Option<Vec<CrawlerForProviderDeltaTarget>>,
    /// Description of the crawler.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// List of nested DynamoDB target arguments. See Dynamodb Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dynamodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub dynamodb_target: Option<Vec<CrawlerForProviderDynamodbTarget>>,
    /// List of nested Hudi target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hudiTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub hudi_target: Option<Vec<CrawlerForProviderHudiTarget>>,
    /// List of nested Iceberg target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "icebergTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub iceberg_target: Option<Vec<CrawlerForProviderIcebergTarget>>,
    /// List of nested JDBC target arguments. See JDBC Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jdbcTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub jdbc_target: Option<Vec<CrawlerForProviderJdbcTarget>>,
    /// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lakeFormationConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lake_formation_configuration: Option<CrawlerForProviderLakeFormationConfiguration>,
    /// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lineageConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lineage_configuration: Option<CrawlerForProviderLineageConfiguration>,
    /// List of nested MongoDB target arguments. See MongoDB Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mongodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub mongodb_target: Option<Vec<CrawlerForProviderMongodbTarget>>,
    /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_policy: Option<CrawlerForProviderRecrawlPolicy>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The IAM role friendly name (including path without leading slash), or ARN of an IAM role, used by the crawler to access other resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// Reference to a Role in iam to populate role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleRef")]
    #[builder(default, setter(strip_option))]
    pub role_ref: Option<CrawlerForProviderRoleRef>,
    /// Selector for a Role in iam to populate role.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_selector: Option<CrawlerForProviderRoleSelector>,
    /// List of nested Amazon S3 target arguments. See S3 Target below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Target")]
    #[builder(default, setter(strip_option))]
    pub s3_target: Option<Vec<CrawlerForProviderS3Target>>,
    /// Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<String>,
    /// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "schemaChangePolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub schema_change_policy: Option<CrawlerForProviderSchemaChangePolicy>,
    /// The name of Security Configuration to be used by the crawler
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub security_configuration: Option<String>,
    /// The table prefix used for catalog tables that are created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablePrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub table_prefix: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_ref: Option<CrawlerForProviderCatalogTargetDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_selector: Option<CrawlerForProviderCatalogTargetDatabaseNameSelector>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of catalog tables to be synchronized.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tables: Option<Vec<String>>,
    /// References to CatalogTable in glue to populate tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablesRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub tables_refs: Option<Vec<CrawlerForProviderCatalogTargetTablesRefs>>,
    /// Selector for a list of CatalogTable in glue to populate tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablesSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub tables_selector: Option<CrawlerForProviderCatalogTargetTablesSelector>,
}

/// Reference to a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderCatalogTargetDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderCatalogTargetDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderCatalogTargetDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetTablesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderCatalogTargetTablesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetTablesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderCatalogTargetTablesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderCatalogTargetTablesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetTablesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetTablesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of CatalogTable in glue to populate tables.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetTablesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderCatalogTargetTablesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderCatalogTargetTablesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderCatalogTargetTablesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderCatalogTargetTablesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetTablesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderCatalogTargetTablesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDeltaTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createNativeDeltaTable"
    )]
    #[builder(default, setter(strip_option))]
    pub create_native_delta_table: Option<bool>,
    /// A list of the Amazon S3 paths to the Delta tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTables"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_tables: Option<Vec<String>>,
    /// Specifies whether to write the manifest files to the Delta table path.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeManifest"
    )]
    #[builder(default, setter(strip_option))]
    pub write_manifest: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderDynamodbTarget {
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
    /// The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanRate")]
    #[builder(default, setter(strip_option))]
    pub scan_rate: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderHudiTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderIcebergTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderJdbcTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Reference to a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_ref: Option<CrawlerForProviderJdbcTargetConnectionNameRef>,
    /// Selector for a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_selector: Option<CrawlerForProviderJdbcTargetConnectionNameSelector>,
    /// Specify a value of RAWTYPES or COMMENTS to enable additional metadata intable responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableAdditionalMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_additional_metadata: Option<Vec<String>>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// Reference to a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderJdbcTargetConnectionNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderJdbcTargetConnectionNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderJdbcTargetConnectionNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderJdbcTargetConnectionNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderJdbcTargetConnectionNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderJdbcTargetConnectionNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderJdbcTargetConnectionNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderJdbcTargetConnectionNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderJdbcTargetConnectionNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderJdbcTargetConnectionNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderJdbcTargetConnectionNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderJdbcTargetConnectionNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderJdbcTargetConnectionNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderJdbcTargetConnectionNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderLakeFormationConfiguration {
    /// Required for cross account crawls. For same account crawls as the target data, this can omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountId")]
    #[builder(default, setter(strip_option))]
    pub account_id: Option<String>,
    /// Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLakeFormationCredentials"
    )]
    #[builder(default, setter(strip_option))]
    pub use_lake_formation_credentials: Option<bool>,
}

/// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderLineageConfiguration {
    /// Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE and DISABLE. Default value is DISABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlerLineageSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub crawler_lineage_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderMongodbTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Reference to a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_ref: Option<CrawlerForProviderMongodbTargetConnectionNameRef>,
    /// Selector for a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_selector: Option<CrawlerForProviderMongodbTargetConnectionNameSelector>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
}

/// Reference to a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderMongodbTargetConnectionNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderMongodbTargetConnectionNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderMongodbTargetConnectionNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderMongodbTargetConnectionNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderMongodbTargetConnectionNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderMongodbTargetConnectionNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderMongodbTargetConnectionNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderMongodbTargetConnectionNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderMongodbTargetConnectionNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderMongodbTargetConnectionNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderMongodbTargetConnectionNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderMongodbTargetConnectionNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderMongodbTargetConnectionNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderMongodbTargetConnectionNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderRecrawlPolicy {
    /// Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: CRAWL_EVENT_MODE, CRAWL_EVERYTHING and CRAWL_NEW_FOLDERS_ONLY. Default value is CRAWL_EVERYTHING.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_behavior: Option<String>,
}

/// Reference to a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerForProviderRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerForProviderRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerForProviderRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerForProviderRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderS3Target {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sampleSize"
    )]
    #[builder(default, setter(strip_option))]
    pub sample_size: Option<f64>,
}

/// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerForProviderSchemaChangePolicy {
    /// The deletion behavior when the crawler finds a deleted object. Valid values: LOG, DELETE_FROM_DATABASE, or DEPRECATE_IN_DATABASE. Defaults to DEPRECATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_behavior: Option<String>,
    /// The update behavior when the crawler finds a changed schema. Valid values: LOG or UPDATE_IN_DATABASE. Defaults to UPDATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub update_behavior: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProvider {
    /// List of nested AWS Glue Data Catalog target arguments. See Catalog Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_target: Option<Vec<CrawlerInitProviderCatalogTarget>>,
    /// List of custom classifiers. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub classifiers: Option<Vec<String>>,
    /// JSON string of configuration information. For more details see Setting Crawler Configuration Options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_ref: Option<CrawlerInitProviderDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_selector: Option<CrawlerInitProviderDatabaseNameSelector>,
    /// List of nested Delta Lake target arguments. See Delta Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_target: Option<Vec<CrawlerInitProviderDeltaTarget>>,
    /// Description of the crawler.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// List of nested DynamoDB target arguments. See Dynamodb Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dynamodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub dynamodb_target: Option<Vec<CrawlerInitProviderDynamodbTarget>>,
    /// List of nested Hudi target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hudiTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub hudi_target: Option<Vec<CrawlerInitProviderHudiTarget>>,
    /// List of nested Iceberg target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "icebergTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub iceberg_target: Option<Vec<CrawlerInitProviderIcebergTarget>>,
    /// List of nested JDBC target arguments. See JDBC Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jdbcTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub jdbc_target: Option<Vec<CrawlerInitProviderJdbcTarget>>,
    /// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lakeFormationConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lake_formation_configuration: Option<CrawlerInitProviderLakeFormationConfiguration>,
    /// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lineageConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lineage_configuration: Option<CrawlerInitProviderLineageConfiguration>,
    /// List of nested MongoDB target arguments. See MongoDB Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mongodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub mongodb_target: Option<Vec<CrawlerInitProviderMongodbTarget>>,
    /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_policy: Option<CrawlerInitProviderRecrawlPolicy>,
    /// The IAM role friendly name (including path without leading slash), or ARN of an IAM role, used by the crawler to access other resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// Reference to a Role in iam to populate role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleRef")]
    #[builder(default, setter(strip_option))]
    pub role_ref: Option<CrawlerInitProviderRoleRef>,
    /// Selector for a Role in iam to populate role.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_selector: Option<CrawlerInitProviderRoleSelector>,
    /// List of nested Amazon S3 target arguments. See S3 Target below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Target")]
    #[builder(default, setter(strip_option))]
    pub s3_target: Option<Vec<CrawlerInitProviderS3Target>>,
    /// Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<String>,
    /// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "schemaChangePolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub schema_change_policy: Option<CrawlerInitProviderSchemaChangePolicy>,
    /// The name of Security Configuration to be used by the crawler
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub security_configuration: Option<String>,
    /// The table prefix used for catalog tables that are created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablePrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub table_prefix: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// Reference to a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_ref: Option<CrawlerInitProviderCatalogTargetDatabaseNameRef>,
    /// Selector for a CatalogDatabase in glue to populate databaseName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name_selector: Option<CrawlerInitProviderCatalogTargetDatabaseNameSelector>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of catalog tables to be synchronized.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tables: Option<Vec<String>>,
    /// References to CatalogTable in glue to populate tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablesRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub tables_refs: Option<Vec<CrawlerInitProviderCatalogTargetTablesRefs>>,
    /// Selector for a list of CatalogTable in glue to populate tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablesSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub tables_selector: Option<CrawlerInitProviderCatalogTargetTablesSelector>,
}

/// Reference to a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderCatalogTargetDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderCatalogTargetDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderCatalogTargetDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetTablesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderCatalogTargetTablesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetTablesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderCatalogTargetTablesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderCatalogTargetTablesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetTablesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetTablesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of CatalogTable in glue to populate tables.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetTablesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderCatalogTargetTablesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderCatalogTargetTablesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderCatalogTargetTablesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderCatalogTargetTablesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetTablesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderCatalogTargetTablesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDatabaseNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderDatabaseNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDatabaseNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderDatabaseNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderDatabaseNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderDatabaseNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderDatabaseNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CatalogDatabase in glue to populate databaseName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDatabaseNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderDatabaseNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDatabaseNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderDatabaseNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderDatabaseNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderDatabaseNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderDatabaseNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDeltaTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createNativeDeltaTable"
    )]
    #[builder(default, setter(strip_option))]
    pub create_native_delta_table: Option<bool>,
    /// A list of the Amazon S3 paths to the Delta tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTables"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_tables: Option<Vec<String>>,
    /// Specifies whether to write the manifest files to the Delta table path.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeManifest"
    )]
    #[builder(default, setter(strip_option))]
    pub write_manifest: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderDynamodbTarget {
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
    /// The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanRate")]
    #[builder(default, setter(strip_option))]
    pub scan_rate: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderHudiTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderIcebergTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderJdbcTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Reference to a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_ref: Option<CrawlerInitProviderJdbcTargetConnectionNameRef>,
    /// Selector for a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_selector: Option<CrawlerInitProviderJdbcTargetConnectionNameSelector>,
    /// Specify a value of RAWTYPES or COMMENTS to enable additional metadata intable responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableAdditionalMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_additional_metadata: Option<Vec<String>>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// Reference to a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderJdbcTargetConnectionNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderJdbcTargetConnectionNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderJdbcTargetConnectionNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderJdbcTargetConnectionNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderJdbcTargetConnectionNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderJdbcTargetConnectionNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderJdbcTargetConnectionNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderJdbcTargetConnectionNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderJdbcTargetConnectionNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderLakeFormationConfiguration {
    /// Required for cross account crawls. For same account crawls as the target data, this can omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountId")]
    #[builder(default, setter(strip_option))]
    pub account_id: Option<String>,
    /// Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLakeFormationCredentials"
    )]
    #[builder(default, setter(strip_option))]
    pub use_lake_formation_credentials: Option<bool>,
}

/// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderLineageConfiguration {
    /// Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE and DISABLE. Default value is DISABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlerLineageSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub crawler_lineage_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderMongodbTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Reference to a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_ref: Option<CrawlerInitProviderMongodbTargetConnectionNameRef>,
    /// Selector for a Connection in glue to populate connectionName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name_selector: Option<CrawlerInitProviderMongodbTargetConnectionNameSelector>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
}

/// Reference to a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderMongodbTargetConnectionNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderMongodbTargetConnectionNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderMongodbTargetConnectionNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderMongodbTargetConnectionNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderMongodbTargetConnectionNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderMongodbTargetConnectionNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderMongodbTargetConnectionNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in glue to populate connectionName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderMongodbTargetConnectionNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderMongodbTargetConnectionNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderRecrawlPolicy {
    /// Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: CRAWL_EVENT_MODE, CRAWL_EVERYTHING and CRAWL_NEW_FOLDERS_ONLY. Default value is CRAWL_EVERYTHING.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_behavior: Option<String>,
}

/// Reference to a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerInitProviderRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerInitProviderRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerInitProviderRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerInitProviderRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderS3Target {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sampleSize"
    )]
    #[builder(default, setter(strip_option))]
    pub sample_size: Option<f64>,
}

/// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerInitProviderSchemaChangePolicy {
    /// The deletion behavior when the crawler finds a deleted object. Valid values: LOG, DELETE_FROM_DATABASE, or DEPRECATE_IN_DATABASE. Defaults to DEPRECATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_behavior: Option<String>,
    /// The update behavior when the crawler finds a changed schema. Valid values: LOG or UPDATE_IN_DATABASE. Defaults to UPDATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub update_behavior: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<CrawlerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<CrawlerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<CrawlerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<CrawlerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<CrawlerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum CrawlerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// CrawlerStatus defines the observed state of Crawler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<CrawlerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProvider {
    /// The ARN of the crawler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// List of nested AWS Glue Data Catalog target arguments. See Catalog Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "catalogTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub catalog_target: Option<Vec<CrawlerStatusAtProviderCatalogTarget>>,
    /// List of custom classifiers. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub classifiers: Option<Vec<String>>,
    /// JSON string of configuration information. For more details see Setting Crawler Configuration Options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// List of nested Delta Lake target arguments. See Delta Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_target: Option<Vec<CrawlerStatusAtProviderDeltaTarget>>,
    /// Description of the crawler.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// List of nested DynamoDB target arguments. See Dynamodb Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dynamodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub dynamodb_target: Option<Vec<CrawlerStatusAtProviderDynamodbTarget>>,
    /// List of nested Hudi target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hudiTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub hudi_target: Option<Vec<CrawlerStatusAtProviderHudiTarget>>,
    /// List of nested Iceberg target arguments. See Iceberg Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "icebergTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub iceberg_target: Option<Vec<CrawlerStatusAtProviderIcebergTarget>>,
    /// Crawler name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// List of nested JDBC target arguments. See JDBC Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jdbcTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub jdbc_target: Option<Vec<CrawlerStatusAtProviderJdbcTarget>>,
    /// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lakeFormationConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lake_formation_configuration: Option<CrawlerStatusAtProviderLakeFormationConfiguration>,
    /// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lineageConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub lineage_configuration: Option<CrawlerStatusAtProviderLineageConfiguration>,
    /// List of nested MongoDB target arguments. See MongoDB Target below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mongodbTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub mongodb_target: Option<Vec<CrawlerStatusAtProviderMongodbTarget>>,
    /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_policy: Option<CrawlerStatusAtProviderRecrawlPolicy>,
    /// The IAM role friendly name (including path without leading slash), or ARN of an IAM role, used by the crawler to access other resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// List of nested Amazon S3 target arguments. See S3 Target below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Target")]
    #[builder(default, setter(strip_option))]
    pub s3_target: Option<Vec<CrawlerStatusAtProviderS3Target>>,
    /// Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<String>,
    /// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "schemaChangePolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub schema_change_policy: Option<CrawlerStatusAtProviderSchemaChangePolicy>,
    /// The name of Security Configuration to be used by the crawler
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub security_configuration: Option<String>,
    /// The table prefix used for catalog tables that are created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tablePrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub table_prefix: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderCatalogTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Glue database where results are written.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of catalog tables to be synchronized.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tables: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderDeltaTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createNativeDeltaTable"
    )]
    #[builder(default, setter(strip_option))]
    pub create_native_delta_table: Option<bool>,
    /// A list of the Amazon S3 paths to the Delta tables.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deltaTables"
    )]
    #[builder(default, setter(strip_option))]
    pub delta_tables: Option<Vec<String>>,
    /// Specifies whether to write the manifest files to the Delta table path.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeManifest"
    )]
    #[builder(default, setter(strip_option))]
    pub write_manifest: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderDynamodbTarget {
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
    /// The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanRate")]
    #[builder(default, setter(strip_option))]
    pub scan_rate: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderHudiTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderIcebergTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between 1 and 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumTraversalDepth"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_traversal_depth: Option<f64>,
    /// One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderJdbcTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// Specify a value of RAWTYPES or COMMENTS to enable additional metadata intable responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableAdditionalMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_additional_metadata: Option<Vec<String>>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderLakeFormationConfiguration {
    /// Required for cross account crawls. For same account crawls as the target data, this can omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountId")]
    #[builder(default, setter(strip_option))]
    pub account_id: Option<String>,
    /// Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLakeFormationCredentials"
    )]
    #[builder(default, setter(strip_option))]
    pub use_lake_formation_credentials: Option<bool>,
}

/// Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderLineageConfiguration {
    /// Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE and DISABLE. Default value is DISABLE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlerLineageSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub crawler_lineage_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderMongodbTarget {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scanAll")]
    #[builder(default, setter(strip_option))]
    pub scan_all: Option<bool>,
}

/// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderRecrawlPolicy {
    /// Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: CRAWL_EVENT_MODE, CRAWL_EVERYTHING and CRAWL_NEW_FOLDERS_ONLY. Default value is CRAWL_EVERYTHING.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recrawlBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub recrawl_behavior: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderS3Target {
    /// The name of the connection to use to connect to the JDBC target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionName"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_name: Option<String>,
    /// The ARN of the dead-letter SQS queue.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dlqEventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub dlq_event_queue_arn: Option<String>,
    /// The ARN of the SQS queue to receive S3 notifications from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventQueueArn"
    )]
    #[builder(default, setter(strip_option))]
    pub event_queue_arn: Option<String>,
    /// A list of glob patterns used to exclude from the crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exclusions: Option<Vec<String>>,
    /// The name of the DynamoDB table to crawl.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sampleSize"
    )]
    #[builder(default, setter(strip_option))]
    pub sample_size: Option<f64>,
}

/// Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct CrawlerStatusAtProviderSchemaChangePolicy {
    /// The deletion behavior when the crawler finds a deleted object. Valid values: LOG, DELETE_FROM_DATABASE, or DEPRECATE_IN_DATABASE. Defaults to DEPRECATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_behavior: Option<String>,
    /// The update behavior when the crawler finds a changed schema. Valid values: LOG or UPDATE_IN_DATABASE. Defaults to UPDATE_IN_DATABASE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub update_behavior: Option<String>,
}
