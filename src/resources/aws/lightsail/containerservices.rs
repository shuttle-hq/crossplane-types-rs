// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ContainerServiceSpec defines the desired state of ContainerService
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "lightsail.aws.upbound.io",
    version = "v1beta2",
    kind = "ContainerService",
    plural = "containerservices"
)]
#[kube(status = "ContainerServiceStatus")]
pub struct ContainerServiceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ContainerServiceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ContainerServiceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ContainerServiceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ContainerServiceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ContainerServicePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ContainerServiceWriteConnectionSecretToRef>,
}

/// ContainerServiceSpec defines the desired state of ContainerService
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ContainerServiceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceForProvider {
    /// A Boolean value indicating whether the container service is disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "isDisabled"
    )]
    #[builder(default, setter(strip_option))]
    pub is_disabled: Option<bool>,
    /// The power specification for the container service. The power specifies the amount of memory,
    /// the number of vCPUs, and the monthly price of each node of the container service.
    /// Possible values: nano, micro, small, medium, large, xlarge.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub power: Option<String>,
    /// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateRegistryAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub private_registry_access: Option<ContainerServiceForProviderPrivateRegistryAccess>,
    /// The public domain names to use with the container service, such as example.com
    /// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
    /// specify are used when you create a deployment with a container configured as the public endpoint of your container
    /// service. If you don't specify public domain names, then you can use the default domain of the container service.
    /// Defined below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicDomainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub public_domain_names: Option<ContainerServiceForProviderPublicDomainNames>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The scale specification for the container service. The scale specifies the allocated compute
    /// nodes of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scale: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceForProviderPrivateRegistryAccess {
    /// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecrImagePullerRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ecr_image_puller_role:
        Option<ContainerServiceForProviderPrivateRegistryAccessEcrImagePullerRole>,
}

/// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceForProviderPrivateRegistryAccessEcrImagePullerRole {
    /// A Boolean value that indicates whether to activate the role. The default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isActive")]
    #[builder(default, setter(strip_option))]
    pub is_active: Option<bool>,
}

/// The public domain names to use with the container service, such as example.com
/// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
/// specify are used when you create a deployment with a container configured as the public endpoint of your container
/// service. If you don't specify public domain names, then you can use the default domain of the container service.
/// Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceForProviderPublicDomainNames {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<Vec<ContainerServiceForProviderPublicDomainNamesCertificate>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceForProviderPublicDomainNamesCertificate {
    /// The name for the container service. Names must be of length 1 to 63, and be
    /// unique within each AWS Region in your Lightsail account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateName"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_names: Option<Vec<String>>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceInitProvider {
    /// A Boolean value indicating whether the container service is disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "isDisabled"
    )]
    #[builder(default, setter(strip_option))]
    pub is_disabled: Option<bool>,
    /// The power specification for the container service. The power specifies the amount of memory,
    /// the number of vCPUs, and the monthly price of each node of the container service.
    /// Possible values: nano, micro, small, medium, large, xlarge.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub power: Option<String>,
    /// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateRegistryAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub private_registry_access: Option<ContainerServiceInitProviderPrivateRegistryAccess>,
    /// The public domain names to use with the container service, such as example.com
    /// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
    /// specify are used when you create a deployment with a container configured as the public endpoint of your container
    /// service. If you don't specify public domain names, then you can use the default domain of the container service.
    /// Defined below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicDomainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub public_domain_names: Option<ContainerServiceInitProviderPublicDomainNames>,
    /// The scale specification for the container service. The scale specifies the allocated compute
    /// nodes of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scale: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceInitProviderPrivateRegistryAccess {
    /// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecrImagePullerRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ecr_image_puller_role:
        Option<ContainerServiceInitProviderPrivateRegistryAccessEcrImagePullerRole>,
}

/// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceInitProviderPrivateRegistryAccessEcrImagePullerRole {
    /// A Boolean value that indicates whether to activate the role. The default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isActive")]
    #[builder(default, setter(strip_option))]
    pub is_active: Option<bool>,
}

/// The public domain names to use with the container service, such as example.com
/// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
/// specify are used when you create a deployment with a container configured as the public endpoint of your container
/// service. If you don't specify public domain names, then you can use the default domain of the container service.
/// Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceInitProviderPublicDomainNames {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<Vec<ContainerServiceInitProviderPublicDomainNamesCertificate>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceInitProviderPublicDomainNamesCertificate {
    /// The name for the container service. Names must be of length 1 to 63, and be
    /// unique within each AWS Region in your Lightsail account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateName"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_names: Option<Vec<String>>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ContainerServiceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ContainerServiceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ContainerServiceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ContainerServiceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ContainerServiceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServicePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ContainerServicePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ContainerServicePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServicePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ContainerServicePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServicePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ContainerServicePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ContainerServicePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ContainerServicePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ContainerServicePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServicePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ContainerServiceStatus defines the observed state of ContainerService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ContainerServiceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatusAtProvider {
    /// The Amazon Resource Name (ARN) of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The Availability Zone. Follows the format us-east-2a (case-sensitive).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdAt")]
    #[builder(default, setter(strip_option))]
    pub created_at: Option<String>,
    /// Same as name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// A Boolean value indicating whether the container service is disabled. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "isDisabled"
    )]
    #[builder(default, setter(strip_option))]
    pub is_disabled: Option<bool>,
    /// The power specification for the container service. The power specifies the amount of memory,
    /// the number of vCPUs, and the monthly price of each node of the container service.
    /// Possible values: nano, micro, small, medium, large, xlarge.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub power: Option<String>,
    /// The ID of the power of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "powerId")]
    #[builder(default, setter(strip_option))]
    pub power_id: Option<String>,
    /// The principal ARN of the container service. The principal ARN can be used to create a trust
    /// relationship between your standard AWS account and your Lightsail container service. This allows you to give your
    /// service permission to access resources in your standard AWS account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "principalArn"
    )]
    #[builder(default, setter(strip_option))]
    pub principal_arn: Option<String>,
    /// The private domain name of the container service. The private domain name is accessible only
    /// by other resources within the default virtual private cloud (VPC) of your Lightsail account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDomainName"
    )]
    #[builder(default, setter(strip_option))]
    pub private_domain_name: Option<String>,
    /// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateRegistryAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub private_registry_access: Option<ContainerServiceStatusAtProviderPrivateRegistryAccess>,
    /// The public domain names to use with the container service, such as example.com
    /// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
    /// specify are used when you create a deployment with a container configured as the public endpoint of your container
    /// service. If you don't specify public domain names, then you can use the default domain of the container service.
    /// Defined below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicDomainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub public_domain_names: Option<ContainerServiceStatusAtProviderPublicDomainNames>,
    /// The Lightsail resource type of the container service (i.e., ContainerService).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
    /// The scale specification for the container service. The scale specifies the allocated compute
    /// nodes of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scale: Option<f64>,
    /// The current state of the container service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider
    /// default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// The publicly accessible URL of the container service. If no public endpoint is specified in the
    /// currentDeployment, this URL returns a 404 response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub url: Option<String>,
}

/// An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See Private Registry Access below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatusAtProviderPrivateRegistryAccess {
    /// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecrImagePullerRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ecr_image_puller_role:
        Option<ContainerServiceStatusAtProviderPrivateRegistryAccessEcrImagePullerRole>,
}

/// Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatusAtProviderPrivateRegistryAccessEcrImagePullerRole {
    /// A Boolean value that indicates whether to activate the role. The default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isActive")]
    #[builder(default, setter(strip_option))]
    pub is_active: Option<bool>,
    /// The principal ARN of the container service. The principal ARN can be used to create a trust
    /// relationship between your standard AWS account and your Lightsail container service. This allows you to give your
    /// service permission to access resources in your standard AWS account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "principalArn"
    )]
    #[builder(default, setter(strip_option))]
    pub principal_arn: Option<String>,
}

/// The public domain names to use with the container service, such as example.com
/// and www.example.com. You can specify up to four public domain names for a container service. The domain names that you
/// specify are used when you create a deployment with a container configured as the public endpoint of your container
/// service. If you don't specify public domain names, then you can use the default domain of the container service.
/// Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatusAtProviderPublicDomainNames {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<Vec<ContainerServiceStatusAtProviderPublicDomainNamesCertificate>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ContainerServiceStatusAtProviderPublicDomainNamesCertificate {
    /// The name for the container service. Names must be of length 1 to 63, and be
    /// unique within each AWS Region in your Lightsail account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateName"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainNames"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_names: Option<Vec<String>>,
}
