// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ReceiptRuleSpec defines the desired state of ReceiptRule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "ses.aws.upbound.io",
    version = "v1beta1",
    kind = "ReceiptRule",
    plural = "receiptrules"
)]
#[kube(status = "ReceiptRuleStatus")]
pub struct ReceiptRuleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ReceiptRuleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ReceiptRuleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ReceiptRuleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ReceiptRuleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ReceiptRulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ReceiptRuleWriteConnectionSecretToRef>,
}

/// ReceiptRuleSpec defines the desired state of ReceiptRule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReceiptRuleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProvider {
    /// A list of Add Header Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addHeaderAction"
    )]
    #[builder(default, setter(strip_option))]
    pub add_header_action: Option<Vec<ReceiptRuleForProviderAddHeaderAction>>,
    /// The name of the rule to place this rule after
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub after: Option<String>,
    /// A list of Bounce Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bounceAction"
    )]
    #[builder(default, setter(strip_option))]
    pub bounce_action: Option<Vec<ReceiptRuleForProviderBounceAction>>,
    /// If true, the rule will be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// A list of Lambda Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaAction"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_action: Option<Vec<ReceiptRuleForProviderLambdaAction>>,
    /// The name of the rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of email addresses
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub recipients: Option<Vec<String>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The name of the rule set
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ruleSetName"
    )]
    #[builder(default, setter(strip_option))]
    pub rule_set_name: Option<String>,
    /// A list of S3 Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Action")]
    #[builder(default, setter(strip_option))]
    pub s3_action: Option<Vec<ReceiptRuleForProviderS3Action>>,
    /// If true, incoming emails will be scanned for spam and viruses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scanEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub scan_enabled: Option<bool>,
    /// A list of SNS Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsAction")]
    #[builder(default, setter(strip_option))]
    pub sns_action: Option<Vec<ReceiptRuleForProviderSnsAction>>,
    /// A list of Stop Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stopAction"
    )]
    #[builder(default, setter(strip_option))]
    pub stop_action: Option<Vec<ReceiptRuleForProviderStopAction>>,
    /// Require or Optional
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPolicy")]
    #[builder(default, setter(strip_option))]
    pub tls_policy: Option<String>,
    /// A list of WorkMail Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workmailAction"
    )]
    #[builder(default, setter(strip_option))]
    pub workmail_action: Option<Vec<ReceiptRuleForProviderWorkmailAction>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderAddHeaderAction {
    /// The name of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerName"
    )]
    #[builder(default, setter(strip_option))]
    pub header_name: Option<String>,
    /// The value of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerValue"
    )]
    #[builder(default, setter(strip_option))]
    pub header_value: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderBounceAction {
    /// The message to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub message: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The email address of the sender
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sender: Option<String>,
    /// The RFC 5321 SMTP reply code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smtpReplyCode"
    )]
    #[builder(default, setter(strip_option))]
    pub smtp_reply_code: Option<String>,
    /// The RFC 3463 SMTP enhanced status code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderLambdaAction {
    /// The ARN of the Lambda function to invoke
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "functionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub function_arn: Option<String>,
    /// Event or RequestResponse
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationType"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_type: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderS3Action {
    /// The name of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// The ARN of the IAM role to be used by Amazon Simple Email Service while writing to the Amazon S3 bucket, optionally encrypting your mail via the provided customer managed key, and publishing to the Amazon SNS topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_role_arn: Option<String>,
    /// The ARN of the KMS key
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// The key prefix of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectKeyPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub object_key_prefix: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderSnsAction {
    /// The encoding to use for the email within the Amazon SNS notification. Default value is UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encoding: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderStopAction {
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The scope to apply. The only acceptable value is RuleSet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleForProviderWorkmailAction {
    /// The ARN of the WorkMail organization
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "organizationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub organization_arn: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProvider {
    /// A list of Add Header Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addHeaderAction"
    )]
    #[builder(default, setter(strip_option))]
    pub add_header_action: Option<Vec<ReceiptRuleInitProviderAddHeaderAction>>,
    /// The name of the rule to place this rule after
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub after: Option<String>,
    /// A list of Bounce Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bounceAction"
    )]
    #[builder(default, setter(strip_option))]
    pub bounce_action: Option<Vec<ReceiptRuleInitProviderBounceAction>>,
    /// If true, the rule will be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// A list of Lambda Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaAction"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_action: Option<Vec<ReceiptRuleInitProviderLambdaAction>>,
    /// The name of the rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of email addresses
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub recipients: Option<Vec<String>>,
    /// The name of the rule set
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ruleSetName"
    )]
    #[builder(default, setter(strip_option))]
    pub rule_set_name: Option<String>,
    /// A list of S3 Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Action")]
    #[builder(default, setter(strip_option))]
    pub s3_action: Option<Vec<ReceiptRuleInitProviderS3Action>>,
    /// If true, incoming emails will be scanned for spam and viruses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scanEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub scan_enabled: Option<bool>,
    /// A list of SNS Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsAction")]
    #[builder(default, setter(strip_option))]
    pub sns_action: Option<Vec<ReceiptRuleInitProviderSnsAction>>,
    /// A list of Stop Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stopAction"
    )]
    #[builder(default, setter(strip_option))]
    pub stop_action: Option<Vec<ReceiptRuleInitProviderStopAction>>,
    /// Require or Optional
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPolicy")]
    #[builder(default, setter(strip_option))]
    pub tls_policy: Option<String>,
    /// A list of WorkMail Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workmailAction"
    )]
    #[builder(default, setter(strip_option))]
    pub workmail_action: Option<Vec<ReceiptRuleInitProviderWorkmailAction>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderAddHeaderAction {
    /// The name of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerName"
    )]
    #[builder(default, setter(strip_option))]
    pub header_name: Option<String>,
    /// The value of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerValue"
    )]
    #[builder(default, setter(strip_option))]
    pub header_value: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderBounceAction {
    /// The message to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub message: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The email address of the sender
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sender: Option<String>,
    /// The RFC 5321 SMTP reply code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smtpReplyCode"
    )]
    #[builder(default, setter(strip_option))]
    pub smtp_reply_code: Option<String>,
    /// The RFC 3463 SMTP enhanced status code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderLambdaAction {
    /// The ARN of the Lambda function to invoke
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "functionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub function_arn: Option<String>,
    /// Event or RequestResponse
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationType"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_type: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderS3Action {
    /// The name of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// The ARN of the IAM role to be used by Amazon Simple Email Service while writing to the Amazon S3 bucket, optionally encrypting your mail via the provided customer managed key, and publishing to the Amazon SNS topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_role_arn: Option<String>,
    /// The ARN of the KMS key
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// The key prefix of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectKeyPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub object_key_prefix: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderSnsAction {
    /// The encoding to use for the email within the Amazon SNS notification. Default value is UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encoding: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderStopAction {
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The scope to apply. The only acceptable value is RuleSet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleInitProviderWorkmailAction {
    /// The ARN of the WorkMail organization
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "organizationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub organization_arn: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReceiptRuleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReceiptRuleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReceiptRuleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReceiptRuleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReceiptRuleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ReceiptRulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ReceiptRulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReceiptRulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReceiptRulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReceiptRulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReceiptRulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReceiptRulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ReceiptRuleStatus defines the observed state of ReceiptRule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ReceiptRuleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProvider {
    /// A list of Add Header Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addHeaderAction"
    )]
    #[builder(default, setter(strip_option))]
    pub add_header_action: Option<Vec<ReceiptRuleStatusAtProviderAddHeaderAction>>,
    /// The name of the rule to place this rule after
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub after: Option<String>,
    /// The SES receipt rule ARN.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// A list of Bounce Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bounceAction"
    )]
    #[builder(default, setter(strip_option))]
    pub bounce_action: Option<Vec<ReceiptRuleStatusAtProviderBounceAction>>,
    /// If true, the rule will be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The SES receipt rule name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// A list of Lambda Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaAction"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_action: Option<Vec<ReceiptRuleStatusAtProviderLambdaAction>>,
    /// The name of the rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// A list of email addresses
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub recipients: Option<Vec<String>>,
    /// The name of the rule set
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ruleSetName"
    )]
    #[builder(default, setter(strip_option))]
    pub rule_set_name: Option<String>,
    /// A list of S3 Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Action")]
    #[builder(default, setter(strip_option))]
    pub s3_action: Option<Vec<ReceiptRuleStatusAtProviderS3Action>>,
    /// If true, incoming emails will be scanned for spam and viruses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scanEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub scan_enabled: Option<bool>,
    /// A list of SNS Action blocks. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsAction")]
    #[builder(default, setter(strip_option))]
    pub sns_action: Option<Vec<ReceiptRuleStatusAtProviderSnsAction>>,
    /// A list of Stop Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stopAction"
    )]
    #[builder(default, setter(strip_option))]
    pub stop_action: Option<Vec<ReceiptRuleStatusAtProviderStopAction>>,
    /// Require or Optional
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPolicy")]
    #[builder(default, setter(strip_option))]
    pub tls_policy: Option<String>,
    /// A list of WorkMail Action blocks. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workmailAction"
    )]
    #[builder(default, setter(strip_option))]
    pub workmail_action: Option<Vec<ReceiptRuleStatusAtProviderWorkmailAction>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderAddHeaderAction {
    /// The name of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerName"
    )]
    #[builder(default, setter(strip_option))]
    pub header_name: Option<String>,
    /// The value of the header to add
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerValue"
    )]
    #[builder(default, setter(strip_option))]
    pub header_value: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderBounceAction {
    /// The message to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub message: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The email address of the sender
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sender: Option<String>,
    /// The RFC 5321 SMTP reply code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smtpReplyCode"
    )]
    #[builder(default, setter(strip_option))]
    pub smtp_reply_code: Option<String>,
    /// The RFC 3463 SMTP enhanced status code
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "statusCode"
    )]
    #[builder(default, setter(strip_option))]
    pub status_code: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderLambdaAction {
    /// The ARN of the Lambda function to invoke
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "functionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub function_arn: Option<String>,
    /// Event or RequestResponse
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationType"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_type: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderS3Action {
    /// The name of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// The ARN of the IAM role to be used by Amazon Simple Email Service while writing to the Amazon S3 bucket, optionally encrypting your mail via the provided customer managed key, and publishing to the Amazon SNS topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_role_arn: Option<String>,
    /// The ARN of the KMS key
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// The key prefix of the S3 bucket
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectKeyPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub object_key_prefix: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderSnsAction {
    /// The encoding to use for the email within the Amazon SNS notification. Default value is UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encoding: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderStopAction {
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The scope to apply. The only acceptable value is RuleSet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scope: Option<String>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReceiptRuleStatusAtProviderWorkmailAction {
    /// The ARN of the WorkMail organization
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "organizationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub organization_arn: Option<String>,
    /// The position of the action in the receipt rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub position: Option<f64>,
    /// The ARN of an SNS topic to notify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicArn")]
    #[builder(default, setter(strip_option))]
    pub topic_arn: Option<String>,
}
