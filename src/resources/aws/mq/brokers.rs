// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// BrokerSpec defines the desired state of Broker
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "mq.aws.upbound.io",
    version = "v1beta2",
    kind = "Broker",
    plural = "brokers"
)]
#[kube(status = "BrokerStatus")]
pub struct BrokerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<BrokerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: BrokerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<BrokerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<BrokerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<BrokerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<BrokerWriteConnectionSecretToRef>,
}

/// BrokerSpec defines the desired state of Broker
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProvider {
    /// Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Authentication strategy used to secure the broker. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_strategy: Option<String>,
    /// Whether to automatically upgrade to new minor versions of brokers as Amazon MQ makes releases available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<bool>,
    /// Name of the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerName"
    )]
    #[builder(default, setter(strip_option))]
    pub broker_name: Option<String>,
    /// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<BrokerForProviderConfiguration>,
    /// Defines whether this broker is a part of a data replication pair. Valid values are CRDR and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_mode: Option<String>,
    /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when data_replication_mode is CRDR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn: Option<String>,
    /// Reference to a Broker in mq to populate dataReplicationPrimaryBrokerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn_ref:
        Option<BrokerForProviderDataReplicationPrimaryBrokerArnRef>,
    /// Selector for a Broker in mq to populate dataReplicationPrimaryBrokerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn_selector:
        Option<BrokerForProviderDataReplicationPrimaryBrokerArnSelector>,
    /// Deployment mode of the broker. Valid values are SINGLE_INSTANCE, ACTIVE_STANDBY_MULTI_AZ, and CLUSTER_MULTI_AZ. Default is SINGLE_INSTANCE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentMode"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_mode: Option<String>,
    /// Configuration block containing encryption options. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_options: Option<BrokerForProviderEncryptionOptions>,
    /// Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineType"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_type: Option<String>,
    /// Version of the broker engine. See the AmazonMQ Broker Engine docs for supported versions. For example, 5.17.6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Broker's instance type. For example, mq.t3.micro, mq.m5.large.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub host_instance_type: Option<String>,
    /// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ldapServerMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub ldap_server_metadata: Option<BrokerForProviderLdapServerMetadata>,
    /// Configuration block for the logging configuration of the broker. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logs: Option<BrokerForProviderLogs>,
    /// Configuration block for the maintenance window start time. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindowStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window_start_time: Option<BrokerForProviderMaintenanceWindowStartTime>,
    /// Whether to enable connections from applications outside of the VPC that hosts the broker's subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAccessible"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_accessible: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs: Option<Vec<BrokerForProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector: Option<BrokerForProviderSecurityGroupSelector>,
    /// List of security group IDs assigned to the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Storage type of the broker. For engine_type ActiveMQ, the valid values are efs and ebs, and the AWS-default is efs. For engine_type RabbitMQ, only ebs is supported. When using ebs, only the mq.m5 broker instance type family is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<BrokerForProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<BrokerForProviderSubnetIdSelector>,
    /// List of subnet IDs in which to launch the broker. A SINGLE_INSTANCE deployment requires one subnet. An ACTIVE_STANDBY_MULTI_AZ deployment requires multiple subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for broker users. For engine_type of RabbitMQ, Amazon MQ does not return broker users preventing this resource from making user updates and drift detection. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub user: Option<Vec<BrokerForProviderUser>>,
}

/// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderConfiguration {
    /// The Configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Reference to a Configuration in mq to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idRef")]
    #[builder(default, setter(strip_option))]
    pub id_ref: Option<BrokerForProviderConfigurationIdRef>,
    /// Selector for a Configuration in mq to populate id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub id_selector: Option<BrokerForProviderConfigurationIdSelector>,
    /// Revision of the Configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a Configuration in mq to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderConfigurationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderConfigurationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderConfigurationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderConfigurationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderConfigurationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderConfigurationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderConfigurationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Configuration in mq to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderConfigurationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderConfigurationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderConfigurationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderConfigurationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderConfigurationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderConfigurationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderConfigurationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Broker in mq to populate dataReplicationPrimaryBrokerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderDataReplicationPrimaryBrokerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderDataReplicationPrimaryBrokerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Broker in mq to populate dataReplicationPrimaryBrokerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderDataReplicationPrimaryBrokerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block containing encryption options. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderEncryptionOptions {
    /// Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting use_aws_owned_key to false. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useAwsOwnedKey"
    )]
    #[builder(default, setter(strip_option))]
    pub use_aws_owned_key: Option<bool>,
}

/// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderLdapServerMetadata {
    /// List of a fully qualified domain name of the LDAP server and an optional failover server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hosts: Option<Vec<String>>,
    /// Fully qualified name of the directory to search for a user’s groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBase")]
    #[builder(default, setter(strip_option))]
    pub role_base: Option<String>,
    /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleName")]
    #[builder(default, setter(strip_option))]
    pub role_name: Option<String>,
    /// Search criteria for groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_subtree: Option<bool>,
    /// Service account password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_account_password_secret_ref:
        Option<BrokerForProviderLdapServerMetadataServiceAccountPasswordSecretRef>,
    /// Service account username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub service_account_username: Option<String>,
    /// Fully qualified name of the directory where you want to search for users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userBase")]
    #[builder(default, setter(strip_option))]
    pub user_base: Option<String>,
    /// Specifies the name of the LDAP attribute for the user group membership.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub user_role_name: Option<String>,
    /// Search criteria for users.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_subtree: Option<bool>,
}

/// Service account password.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderLdapServerMetadataServiceAccountPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Configuration block for the logging configuration of the broker. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderLogs {
    /// Enables audit logging. Auditing is only possible for engine_type of ActiveMQ. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub audit: Option<String>,
    /// Enables general logging via CloudWatch. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub general: Option<bool>,
}

/// Configuration block for the maintenance window start time. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderMaintenanceWindowStartTime {
    /// Day of the week, e.g., MONDAY, TUESDAY, or WEDNESDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default, setter(strip_option))]
    pub day_of_week: Option<String>,
    /// Time, in 24-hour format, e.g., 02:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    #[builder(default, setter(strip_option))]
    pub time_of_day: Option<String>,
    /// Time zone in either the Country/City format or the UTC offset format, e.g., CET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default, setter(strip_option))]
    pub time_zone: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerForProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerForProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerForProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerForProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderUser {
    /// Whether to enable access to the ActiveMQ Web Console for the user. Applies to engine_type of ActiveMQ only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consoleAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub console_access: Option<bool>,
    /// List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to engine_type of ActiveMQ only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub groups: Option<Vec<String>>,
    /// Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub password_secret_ref: Option<BrokerForProviderUserPasswordSecretRef>,
    /// Whether to set set replication user. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationUser"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_user: Option<bool>,
    /// Username of the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub username: Option<String>,
}

/// Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerForProviderUserPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProvider {
    /// Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Authentication strategy used to secure the broker. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_strategy: Option<String>,
    /// Whether to automatically upgrade to new minor versions of brokers as Amazon MQ makes releases available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<bool>,
    /// Name of the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerName"
    )]
    #[builder(default, setter(strip_option))]
    pub broker_name: Option<String>,
    /// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<BrokerInitProviderConfiguration>,
    /// Defines whether this broker is a part of a data replication pair. Valid values are CRDR and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_mode: Option<String>,
    /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when data_replication_mode is CRDR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn: Option<String>,
    /// Reference to a Broker in mq to populate dataReplicationPrimaryBrokerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn_ref:
        Option<BrokerInitProviderDataReplicationPrimaryBrokerArnRef>,
    /// Selector for a Broker in mq to populate dataReplicationPrimaryBrokerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn_selector:
        Option<BrokerInitProviderDataReplicationPrimaryBrokerArnSelector>,
    /// Deployment mode of the broker. Valid values are SINGLE_INSTANCE, ACTIVE_STANDBY_MULTI_AZ, and CLUSTER_MULTI_AZ. Default is SINGLE_INSTANCE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentMode"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_mode: Option<String>,
    /// Configuration block containing encryption options. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_options: Option<BrokerInitProviderEncryptionOptions>,
    /// Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineType"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_type: Option<String>,
    /// Version of the broker engine. See the AmazonMQ Broker Engine docs for supported versions. For example, 5.17.6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Broker's instance type. For example, mq.t3.micro, mq.m5.large.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub host_instance_type: Option<String>,
    /// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ldapServerMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub ldap_server_metadata: Option<BrokerInitProviderLdapServerMetadata>,
    /// Configuration block for the logging configuration of the broker. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logs: Option<BrokerInitProviderLogs>,
    /// Configuration block for the maintenance window start time. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindowStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window_start_time: Option<BrokerInitProviderMaintenanceWindowStartTime>,
    /// Whether to enable connections from applications outside of the VPC that hosts the broker's subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAccessible"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_accessible: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs: Option<Vec<BrokerInitProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector: Option<BrokerInitProviderSecurityGroupSelector>,
    /// List of security group IDs assigned to the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Storage type of the broker. For engine_type ActiveMQ, the valid values are efs and ebs, and the AWS-default is efs. For engine_type RabbitMQ, only ebs is supported. When using ebs, only the mq.m5 broker instance type family is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<BrokerInitProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<BrokerInitProviderSubnetIdSelector>,
    /// List of subnet IDs in which to launch the broker. A SINGLE_INSTANCE deployment requires one subnet. An ACTIVE_STANDBY_MULTI_AZ deployment requires multiple subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for broker users. For engine_type of RabbitMQ, Amazon MQ does not return broker users preventing this resource from making user updates and drift detection. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub user: Option<Vec<BrokerInitProviderUser>>,
}

/// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderConfiguration {
    /// The Configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Reference to a Configuration in mq to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idRef")]
    #[builder(default, setter(strip_option))]
    pub id_ref: Option<BrokerInitProviderConfigurationIdRef>,
    /// Selector for a Configuration in mq to populate id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub id_selector: Option<BrokerInitProviderConfigurationIdSelector>,
    /// Revision of the Configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a Configuration in mq to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderConfigurationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderConfigurationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderConfigurationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderConfigurationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderConfigurationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderConfigurationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderConfigurationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Configuration in mq to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderConfigurationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderConfigurationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderConfigurationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderConfigurationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderConfigurationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderConfigurationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderConfigurationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Broker in mq to populate dataReplicationPrimaryBrokerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderDataReplicationPrimaryBrokerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderDataReplicationPrimaryBrokerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Broker in mq to populate dataReplicationPrimaryBrokerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderDataReplicationPrimaryBrokerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderDataReplicationPrimaryBrokerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block containing encryption options. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderEncryptionOptions {
    /// Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting use_aws_owned_key to false. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useAwsOwnedKey"
    )]
    #[builder(default, setter(strip_option))]
    pub use_aws_owned_key: Option<bool>,
}

/// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderLdapServerMetadata {
    /// List of a fully qualified domain name of the LDAP server and an optional failover server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hosts: Option<Vec<String>>,
    /// Fully qualified name of the directory to search for a user’s groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBase")]
    #[builder(default, setter(strip_option))]
    pub role_base: Option<String>,
    /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleName")]
    #[builder(default, setter(strip_option))]
    pub role_name: Option<String>,
    /// Search criteria for groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_subtree: Option<bool>,
    /// Service account password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_account_password_secret_ref:
        Option<BrokerInitProviderLdapServerMetadataServiceAccountPasswordSecretRef>,
    /// Service account username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub service_account_username: Option<String>,
    /// Fully qualified name of the directory where you want to search for users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userBase")]
    #[builder(default, setter(strip_option))]
    pub user_base: Option<String>,
    /// Specifies the name of the LDAP attribute for the user group membership.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub user_role_name: Option<String>,
    /// Search criteria for users.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_subtree: Option<bool>,
}

/// Service account password.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderLdapServerMetadataServiceAccountPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Configuration block for the logging configuration of the broker. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderLogs {
    /// Enables audit logging. Auditing is only possible for engine_type of ActiveMQ. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub audit: Option<String>,
    /// Enables general logging via CloudWatch. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub general: Option<bool>,
}

/// Configuration block for the maintenance window start time. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderMaintenanceWindowStartTime {
    /// Day of the week, e.g., MONDAY, TUESDAY, or WEDNESDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default, setter(strip_option))]
    pub day_of_week: Option<String>,
    /// Time, in 24-hour format, e.g., 02:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    #[builder(default, setter(strip_option))]
    pub time_of_day: Option<String>,
    /// Time zone in either the Country/City format or the UTC offset format, e.g., CET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default, setter(strip_option))]
    pub time_zone: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerInitProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerInitProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerInitProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerInitProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderUser {
    /// Whether to enable access to the ActiveMQ Web Console for the user. Applies to engine_type of ActiveMQ only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consoleAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub console_access: Option<bool>,
    /// List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to engine_type of ActiveMQ only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub groups: Option<Vec<String>>,
    /// Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
    #[serde(rename = "passwordSecretRef")]
    pub password_secret_ref: BrokerInitProviderUserPasswordSecretRef,
    /// Whether to set set replication user. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationUser"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_user: Option<bool>,
    /// Username of the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub username: Option<String>,
}

/// Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerInitProviderUserPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<BrokerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<BrokerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BrokerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BrokerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BrokerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BrokerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// BrokerStatus defines the observed state of Broker.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<BrokerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProvider {
    /// Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// ARN of the broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Authentication strategy used to secure the broker. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_strategy: Option<String>,
    /// Whether to automatically upgrade to new minor versions of brokers as Amazon MQ makes releases available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<bool>,
    /// Name of the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerName"
    )]
    #[builder(default, setter(strip_option))]
    pub broker_name: Option<String>,
    /// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configuration: Option<BrokerStatusAtProviderConfiguration>,
    /// Defines whether this broker is a part of a data replication pair. Valid values are CRDR and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_mode: Option<String>,
    /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when data_replication_mode is CRDR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataReplicationPrimaryBrokerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub data_replication_primary_broker_arn: Option<String>,
    /// Deployment mode of the broker. Valid values are SINGLE_INSTANCE, ACTIVE_STANDBY_MULTI_AZ, and CLUSTER_MULTI_AZ. Default is SINGLE_INSTANCE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentMode"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_mode: Option<String>,
    /// Configuration block containing encryption options. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_options: Option<BrokerStatusAtProviderEncryptionOptions>,
    /// Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineType"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_type: Option<String>,
    /// Version of the broker engine. See the AmazonMQ Broker Engine docs for supported versions. For example, 5.17.6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Broker's instance type. For example, mq.t3.micro, mq.m5.large.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub host_instance_type: Option<String>,
    /// Unique ID that Amazon MQ generates for the broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// List of information about allocated brokers (both active & standby).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub instances: Option<Vec<BrokerStatusAtProviderInstances>>,
    /// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ldapServerMetadata"
    )]
    #[builder(default, setter(strip_option))]
    pub ldap_server_metadata: Option<BrokerStatusAtProviderLdapServerMetadata>,
    /// Configuration block for the logging configuration of the broker. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logs: Option<BrokerStatusAtProviderLogs>,
    /// Configuration block for the maintenance window start time. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindowStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window_start_time: Option<BrokerStatusAtProviderMaintenanceWindowStartTime>,
    /// The data replication mode that will be applied after reboot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pendingDataReplicationMode"
    )]
    #[builder(default, setter(strip_option))]
    pub pending_data_replication_mode: Option<String>,
    /// Whether to enable connections from applications outside of the VPC that hosts the broker's subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAccessible"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_accessible: Option<bool>,
    /// List of security group IDs assigned to the broker.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Storage type of the broker. For engine_type ActiveMQ, the valid values are efs and ebs, and the AWS-default is efs. For engine_type RabbitMQ, only ebs is supported. When using ebs, only the mq.m5 broker instance type family is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// List of subnet IDs in which to launch the broker. A SINGLE_INSTANCE deployment requires one subnet. An ACTIVE_STANDBY_MULTI_AZ deployment requires multiple subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Configuration block for broker users. For engine_type of RabbitMQ, Amazon MQ does not return broker users preventing this resource from making user updates and drift detection. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub user: Option<Vec<BrokerStatusAtProviderUser>>,
}

/// Configuration block for broker configuration. Applies to engine_type of ActiveMQ and RabbitMQ only. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderConfiguration {
    /// The Configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Revision of the Configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Configuration block containing encryption options. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderEncryptionOptions {
    /// Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting use_aws_owned_key to false. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useAwsOwnedKey"
    )]
    #[builder(default, setter(strip_option))]
    pub use_aws_owned_key: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderInstances {
    /// The URL of the ActiveMQ Web Console or the RabbitMQ Management UI depending on engine_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consoleUrl"
    )]
    #[builder(default, setter(strip_option))]
    pub console_url: Option<String>,
    /// Broker's wire-level protocol endpoints in the following order & format referenceable e.g., as instances.0.endpoints.0 (SSL):
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub endpoints: Option<Vec<String>>,
    /// IP Address of the broker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    #[builder(default, setter(strip_option))]
    pub ip_address: Option<String>,
}

/// Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderLdapServerMetadata {
    /// List of a fully qualified domain name of the LDAP server and an optional failover server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hosts: Option<Vec<String>>,
    /// Fully qualified name of the directory to search for a user’s groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBase")]
    #[builder(default, setter(strip_option))]
    pub role_base: Option<String>,
    /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleName")]
    #[builder(default, setter(strip_option))]
    pub role_name: Option<String>,
    /// Search criteria for groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub role_search_subtree: Option<bool>,
    /// Service account username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub service_account_username: Option<String>,
    /// Fully qualified name of the directory where you want to search for users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userBase")]
    #[builder(default, setter(strip_option))]
    pub user_base: Option<String>,
    /// Specifies the name of the LDAP attribute for the user group membership.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub user_role_name: Option<String>,
    /// Search criteria for users.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchMatching"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_matching: Option<String>,
    /// Whether the directory search scope is the entire sub-tree.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userSearchSubtree"
    )]
    #[builder(default, setter(strip_option))]
    pub user_search_subtree: Option<bool>,
}

/// Configuration block for the logging configuration of the broker. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderLogs {
    /// Enables audit logging. Auditing is only possible for engine_type of ActiveMQ. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub audit: Option<String>,
    /// Enables general logging via CloudWatch. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub general: Option<bool>,
}

/// Configuration block for the maintenance window start time. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderMaintenanceWindowStartTime {
    /// Day of the week, e.g., MONDAY, TUESDAY, or WEDNESDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default, setter(strip_option))]
    pub day_of_week: Option<String>,
    /// Time, in 24-hour format, e.g., 02:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    #[builder(default, setter(strip_option))]
    pub time_of_day: Option<String>,
    /// Time zone in either the Country/City format or the UTC offset format, e.g., CET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default, setter(strip_option))]
    pub time_zone: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BrokerStatusAtProviderUser {
    /// Whether to enable access to the ActiveMQ Web Console for the user. Applies to engine_type of ActiveMQ only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consoleAccess"
    )]
    #[builder(default, setter(strip_option))]
    pub console_access: Option<bool>,
    /// List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to engine_type of ActiveMQ only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub groups: Option<Vec<String>>,
    /// Whether to set set replication user. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationUser"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_user: Option<bool>,
    /// Username of the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub username: Option<String>,
}
