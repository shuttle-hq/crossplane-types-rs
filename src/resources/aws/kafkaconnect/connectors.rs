// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ConnectorSpec defines the desired state of Connector
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "kafkaconnect.aws.upbound.io",
    version = "v1beta2",
    kind = "Connector",
    plural = "connectors"
)]
#[kube(status = "ConnectorStatus")]
pub struct ConnectorSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ConnectorDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ConnectorForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ConnectorInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ConnectorProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ConnectorPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ConnectorWriteConnectionSecretToRef>,
}

/// ConnectorSpec defines the desired state of Connector
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProvider {
    /// Information about the capacity allocated to the connector. See capacity Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub capacity: Option<ConnectorForProviderCapacity>,
    /// A map of keys to values that represent the configuration for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectorConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub connector_configuration: Option<BTreeMap<String, String>>,
    /// A summary description of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster: Option<ConnectorForProviderKafkaCluster>,
    /// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterClientAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_client_authentication:
        Option<ConnectorForProviderKafkaClusterClientAuthentication>,
    /// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterEncryptionInTransit"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_encryption_in_transit:
        Option<ConnectorForProviderKafkaClusterEncryptionInTransit>,
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaconnectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub kafkaconnect_version: Option<String>,
    /// Details about log delivery. See log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery: Option<ConnectorForProviderLogDelivery>,
    /// The name of the connector.
    pub name: String,
    /// Specifies which plugins to use for the connector. See plugin Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub plugin: Option<Vec<ConnectorForProviderPlugin>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRoleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn_ref: Option<ConnectorForProviderServiceExecutionRoleArnRef>,
    /// Selector for a Role in iam to populate serviceExecutionRoleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn_selector:
        Option<ConnectorForProviderServiceExecutionRoleArnSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_configuration: Option<ConnectorForProviderWorkerConfiguration>,
}

/// Information about the capacity allocated to the connector. See capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderCapacity {
    /// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub autoscaling: Option<ConnectorForProviderCapacityAutoscaling>,
    /// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub provisioned_capacity: Option<ConnectorForProviderCapacityProvisionedCapacity>,
}

/// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderCapacityAutoscaling {
    /// The maximum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub max_worker_count: Option<f64>,
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The minimum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub min_worker_count: Option<f64>,
    /// The scale-in policy for the connector. See scale_in_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleInPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_in_policy: Option<ConnectorForProviderCapacityAutoscalingScaleInPolicy>,
    /// The scale-out policy for the connector. See scale_out_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleOutPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_out_policy: Option<ConnectorForProviderCapacityAutoscalingScaleOutPolicy>,
}

/// The scale-in policy for the connector. See scale_in_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderCapacityAutoscalingScaleInPolicy {
    /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// The scale-out policy for the connector. See scale_out_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderCapacityAutoscalingScaleOutPolicy {
    /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderCapacityProvisionedCapacity {
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The number of workers that are allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_count: Option<f64>,
}

/// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaCluster {
    /// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apacheKafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub apache_kafka_cluster: Option<ConnectorForProviderKafkaClusterApacheKafkaCluster>,
}

/// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaCluster {
    /// The bootstrap servers of the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapServers"
    )]
    #[builder(default, setter(strip_option))]
    pub bootstrap_servers: Option<String>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub vpc: Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpc>,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpc {
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs:
        Option<Vec<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelector>,
    /// The security groups for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_refs: Option<Vec<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_selector:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelector>,
    /// The subnets for the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterClientAuthentication {
    /// The type of client authentication used to connect to the Apache Kafka cluster. Valid values: IAM, NONE. A value of NONE means that no client authentication is used. The default value is NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationType"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_type: Option<String>,
}

/// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderKafkaClusterEncryptionInTransit {
    /// The type of encryption in transit to the Apache Kafka cluster. Valid values: PLAINTEXT, TLS. The default values is PLAINTEXT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionType"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_type: Option<String>,
}

/// Details about log delivery. See log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDelivery {
    /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerLogDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_log_delivery: Option<ConnectorForProviderLogDeliveryWorkerLogDelivery>,
}

/// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDelivery {
    /// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_logs: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs>,
    /// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub firehose: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehose>,
    /// Details about delivering logs to Amazon S3. See s3 Block for deetails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub s3: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3>,
}

/// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs {
    /// Whether log delivery to Amazon CloudWatch Logs is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The name of the CloudWatch log group that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupRef"
    )]
    #[builder(default, setter(strip_option))]
    pub log_group_ref:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRef>,
    /// Selector for a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub log_group_selector:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelector>,
}

/// Reference to a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehose {
    /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamRef"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream_ref:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRef>,
    /// Selector for a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream_selector:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelector>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Reference to a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<
        ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Details about delivering logs to Amazon S3. See s3 Block for deetails.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryS3 {
    /// The name of the S3 bucket that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelector>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The S3 prefix that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPlugin {
    /// Details about a custom plugin. See custom_plugin Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customPlugin"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_plugin: Option<ConnectorForProviderPluginCustomPlugin>,
}

/// Details about a custom plugin. See custom_plugin Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPluginCustomPlugin {
    /// The Amazon Resource Name (ARN) of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a CustomPlugin in kafkaconnect to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ConnectorForProviderPluginCustomPluginArnRef>,
    /// Selector for a CustomPlugin in kafkaconnect to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ConnectorForProviderPluginCustomPluginArnSelector>,
    /// The revision of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a CustomPlugin in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPluginCustomPluginArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderPluginCustomPluginArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPluginCustomPluginArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderPluginCustomPluginArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderPluginCustomPluginArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderPluginCustomPluginArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderPluginCustomPluginArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CustomPlugin in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPluginCustomPluginArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderPluginCustomPluginArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderPluginCustomPluginArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderPluginCustomPluginArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderPluginCustomPluginArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderPluginCustomPluginArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderPluginCustomPluginArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderServiceExecutionRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderServiceExecutionRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderServiceExecutionRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderServiceExecutionRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderServiceExecutionRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderServiceExecutionRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderServiceExecutionRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderServiceExecutionRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderServiceExecutionRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderServiceExecutionRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderServiceExecutionRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderServiceExecutionRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderServiceExecutionRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderServiceExecutionRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderWorkerConfiguration {
    /// The Amazon Resource Name (ARN) of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a WorkerConfiguration in kafkaconnect to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ConnectorForProviderWorkerConfigurationArnRef>,
    /// Selector for a WorkerConfiguration in kafkaconnect to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ConnectorForProviderWorkerConfigurationArnSelector>,
    /// The revision of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a WorkerConfiguration in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderWorkerConfigurationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderWorkerConfigurationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderWorkerConfigurationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderWorkerConfigurationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderWorkerConfigurationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderWorkerConfigurationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderWorkerConfigurationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a WorkerConfiguration in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderWorkerConfigurationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorForProviderWorkerConfigurationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorForProviderWorkerConfigurationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorForProviderWorkerConfigurationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorForProviderWorkerConfigurationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderWorkerConfigurationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorForProviderWorkerConfigurationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProvider {
    /// Information about the capacity allocated to the connector. See capacity Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub capacity: Option<ConnectorInitProviderCapacity>,
    /// A map of keys to values that represent the configuration for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectorConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub connector_configuration: Option<BTreeMap<String, String>>,
    /// A summary description of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster: Option<ConnectorInitProviderKafkaCluster>,
    /// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterClientAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_client_authentication:
        Option<ConnectorInitProviderKafkaClusterClientAuthentication>,
    /// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterEncryptionInTransit"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_encryption_in_transit:
        Option<ConnectorInitProviderKafkaClusterEncryptionInTransit>,
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaconnectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub kafkaconnect_version: Option<String>,
    /// Details about log delivery. See log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery: Option<ConnectorInitProviderLogDelivery>,
    /// Specifies which plugins to use for the connector. See plugin Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub plugin: Option<Vec<ConnectorInitProviderPlugin>>,
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRoleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn_ref: Option<ConnectorInitProviderServiceExecutionRoleArnRef>,
    /// Selector for a Role in iam to populate serviceExecutionRoleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn_selector:
        Option<ConnectorInitProviderServiceExecutionRoleArnSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_configuration: Option<ConnectorInitProviderWorkerConfiguration>,
}

/// Information about the capacity allocated to the connector. See capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderCapacity {
    /// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub autoscaling: Option<ConnectorInitProviderCapacityAutoscaling>,
    /// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub provisioned_capacity: Option<ConnectorInitProviderCapacityProvisionedCapacity>,
}

/// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderCapacityAutoscaling {
    /// The maximum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub max_worker_count: Option<f64>,
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The minimum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub min_worker_count: Option<f64>,
    /// The scale-in policy for the connector. See scale_in_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleInPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_in_policy: Option<ConnectorInitProviderCapacityAutoscalingScaleInPolicy>,
    /// The scale-out policy for the connector. See scale_out_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleOutPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_out_policy: Option<ConnectorInitProviderCapacityAutoscalingScaleOutPolicy>,
}

/// The scale-in policy for the connector. See scale_in_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderCapacityAutoscalingScaleInPolicy {
    /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// The scale-out policy for the connector. See scale_out_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderCapacityAutoscalingScaleOutPolicy {
    /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderCapacityProvisionedCapacity {
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The number of workers that are allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_count: Option<f64>,
}

/// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaCluster {
    /// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apacheKafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub apache_kafka_cluster: Option<ConnectorInitProviderKafkaClusterApacheKafkaCluster>,
}

/// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaCluster {
    /// The bootstrap servers of the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapServers"
    )]
    #[builder(default, setter(strip_option))]
    pub bootstrap_servers: Option<String>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub vpc: Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpc>,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpc {
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs:
        Option<Vec<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelector>,
    /// The security groups for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_refs: Option<Vec<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_selector:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelector>,
    /// The subnets for the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderKafkaClusterApacheKafkaClusterVpcSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterClientAuthentication {
    /// The type of client authentication used to connect to the Apache Kafka cluster. Valid values: IAM, NONE. A value of NONE means that no client authentication is used. The default value is NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationType"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_type: Option<String>,
}

/// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderKafkaClusterEncryptionInTransit {
    /// The type of encryption in transit to the Apache Kafka cluster. Valid values: PLAINTEXT, TLS. The default values is PLAINTEXT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionType"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_type: Option<String>,
}

/// Details about log delivery. See log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDelivery {
    /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerLogDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_log_delivery: Option<ConnectorInitProviderLogDeliveryWorkerLogDelivery>,
}

/// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDelivery {
    /// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_logs: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs>,
    /// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub firehose: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehose>,
    /// Details about delivering logs to Amazon S3. See s3 Block for deetails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub s3: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3>,
}

/// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs {
    /// Whether log delivery to Amazon CloudWatch Logs is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The name of the CloudWatch log group that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupRef"
    )]
    #[builder(default, setter(strip_option))]
    pub log_group_ref:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRef>,
    /// Selector for a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub log_group_selector:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelector>,
}

/// Reference to a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryCloudwatchLogsLogGroupSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehose {
    /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamRef"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream_ref:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRef>,
    /// Selector for a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream_selector:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelector>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Reference to a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<
        ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryFirehoseDeliveryStreamSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Details about delivering logs to Amazon S3. See s3 Block for deetails.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3 {
    /// The name of the S3 bucket that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelector>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The S3 prefix that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderLogDeliveryWorkerLogDeliveryS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPlugin {
    /// Details about a custom plugin. See custom_plugin Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customPlugin"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_plugin: Option<ConnectorInitProviderPluginCustomPlugin>,
}

/// Details about a custom plugin. See custom_plugin Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPluginCustomPlugin {
    /// The Amazon Resource Name (ARN) of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a CustomPlugin in kafkaconnect to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ConnectorInitProviderPluginCustomPluginArnRef>,
    /// Selector for a CustomPlugin in kafkaconnect to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ConnectorInitProviderPluginCustomPluginArnSelector>,
    /// The revision of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a CustomPlugin in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPluginCustomPluginArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderPluginCustomPluginArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPluginCustomPluginArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderPluginCustomPluginArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderPluginCustomPluginArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderPluginCustomPluginArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderPluginCustomPluginArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CustomPlugin in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPluginCustomPluginArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderPluginCustomPluginArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderPluginCustomPluginArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderPluginCustomPluginArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderPluginCustomPluginArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderPluginCustomPluginArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderPluginCustomPluginArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderServiceExecutionRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderServiceExecutionRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderServiceExecutionRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderServiceExecutionRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderServiceExecutionRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderServiceExecutionRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderServiceExecutionRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderServiceExecutionRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderServiceExecutionRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderServiceExecutionRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderServiceExecutionRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderServiceExecutionRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderServiceExecutionRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderServiceExecutionRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderWorkerConfiguration {
    /// The Amazon Resource Name (ARN) of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a WorkerConfiguration in kafkaconnect to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ConnectorInitProviderWorkerConfigurationArnRef>,
    /// Selector for a WorkerConfiguration in kafkaconnect to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ConnectorInitProviderWorkerConfigurationArnSelector>,
    /// The revision of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Reference to a WorkerConfiguration in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderWorkerConfigurationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderWorkerConfigurationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderWorkerConfigurationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderWorkerConfigurationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderWorkerConfigurationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderWorkerConfigurationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderWorkerConfigurationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a WorkerConfiguration in kafkaconnect to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderWorkerConfigurationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorInitProviderWorkerConfigurationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorInitProviderWorkerConfigurationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorInitProviderWorkerConfigurationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorInitProviderWorkerConfigurationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderWorkerConfigurationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorInitProviderWorkerConfigurationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ConnectorPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ConnectorPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ConnectorPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ConnectorPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ConnectorPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectorPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ConnectorStatus defines the observed state of Connector.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ConnectorStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProvider {
    /// The Amazon Resource Name (ARN) of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Information about the capacity allocated to the connector. See capacity Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub capacity: Option<ConnectorStatusAtProviderCapacity>,
    /// A map of keys to values that represent the configuration for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectorConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub connector_configuration: Option<BTreeMap<String, String>>,
    /// A summary description of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster: Option<ConnectorStatusAtProviderKafkaCluster>,
    /// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterClientAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_client_authentication:
        Option<ConnectorStatusAtProviderKafkaClusterClientAuthentication>,
    /// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaClusterEncryptionInTransit"
    )]
    #[builder(default, setter(strip_option))]
    pub kafka_cluster_encryption_in_transit:
        Option<ConnectorStatusAtProviderKafkaClusterEncryptionInTransit>,
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaconnectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub kafkaconnect_version: Option<String>,
    /// Details about log delivery. See log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery: Option<ConnectorStatusAtProviderLogDelivery>,
    /// The name of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Specifies which plugins to use for the connector. See plugin Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub plugin: Option<Vec<ConnectorStatusAtProviderPlugin>>,
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub service_execution_role_arn: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// The current version of the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub version: Option<String>,
    /// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_configuration: Option<ConnectorStatusAtProviderWorkerConfiguration>,
}

/// Information about the capacity allocated to the connector. See capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderCapacity {
    /// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub autoscaling: Option<ConnectorStatusAtProviderCapacityAutoscaling>,
    /// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub provisioned_capacity: Option<ConnectorStatusAtProviderCapacityProvisionedCapacity>,
}

/// Information about the auto scaling parameters for the connector. See autoscaling Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderCapacityAutoscaling {
    /// The maximum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub max_worker_count: Option<f64>,
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The minimum number of workers allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minWorkerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub min_worker_count: Option<f64>,
    /// The scale-in policy for the connector. See scale_in_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleInPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_in_policy: Option<ConnectorStatusAtProviderCapacityAutoscalingScaleInPolicy>,
    /// The scale-out policy for the connector. See scale_out_policy Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scaleOutPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub scale_out_policy: Option<ConnectorStatusAtProviderCapacityAutoscalingScaleOutPolicy>,
}

/// The scale-in policy for the connector. See scale_in_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderCapacityAutoscalingScaleInPolicy {
    /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// The scale-out policy for the connector. See scale_out_policy Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderCapacityAutoscalingScaleOutPolicy {
    /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuUtilizationPercentage"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_utilization_percentage: Option<f64>,
}

/// Details about a fixed capacity allocated to a connector. See provisioned_capacity Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderCapacityProvisionedCapacity {
    /// The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: 1, 2, 4, 8. The default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mcuCount")]
    #[builder(default, setter(strip_option))]
    pub mcu_count: Option<f64>,
    /// The number of workers that are allocated to the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerCount"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_count: Option<f64>,
}

/// Specifies which Apache Kafka cluster to connect to. See kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderKafkaCluster {
    /// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apacheKafkaCluster"
    )]
    #[builder(default, setter(strip_option))]
    pub apache_kafka_cluster: Option<ConnectorStatusAtProviderKafkaClusterApacheKafkaCluster>,
}

/// The Apache Kafka cluster to which the connector is connected. See apache_kafka_cluster Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderKafkaClusterApacheKafkaCluster {
    /// The bootstrap servers of the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapServers"
    )]
    #[builder(default, setter(strip_option))]
    pub bootstrap_servers: Option<String>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub vpc: Option<ConnectorStatusAtProviderKafkaClusterApacheKafkaClusterVpc>,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster. See vpc Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderKafkaClusterApacheKafkaClusterVpc {
    /// The security groups for the connector.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// The subnets for the connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

/// Details of the client authentication used by the Apache Kafka cluster. See kafka_cluster_client_authentication Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderKafkaClusterClientAuthentication {
    /// The type of client authentication used to connect to the Apache Kafka cluster. Valid values: IAM, NONE. A value of NONE means that no client authentication is used. The default value is NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationType"
    )]
    #[builder(default, setter(strip_option))]
    pub authentication_type: Option<String>,
}

/// Details of encryption in transit to the Apache Kafka cluster. See kafka_cluster_encryption_in_transit Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderKafkaClusterEncryptionInTransit {
    /// The type of encryption in transit to the Apache Kafka cluster. Valid values: PLAINTEXT, TLS. The default values is PLAINTEXT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionType"
    )]
    #[builder(default, setter(strip_option))]
    pub encryption_type: Option<String>,
}

/// Details about log delivery. See log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderLogDelivery {
    /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workerLogDelivery"
    )]
    #[builder(default, setter(strip_option))]
    pub worker_log_delivery: Option<ConnectorStatusAtProviderLogDeliveryWorkerLogDelivery>,
}

/// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See worker_log_delivery Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderLogDeliveryWorkerLogDelivery {
    /// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_logs:
        Option<ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs>,
    /// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub firehose: Option<ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryFirehose>,
    /// Details about delivering logs to Amazon S3. See s3 Block for deetails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub s3: Option<ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryS3>,
}

/// Details about delivering logs to Amazon CloudWatch Logs. See cloudwatch_logs Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryCloudwatchLogs {
    /// Whether log delivery to Amazon CloudWatch Logs is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The name of the CloudWatch log group that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
}

/// Details about delivering logs to Amazon Kinesis Data Firehose. See firehose Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryFirehose {
    /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default, setter(strip_option))]
    pub delivery_stream: Option<String>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Details about delivering logs to Amazon S3. See s3 Block for deetails.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderLogDeliveryWorkerLogDeliveryS3 {
    /// The name of the S3 bucket that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// The S3 prefix that is the destination for log delivery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderPlugin {
    /// Details about a custom plugin. See custom_plugin Block for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customPlugin"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_plugin: Option<ConnectorStatusAtProviderPluginCustomPlugin>,
}

/// Details about a custom plugin. See custom_plugin Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderPluginCustomPlugin {
    /// The Amazon Resource Name (ARN) of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The revision of the custom plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}

/// Specifies which worker configuration to use with the connector. See worker_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ConnectorStatusAtProviderWorkerConfiguration {
    /// The Amazon Resource Name (ARN) of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The revision of the worker configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub revision: Option<f64>,
}
