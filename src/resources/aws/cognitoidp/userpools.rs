// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// UserPoolSpec defines the desired state of UserPool
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "cognitoidp.aws.upbound.io",
    version = "v1beta2",
    kind = "UserPool",
    plural = "userpools"
)]
#[kube(status = "UserPoolStatus")]
pub struct UserPoolSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<UserPoolDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: UserPoolForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<UserPoolInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<UserPoolProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<UserPoolPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<UserPoolWriteConnectionSecretToRef>,
}

/// UserPoolSpec defines the desired state of UserPool
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProvider {
    /// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accountRecoverySetting"
    )]
    #[builder(default, setter(strip_option))]
    pub account_recovery_setting: Option<UserPoolForProviderAccountRecoverySetting>,
    /// Configuration block for creating a new user profile. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "adminCreateUserConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub admin_create_user_config: Option<UserPoolForProviderAdminCreateUserConfig>,
    /// Attributes supported as an alias for this user pool. Valid values: phone_number, email, or preferred_username. Conflicts with username_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "aliasAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub alias_attributes: Option<Vec<String>>,
    /// Attributes to be auto-verified. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoVerifiedAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_verified_attributes: Option<Vec<String>>,
    /// When active, DeletionProtection prevents accidental deletion of your user pool. Before you can delete a user pool that you have protected against deletion, you must deactivate this feature. Valid values are ACTIVE and INACTIVE, Default value is INACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<String>,
    /// Configuration block for the user pool's device tracking. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub device_configuration: Option<UserPoolForProviderDeviceConfiguration>,
    /// Configuration block for configuring email. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub email_configuration: Option<UserPoolForProviderEmailConfiguration>,
    /// String representing the email verification message. Conflicts with verification_message_template configuration block email_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_message: Option<String>,
    /// String representing the email verification subject. Conflicts with verification_message_template configuration block email_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_subject: Option<String>,
    /// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_config: Option<UserPoolForProviderLambdaConfig>,
    /// Multi-Factor Authentication (MFA) configuration for the User Pool. Defaults of OFF. Valid values are OFF (MFA Tokens are not required), ON (MFA is required for all users to sign in; requires at least one of sms_configuration or software_token_mfa_configuration to be configured), or OPTIONAL (MFA Will be required only for individual users who have MFA Enabled; requires at least one of sms_configuration or software_token_mfa_configuration to be configured).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub mfa_configuration: Option<String>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for information about the user pool password policy. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub password_policy: Option<UserPoolForProviderPasswordPolicy>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Configuration block for the schema attributes of a user pool. Detailed below. Schema attributes from the standard attribute set only need to be specified if they are different from the default configuration. Attributes can be added, but not modified or removed. Maximum of 50 attributes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schema: Option<Vec<UserPoolForProviderSchema>>,
    /// String representing the SMS authentication message. The Message must contain the {####} placeholder, which will be replaced with the code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsAuthenticationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_authentication_message: Option<String>,
    /// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_configuration: Option<UserPoolForProviderSmsConfiguration>,
    /// String representing the SMS verification message. Conflicts with verification_message_template configuration block sms_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_verification_message: Option<String>,
    /// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "softwareTokenMfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub software_token_mfa_configuration: Option<UserPoolForProviderSoftwareTokenMfaConfiguration>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for user attribute update settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userAttributeUpdateSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub user_attribute_update_settings: Option<UserPoolForProviderUserAttributeUpdateSettings>,
    /// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolAddOns"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_add_ons: Option<UserPoolForProviderUserPoolAddOns>,
    /// Whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with alias_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub username_attributes: Option<Vec<String>>,
    /// Configuration block for username configuration. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub username_configuration: Option<UserPoolForProviderUsernameConfiguration>,
    /// Configuration block for verification message templates. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verificationMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub verification_message_template: Option<UserPoolForProviderVerificationMessageTemplate>,
}

/// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderAccountRecoverySetting {
    /// List of Account Recovery Options of the following structure:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recoveryMechanism"
    )]
    #[builder(default, setter(strip_option))]
    pub recovery_mechanism: Option<Vec<UserPoolForProviderAccountRecoverySettingRecoveryMechanism>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderAccountRecoverySettingRecoveryMechanism {
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Positive integer specifying priority of a method with 1 being the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
}

/// Configuration block for creating a new user profile. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderAdminCreateUserConfig {
    /// Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowAdminCreateUserOnly"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_admin_create_user_only: Option<bool>,
    /// Invite message template structure. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inviteMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub invite_message_template:
        Option<UserPoolForProviderAdminCreateUserConfigInviteMessageTemplate>,
}

/// Invite message template structure. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderAdminCreateUserConfigInviteMessageTemplate {
    /// Message template for email messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Subject line for email messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Message template for SMS messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}

/// Configuration block for the user pool's device tracking. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderDeviceConfiguration {
    /// Whether a challenge is required on a new device. Only applicable to a new device.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "challengeRequiredOnNewDevice"
    )]
    #[builder(default, setter(strip_option))]
    pub challenge_required_on_new_device: Option<bool>,
    /// Whether a device is only remembered on user prompt. false equates to "Always" remember, true is "User Opt In," and not using a device_configuration block is "No."
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceOnlyRememberedOnUserPrompt"
    )]
    #[builder(default, setter(strip_option))]
    pub device_only_remembered_on_user_prompt: Option<bool>,
}

/// Configuration block for configuring email. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderEmailConfiguration {
    /// Email configuration set name from SES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationSet"
    )]
    #[builder(default, setter(strip_option))]
    pub configuration_set: Option<String>,
    /// Email delivery method to use. COGNITO_DEFAULT for the default email functionality built into Cognito or DEVELOPER to use your Amazon SES configuration. Required to be DEVELOPER if from_email_address is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSendingAccount"
    )]
    #[builder(default, setter(strip_option))]
    pub email_sending_account: Option<String>,
    /// Sender’s email address or sender’s display name with their email address (e.g., john@example.com, John Smith <john@example.com> or \"John Smith Ph.D.\" <john@example.com>). Escaped double quotes are required around display names that contain certain characters as specified in RFC 5322.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fromEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub from_email_address: Option<String>,
    /// REPLY-TO email address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replyToEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub reply_to_email_address: Option<String>,
    /// ARN of the SES verified email identity to use. Required if email_sending_account is set to DEVELOPER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceArn")]
    #[builder(default, setter(strip_option))]
    pub source_arn: Option<String>,
}

/// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfig {
    /// ARN of the lambda creating an authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge: Option<String>,
    /// Reference to a Function in lambda to populate createAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallengeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge_ref: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeRef>,
    /// Selector for a Function in lambda to populate createAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallengeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge_selector:
        Option<UserPoolForProviderLambdaConfigCreateAuthChallengeSelector>,
    /// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customEmailSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_email_sender: Option<UserPoolForProviderLambdaConfigCustomEmailSender>,
    /// Custom Message AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message: Option<String>,
    /// Reference to a Function in lambda to populate customMessage.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessageRef"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message_ref: Option<UserPoolForProviderLambdaConfigCustomMessageRef>,
    /// Selector for a Function in lambda to populate customMessage.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessageSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message_selector: Option<UserPoolForProviderLambdaConfigCustomMessageSelector>,
    /// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customSmsSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_sms_sender: Option<UserPoolForProviderLambdaConfigCustomSmsSender>,
    /// Defines the authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge: Option<String>,
    /// Reference to a Function in lambda to populate defineAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallengeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge_ref: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeRef>,
    /// Selector for a Function in lambda to populate defineAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallengeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge_selector:
        Option<UserPoolForProviderLambdaConfigDefineAuthChallengeSelector>,
    /// The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<UserPoolForProviderLambdaConfigKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<UserPoolForProviderLambdaConfigKmsKeyIdSelector>,
    /// Post-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication: Option<String>,
    /// Reference to a Function in lambda to populate postAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_ref: Option<UserPoolForProviderLambdaConfigPostAuthenticationRef>,
    /// Selector for a Function in lambda to populate postAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_selector:
        Option<UserPoolForProviderLambdaConfigPostAuthenticationSelector>,
    /// Post-confirmation AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmation"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation: Option<String>,
    /// Reference to a Function in lambda to populate postConfirmation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation_ref: Option<UserPoolForProviderLambdaConfigPostConfirmationRef>,
    /// Selector for a Function in lambda to populate postConfirmation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation_selector: Option<UserPoolForProviderLambdaConfigPostConfirmationSelector>,
    /// Pre-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication: Option<String>,
    /// Reference to a Function in lambda to populate preAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_ref: Option<UserPoolForProviderLambdaConfigPreAuthenticationRef>,
    /// Selector for a Function in lambda to populate preAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_selector:
        Option<UserPoolForProviderLambdaConfigPreAuthenticationSelector>,
    /// Pre-registration AWS Lambda trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preSignUp")]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up: Option<String>,
    /// Reference to a Function in lambda to populate preSignUp.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preSignUpRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up_ref: Option<UserPoolForProviderLambdaConfigPreSignUpRef>,
    /// Selector for a Function in lambda to populate preSignUp.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preSignUpSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up_selector: Option<UserPoolForProviderLambdaConfigPreSignUpSelector>,
    /// Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of pre_token_generation_config.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation: Option<String>,
    /// Allow to customize access tokens. See pre_token_configuration_type
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_config:
        Option<UserPoolForProviderLambdaConfigPreTokenGenerationConfig>,
    /// Reference to a Function in lambda to populate preTokenGeneration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_ref: Option<UserPoolForProviderLambdaConfigPreTokenGenerationRef>,
    /// Selector for a Function in lambda to populate preTokenGeneration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_selector:
        Option<UserPoolForProviderLambdaConfigPreTokenGenerationSelector>,
    /// User migration Lambda config type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigration"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration: Option<String>,
    /// Reference to a Function in lambda to populate userMigration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigrationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration_ref: Option<UserPoolForProviderLambdaConfigUserMigrationRef>,
    /// Selector for a Function in lambda to populate userMigration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigrationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration_selector: Option<UserPoolForProviderLambdaConfigUserMigrationSelector>,
    /// Verifies the authentication challenge response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response: Option<String>,
    /// Reference to a Function in lambda to populate verifyAuthChallengeResponse.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponseRef"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response_ref:
        Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRef>,
    /// Selector for a Function in lambda to populate verifyAuthChallengeResponse.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponseSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response_selector:
        Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelector>,
}

/// Reference to a Function in lambda to populate createAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCreateAuthChallengeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCreateAuthChallengeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate createAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCreateAuthChallengeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomEmailSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_ref: Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_selector:
        Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelector>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate customMessage.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomMessageRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomMessageRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomMessageRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigCustomMessageRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCustomMessageRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomMessageRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomMessageRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate customMessage.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomMessageSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomMessageSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomMessageSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigCustomMessageSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCustomMessageSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomMessageSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomMessageSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomSmsSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_ref: Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_selector:
        Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelector>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate defineAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigDefineAuthChallengeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigDefineAuthChallengeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate defineAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigDefineAuthChallengeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate postAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostAuthenticationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPostAuthenticationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostAuthenticationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPostAuthenticationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPostAuthenticationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostAuthenticationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostAuthenticationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate postAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostAuthenticationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostAuthenticationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate postConfirmation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostConfirmationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPostConfirmationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostConfirmationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPostConfirmationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPostConfirmationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostConfirmationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostConfirmationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate postConfirmation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostConfirmationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPostConfirmationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate preAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreAuthenticationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreAuthenticationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreAuthenticationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPreAuthenticationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreAuthenticationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreAuthenticationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreAuthenticationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreAuthenticationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreAuthenticationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate preSignUp.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreSignUpRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreSignUpRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreSignUpRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPreSignUpRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreSignUpRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreSignUpRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreSignUpRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preSignUp.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreSignUpSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreSignUpSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreSignUpSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPreSignUpSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreSignUpSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreSignUpSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreSignUpSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Allow to customize access tokens. See pre_token_configuration_type
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreTokenGenerationConfig {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// The Lambda version represents the signature of the "version" attribute in the "event" information Amazon Cognito passes to your pre Token Generation Lambda function. The supported values are V1_0, V2_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate preTokenGeneration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreTokenGenerationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreTokenGenerationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preTokenGeneration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreTokenGenerationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigPreTokenGenerationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate userMigration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigUserMigrationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigUserMigrationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigUserMigrationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigUserMigrationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigUserMigrationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigUserMigrationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigUserMigrationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate userMigration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigUserMigrationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigUserMigrationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigUserMigrationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderLambdaConfigUserMigrationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigUserMigrationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigUserMigrationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigUserMigrationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate verifyAuthChallengeResponse.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate verifyAuthChallengeResponse.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for information about the user pool password policy. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderPasswordPolicy {
    /// Minimum length of the password policy that you have set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minimumLength"
    )]
    #[builder(default, setter(strip_option))]
    pub minimum_length: Option<f64>,
    /// Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordHistorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub password_history_size: Option<f64>,
    /// Whether you have required users to use at least one lowercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireLowercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_lowercase: Option<bool>,
    /// Whether you have required users to use at least one number in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireNumbers"
    )]
    #[builder(default, setter(strip_option))]
    pub require_numbers: Option<bool>,
    /// Whether you have required users to use at least one symbol in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireSymbols"
    )]
    #[builder(default, setter(strip_option))]
    pub require_symbols: Option<bool>,
    /// Whether you have required users to use at least one uppercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireUppercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_uppercase: Option<bool>,
    /// In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "temporaryPasswordValidityDays"
    )]
    #[builder(default, setter(strip_option))]
    pub temporary_password_validity_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSchema {
    /// Attribute data type. Must be one of Boolean, Number, String, DateTime.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeDataType"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_data_type: Option<String>,
    /// Whether the attribute type is developer only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "developerOnlyAttribute"
    )]
    #[builder(default, setter(strip_option))]
    pub developer_only_attribute: Option<bool>,
    /// Whether the attribute can be changed once it has been created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mutable: Option<bool>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for the constraints for an attribute of the number type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub number_attribute_constraints: Option<UserPoolForProviderSchemaNumberAttributeConstraints>,
    /// Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub required: Option<bool>,
    /// Constraints for an attribute of the string type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub string_attribute_constraints: Option<UserPoolForProviderSchemaStringAttributeConstraints>,
}

/// Configuration block for the constraints for an attribute of the number type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSchemaNumberAttributeConstraints {
    /// Maximum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxValue")]
    #[builder(default, setter(strip_option))]
    pub max_value: Option<String>,
    /// Minimum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minValue")]
    #[builder(default, setter(strip_option))]
    pub min_value: Option<String>,
}

/// Constraints for an attribute of the string type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSchemaStringAttributeConstraints {
    /// Maximum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    #[builder(default, setter(strip_option))]
    pub max_length: Option<String>,
    /// Minimum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    #[builder(default, setter(strip_option))]
    pub min_length: Option<String>,
}

/// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSmsConfiguration {
    /// External ID used in IAM role trust relationships. For more information about using external IDs, see How to Use an External ID When Granting Access to Your AWS Resources to a Third Party.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "externalId"
    )]
    #[builder(default, setter(strip_option))]
    pub external_id: Option<String>,
    /// ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn: Option<String>,
    /// Reference to a Role in iam to populate snsCallerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn_ref: Option<UserPoolForProviderSmsConfigurationSnsCallerArnRef>,
    /// Selector for a Role in iam to populate snsCallerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn_selector: Option<UserPoolForProviderSmsConfigurationSnsCallerArnSelector>,
    /// The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see SMS message settings for Amazon Cognito user pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsRegion")]
    #[builder(default, setter(strip_option))]
    pub sns_region: Option<String>,
}

/// Reference to a Role in iam to populate snsCallerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSmsConfigurationSnsCallerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderSmsConfigurationSnsCallerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate snsCallerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSmsConfigurationSnsCallerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderSoftwareTokenMfaConfiguration {
    /// Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When sms_configuration is not present, the mfa_configuration argument must be set to OFF and the software_token_mfa_configuration configuration block must be fully removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Configuration block for user attribute update settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderUserAttributeUpdateSettings {
    /// A list of attributes requiring verification before update. If set, the provided value(s) must also be set in auto_verified_attributes. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributesRequireVerificationBeforeUpdate"
    )]
    #[builder(default, setter(strip_option))]
    pub attributes_require_verification_before_update: Option<Vec<String>>,
}

/// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderUserPoolAddOns {
    /// Mode for advanced security, must be one of OFF, AUDIT or ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "advancedSecurityMode"
    )]
    #[builder(default, setter(strip_option))]
    pub advanced_security_mode: Option<String>,
}

/// Configuration block for username configuration. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderUsernameConfiguration {
    /// Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caseSensitive"
    )]
    #[builder(default, setter(strip_option))]
    pub case_sensitive: Option<bool>,
}

/// Configuration block for verification message templates. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolForProviderVerificationMessageTemplate {
    /// Default email option. Must be either CONFIRM_WITH_CODE or CONFIRM_WITH_LINK. Defaults to CONFIRM_WITH_CODE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultEmailOption"
    )]
    #[builder(default, setter(strip_option))]
    pub default_email_option: Option<String>,
    /// Email message template. Must contain the {####} placeholder. Conflicts with email_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Email message template for sending a confirmation link to the user, it must contain the {##Click Here##} placeholder.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessageByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message_by_link: Option<String>,
    /// Subject line for the email message template. Conflicts with email_verification_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Subject line for the email message template for sending a confirmation link to the user.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubjectByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject_by_link: Option<String>,
    /// SMS message template. Must contain the {####} placeholder. Conflicts with sms_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProvider {
    /// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accountRecoverySetting"
    )]
    #[builder(default, setter(strip_option))]
    pub account_recovery_setting: Option<UserPoolInitProviderAccountRecoverySetting>,
    /// Configuration block for creating a new user profile. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "adminCreateUserConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub admin_create_user_config: Option<UserPoolInitProviderAdminCreateUserConfig>,
    /// Attributes supported as an alias for this user pool. Valid values: phone_number, email, or preferred_username. Conflicts with username_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "aliasAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub alias_attributes: Option<Vec<String>>,
    /// Attributes to be auto-verified. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoVerifiedAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_verified_attributes: Option<Vec<String>>,
    /// When active, DeletionProtection prevents accidental deletion of your user pool. Before you can delete a user pool that you have protected against deletion, you must deactivate this feature. Valid values are ACTIVE and INACTIVE, Default value is INACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<String>,
    /// Configuration block for the user pool's device tracking. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub device_configuration: Option<UserPoolInitProviderDeviceConfiguration>,
    /// Configuration block for configuring email. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub email_configuration: Option<UserPoolInitProviderEmailConfiguration>,
    /// String representing the email verification message. Conflicts with verification_message_template configuration block email_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_message: Option<String>,
    /// String representing the email verification subject. Conflicts with verification_message_template configuration block email_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_subject: Option<String>,
    /// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_config: Option<UserPoolInitProviderLambdaConfig>,
    /// Multi-Factor Authentication (MFA) configuration for the User Pool. Defaults of OFF. Valid values are OFF (MFA Tokens are not required), ON (MFA is required for all users to sign in; requires at least one of sms_configuration or software_token_mfa_configuration to be configured), or OPTIONAL (MFA Will be required only for individual users who have MFA Enabled; requires at least one of sms_configuration or software_token_mfa_configuration to be configured).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub mfa_configuration: Option<String>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for information about the user pool password policy. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub password_policy: Option<UserPoolInitProviderPasswordPolicy>,
    /// Configuration block for the schema attributes of a user pool. Detailed below. Schema attributes from the standard attribute set only need to be specified if they are different from the default configuration. Attributes can be added, but not modified or removed. Maximum of 50 attributes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schema: Option<Vec<UserPoolInitProviderSchema>>,
    /// String representing the SMS authentication message. The Message must contain the {####} placeholder, which will be replaced with the code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsAuthenticationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_authentication_message: Option<String>,
    /// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_configuration: Option<UserPoolInitProviderSmsConfiguration>,
    /// String representing the SMS verification message. Conflicts with verification_message_template configuration block sms_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_verification_message: Option<String>,
    /// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "softwareTokenMfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub software_token_mfa_configuration: Option<UserPoolInitProviderSoftwareTokenMfaConfiguration>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for user attribute update settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userAttributeUpdateSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub user_attribute_update_settings: Option<UserPoolInitProviderUserAttributeUpdateSettings>,
    /// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolAddOns"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_add_ons: Option<UserPoolInitProviderUserPoolAddOns>,
    /// Whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with alias_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub username_attributes: Option<Vec<String>>,
    /// Configuration block for username configuration. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub username_configuration: Option<UserPoolInitProviderUsernameConfiguration>,
    /// Configuration block for verification message templates. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verificationMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub verification_message_template: Option<UserPoolInitProviderVerificationMessageTemplate>,
}

/// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderAccountRecoverySetting {
    /// List of Account Recovery Options of the following structure:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recoveryMechanism"
    )]
    #[builder(default, setter(strip_option))]
    pub recovery_mechanism:
        Option<Vec<UserPoolInitProviderAccountRecoverySettingRecoveryMechanism>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderAccountRecoverySettingRecoveryMechanism {
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Positive integer specifying priority of a method with 1 being the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
}

/// Configuration block for creating a new user profile. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderAdminCreateUserConfig {
    /// Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowAdminCreateUserOnly"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_admin_create_user_only: Option<bool>,
    /// Invite message template structure. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inviteMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub invite_message_template:
        Option<UserPoolInitProviderAdminCreateUserConfigInviteMessageTemplate>,
}

/// Invite message template structure. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderAdminCreateUserConfigInviteMessageTemplate {
    /// Message template for email messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Subject line for email messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Message template for SMS messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}

/// Configuration block for the user pool's device tracking. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderDeviceConfiguration {
    /// Whether a challenge is required on a new device. Only applicable to a new device.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "challengeRequiredOnNewDevice"
    )]
    #[builder(default, setter(strip_option))]
    pub challenge_required_on_new_device: Option<bool>,
    /// Whether a device is only remembered on user prompt. false equates to "Always" remember, true is "User Opt In," and not using a device_configuration block is "No."
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceOnlyRememberedOnUserPrompt"
    )]
    #[builder(default, setter(strip_option))]
    pub device_only_remembered_on_user_prompt: Option<bool>,
}

/// Configuration block for configuring email. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderEmailConfiguration {
    /// Email configuration set name from SES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationSet"
    )]
    #[builder(default, setter(strip_option))]
    pub configuration_set: Option<String>,
    /// Email delivery method to use. COGNITO_DEFAULT for the default email functionality built into Cognito or DEVELOPER to use your Amazon SES configuration. Required to be DEVELOPER if from_email_address is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSendingAccount"
    )]
    #[builder(default, setter(strip_option))]
    pub email_sending_account: Option<String>,
    /// Sender’s email address or sender’s display name with their email address (e.g., john@example.com, John Smith <john@example.com> or \"John Smith Ph.D.\" <john@example.com>). Escaped double quotes are required around display names that contain certain characters as specified in RFC 5322.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fromEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub from_email_address: Option<String>,
    /// REPLY-TO email address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replyToEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub reply_to_email_address: Option<String>,
    /// ARN of the SES verified email identity to use. Required if email_sending_account is set to DEVELOPER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceArn")]
    #[builder(default, setter(strip_option))]
    pub source_arn: Option<String>,
}

/// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfig {
    /// ARN of the lambda creating an authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge: Option<String>,
    /// Reference to a Function in lambda to populate createAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallengeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge_ref: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeRef>,
    /// Selector for a Function in lambda to populate createAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallengeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge_selector:
        Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeSelector>,
    /// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customEmailSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_email_sender: Option<UserPoolInitProviderLambdaConfigCustomEmailSender>,
    /// Custom Message AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message: Option<String>,
    /// Reference to a Function in lambda to populate customMessage.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessageRef"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message_ref: Option<UserPoolInitProviderLambdaConfigCustomMessageRef>,
    /// Selector for a Function in lambda to populate customMessage.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessageSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message_selector: Option<UserPoolInitProviderLambdaConfigCustomMessageSelector>,
    /// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customSmsSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_sms_sender: Option<UserPoolInitProviderLambdaConfigCustomSmsSender>,
    /// Defines the authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge: Option<String>,
    /// Reference to a Function in lambda to populate defineAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallengeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge_ref: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeRef>,
    /// Selector for a Function in lambda to populate defineAuthChallenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallengeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge_selector:
        Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeSelector>,
    /// The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<UserPoolInitProviderLambdaConfigKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<UserPoolInitProviderLambdaConfigKmsKeyIdSelector>,
    /// Post-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication: Option<String>,
    /// Reference to a Function in lambda to populate postAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_ref: Option<UserPoolInitProviderLambdaConfigPostAuthenticationRef>,
    /// Selector for a Function in lambda to populate postAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_selector:
        Option<UserPoolInitProviderLambdaConfigPostAuthenticationSelector>,
    /// Post-confirmation AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmation"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation: Option<String>,
    /// Reference to a Function in lambda to populate postConfirmation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation_ref: Option<UserPoolInitProviderLambdaConfigPostConfirmationRef>,
    /// Selector for a Function in lambda to populate postConfirmation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation_selector:
        Option<UserPoolInitProviderLambdaConfigPostConfirmationSelector>,
    /// Pre-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication: Option<String>,
    /// Reference to a Function in lambda to populate preAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_ref: Option<UserPoolInitProviderLambdaConfigPreAuthenticationRef>,
    /// Selector for a Function in lambda to populate preAuthentication.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_selector:
        Option<UserPoolInitProviderLambdaConfigPreAuthenticationSelector>,
    /// Pre-registration AWS Lambda trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preSignUp")]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up: Option<String>,
    /// Reference to a Function in lambda to populate preSignUp.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preSignUpRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up_ref: Option<UserPoolInitProviderLambdaConfigPreSignUpRef>,
    /// Selector for a Function in lambda to populate preSignUp.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preSignUpSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up_selector: Option<UserPoolInitProviderLambdaConfigPreSignUpSelector>,
    /// Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of pre_token_generation_config.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation: Option<String>,
    /// Allow to customize access tokens. See pre_token_configuration_type
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_config:
        Option<UserPoolInitProviderLambdaConfigPreTokenGenerationConfig>,
    /// Reference to a Function in lambda to populate preTokenGeneration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_ref: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationRef>,
    /// Selector for a Function in lambda to populate preTokenGeneration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_selector:
        Option<UserPoolInitProviderLambdaConfigPreTokenGenerationSelector>,
    /// User migration Lambda config type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigration"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration: Option<String>,
    /// Reference to a Function in lambda to populate userMigration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigrationRef"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration_ref: Option<UserPoolInitProviderLambdaConfigUserMigrationRef>,
    /// Selector for a Function in lambda to populate userMigration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigrationSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration_selector: Option<UserPoolInitProviderLambdaConfigUserMigrationSelector>,
    /// Verifies the authentication challenge response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response: Option<String>,
    /// Reference to a Function in lambda to populate verifyAuthChallengeResponse.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponseRef"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response_ref:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRef>,
    /// Selector for a Function in lambda to populate verifyAuthChallengeResponse.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponseSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response_selector:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelector>,
}

/// Reference to a Function in lambda to populate createAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCreateAuthChallengeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCreateAuthChallengeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate createAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCreateAuthChallengeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCreateAuthChallengeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomEmailSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_ref: Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_selector:
        Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelector>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomEmailSenderLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate customMessage.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomMessageRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomMessageRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomMessageRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigCustomMessageRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCustomMessageRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomMessageRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomMessageRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate customMessage.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomMessageSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomMessageSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomSmsSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_ref: Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_arn_selector:
        Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelector>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigCustomSmsSenderLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate defineAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigDefineAuthChallengeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigDefineAuthChallengeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate defineAuthChallenge.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigDefineAuthChallengeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigDefineAuthChallengeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate postAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostAuthenticationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostAuthenticationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate postAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostAuthenticationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostAuthenticationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate postConfirmation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostConfirmationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPostConfirmationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostConfirmationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPostConfirmationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPostConfirmationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostConfirmationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostConfirmationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate postConfirmation.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostConfirmationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPostConfirmationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate preAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreAuthenticationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreAuthenticationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preAuthentication.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreAuthenticationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreAuthenticationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate preSignUp.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreSignUpRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreSignUpRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreSignUpRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPreSignUpRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreSignUpRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreSignUpRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreSignUpRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preSignUp.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreSignUpSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreSignUpSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Allow to customize access tokens. See pre_token_configuration_type
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreTokenGenerationConfig {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// The Lambda version represents the signature of the "version" attribute in the "event" information Amazon Cognito passes to your pre Token Generation Lambda function. The supported values are V1_0, V2_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Reference to a Function in lambda to populate preTokenGeneration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreTokenGenerationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreTokenGenerationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate preTokenGeneration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreTokenGenerationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigPreTokenGenerationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate userMigration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigUserMigrationRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigUserMigrationRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigUserMigrationRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigUserMigrationRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigUserMigrationRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigUserMigrationRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigUserMigrationRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate userMigration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigUserMigrationSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigUserMigrationSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Function in lambda to populate verifyAuthChallengeResponse.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate verifyAuthChallengeResponse.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderLambdaConfigVerifyAuthChallengeResponseSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for information about the user pool password policy. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderPasswordPolicy {
    /// Minimum length of the password policy that you have set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minimumLength"
    )]
    #[builder(default, setter(strip_option))]
    pub minimum_length: Option<f64>,
    /// Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordHistorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub password_history_size: Option<f64>,
    /// Whether you have required users to use at least one lowercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireLowercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_lowercase: Option<bool>,
    /// Whether you have required users to use at least one number in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireNumbers"
    )]
    #[builder(default, setter(strip_option))]
    pub require_numbers: Option<bool>,
    /// Whether you have required users to use at least one symbol in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireSymbols"
    )]
    #[builder(default, setter(strip_option))]
    pub require_symbols: Option<bool>,
    /// Whether you have required users to use at least one uppercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireUppercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_uppercase: Option<bool>,
    /// In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "temporaryPasswordValidityDays"
    )]
    #[builder(default, setter(strip_option))]
    pub temporary_password_validity_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSchema {
    /// Attribute data type. Must be one of Boolean, Number, String, DateTime.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeDataType"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_data_type: Option<String>,
    /// Whether the attribute type is developer only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "developerOnlyAttribute"
    )]
    #[builder(default, setter(strip_option))]
    pub developer_only_attribute: Option<bool>,
    /// Whether the attribute can be changed once it has been created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mutable: Option<bool>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for the constraints for an attribute of the number type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub number_attribute_constraints: Option<UserPoolInitProviderSchemaNumberAttributeConstraints>,
    /// Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub required: Option<bool>,
    /// Constraints for an attribute of the string type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub string_attribute_constraints: Option<UserPoolInitProviderSchemaStringAttributeConstraints>,
}

/// Configuration block for the constraints for an attribute of the number type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSchemaNumberAttributeConstraints {
    /// Maximum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxValue")]
    #[builder(default, setter(strip_option))]
    pub max_value: Option<String>,
    /// Minimum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minValue")]
    #[builder(default, setter(strip_option))]
    pub min_value: Option<String>,
}

/// Constraints for an attribute of the string type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSchemaStringAttributeConstraints {
    /// Maximum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    #[builder(default, setter(strip_option))]
    pub max_length: Option<String>,
    /// Minimum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    #[builder(default, setter(strip_option))]
    pub min_length: Option<String>,
}

/// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSmsConfiguration {
    /// External ID used in IAM role trust relationships. For more information about using external IDs, see How to Use an External ID When Granting Access to Your AWS Resources to a Third Party.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "externalId"
    )]
    #[builder(default, setter(strip_option))]
    pub external_id: Option<String>,
    /// ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn: Option<String>,
    /// Reference to a Role in iam to populate snsCallerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn_ref: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnRef>,
    /// Selector for a Role in iam to populate snsCallerArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn_selector: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnSelector>,
    /// The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see SMS message settings for Amazon Cognito user pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsRegion")]
    #[builder(default, setter(strip_option))]
    pub sns_region: Option<String>,
}

/// Reference to a Role in iam to populate snsCallerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSmsConfigurationSnsCallerArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderSmsConfigurationSnsCallerArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate snsCallerArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSmsConfigurationSnsCallerArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolInitProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderSoftwareTokenMfaConfiguration {
    /// Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When sms_configuration is not present, the mfa_configuration argument must be set to OFF and the software_token_mfa_configuration configuration block must be fully removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Configuration block for user attribute update settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderUserAttributeUpdateSettings {
    /// A list of attributes requiring verification before update. If set, the provided value(s) must also be set in auto_verified_attributes. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributesRequireVerificationBeforeUpdate"
    )]
    #[builder(default, setter(strip_option))]
    pub attributes_require_verification_before_update: Option<Vec<String>>,
}

/// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderUserPoolAddOns {
    /// Mode for advanced security, must be one of OFF, AUDIT or ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "advancedSecurityMode"
    )]
    #[builder(default, setter(strip_option))]
    pub advanced_security_mode: Option<String>,
}

/// Configuration block for username configuration. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderUsernameConfiguration {
    /// Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caseSensitive"
    )]
    #[builder(default, setter(strip_option))]
    pub case_sensitive: Option<bool>,
}

/// Configuration block for verification message templates. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolInitProviderVerificationMessageTemplate {
    /// Default email option. Must be either CONFIRM_WITH_CODE or CONFIRM_WITH_LINK. Defaults to CONFIRM_WITH_CODE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultEmailOption"
    )]
    #[builder(default, setter(strip_option))]
    pub default_email_option: Option<String>,
    /// Email message template. Must contain the {####} placeholder. Conflicts with email_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Email message template for sending a confirmation link to the user, it must contain the {##Click Here##} placeholder.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessageByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message_by_link: Option<String>,
    /// Subject line for the email message template. Conflicts with email_verification_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Subject line for the email message template for sending a confirmation link to the user.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubjectByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject_by_link: Option<String>,
    /// SMS message template. Must contain the {####} placeholder. Conflicts with sms_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<UserPoolPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<UserPoolPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<UserPoolPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<UserPoolPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<UserPoolPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// UserPoolStatus defines the observed state of UserPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<UserPoolStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProvider {
    /// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accountRecoverySetting"
    )]
    #[builder(default, setter(strip_option))]
    pub account_recovery_setting: Option<UserPoolStatusAtProviderAccountRecoverySetting>,
    /// Configuration block for creating a new user profile. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "adminCreateUserConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub admin_create_user_config: Option<UserPoolStatusAtProviderAdminCreateUserConfig>,
    /// Attributes supported as an alias for this user pool. Valid values: phone_number, email, or preferred_username. Conflicts with username_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "aliasAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub alias_attributes: Option<Vec<String>>,
    /// ARN of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Attributes to be auto-verified. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoVerifiedAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_verified_attributes: Option<Vec<String>>,
    /// Date the user pool was created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "creationDate"
    )]
    #[builder(default, setter(strip_option))]
    pub creation_date: Option<String>,
    /// A custom domain name that you provide to Amazon Cognito. This parameter applies only if you use a custom domain to host the sign-up and sign-in pages for your application. For example: auth.example.com.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_domain: Option<String>,
    /// When active, DeletionProtection prevents accidental deletion of your user pool. Before you can delete a user pool that you have protected against deletion, you must deactivate this feature. Valid values are ACTIVE and INACTIVE, Default value is INACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<String>,
    /// Configuration block for the user pool's device tracking. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub device_configuration: Option<UserPoolStatusAtProviderDeviceConfiguration>,
    /// Holds the domain prefix if the user pool has a domain associated with it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// Configuration block for configuring email. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub email_configuration: Option<UserPoolStatusAtProviderEmailConfiguration>,
    /// String representing the email verification message. Conflicts with verification_message_template configuration block email_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_message: Option<String>,
    /// String representing the email verification subject. Conflicts with verification_message_template configuration block email_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailVerificationSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_verification_subject: Option<String>,
    /// Endpoint name of the user pool. Example format: cognito-idp.REGION.amazonaws.com/xxxx_yyyyy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub endpoint: Option<String>,
    /// A number estimating the size of the user pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "estimatedNumberOfUsers"
    )]
    #[builder(default, setter(strip_option))]
    pub estimated_number_of_users: Option<f64>,
    /// ID of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_config: Option<UserPoolStatusAtProviderLambdaConfig>,
    /// Date the user pool was last modified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastModifiedDate"
    )]
    #[builder(default, setter(strip_option))]
    pub last_modified_date: Option<String>,
    /// Multi-Factor Authentication (MFA) configuration for the User Pool. Defaults of OFF. Valid values are OFF (MFA Tokens are not required), ON (MFA is required for all users to sign in; requires at least one of sms_configuration or software_token_mfa_configuration to be configured), or OPTIONAL (MFA Will be required only for individual users who have MFA Enabled; requires at least one of sms_configuration or software_token_mfa_configuration to be configured).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub mfa_configuration: Option<String>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for information about the user pool password policy. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub password_policy: Option<UserPoolStatusAtProviderPasswordPolicy>,
    /// Configuration block for the schema attributes of a user pool. Detailed below. Schema attributes from the standard attribute set only need to be specified if they are different from the default configuration. Attributes can be added, but not modified or removed. Maximum of 50 attributes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schema: Option<Vec<UserPoolStatusAtProviderSchema>>,
    /// String representing the SMS authentication message. The Message must contain the {####} placeholder, which will be replaced with the code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsAuthenticationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_authentication_message: Option<String>,
    /// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_configuration: Option<UserPoolStatusAtProviderSmsConfiguration>,
    /// String representing the SMS verification message. Conflicts with verification_message_template configuration block sms_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsVerificationMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_verification_message: Option<String>,
    /// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "softwareTokenMfaConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub software_token_mfa_configuration:
        Option<UserPoolStatusAtProviderSoftwareTokenMfaConfiguration>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Configuration block for user attribute update settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userAttributeUpdateSettings"
    )]
    #[builder(default, setter(strip_option))]
    pub user_attribute_update_settings: Option<UserPoolStatusAtProviderUserAttributeUpdateSettings>,
    /// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userPoolAddOns"
    )]
    #[builder(default, setter(strip_option))]
    pub user_pool_add_ons: Option<UserPoolStatusAtProviderUserPoolAddOns>,
    /// Whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with alias_attributes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub username_attributes: Option<Vec<String>>,
    /// Configuration block for username configuration. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub username_configuration: Option<UserPoolStatusAtProviderUsernameConfiguration>,
    /// Configuration block for verification message templates. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verificationMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub verification_message_template: Option<UserPoolStatusAtProviderVerificationMessageTemplate>,
}

/// Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderAccountRecoverySetting {
    /// List of Account Recovery Options of the following structure:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recoveryMechanism"
    )]
    #[builder(default, setter(strip_option))]
    pub recovery_mechanism:
        Option<Vec<UserPoolStatusAtProviderAccountRecoverySettingRecoveryMechanism>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderAccountRecoverySettingRecoveryMechanism {
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Positive integer specifying priority of a method with 1 being the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
}

/// Configuration block for creating a new user profile. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderAdminCreateUserConfig {
    /// Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowAdminCreateUserOnly"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_admin_create_user_only: Option<bool>,
    /// Invite message template structure. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inviteMessageTemplate"
    )]
    #[builder(default, setter(strip_option))]
    pub invite_message_template:
        Option<UserPoolStatusAtProviderAdminCreateUserConfigInviteMessageTemplate>,
}

/// Invite message template structure. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderAdminCreateUserConfigInviteMessageTemplate {
    /// Message template for email messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Subject line for email messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Message template for SMS messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}

/// Configuration block for the user pool's device tracking. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderDeviceConfiguration {
    /// Whether a challenge is required on a new device. Only applicable to a new device.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "challengeRequiredOnNewDevice"
    )]
    #[builder(default, setter(strip_option))]
    pub challenge_required_on_new_device: Option<bool>,
    /// Whether a device is only remembered on user prompt. false equates to "Always" remember, true is "User Opt In," and not using a device_configuration block is "No."
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceOnlyRememberedOnUserPrompt"
    )]
    #[builder(default, setter(strip_option))]
    pub device_only_remembered_on_user_prompt: Option<bool>,
}

/// Configuration block for configuring email. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderEmailConfiguration {
    /// Email configuration set name from SES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationSet"
    )]
    #[builder(default, setter(strip_option))]
    pub configuration_set: Option<String>,
    /// Email delivery method to use. COGNITO_DEFAULT for the default email functionality built into Cognito or DEVELOPER to use your Amazon SES configuration. Required to be DEVELOPER if from_email_address is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSendingAccount"
    )]
    #[builder(default, setter(strip_option))]
    pub email_sending_account: Option<String>,
    /// Sender’s email address or sender’s display name with their email address (e.g., john@example.com, John Smith <john@example.com> or \"John Smith Ph.D.\" <john@example.com>). Escaped double quotes are required around display names that contain certain characters as specified in RFC 5322.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fromEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub from_email_address: Option<String>,
    /// REPLY-TO email address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replyToEmailAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub reply_to_email_address: Option<String>,
    /// ARN of the SES verified email identity to use. Required if email_sending_account is set to DEVELOPER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceArn")]
    #[builder(default, setter(strip_option))]
    pub source_arn: Option<String>,
}

/// Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderLambdaConfig {
    /// ARN of the lambda creating an authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub create_auth_challenge: Option<String>,
    /// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customEmailSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_email_sender: Option<UserPoolStatusAtProviderLambdaConfigCustomEmailSender>,
    /// Custom Message AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_message: Option<String>,
    /// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customSmsSender"
    )]
    #[builder(default, setter(strip_option))]
    pub custom_sms_sender: Option<UserPoolStatusAtProviderLambdaConfigCustomSmsSender>,
    /// Defines the authentication challenge.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defineAuthChallenge"
    )]
    #[builder(default, setter(strip_option))]
    pub define_auth_challenge: Option<String>,
    /// The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Post-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication: Option<String>,
    /// Post-confirmation AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postConfirmation"
    )]
    #[builder(default, setter(strip_option))]
    pub post_confirmation: Option<String>,
    /// Pre-authentication AWS Lambda trigger.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthentication"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication: Option<String>,
    /// Pre-registration AWS Lambda trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preSignUp")]
    #[builder(default, setter(strip_option))]
    pub pre_sign_up: Option<String>,
    /// Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of pre_token_generation_config.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation: Option<String>,
    /// Allow to customize access tokens. See pre_token_configuration_type
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preTokenGenerationConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_token_generation_config:
        Option<UserPoolStatusAtProviderLambdaConfigPreTokenGenerationConfig>,
    /// User migration Lambda config type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userMigration"
    )]
    #[builder(default, setter(strip_option))]
    pub user_migration: Option<String>,
    /// Verifies the authentication challenge response.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyAuthChallengeResponse"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_auth_challenge_response: Option<String>,
}

/// A custom email sender AWS Lambda trigger. See custom_email_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderLambdaConfigCustomEmailSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderLambdaConfigCustomSmsSender {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is V1_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Allow to customize access tokens. See pre_token_configuration_type
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderLambdaConfigPreTokenGenerationConfig {
    /// The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default, setter(strip_option))]
    pub lambda_arn: Option<String>,
    /// The Lambda version represents the signature of the "version" attribute in the "event" information Amazon Cognito passes to your pre Token Generation Lambda function. The supported values are V1_0, V2_0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lambdaVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub lambda_version: Option<String>,
}

/// Configuration block for information about the user pool password policy. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderPasswordPolicy {
    /// Minimum length of the password policy that you have set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minimumLength"
    )]
    #[builder(default, setter(strip_option))]
    pub minimum_length: Option<f64>,
    /// Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordHistorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub password_history_size: Option<f64>,
    /// Whether you have required users to use at least one lowercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireLowercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_lowercase: Option<bool>,
    /// Whether you have required users to use at least one number in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireNumbers"
    )]
    #[builder(default, setter(strip_option))]
    pub require_numbers: Option<bool>,
    /// Whether you have required users to use at least one symbol in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireSymbols"
    )]
    #[builder(default, setter(strip_option))]
    pub require_symbols: Option<bool>,
    /// Whether you have required users to use at least one uppercase letter in their password.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireUppercase"
    )]
    #[builder(default, setter(strip_option))]
    pub require_uppercase: Option<bool>,
    /// In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "temporaryPasswordValidityDays"
    )]
    #[builder(default, setter(strip_option))]
    pub temporary_password_validity_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderSchema {
    /// Attribute data type. Must be one of Boolean, Number, String, DateTime.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeDataType"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_data_type: Option<String>,
    /// Whether the attribute type is developer only.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "developerOnlyAttribute"
    )]
    #[builder(default, setter(strip_option))]
    pub developer_only_attribute: Option<bool>,
    /// Whether the attribute can be changed once it has been created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mutable: Option<bool>,
    /// Name of the user pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block for the constraints for an attribute of the number type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub number_attribute_constraints:
        Option<UserPoolStatusAtProviderSchemaNumberAttributeConstraints>,
    /// Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub required: Option<bool>,
    /// Constraints for an attribute of the string type. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringAttributeConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub string_attribute_constraints:
        Option<UserPoolStatusAtProviderSchemaStringAttributeConstraints>,
}

/// Configuration block for the constraints for an attribute of the number type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderSchemaNumberAttributeConstraints {
    /// Maximum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxValue")]
    #[builder(default, setter(strip_option))]
    pub max_value: Option<String>,
    /// Minimum value of an attribute that is of the number data type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minValue")]
    #[builder(default, setter(strip_option))]
    pub min_value: Option<String>,
}

/// Constraints for an attribute of the string type. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderSchemaStringAttributeConstraints {
    /// Maximum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    #[builder(default, setter(strip_option))]
    pub max_length: Option<String>,
    /// Minimum length of an attribute value of the string type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    #[builder(default, setter(strip_option))]
    pub min_length: Option<String>,
}

/// Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderSmsConfiguration {
    /// External ID used in IAM role trust relationships. For more information about using external IDs, see How to Use an External ID When Granting Access to Your AWS Resources to a Third Party.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "externalId"
    )]
    #[builder(default, setter(strip_option))]
    pub external_id: Option<String>,
    /// ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snsCallerArn"
    )]
    #[builder(default, setter(strip_option))]
    pub sns_caller_arn: Option<String>,
    /// The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see SMS message settings for Amazon Cognito user pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsRegion")]
    #[builder(default, setter(strip_option))]
    pub sns_region: Option<String>,
}

/// Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderSoftwareTokenMfaConfiguration {
    /// Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When sms_configuration is not present, the mfa_configuration argument must be set to OFF and the software_token_mfa_configuration configuration block must be fully removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// Configuration block for user attribute update settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderUserAttributeUpdateSettings {
    /// A list of attributes requiring verification before update. If set, the provided value(s) must also be set in auto_verified_attributes. Valid values: email, phone_number.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributesRequireVerificationBeforeUpdate"
    )]
    #[builder(default, setter(strip_option))]
    pub attributes_require_verification_before_update: Option<Vec<String>>,
}

/// Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderUserPoolAddOns {
    /// Mode for advanced security, must be one of OFF, AUDIT or ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "advancedSecurityMode"
    )]
    #[builder(default, setter(strip_option))]
    pub advanced_security_mode: Option<String>,
}

/// Configuration block for username configuration. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderUsernameConfiguration {
    /// Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caseSensitive"
    )]
    #[builder(default, setter(strip_option))]
    pub case_sensitive: Option<bool>,
}

/// Configuration block for verification message templates. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct UserPoolStatusAtProviderVerificationMessageTemplate {
    /// Default email option. Must be either CONFIRM_WITH_CODE or CONFIRM_WITH_LINK. Defaults to CONFIRM_WITH_CODE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultEmailOption"
    )]
    #[builder(default, setter(strip_option))]
    pub default_email_option: Option<String>,
    /// Email message template. Must contain the {####} placeholder. Conflicts with email_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message: Option<String>,
    /// Email message template for sending a confirmation link to the user, it must contain the {##Click Here##} placeholder.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailMessageByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_message_by_link: Option<String>,
    /// Subject line for the email message template. Conflicts with email_verification_subject argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubject"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject: Option<String>,
    /// Subject line for the email message template for sending a confirmation link to the user.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "emailSubjectByLink"
    )]
    #[builder(default, setter(strip_option))]
    pub email_subject_by_link: Option<String>,
    /// SMS message template. Must contain the {####} placeholder. Conflicts with sms_verification_message argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "smsMessage"
    )]
    #[builder(default, setter(strip_option))]
    pub sms_message: Option<String>,
}
