// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// OntapFileSystemSpec defines the desired state of OntapFileSystem
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "fsx.aws.upbound.io",
    version = "v1beta2",
    kind = "OntapFileSystem",
    plural = "ontapfilesystems"
)]
#[kube(status = "OntapFileSystemStatus")]
pub struct OntapFileSystemSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<OntapFileSystemDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: OntapFileSystemForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<OntapFileSystemInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<OntapFileSystemProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<OntapFileSystemPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<OntapFileSystemWriteConnectionSecretToRef>,
}

/// OntapFileSystemSpec defines the desired state of OntapFileSystem
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProvider {
    /// The number of days to retain automatic backups. Setting this to 0 disables automatic backups. You can retain automatic backups for a maximum of 90 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticBackupRetentionDays"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_backup_retention_days: Option<f64>,
    /// A recurring daily time, in the format HH:MM. HH is the zero-padded hour of the day (0-23), and MM is the zero-padded minute of the hour. For example, 05:00 specifies 5 AM daily. Requires automatic_backup_retention_days to be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dailyAutomaticBackupStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub daily_automatic_backup_start_time: Option<String>,
    /// - The filesystem deployment type. Supports MULTI_AZ_1, MULTI_AZ_2, SINGLE_AZ_1, and SINGLE_AZ_2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentType"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "diskIopsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub disk_iops_configuration: Option<OntapFileSystemForProviderDiskIopsConfiguration>,
    /// Specifies the IP address range in which the endpoints to access your file system will be created. By default, Amazon FSx selects an unused IP address range for you from the 198.19.* range.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointIpAddressRange"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_ip_address_range: Option<String>,
    /// The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fsxAdminPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub fsx_admin_password_secret_ref: Option<OntapFileSystemForProviderFsxAdminPasswordSecretRef>,
    /// - The number of ha_pairs to deploy for the file system. Valid value is 1 for SINGLE_AZ_1 or MULTI_AZ_1 and MULTI_AZ_2. Valid values are 1 through 12 for SINGLE_AZ_2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "haPairs")]
    #[builder(default, setter(strip_option))]
    pub ha_pairs: Option<f64>,
    /// ARN for the KMS Key to encrypt the file system at rest, Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<OntapFileSystemForProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<OntapFileSystemForProviderKmsKeyIdSelector>,
    /// The ID for a subnet. A subnet is a range of IP addresses in your virtual private cloud (VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetId"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate preferredSubnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id_ref: Option<OntapFileSystemForProviderPreferredSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate preferredSubnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id_selector: Option<OntapFileSystemForProviderPreferredSubnetIdSelector>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Specifies the VPC route tables in which your file system's endpoints will be created. You should specify all VPC route tables associated with the subnets in which your clients are located. By default, Amazon FSx selects your VPC's default route table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "routeTableIds"
    )]
    #[builder(default, setter(strip_option))]
    pub route_table_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<OntapFileSystemForProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<OntapFileSystemForProviderSecurityGroupIdSelector>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// The storage capacity (GiB) of the file system. Valid values between 1024 and 196608 for file systems with deployment_type SINGLE_AZ_1 and MULTI_AZ_1. Valid values are between 1024 and 524288 for MULTI_AZ_2. Valid values between 1024 (1024 per ha pair) and 1048576 for file systems with deployment_type SINGLE_AZ_2. For SINGLE_AZ_2, the 1048576 (1PB) maximum is only supported when using 2 or more ha_pairs, the maximum is 524288 (512TB) when using 1 ha_pair.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_capacity: Option<f64>,
    /// - The filesystem storage type. defaults to SSD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<OntapFileSystemForProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<OntapFileSystemForProviderSubnetIdSelector>,
    /// A list of IDs for the subnets that the file system will be accessible from. Up to 2 subnets can be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Sets the throughput capacity (in MBps) for the file system that you're creating. Valid values are 128, 256, 512, 1024, 2048, and 4096. This parameter is only supported when not using the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity: Option<f64>,
    /// Sets the per-HA-pair throughput capacity (in MBps) for the file system that you're creating, as opposed to throughput_capacity which specifies the total throughput capacity for the file system. Valid value for MULTI_AZ_1 and SINGLE_AZ_1 are 128, 256, 512, 1024, 2048, and 4096. Valid values for deployment type MULTI_AZ_2 and SINGLE_AZ_2 are 384,768,1536,3072,6144 where ha_pairs is 1. Valid values for deployment type SINGLE_AZ_2 are 1536, 3072, and 6144 where ha_pairs is greater than 1. This parameter is only supported when specifying the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacityPerHaPair"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity_per_ha_pair: Option<f64>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weeklyMaintenanceStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub weekly_maintenance_start_time: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderDiskIopsConfiguration {
    /// - The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// - Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderFsxAdminPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate preferredSubnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderPreferredSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderPreferredSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderPreferredSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderPreferredSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderPreferredSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderPreferredSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderPreferredSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate preferredSubnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderPreferredSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderPreferredSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderPreferredSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderPreferredSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderPreferredSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderPreferredSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderPreferredSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemForProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemForProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemForProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemForProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemForProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProvider {
    /// The number of days to retain automatic backups. Setting this to 0 disables automatic backups. You can retain automatic backups for a maximum of 90 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticBackupRetentionDays"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_backup_retention_days: Option<f64>,
    /// A recurring daily time, in the format HH:MM. HH is the zero-padded hour of the day (0-23), and MM is the zero-padded minute of the hour. For example, 05:00 specifies 5 AM daily. Requires automatic_backup_retention_days to be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dailyAutomaticBackupStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub daily_automatic_backup_start_time: Option<String>,
    /// - The filesystem deployment type. Supports MULTI_AZ_1, MULTI_AZ_2, SINGLE_AZ_1, and SINGLE_AZ_2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentType"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "diskIopsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub disk_iops_configuration: Option<OntapFileSystemInitProviderDiskIopsConfiguration>,
    /// Specifies the IP address range in which the endpoints to access your file system will be created. By default, Amazon FSx selects an unused IP address range for you from the 198.19.* range.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointIpAddressRange"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_ip_address_range: Option<String>,
    /// The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fsxAdminPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub fsx_admin_password_secret_ref: Option<OntapFileSystemInitProviderFsxAdminPasswordSecretRef>,
    /// - The number of ha_pairs to deploy for the file system. Valid value is 1 for SINGLE_AZ_1 or MULTI_AZ_1 and MULTI_AZ_2. Valid values are 1 through 12 for SINGLE_AZ_2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "haPairs")]
    #[builder(default, setter(strip_option))]
    pub ha_pairs: Option<f64>,
    /// ARN for the KMS Key to encrypt the file system at rest, Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<OntapFileSystemInitProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<OntapFileSystemInitProviderKmsKeyIdSelector>,
    /// The ID for a subnet. A subnet is a range of IP addresses in your virtual private cloud (VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetId"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate preferredSubnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id_ref: Option<OntapFileSystemInitProviderPreferredSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate preferredSubnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id_selector: Option<OntapFileSystemInitProviderPreferredSubnetIdSelector>,
    /// Specifies the VPC route tables in which your file system's endpoints will be created. You should specify all VPC route tables associated with the subnets in which your clients are located. By default, Amazon FSx selects your VPC's default route table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "routeTableIds"
    )]
    #[builder(default, setter(strip_option))]
    pub route_table_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<OntapFileSystemInitProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<OntapFileSystemInitProviderSecurityGroupIdSelector>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// The storage capacity (GiB) of the file system. Valid values between 1024 and 196608 for file systems with deployment_type SINGLE_AZ_1 and MULTI_AZ_1. Valid values are between 1024 and 524288 for MULTI_AZ_2. Valid values between 1024 (1024 per ha pair) and 1048576 for file systems with deployment_type SINGLE_AZ_2. For SINGLE_AZ_2, the 1048576 (1PB) maximum is only supported when using 2 or more ha_pairs, the maximum is 524288 (512TB) when using 1 ha_pair.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_capacity: Option<f64>,
    /// - The filesystem storage type. defaults to SSD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<OntapFileSystemInitProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<OntapFileSystemInitProviderSubnetIdSelector>,
    /// A list of IDs for the subnets that the file system will be accessible from. Up to 2 subnets can be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Sets the throughput capacity (in MBps) for the file system that you're creating. Valid values are 128, 256, 512, 1024, 2048, and 4096. This parameter is only supported when not using the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity: Option<f64>,
    /// Sets the per-HA-pair throughput capacity (in MBps) for the file system that you're creating, as opposed to throughput_capacity which specifies the total throughput capacity for the file system. Valid value for MULTI_AZ_1 and SINGLE_AZ_1 are 128, 256, 512, 1024, 2048, and 4096. Valid values for deployment type MULTI_AZ_2 and SINGLE_AZ_2 are 384,768,1536,3072,6144 where ha_pairs is 1. Valid values for deployment type SINGLE_AZ_2 are 1536, 3072, and 6144 where ha_pairs is greater than 1. This parameter is only supported when specifying the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacityPerHaPair"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity_per_ha_pair: Option<f64>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weeklyMaintenanceStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub weekly_maintenance_start_time: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderDiskIopsConfiguration {
    /// - The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// - Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderFsxAdminPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate preferredSubnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderPreferredSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderPreferredSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderPreferredSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderPreferredSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderPreferredSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderPreferredSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderPreferredSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate preferredSubnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderPreferredSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderPreferredSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemInitProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemInitProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemInitProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemInitProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemInitProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<OntapFileSystemPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<OntapFileSystemPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<OntapFileSystemPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<OntapFileSystemPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<OntapFileSystemPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum OntapFileSystemPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// OntapFileSystemStatus defines the observed state of OntapFileSystem.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<OntapFileSystemStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatusAtProvider {
    /// Amazon Resource Name of the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The number of days to retain automatic backups. Setting this to 0 disables automatic backups. You can retain automatic backups for a maximum of 90 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticBackupRetentionDays"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_backup_retention_days: Option<f64>,
    /// A recurring daily time, in the format HH:MM. HH is the zero-padded hour of the day (0-23), and MM is the zero-padded minute of the hour. For example, 05:00 specifies 5 AM daily. Requires automatic_backup_retention_days to be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dailyAutomaticBackupStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub daily_automatic_backup_start_time: Option<String>,
    /// - The filesystem deployment type. Supports MULTI_AZ_1, MULTI_AZ_2, SINGLE_AZ_1, and SINGLE_AZ_2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deploymentType"
    )]
    #[builder(default, setter(strip_option))]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "diskIopsConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub disk_iops_configuration: Option<OntapFileSystemStatusAtProviderDiskIopsConfiguration>,
    /// DNS name for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default, setter(strip_option))]
    pub dns_name: Option<String>,
    /// Specifies the IP address range in which the endpoints to access your file system will be created. By default, Amazon FSx selects an unused IP address range for you from the 198.19.* range.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointIpAddressRange"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_ip_address_range: Option<String>,
    /// The endpoints that are used to access data or to manage the file system using the NetApp ONTAP CLI, REST API, or NetApp SnapMirror. See Endpoints below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub endpoints: Option<Vec<OntapFileSystemStatusAtProviderEndpoints>>,
    /// - The number of ha_pairs to deploy for the file system. Valid value is 1 for SINGLE_AZ_1 or MULTI_AZ_1 and MULTI_AZ_2. Valid values are 1 through 12 for SINGLE_AZ_2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "haPairs")]
    #[builder(default, setter(strip_option))]
    pub ha_pairs: Option<f64>,
    /// Identifier of the file system, e.g., fs-12345678
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// ARN for the KMS Key to encrypt the file system at rest, Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Set of Elastic Network Interface identifiers from which the file system is accessible The first network interface returned is the primary network interface.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIds"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_ids: Option<Vec<String>>,
    /// AWS account identifier that created the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerId")]
    #[builder(default, setter(strip_option))]
    pub owner_id: Option<String>,
    /// The ID for a subnet. A subnet is a range of IP addresses in your virtual private cloud (VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredSubnetId"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_subnet_id: Option<String>,
    /// Specifies the VPC route tables in which your file system's endpoints will be created. You should specify all VPC route tables associated with the subnets in which your clients are located. By default, Amazon FSx selects your VPC's default route table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "routeTableIds"
    )]
    #[builder(default, setter(strip_option))]
    pub route_table_ids: Option<Vec<String>>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// The storage capacity (GiB) of the file system. Valid values between 1024 and 196608 for file systems with deployment_type SINGLE_AZ_1 and MULTI_AZ_1. Valid values are between 1024 and 524288 for MULTI_AZ_2. Valid values between 1024 (1024 per ha pair) and 1048576 for file systems with deployment_type SINGLE_AZ_2. For SINGLE_AZ_2, the 1048576 (1PB) maximum is only supported when using 2 or more ha_pairs, the maximum is 524288 (512TB) when using 1 ha_pair.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_capacity: Option<f64>,
    /// - The filesystem storage type. defaults to SSD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// A list of IDs for the subnets that the file system will be accessible from. Up to 2 subnets can be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Sets the throughput capacity (in MBps) for the file system that you're creating. Valid values are 128, 256, 512, 1024, 2048, and 4096. This parameter is only supported when not using the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity: Option<f64>,
    /// Sets the per-HA-pair throughput capacity (in MBps) for the file system that you're creating, as opposed to throughput_capacity which specifies the total throughput capacity for the file system. Valid value for MULTI_AZ_1 and SINGLE_AZ_1 are 128, 256, 512, 1024, 2048, and 4096. Valid values for deployment type MULTI_AZ_2 and SINGLE_AZ_2 are 384,768,1536,3072,6144 where ha_pairs is 1. Valid values for deployment type SINGLE_AZ_2 are 1536, 3072, and 6144 where ha_pairs is greater than 1. This parameter is only supported when specifying the ha_pairs parameter. Either throughput_capacity or throughput_capacity_per_ha_pair must be specified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "throughputCapacityPerHaPair"
    )]
    #[builder(default, setter(strip_option))]
    pub throughput_capacity_per_ha_pair: Option<f64>,
    /// Identifier of the Virtual Private Cloud for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weeklyMaintenanceStartTime"
    )]
    #[builder(default, setter(strip_option))]
    pub weekly_maintenance_start_time: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatusAtProviderDiskIopsConfiguration {
    /// - The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// - Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatusAtProviderEndpoints {
    /// An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub intercluster: Option<Vec<OntapFileSystemStatusAtProviderEndpointsIntercluster>>,
    /// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub management: Option<Vec<OntapFileSystemStatusAtProviderEndpointsManagement>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatusAtProviderEndpointsIntercluster {
    /// DNS name for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default, setter(strip_option))]
    pub dns_name: Option<String>,
    /// IP addresses of the file system endpoint.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_addresses: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct OntapFileSystemStatusAtProviderEndpointsManagement {
    /// DNS name for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default, setter(strip_option))]
    pub dns_name: Option<String>,
    /// IP addresses of the file system endpoint.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_addresses: Option<Vec<String>>,
}
