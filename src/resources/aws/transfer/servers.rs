// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ServerSpec defines the desired state of Server
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "transfer.aws.upbound.io",
    version = "v1beta2",
    kind = "Server",
    plural = "servers"
)]
#[kube(status = "ServerStatus")]
pub struct ServerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ServerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ServerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ServerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ServerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ServerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ServerWriteConnectionSecretToRef>,
}

/// ServerSpec defines the desired state of Server
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProvider {
    /// The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. This is required when protocols is set to FTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<String>,
    /// Reference to a Certificate in acm to populate certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateRef"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_ref: Option<ServerForProviderCertificateRef>,
    /// Selector for a Certificate in acm to populate certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_selector: Option<ServerForProviderCertificateSelector>,
    /// The directory service ID of the directory service you want to connect to with an identity_provider_type of AWS_DIRECTORY_SERVICE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryId"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id: Option<String>,
    /// Reference to a Directory in ds to populate directoryId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id_ref: Option<ServerForProviderDirectoryIdRef>,
    /// Selector for a Directory in ds to populate directoryId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id_selector: Option<ServerForProviderDirectoryIdSelector>,
    /// The domain of the storage system that is used for file transfers. Valid values are: S3 and EFS. The default value is S3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_details: Option<ServerForProviderEndpointDetails>,
    /// The type of endpoint that you want your SFTP server connect to. If you connect to a VPC (or VPC_ENDPOINT), your SFTP server isn't accessible over the public internet. If you want to connect your SFTP server via public internet, set PUBLIC.  Defaults to PUBLIC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_type: Option<String>,
    /// A boolean that indicates all users associated with the server should be deleted so that the Server can be destroyed without error. The default value is false. This option only applies to servers configured with a SERVICE_MANAGED identity_provider_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forceDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub force_destroy: Option<bool>,
    /// The ARN for a lambda function to use for the Identity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub function: Option<String>,
    /// RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostKeySecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub host_key_secret_ref: Option<ServerForProviderHostKeySecretRef>,
    /// The mode of authentication enabled for this service. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the service. API_GATEWAY indicates that user authentication requires a call to an API Gateway endpoint URL provided by you to integrate an identity provider of your choice. Using AWS_DIRECTORY_SERVICE will allow for authentication against AWS Managed Active Directory or Microsoft Active Directory in your on-premises environment, or in AWS using AD Connectors. Use the AWS_LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the function argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "identityProviderType"
    )]
    #[builder(default, setter(strip_option))]
    pub identity_provider_type: Option<String>,
    /// Amazon Resource Name (ARN) of the IAM role used to authenticate the user account with an identity_provider_type of API_GATEWAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationRole"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_role: Option<String>,
    /// Amazon Resource Name (ARN) of an IAM role that allows the service to write your SFTP usersâ€™ activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRole"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role: Option<String>,
    /// Reference to a Role in iam to populate loggingRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRoleRef"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role_ref: Option<ServerForProviderLoggingRoleRef>,
    /// Selector for a Role in iam to populate loggingRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRoleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role_selector: Option<ServerForProviderLoggingRoleSelector>,
    /// Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationLoginBannerSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_login_banner_secret_ref:
        Option<ServerForProviderPostAuthenticationLoginBannerSecretRef>,
    /// Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationLoginBannerSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_login_banner_secret_ref:
        Option<ServerForProviderPreAuthenticationLoginBannerSecretRef>,
    /// The protocol settings that are configured for your server. See protocol_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "protocolDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub protocol_details: Option<ServerForProviderProtocolDetails>,
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. This defaults to SFTP . The available protocols are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocols: Option<Vec<String>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3StorageOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_storage_options: Option<ServerForProviderS3StorageOptions>,
    /// Specifies the name of the security policy that is attached to the server. Default value is: TransferSecurityPolicy-2018-11. The available values are:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityPolicyName"
    )]
    #[builder(default, setter(strip_option))]
    pub security_policy_name: Option<String>,
    /// For SFTP-enabled servers, and for custom identity providers only. Valid values are PASSWORD, PUBLIC_KEY, PUBLIC_KEY_OR_PASSWORD and PUBLIC_KEY_AND_PASSWORD. Default value is: PUBLIC_KEY_OR_PASSWORD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sftpAuthenticationMethods"
    )]
    #[builder(default, setter(strip_option))]
    pub sftp_authentication_methods: Option<String>,
    /// A set of ARNs of destinations that will receive structured logs from the transfer server such as CloudWatch Log Group ARNs. If provided this enables the transfer server to emit structured logs to the specified locations.
    /// This is a set of arns of destinations that will receive structured logs from the transfer server
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "structuredLogDestinations"
    )]
    #[builder(default, setter(strip_option))]
    pub structured_log_destinations: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// - URL of the service endpoint used to authenticate users with an identity_provider_type of API_GATEWAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub url: Option<String>,
    /// Specifies the workflow details. See workflow_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_details: Option<ServerForProviderWorkflowDetails>,
}

/// Reference to a Certificate in acm to populate certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderCertificateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderCertificateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderCertificateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderCertificateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderCertificateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderCertificateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderCertificateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Certificate in acm to populate certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderCertificateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderCertificateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderCertificateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderCertificateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderCertificateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderCertificateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderCertificateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Directory in ds to populate directoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderDirectoryIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderDirectoryIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderDirectoryIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderDirectoryIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderDirectoryIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderDirectoryIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderDirectoryIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Directory in ds to populate directoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderDirectoryIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderDirectoryIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderDirectoryIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderDirectoryIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderDirectoryIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderDirectoryIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderDirectoryIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetails {
    /// A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIds"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids: Option<Vec<String>>,
    /// References to EIP in ec2 to populate addressAllocationIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIdsRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids_refs:
        Option<Vec<ServerForProviderEndpointDetailsAddressAllocationIdsRefs>>,
    /// Selector for a list of EIP in ec2 to populate addressAllocationIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIdsSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids_selector:
        Option<ServerForProviderEndpointDetailsAddressAllocationIdsSelector>,
    /// A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_ids_refs: Option<Vec<ServerForProviderEndpointDetailsSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_ids_selector: Option<ServerForProviderEndpointDetailsSubnetIdsSelector>,
    /// The ID of the VPC endpoint. This property can only be used when endpoint_type is set to VPC_ENDPOINT
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointId"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_id: Option<String>,
    /// The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default, setter(strip_option))]
    pub vpc_id_ref: Option<ServerForProviderEndpointDetailsVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_id_selector: Option<ServerForProviderEndpointDetailsVpcIdSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsAddressAllocationIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of EIP in ec2 to populate addressAllocationIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsAddressAllocationIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderEndpointDetailsSubnetIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsSubnetIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsSubnetIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsSubnetIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderEndpointDetailsSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsSubnetIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsSubnetIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderEndpointDetailsVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderEndpointDetailsVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderEndpointDetailsVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderEndpointDetailsVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderEndpointDetailsVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderEndpointDetailsVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderHostKeySecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Role in iam to populate loggingRole.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderLoggingRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderLoggingRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderLoggingRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderLoggingRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderLoggingRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderLoggingRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderLoggingRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate loggingRole.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderLoggingRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerForProviderLoggingRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderLoggingRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerForProviderLoggingRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerForProviderLoggingRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderLoggingRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerForProviderLoggingRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderPostAuthenticationLoginBannerSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderPreAuthenticationLoginBannerSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The protocol settings that are configured for your server. See protocol_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderProtocolDetails {
    /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "as2Transports"
    )]
    #[builder(default, setter(strip_option))]
    pub as2_transports: Option<Vec<String>>,
    /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passiveIp")]
    #[builder(default, setter(strip_option))]
    pub passive_ip: Option<String>,
    /// Use to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Valid values: DEFAULT, ENABLE_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "setStatOption"
    )]
    #[builder(default, setter(strip_option))]
    pub set_stat_option: Option<String>,
    /// A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: DISABLED, ENABLED, ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tlsSessionResumptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub tls_session_resumption_mode: Option<String>,
}

/// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderS3StorageOptions {
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. Valid values are DISABLED, ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryListingOptimization"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_listing_optimization: Option<String>,
}

/// Specifies the workflow details. See workflow_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderWorkflowDetails {
    /// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onPartialUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub on_partial_upload: Option<ServerForProviderWorkflowDetailsOnPartialUpload>,
    /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUpload")]
    #[builder(default, setter(strip_option))]
    pub on_upload: Option<ServerForProviderWorkflowDetailsOnUpload>,
}

/// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderWorkflowDetailsOnPartialUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}

/// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerForProviderWorkflowDetailsOnUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProvider {
    /// The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. This is required when protocols is set to FTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<String>,
    /// Reference to a Certificate in acm to populate certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateRef"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_ref: Option<ServerInitProviderCertificateRef>,
    /// Selector for a Certificate in acm to populate certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_selector: Option<ServerInitProviderCertificateSelector>,
    /// The directory service ID of the directory service you want to connect to with an identity_provider_type of AWS_DIRECTORY_SERVICE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryId"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id: Option<String>,
    /// Reference to a Directory in ds to populate directoryId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id_ref: Option<ServerInitProviderDirectoryIdRef>,
    /// Selector for a Directory in ds to populate directoryId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id_selector: Option<ServerInitProviderDirectoryIdSelector>,
    /// The domain of the storage system that is used for file transfers. Valid values are: S3 and EFS. The default value is S3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_details: Option<ServerInitProviderEndpointDetails>,
    /// The type of endpoint that you want your SFTP server connect to. If you connect to a VPC (or VPC_ENDPOINT), your SFTP server isn't accessible over the public internet. If you want to connect your SFTP server via public internet, set PUBLIC.  Defaults to PUBLIC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_type: Option<String>,
    /// A boolean that indicates all users associated with the server should be deleted so that the Server can be destroyed without error. The default value is false. This option only applies to servers configured with a SERVICE_MANAGED identity_provider_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forceDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub force_destroy: Option<bool>,
    /// The ARN for a lambda function to use for the Identity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub function: Option<String>,
    /// RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostKeySecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub host_key_secret_ref: Option<ServerInitProviderHostKeySecretRef>,
    /// The mode of authentication enabled for this service. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the service. API_GATEWAY indicates that user authentication requires a call to an API Gateway endpoint URL provided by you to integrate an identity provider of your choice. Using AWS_DIRECTORY_SERVICE will allow for authentication against AWS Managed Active Directory or Microsoft Active Directory in your on-premises environment, or in AWS using AD Connectors. Use the AWS_LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the function argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "identityProviderType"
    )]
    #[builder(default, setter(strip_option))]
    pub identity_provider_type: Option<String>,
    /// Amazon Resource Name (ARN) of the IAM role used to authenticate the user account with an identity_provider_type of API_GATEWAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationRole"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_role: Option<String>,
    /// Amazon Resource Name (ARN) of an IAM role that allows the service to write your SFTP usersâ€™ activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRole"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role: Option<String>,
    /// Reference to a Role in iam to populate loggingRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRoleRef"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role_ref: Option<ServerInitProviderLoggingRoleRef>,
    /// Selector for a Role in iam to populate loggingRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRoleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role_selector: Option<ServerInitProviderLoggingRoleSelector>,
    /// Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postAuthenticationLoginBannerSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub post_authentication_login_banner_secret_ref:
        Option<ServerInitProviderPostAuthenticationLoginBannerSecretRef>,
    /// Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preAuthenticationLoginBannerSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub pre_authentication_login_banner_secret_ref:
        Option<ServerInitProviderPreAuthenticationLoginBannerSecretRef>,
    /// The protocol settings that are configured for your server. See protocol_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "protocolDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub protocol_details: Option<ServerInitProviderProtocolDetails>,
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. This defaults to SFTP . The available protocols are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocols: Option<Vec<String>>,
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3StorageOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_storage_options: Option<ServerInitProviderS3StorageOptions>,
    /// Specifies the name of the security policy that is attached to the server. Default value is: TransferSecurityPolicy-2018-11. The available values are:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityPolicyName"
    )]
    #[builder(default, setter(strip_option))]
    pub security_policy_name: Option<String>,
    /// For SFTP-enabled servers, and for custom identity providers only. Valid values are PASSWORD, PUBLIC_KEY, PUBLIC_KEY_OR_PASSWORD and PUBLIC_KEY_AND_PASSWORD. Default value is: PUBLIC_KEY_OR_PASSWORD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sftpAuthenticationMethods"
    )]
    #[builder(default, setter(strip_option))]
    pub sftp_authentication_methods: Option<String>,
    /// A set of ARNs of destinations that will receive structured logs from the transfer server such as CloudWatch Log Group ARNs. If provided this enables the transfer server to emit structured logs to the specified locations.
    /// This is a set of arns of destinations that will receive structured logs from the transfer server
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "structuredLogDestinations"
    )]
    #[builder(default, setter(strip_option))]
    pub structured_log_destinations: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// - URL of the service endpoint used to authenticate users with an identity_provider_type of API_GATEWAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub url: Option<String>,
    /// Specifies the workflow details. See workflow_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_details: Option<ServerInitProviderWorkflowDetails>,
}

/// Reference to a Certificate in acm to populate certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderCertificateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderCertificateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderCertificateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderCertificateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderCertificateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderCertificateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderCertificateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Certificate in acm to populate certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderCertificateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderCertificateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderCertificateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderCertificateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderCertificateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderCertificateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderCertificateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Directory in ds to populate directoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderDirectoryIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderDirectoryIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderDirectoryIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderDirectoryIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderDirectoryIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderDirectoryIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderDirectoryIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Directory in ds to populate directoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderDirectoryIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderDirectoryIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderDirectoryIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderDirectoryIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderDirectoryIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderDirectoryIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderDirectoryIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetails {
    /// A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIds"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids: Option<Vec<String>>,
    /// References to EIP in ec2 to populate addressAllocationIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIdsRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids_refs:
        Option<Vec<ServerInitProviderEndpointDetailsAddressAllocationIdsRefs>>,
    /// Selector for a list of EIP in ec2 to populate addressAllocationIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIdsSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids_selector:
        Option<ServerInitProviderEndpointDetailsAddressAllocationIdsSelector>,
    /// A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_ids_refs: Option<Vec<ServerInitProviderEndpointDetailsSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_ids_selector: Option<ServerInitProviderEndpointDetailsSubnetIdsSelector>,
    /// The ID of the VPC endpoint. This property can only be used when endpoint_type is set to VPC_ENDPOINT
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointId"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_id: Option<String>,
    /// The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default, setter(strip_option))]
    pub vpc_id_ref: Option<ServerInitProviderEndpointDetailsVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_id_selector: Option<ServerInitProviderEndpointDetailsVpcIdSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsAddressAllocationIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsAddressAllocationIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of EIP in ec2 to populate addressAllocationIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsAddressAllocationIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsAddressAllocationIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderEndpointDetailsSubnetIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsSubnetIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsSubnetIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsSubnetIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderEndpointDetailsVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderEndpointDetailsVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderEndpointDetailsVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderEndpointDetailsVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderEndpointDetailsVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderEndpointDetailsVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderHostKeySecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Role in iam to populate loggingRole.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderLoggingRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderLoggingRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderLoggingRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderLoggingRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderLoggingRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderLoggingRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderLoggingRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate loggingRole.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderLoggingRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerInitProviderLoggingRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderLoggingRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerInitProviderLoggingRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerInitProviderLoggingRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderLoggingRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerInitProviderLoggingRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderPostAuthenticationLoginBannerSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderPreAuthenticationLoginBannerSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The protocol settings that are configured for your server. See protocol_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderProtocolDetails {
    /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "as2Transports"
    )]
    #[builder(default, setter(strip_option))]
    pub as2_transports: Option<Vec<String>>,
    /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passiveIp")]
    #[builder(default, setter(strip_option))]
    pub passive_ip: Option<String>,
    /// Use to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Valid values: DEFAULT, ENABLE_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "setStatOption"
    )]
    #[builder(default, setter(strip_option))]
    pub set_stat_option: Option<String>,
    /// A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: DISABLED, ENABLED, ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tlsSessionResumptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub tls_session_resumption_mode: Option<String>,
}

/// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderS3StorageOptions {
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. Valid values are DISABLED, ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryListingOptimization"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_listing_optimization: Option<String>,
}

/// Specifies the workflow details. See workflow_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderWorkflowDetails {
    /// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onPartialUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub on_partial_upload: Option<ServerInitProviderWorkflowDetailsOnPartialUpload>,
    /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUpload")]
    #[builder(default, setter(strip_option))]
    pub on_upload: Option<ServerInitProviderWorkflowDetailsOnUpload>,
}

/// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderWorkflowDetailsOnPartialUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}

/// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerInitProviderWorkflowDetailsOnUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ServerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ServerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ServerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ServerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ServerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ServerStatus defines the observed state of Server.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ServerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProvider {
    /// Amazon Resource Name (ARN) of Transfer Server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. This is required when protocols is set to FTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<String>,
    /// The directory service ID of the directory service you want to connect to with an identity_provider_type of AWS_DIRECTORY_SERVICE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryId"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_id: Option<String>,
    /// The domain of the storage system that is used for file transfers. Valid values are: S3 and EFS. The default value is S3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The endpoint of the Transfer Server (e.g., s-12345678.server.transfer.REGION.amazonaws.com)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub endpoint: Option<String>,
    /// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_details: Option<ServerStatusAtProviderEndpointDetails>,
    /// The type of endpoint that you want your SFTP server connect to. If you connect to a VPC (or VPC_ENDPOINT), your SFTP server isn't accessible over the public internet. If you want to connect your SFTP server via public internet, set PUBLIC.  Defaults to PUBLIC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub endpoint_type: Option<String>,
    /// A boolean that indicates all users associated with the server should be deleted so that the Server can be destroyed without error. The default value is false. This option only applies to servers configured with a SERVICE_MANAGED identity_provider_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forceDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub force_destroy: Option<bool>,
    /// The ARN for a lambda function to use for the Identity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub function: Option<String>,
    /// This value contains the message-digest algorithm (MD5) hash of the server's host key. This value is equivalent to the output of the ssh-keygen -l -E md5 -f my-new-server-key command.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostKeyFingerprint"
    )]
    #[builder(default, setter(strip_option))]
    pub host_key_fingerprint: Option<String>,
    /// The Server ID of the Transfer Server (e.g., s-12345678)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The mode of authentication enabled for this service. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the service. API_GATEWAY indicates that user authentication requires a call to an API Gateway endpoint URL provided by you to integrate an identity provider of your choice. Using AWS_DIRECTORY_SERVICE will allow for authentication against AWS Managed Active Directory or Microsoft Active Directory in your on-premises environment, or in AWS using AD Connectors. Use the AWS_LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the function argument.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "identityProviderType"
    )]
    #[builder(default, setter(strip_option))]
    pub identity_provider_type: Option<String>,
    /// Amazon Resource Name (ARN) of the IAM role used to authenticate the user account with an identity_provider_type of API_GATEWAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "invocationRole"
    )]
    #[builder(default, setter(strip_option))]
    pub invocation_role: Option<String>,
    /// Amazon Resource Name (ARN) of an IAM role that allows the service to write your SFTP usersâ€™ activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingRole"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_role: Option<String>,
    /// The protocol settings that are configured for your server. See protocol_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "protocolDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub protocol_details: Option<ServerStatusAtProviderProtocolDetails>,
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. This defaults to SFTP . The available protocols are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocols: Option<Vec<String>>,
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3StorageOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_storage_options: Option<ServerStatusAtProviderS3StorageOptions>,
    /// Specifies the name of the security policy that is attached to the server. Default value is: TransferSecurityPolicy-2018-11. The available values are:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityPolicyName"
    )]
    #[builder(default, setter(strip_option))]
    pub security_policy_name: Option<String>,
    /// For SFTP-enabled servers, and for custom identity providers only. Valid values are PASSWORD, PUBLIC_KEY, PUBLIC_KEY_OR_PASSWORD and PUBLIC_KEY_AND_PASSWORD. Default value is: PUBLIC_KEY_OR_PASSWORD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sftpAuthenticationMethods"
    )]
    #[builder(default, setter(strip_option))]
    pub sftp_authentication_methods: Option<String>,
    /// A set of ARNs of destinations that will receive structured logs from the transfer server such as CloudWatch Log Group ARNs. If provided this enables the transfer server to emit structured logs to the specified locations.
    /// This is a set of arns of destinations that will receive structured logs from the transfer server
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "structuredLogDestinations"
    )]
    #[builder(default, setter(strip_option))]
    pub structured_log_destinations: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// - URL of the service endpoint used to authenticate users with an identity_provider_type of API_GATEWAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub url: Option<String>,
    /// Specifies the workflow details. See workflow_details Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowDetails"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_details: Option<ServerStatusAtProviderWorkflowDetails>,
}

/// The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. See endpoint_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderEndpointDetails {
    /// A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressAllocationIds"
    )]
    #[builder(default, setter(strip_option))]
    pub address_allocation_ids: Option<Vec<String>>,
    /// A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when endpoint_type is set to VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// The ID of the VPC endpoint. This property can only be used when endpoint_type is set to VPC_ENDPOINT
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointId"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_id: Option<String>,
    /// The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when endpoint_type is set to VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
}

/// The protocol settings that are configured for your server. See protocol_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderProtocolDetails {
    /// Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "as2Transports"
    )]
    #[builder(default, setter(strip_option))]
    pub as2_transports: Option<Vec<String>>,
    /// Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passiveIp")]
    #[builder(default, setter(strip_option))]
    pub passive_ip: Option<String>,
    /// Use to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Valid values: DEFAULT, ENABLE_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "setStatOption"
    )]
    #[builder(default, setter(strip_option))]
    pub set_stat_option: Option<String>,
    /// A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: DISABLED, ENABLED, ENFORCED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tlsSessionResumptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub tls_session_resumption_mode: Option<String>,
}

/// Specifies whether or not performance for your Amazon S3 directories is optimized. This is disabled by default. See s3_storage_options Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderS3StorageOptions {
    /// Specifies whether or not performance for your Amazon S3 directories is optimized. Valid values are DISABLED, ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "directoryListingOptimization"
    )]
    #[builder(default, setter(strip_option))]
    pub directory_listing_optimization: Option<String>,
}

/// Specifies the workflow details. See workflow_details Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderWorkflowDetails {
    /// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onPartialUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub on_partial_upload: Option<ServerStatusAtProviderWorkflowDetailsOnPartialUpload>,
    /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onUpload")]
    #[builder(default, setter(strip_option))]
    pub on_upload: Option<ServerStatusAtProviderWorkflowDetailsOnUpload>,
}

/// A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See on_partial_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderWorkflowDetailsOnPartialUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}

/// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See on_upload Block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ServerStatusAtProviderWorkflowDetailsOnUpload {
    /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "executionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub execution_role: Option<String>,
    /// A unique identifier for the workflow.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workflowId"
    )]
    #[builder(default, setter(strip_option))]
    pub workflow_id: Option<String>,
}
