// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// TableSpec defines the desired state of Table
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "dynamodb.aws.upbound.io",
    version = "v1beta2",
    kind = "Table",
    plural = "tables"
)]
#[kube(status = "TableStatus")]
pub struct TableSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<TableDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TableForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<TableInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<TableProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<TablePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<TableWriteConnectionSecretToRef>,
}

/// TableSpec defines the desired state of Table
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TableDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProvider {
    /// Set of nested attribute definitions. Only required for hash_key and range_key attributes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attribute: Option<Vec<TableForProviderAttribute>>,
    /// Controls how you are charged for read and write throughput and how you manage capacity. The valid values are PROVISIONED and PAY_PER_REQUEST. Defaults to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "billingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub billing_mode: Option<String>,
    /// Enables deletion protection for table. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtectionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection_enabled: Option<bool>,
    /// Describe a GSI for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub global_secondary_index: Option<Vec<TableForProviderGlobalSecondaryIndex>>,
    /// Attribute to use as the hash (partition) key. Must also be defined as an attribute. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Import Amazon S3 data into a new table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "importTable"
    )]
    #[builder(default, setter(strip_option))]
    pub import_table: Option<TableForProviderImportTable>,
    /// Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub local_secondary_index: Option<Vec<TableForProviderLocalSecondaryIndex>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableForProviderOnDemandThroughput>,
    /// Enable point-in-time recovery options. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<TableForProviderPointInTimeRecovery>,
    /// Attribute to use as the range (sort) key. Must also be defined as an attribute, see below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Configuration block(s) with DynamoDB Global Tables V2 (version 2019.11.21) replication configurations. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub replica: Option<Vec<TableForProviderReplica>>,
    /// Time of the point-in-time recovery point to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreDateTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_date_time: Option<String>,
    /// Name of the table to restore. Must match the name of an existing table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceName"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_name: Option<String>,
    /// ARN of the source table to restore. Must be supplied for cross-region restores.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceTableArn"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_table_arn: Option<String>,
    /// If set, restores table to the most recent point-in-time recovery point.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToLatestTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_latest_time: Option<bool>,
    /// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverSideEncryption"
    )]
    #[builder(default, setter(strip_option))]
    pub server_side_encryption: Option<TableForProviderServerSideEncryption>,
    /// Whether Streams are enabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_enabled: Option<bool>,
    /// When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are KEYS_ONLY, NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamViewType"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_view_type: Option<String>,
    /// Storage class of the table.
    /// Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS.
    /// Default value is STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableClass"
    )]
    #[builder(default, setter(strip_option))]
    pub table_class: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for TTL. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ttl: Option<TableForProviderTtl>,
    /// Number of write units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderAttribute {
    /// Name of the attribute
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Attribute type. Valid values are S (string), N (number), B (binary).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderGlobalSecondaryIndex {
    /// Name of the hash key in the index; must be defined as an attribute in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Name of the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableForProviderGlobalSecondaryIndexOnDemandThroughput>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key; must be defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderGlobalSecondaryIndexOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Import Amazon S3 data into a new table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderImportTable {
    /// Type of compression to be used on the input coming from the imported table.
    /// Valid values are GZIP, ZSTD and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputCompressionType"
    )]
    #[builder(default, setter(strip_option))]
    pub input_compression_type: Option<String>,
    /// The format of the source data.
    /// Valid values are CSV, DYNAMODB_JSON, and ION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormat"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format: Option<String>,
    /// Describe the format options for the data that was imported into the target table.
    /// There is one value, csv.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormatOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format_options: Option<TableForProviderImportTableInputFormatOptions>,
    /// Values for the S3 bucket the source file is imported from.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketSource"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_source: Option<TableForProviderImportTableS3BucketSource>,
}

/// Describe the format options for the data that was imported into the target table.
/// There is one value, csv.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderImportTableInputFormatOptions {
    /// This block contains the processing options for the CSV file being imported:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub csv: Option<TableForProviderImportTableInputFormatOptionsCsv>,
}

/// This block contains the processing options for the CSV file being imported:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderImportTableInputFormatOptionsCsv {
    /// The delimiter used for separating items in the CSV file being imported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub delimiter: Option<String>,
    /// List of the headers used to specify a common header for all source CSV files being imported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerList"
    )]
    #[builder(default, setter(strip_option))]
    pub header_list: Option<Vec<String>>,
}

/// Values for the S3 bucket the source file is imported from.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderImportTableS3BucketSource {
    /// The S3 bucket that is being imported from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// The account number of the S3 bucket that is being imported from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_owner: Option<String>,
    /// The key prefix shared by all S3 Objects that are being imported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPrefix")]
    #[builder(default, setter(strip_option))]
    pub key_prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderLocalSecondaryIndex {
    /// Name of the index
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Enable point-in-time recovery options. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderPointInTimeRecovery {
    /// Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the point_in_time_recovery block is not provided, this defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderReplica {
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Whether to enable Point In Time Recovery for the replica. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<bool>,
    /// Whether to propagate the global table's tags to a replica. Default is false. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from true to false on a subsequent apply means replica tags are left as they were, unmanaged, not deleted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<bool>,
    /// Region name of the replica.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "regionName"
    )]
    #[builder(default, setter(strip_option))]
    pub region_name: Option<String>,
}

/// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderServerSideEncryption {
    /// Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If enabled is false then server-side encryption is set to AWS-owned key (shown as DEFAULT in the AWS console). Potentially confusingly, if enabled is true and no kms_key_arn is specified then server-side encryption is set to the default KMS-managed key (shown as KMS in the AWS console). The AWS KMS documentation explains the difference between AWS-owned and KMS-managed keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
}

/// Configuration block for TTL. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableForProviderTtl {
    /// Name of the table attribute to store the TTL timestamp in.
    /// Required if enabled is true, must not be set otherwise.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeName"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_name: Option<String>,
    /// Whether TTL is enabled.
    /// Default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProvider {
    /// Set of nested attribute definitions. Only required for hash_key and range_key attributes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attribute: Option<Vec<TableInitProviderAttribute>>,
    /// Controls how you are charged for read and write throughput and how you manage capacity. The valid values are PROVISIONED and PAY_PER_REQUEST. Defaults to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "billingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub billing_mode: Option<String>,
    /// Enables deletion protection for table. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtectionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection_enabled: Option<bool>,
    /// Describe a GSI for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub global_secondary_index: Option<Vec<TableInitProviderGlobalSecondaryIndex>>,
    /// Attribute to use as the hash (partition) key. Must also be defined as an attribute. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Import Amazon S3 data into a new table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "importTable"
    )]
    #[builder(default, setter(strip_option))]
    pub import_table: Option<TableInitProviderImportTable>,
    /// Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub local_secondary_index: Option<Vec<TableInitProviderLocalSecondaryIndex>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableInitProviderOnDemandThroughput>,
    /// Enable point-in-time recovery options. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<TableInitProviderPointInTimeRecovery>,
    /// Attribute to use as the range (sort) key. Must also be defined as an attribute, see below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Configuration block(s) with DynamoDB Global Tables V2 (version 2019.11.21) replication configurations. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub replica: Option<Vec<TableInitProviderReplica>>,
    /// Time of the point-in-time recovery point to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreDateTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_date_time: Option<String>,
    /// Name of the table to restore. Must match the name of an existing table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceName"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_name: Option<String>,
    /// ARN of the source table to restore. Must be supplied for cross-region restores.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceTableArn"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_table_arn: Option<String>,
    /// If set, restores table to the most recent point-in-time recovery point.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToLatestTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_latest_time: Option<bool>,
    /// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverSideEncryption"
    )]
    #[builder(default, setter(strip_option))]
    pub server_side_encryption: Option<TableInitProviderServerSideEncryption>,
    /// Whether Streams are enabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_enabled: Option<bool>,
    /// When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are KEYS_ONLY, NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamViewType"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_view_type: Option<String>,
    /// Storage class of the table.
    /// Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS.
    /// Default value is STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableClass"
    )]
    #[builder(default, setter(strip_option))]
    pub table_class: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block for TTL. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ttl: Option<TableInitProviderTtl>,
    /// Number of write units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderAttribute {
    /// Name of the attribute
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Attribute type. Valid values are S (string), N (number), B (binary).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderGlobalSecondaryIndex {
    /// Name of the hash key in the index; must be defined as an attribute in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Name of the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableInitProviderGlobalSecondaryIndexOnDemandThroughput>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key; must be defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderGlobalSecondaryIndexOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Import Amazon S3 data into a new table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderImportTable {
    /// Type of compression to be used on the input coming from the imported table.
    /// Valid values are GZIP, ZSTD and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputCompressionType"
    )]
    #[builder(default, setter(strip_option))]
    pub input_compression_type: Option<String>,
    /// The format of the source data.
    /// Valid values are CSV, DYNAMODB_JSON, and ION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormat"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format: Option<String>,
    /// Describe the format options for the data that was imported into the target table.
    /// There is one value, csv.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormatOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format_options: Option<TableInitProviderImportTableInputFormatOptions>,
    /// Values for the S3 bucket the source file is imported from.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketSource"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_source: Option<TableInitProviderImportTableS3BucketSource>,
}

/// Describe the format options for the data that was imported into the target table.
/// There is one value, csv.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderImportTableInputFormatOptions {
    /// This block contains the processing options for the CSV file being imported:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub csv: Option<TableInitProviderImportTableInputFormatOptionsCsv>,
}

/// This block contains the processing options for the CSV file being imported:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderImportTableInputFormatOptionsCsv {
    /// The delimiter used for separating items in the CSV file being imported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub delimiter: Option<String>,
    /// List of the headers used to specify a common header for all source CSV files being imported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerList"
    )]
    #[builder(default, setter(strip_option))]
    pub header_list: Option<Vec<String>>,
}

/// Values for the S3 bucket the source file is imported from.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderImportTableS3BucketSource {
    /// The S3 bucket that is being imported from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// The account number of the S3 bucket that is being imported from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_owner: Option<String>,
    /// The key prefix shared by all S3 Objects that are being imported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPrefix")]
    #[builder(default, setter(strip_option))]
    pub key_prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderLocalSecondaryIndex {
    /// Name of the index
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Enable point-in-time recovery options. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderPointInTimeRecovery {
    /// Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the point_in_time_recovery block is not provided, this defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderReplica {
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Whether to enable Point In Time Recovery for the replica. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<bool>,
    /// Whether to propagate the global table's tags to a replica. Default is false. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from true to false on a subsequent apply means replica tags are left as they were, unmanaged, not deleted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<bool>,
    /// Region name of the replica.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "regionName"
    )]
    #[builder(default, setter(strip_option))]
    pub region_name: Option<String>,
}

/// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderServerSideEncryption {
    /// Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If enabled is false then server-side encryption is set to AWS-owned key (shown as DEFAULT in the AWS console). Potentially confusingly, if enabled is true and no kms_key_arn is specified then server-side encryption is set to the default KMS-managed key (shown as KMS in the AWS console). The AWS KMS documentation explains the difference between AWS-owned and KMS-managed keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
}

/// Configuration block for TTL. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableInitProviderTtl {
    /// Name of the table attribute to store the TTL timestamp in.
    /// Required if enabled is true, must not be set otherwise.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeName"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_name: Option<String>,
    /// Whether TTL is enabled.
    /// Default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TableProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TableProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TableProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TableProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TableProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TablePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<TablePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<TablePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TablePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TablePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TablePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TablePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TablePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TablePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TablePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TablePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TableStatus defines the observed state of Table.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<TableStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProvider {
    /// ARN of the table
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Set of nested attribute definitions. Only required for hash_key and range_key attributes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attribute: Option<Vec<TableStatusAtProviderAttribute>>,
    /// Controls how you are charged for read and write throughput and how you manage capacity. The valid values are PROVISIONED and PAY_PER_REQUEST. Defaults to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "billingMode"
    )]
    #[builder(default, setter(strip_option))]
    pub billing_mode: Option<String>,
    /// Enables deletion protection for table. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtectionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection_enabled: Option<bool>,
    /// Describe a GSI for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub global_secondary_index: Option<Vec<TableStatusAtProviderGlobalSecondaryIndex>>,
    /// Attribute to use as the hash (partition) key. Must also be defined as an attribute. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Name of the table
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Import Amazon S3 data into a new table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "importTable"
    )]
    #[builder(default, setter(strip_option))]
    pub import_table: Option<TableStatusAtProviderImportTable>,
    /// Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localSecondaryIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub local_secondary_index: Option<Vec<TableStatusAtProviderLocalSecondaryIndex>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableStatusAtProviderOnDemandThroughput>,
    /// Enable point-in-time recovery options. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<TableStatusAtProviderPointInTimeRecovery>,
    /// Attribute to use as the range (sort) key. Must also be defined as an attribute, see below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Configuration block(s) with DynamoDB Global Tables V2 (version 2019.11.21) replication configurations. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub replica: Option<Vec<TableStatusAtProviderReplica>>,
    /// Time of the point-in-time recovery point to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreDateTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_date_time: Option<String>,
    /// Name of the table to restore. Must match the name of an existing table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceName"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_name: Option<String>,
    /// ARN of the source table to restore. Must be supplied for cross-region restores.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreSourceTableArn"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_source_table_arn: Option<String>,
    /// If set, restores table to the most recent point-in-time recovery point.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToLatestTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_latest_time: Option<bool>,
    /// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverSideEncryption"
    )]
    #[builder(default, setter(strip_option))]
    pub server_side_encryption: Option<TableStatusAtProviderServerSideEncryption>,
    /// ARN of the Table Stream. Only available when stream_enabled = true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamArn")]
    #[builder(default, setter(strip_option))]
    pub stream_arn: Option<String>,
    /// Whether Streams are enabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_enabled: Option<bool>,
    /// Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when stream_enabled = true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamLabel"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_label: Option<String>,
    /// When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are KEYS_ONLY, NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamViewType"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_view_type: Option<String>,
    /// Storage class of the table.
    /// Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS.
    /// Default value is STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tableClass"
    )]
    #[builder(default, setter(strip_option))]
    pub table_class: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Configuration block for TTL. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ttl: Option<TableStatusAtProviderTtl>,
    /// Number of write units for this table. If the billing_mode is PROVISIONED, this field is required.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderAttribute {
    /// Name of the attribute
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Attribute type. Valid values are S (string), N (number), B (binary).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderGlobalSecondaryIndex {
    /// Name of the hash key in the index; must be defined as an attribute in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKey")]
    #[builder(default, setter(strip_option))]
    pub hash_key: Option<String>,
    /// Name of the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// Sets the maximum number of read and write units for the specified on-demand table. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandThroughput"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_throughput: Option<TableStatusAtProviderGlobalSecondaryIndexOnDemandThroughput>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key; must be defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
    /// Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub read_capacity: Option<f64>,
    /// Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub write_capacity: Option<f64>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderGlobalSecondaryIndexOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Import Amazon S3 data into a new table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderImportTable {
    /// Type of compression to be used on the input coming from the imported table.
    /// Valid values are GZIP, ZSTD and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputCompressionType"
    )]
    #[builder(default, setter(strip_option))]
    pub input_compression_type: Option<String>,
    /// The format of the source data.
    /// Valid values are CSV, DYNAMODB_JSON, and ION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormat"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format: Option<String>,
    /// Describe the format options for the data that was imported into the target table.
    /// There is one value, csv.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputFormatOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub input_format_options: Option<TableStatusAtProviderImportTableInputFormatOptions>,
    /// Values for the S3 bucket the source file is imported from.
    /// See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketSource"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_source: Option<TableStatusAtProviderImportTableS3BucketSource>,
}

/// Describe the format options for the data that was imported into the target table.
/// There is one value, csv.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderImportTableInputFormatOptions {
    /// This block contains the processing options for the CSV file being imported:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub csv: Option<TableStatusAtProviderImportTableInputFormatOptionsCsv>,
}

/// This block contains the processing options for the CSV file being imported:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderImportTableInputFormatOptionsCsv {
    /// The delimiter used for separating items in the CSV file being imported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub delimiter: Option<String>,
    /// List of the headers used to specify a common header for all source CSV files being imported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "headerList"
    )]
    #[builder(default, setter(strip_option))]
    pub header_list: Option<Vec<String>>,
}

/// Values for the S3 bucket the source file is imported from.
/// See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderImportTableS3BucketSource {
    /// The S3 bucket that is being imported from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// The account number of the S3 bucket that is being imported from.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_owner: Option<String>,
    /// The key prefix shared by all S3 Objects that are being imported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPrefix")]
    #[builder(default, setter(strip_option))]
    pub key_prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderLocalSecondaryIndex {
    /// Name of the index
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nonKeyAttributes"
    )]
    #[builder(default, setter(strip_option))]
    pub non_key_attributes: Option<Vec<String>>,
    /// One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "projectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub projection_type: Option<String>,
    /// Name of the range key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKey")]
    #[builder(default, setter(strip_option))]
    pub range_key: Option<String>,
}

/// Sets the maximum number of read and write units for the specified on-demand table. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderOnDemandThroughput {
    /// Maximum number of read request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxReadRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_read_request_units: Option<f64>,
    /// Maximum number of write request units for the specified table. To specify set the value greater than or equal to 1. To remove set the value to -1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxWriteRequestUnits"
    )]
    #[builder(default, setter(strip_option))]
    pub max_write_request_units: Option<f64>,
}

/// Enable point-in-time recovery options. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderPointInTimeRecovery {
    /// Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the point_in_time_recovery block is not provided, this defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderReplica {
    /// ARN of the replica
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Whether to enable Point In Time Recovery for the replica. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pointInTimeRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub point_in_time_recovery: Option<bool>,
    /// Whether to propagate the global table's tags to a replica. Default is false. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from true to false on a subsequent apply means replica tags are left as they were, unmanaged, not deleted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<bool>,
    /// Region name of the replica.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "regionName"
    )]
    #[builder(default, setter(strip_option))]
    pub region_name: Option<String>,
    /// ARN of the Table Stream. Only available when stream_enabled = true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamArn")]
    #[builder(default, setter(strip_option))]
    pub stream_arn: Option<String>,
    /// Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when stream_enabled = true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "streamLabel"
    )]
    #[builder(default, setter(strip_option))]
    pub stream_label: Option<String>,
}

/// Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. Must be supplied for cross-region restores. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderServerSideEncryption {
    /// Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If enabled is false then server-side encryption is set to AWS-owned key (shown as DEFAULT in the AWS console). Potentially confusingly, if enabled is true and no kms_key_arn is specified then server-side encryption is set to the default KMS-managed key (shown as KMS in the AWS console). The AWS KMS documentation explains the difference between AWS-owned and KMS-managed keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
    /// ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
}

/// Configuration block for TTL. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TableStatusAtProviderTtl {
    /// Name of the table attribute to store the TTL timestamp in.
    /// Required if enabled is true, must not be set otherwise.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "attributeName"
    )]
    #[builder(default, setter(strip_option))]
    pub attribute_name: Option<String>,
    /// Whether TTL is enabled.
    /// Default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}
