// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// TaskSpec defines the desired state of Task
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "datasync.aws.upbound.io",
    version = "v1beta2",
    kind = "Task",
    plural = "tasks"
)]
#[kube(status = "TaskStatus")]
pub struct TaskSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<TaskDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TaskForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<TaskInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<TaskProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<TaskPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<TaskWriteConnectionSecretToRef>,
}

/// TaskSpec defines the desired state of Task
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProvider {
    /// Amazon Resource Name (ARN) of the CloudWatch Log Group that is used to monitor and log events in the sync task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn_ref: Option<TaskForProviderCloudwatchLogGroupArnRef>,
    /// Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn_selector: Option<TaskForProviderCloudwatchLogGroupArnSelector>,
    /// Amazon Resource Name (ARN) of destination DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn: Option<String>,
    /// Reference to a LocationS3 in datasync to populate destinationLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn_ref: Option<TaskForProviderDestinationLocationArnRef>,
    /// Selector for a LocationS3 in datasync to populate destinationLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn_selector: Option<TaskForProviderDestinationLocationArnSelector>,
    /// Filter rules that determines which files to exclude from a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub excludes: Option<TaskForProviderExcludes>,
    /// Filter rules that determines which files to include in a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub includes: Option<TaskForProviderIncludes>,
    /// Name of the DataSync Task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub options: Option<TaskForProviderOptions>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Specifies a schedule used to periodically transfer files from a source to a destination location.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<TaskForProviderSchedule>,
    /// Amazon Resource Name (ARN) of source DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn: Option<String>,
    /// Reference to a LocationS3 in datasync to populate sourceLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn_ref: Option<TaskForProviderSourceLocationArnRef>,
    /// Selector for a LocationS3 in datasync to populate sourceLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn_selector: Option<TaskForProviderSourceLocationArnSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskReportConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub task_report_config: Option<TaskForProviderTaskReportConfig>,
}

/// Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderCloudwatchLogGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderCloudwatchLogGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderCloudwatchLogGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderCloudwatchLogGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderCloudwatchLogGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderCloudwatchLogGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderCloudwatchLogGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderCloudwatchLogGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderCloudwatchLogGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderCloudwatchLogGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderCloudwatchLogGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderCloudwatchLogGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderCloudwatchLogGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderCloudwatchLogGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a LocationS3 in datasync to populate destinationLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderDestinationLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderDestinationLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderDestinationLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderDestinationLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderDestinationLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderDestinationLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderDestinationLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LocationS3 in datasync to populate destinationLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderDestinationLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderDestinationLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderDestinationLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderDestinationLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderDestinationLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderDestinationLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderDestinationLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Filter rules that determines which files to exclude from a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderExcludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Filter rules that determines which files to include in a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderIncludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderOptions {
    /// A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to BEST_EFFORT, the DataSync Task attempts to preserve the original (that is, the version before sync PREPARING phase) atime attribute on all source files. Valid values: BEST_EFFORT, NONE. Default: BEST_EFFORT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub atime: Option<String>,
    /// Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to 1048576. Value values: -1 or greater. Default: -1 (unlimited).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bytesPerSecond"
    )]
    #[builder(default, setter(strip_option))]
    pub bytes_per_second: Option<f64>,
    /// Group identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub gid: Option<String>,
    /// Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: OFF, BASIC, TRANSFER. Default: OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    #[builder(default, setter(strip_option))]
    pub log_level: Option<String>,
    /// A file metadata that indicates the last time a file was modified (written to) before the sync PREPARING phase. Value values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mtime: Option<String>,
    /// Specifies whether object tags are maintained when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the NONE value. Valid values: PRESERVE, NONE. Default value: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectTags"
    )]
    #[builder(default, setter(strip_option))]
    pub object_tags: Option<String>,
    /// Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: ALWAYS, NEVER. Default: ALWAYS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "overwriteMode"
    )]
    #[builder(default, setter(strip_option))]
    pub overwrite_mode: Option<String>,
    /// Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "posixPermissions"
    )]
    #[builder(default, setter(strip_option))]
    pub posix_permissions: Option<String>,
    /// Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: PRESERVE, REMOVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDeletedFiles"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_deleted_files: Option<String>,
    /// Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task can’t sync the actual contents of such devices, because many of the devices are non-terminal and don’t return an end of file (EOF) marker. Valid values: NONE, PRESERVE. Default: NONE (ignore special devices).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDevices"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_devices: Option<String>,
    /// Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: NONE, OWNER_DACL, OWNER_DACL_SACL. Default: OWNER_DACL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityDescriptorCopyFlags"
    )]
    #[builder(default, setter(strip_option))]
    pub security_descriptor_copy_flags: Option<String>,
    /// Determines whether tasks should be queued before executing the tasks. Valid values: ENABLED, DISABLED. Default ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskQueueing"
    )]
    #[builder(default, setter(strip_option))]
    pub task_queueing: Option<String>,
    /// Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: CHANGED, ALL. Default: CHANGED
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transfer_mode: Option<String>,
    /// User identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uid: Option<String>,
    /// Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: NONE, POINT_IN_TIME_CONSISTENT, ONLY_FILES_TRANSFERRED. Default: POINT_IN_TIME_CONSISTENT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyMode"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_mode: Option<String>,
}

/// Specifies a schedule used to periodically transfer files from a source to a destination location.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderSchedule {
    /// Specifies the schedule you want your task to use for repeated executions. For more information, see Schedule Expressions for Rules.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
}

/// Reference to a LocationS3 in datasync to populate sourceLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderSourceLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderSourceLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderSourceLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderSourceLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderSourceLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderSourceLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderSourceLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LocationS3 in datasync to populate sourceLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderSourceLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskForProviderSourceLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderSourceLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskForProviderSourceLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskForProviderSourceLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderSourceLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskForProviderSourceLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderTaskReportConfig {
    /// Specifies the type of task report you'd like. Valid values: SUMMARY_ONLY and STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outputType"
    )]
    #[builder(default, setter(strip_option))]
    pub output_type: Option<String>,
    /// Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub report_level: Option<String>,
    /// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportOverrides"
    )]
    #[builder(default, setter(strip_option))]
    pub report_overrides: Option<TaskForProviderTaskReportConfigReportOverrides>,
    /// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Destination"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_destination: Option<TaskForProviderTaskReportConfigS3Destination>,
    /// Specifies whether your task report includes the new version of each object transferred into an S3 bucket. This only applies if you enable versioning on your bucket. Keep in mind that setting this to INCLUDE can increase the duration of your task execution. Valid values: INCLUDE and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersioning"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_versioning: Option<String>,
}

/// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderTaskReportConfigReportOverrides {
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub deleted_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to skip during your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skippedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub skipped_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferredOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub transferred_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to verify at the end of your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifiedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub verified_override: Option<String>,
}

/// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskForProviderTaskReportConfigS3Destination {
    /// Specifies the Amazon Resource Name (ARN) of the IAM policy that allows DataSync to upload a task report to your S3 bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketAccessRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_access_role_arn: Option<String>,
    /// Specifies the ARN of the S3 bucket where DataSync uploads your report.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketArn"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_arn: Option<String>,
    /// Specifies a bucket prefix for your report.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subdirectory: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProvider {
    /// Amazon Resource Name (ARN) of the CloudWatch Log Group that is used to monitor and log events in the sync task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn_ref: Option<TaskInitProviderCloudwatchLogGroupArnRef>,
    /// Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn_selector: Option<TaskInitProviderCloudwatchLogGroupArnSelector>,
    /// Amazon Resource Name (ARN) of destination DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn: Option<String>,
    /// Reference to a LocationS3 in datasync to populate destinationLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn_ref: Option<TaskInitProviderDestinationLocationArnRef>,
    /// Selector for a LocationS3 in datasync to populate destinationLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn_selector: Option<TaskInitProviderDestinationLocationArnSelector>,
    /// Filter rules that determines which files to exclude from a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub excludes: Option<TaskInitProviderExcludes>,
    /// Filter rules that determines which files to include in a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub includes: Option<TaskInitProviderIncludes>,
    /// Name of the DataSync Task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub options: Option<TaskInitProviderOptions>,
    /// Specifies a schedule used to periodically transfer files from a source to a destination location.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<TaskInitProviderSchedule>,
    /// Amazon Resource Name (ARN) of source DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn: Option<String>,
    /// Reference to a LocationS3 in datasync to populate sourceLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn_ref: Option<TaskInitProviderSourceLocationArnRef>,
    /// Selector for a LocationS3 in datasync to populate sourceLocationArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn_selector: Option<TaskInitProviderSourceLocationArnSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskReportConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub task_report_config: Option<TaskInitProviderTaskReportConfig>,
}

/// Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderCloudwatchLogGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderCloudwatchLogGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderCloudwatchLogGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderCloudwatchLogGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderCloudwatchLogGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderCloudwatchLogGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderCloudwatchLogGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderCloudwatchLogGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderCloudwatchLogGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderCloudwatchLogGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderCloudwatchLogGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderCloudwatchLogGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderCloudwatchLogGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderCloudwatchLogGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a LocationS3 in datasync to populate destinationLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderDestinationLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderDestinationLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderDestinationLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderDestinationLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderDestinationLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderDestinationLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderDestinationLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LocationS3 in datasync to populate destinationLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderDestinationLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderDestinationLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderDestinationLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderDestinationLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderDestinationLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderDestinationLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderDestinationLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Filter rules that determines which files to exclude from a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderExcludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Filter rules that determines which files to include in a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderIncludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderOptions {
    /// A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to BEST_EFFORT, the DataSync Task attempts to preserve the original (that is, the version before sync PREPARING phase) atime attribute on all source files. Valid values: BEST_EFFORT, NONE. Default: BEST_EFFORT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub atime: Option<String>,
    /// Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to 1048576. Value values: -1 or greater. Default: -1 (unlimited).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bytesPerSecond"
    )]
    #[builder(default, setter(strip_option))]
    pub bytes_per_second: Option<f64>,
    /// Group identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub gid: Option<String>,
    /// Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: OFF, BASIC, TRANSFER. Default: OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    #[builder(default, setter(strip_option))]
    pub log_level: Option<String>,
    /// A file metadata that indicates the last time a file was modified (written to) before the sync PREPARING phase. Value values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mtime: Option<String>,
    /// Specifies whether object tags are maintained when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the NONE value. Valid values: PRESERVE, NONE. Default value: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectTags"
    )]
    #[builder(default, setter(strip_option))]
    pub object_tags: Option<String>,
    /// Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: ALWAYS, NEVER. Default: ALWAYS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "overwriteMode"
    )]
    #[builder(default, setter(strip_option))]
    pub overwrite_mode: Option<String>,
    /// Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "posixPermissions"
    )]
    #[builder(default, setter(strip_option))]
    pub posix_permissions: Option<String>,
    /// Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: PRESERVE, REMOVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDeletedFiles"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_deleted_files: Option<String>,
    /// Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task can’t sync the actual contents of such devices, because many of the devices are non-terminal and don’t return an end of file (EOF) marker. Valid values: NONE, PRESERVE. Default: NONE (ignore special devices).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDevices"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_devices: Option<String>,
    /// Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: NONE, OWNER_DACL, OWNER_DACL_SACL. Default: OWNER_DACL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityDescriptorCopyFlags"
    )]
    #[builder(default, setter(strip_option))]
    pub security_descriptor_copy_flags: Option<String>,
    /// Determines whether tasks should be queued before executing the tasks. Valid values: ENABLED, DISABLED. Default ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskQueueing"
    )]
    #[builder(default, setter(strip_option))]
    pub task_queueing: Option<String>,
    /// Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: CHANGED, ALL. Default: CHANGED
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transfer_mode: Option<String>,
    /// User identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uid: Option<String>,
    /// Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: NONE, POINT_IN_TIME_CONSISTENT, ONLY_FILES_TRANSFERRED. Default: POINT_IN_TIME_CONSISTENT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyMode"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_mode: Option<String>,
}

/// Specifies a schedule used to periodically transfer files from a source to a destination location.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderSchedule {
    /// Specifies the schedule you want your task to use for repeated executions. For more information, see Schedule Expressions for Rules.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
}

/// Reference to a LocationS3 in datasync to populate sourceLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderSourceLocationArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderSourceLocationArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderSourceLocationArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderSourceLocationArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderSourceLocationArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderSourceLocationArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderSourceLocationArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LocationS3 in datasync to populate sourceLocationArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderSourceLocationArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskInitProviderSourceLocationArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderSourceLocationArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskInitProviderSourceLocationArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskInitProviderSourceLocationArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderSourceLocationArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskInitProviderSourceLocationArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderTaskReportConfig {
    /// Specifies the type of task report you'd like. Valid values: SUMMARY_ONLY and STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outputType"
    )]
    #[builder(default, setter(strip_option))]
    pub output_type: Option<String>,
    /// Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub report_level: Option<String>,
    /// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportOverrides"
    )]
    #[builder(default, setter(strip_option))]
    pub report_overrides: Option<TaskInitProviderTaskReportConfigReportOverrides>,
    /// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Destination"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_destination: Option<TaskInitProviderTaskReportConfigS3Destination>,
    /// Specifies whether your task report includes the new version of each object transferred into an S3 bucket. This only applies if you enable versioning on your bucket. Keep in mind that setting this to INCLUDE can increase the duration of your task execution. Valid values: INCLUDE and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersioning"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_versioning: Option<String>,
}

/// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderTaskReportConfigReportOverrides {
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub deleted_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to skip during your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skippedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub skipped_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferredOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub transferred_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to verify at the end of your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifiedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub verified_override: Option<String>,
}

/// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskInitProviderTaskReportConfigS3Destination {
    /// Specifies the Amazon Resource Name (ARN) of the IAM policy that allows DataSync to upload a task report to your S3 bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketAccessRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_access_role_arn: Option<String>,
    /// Specifies the ARN of the S3 bucket where DataSync uploads your report.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketArn"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_arn: Option<String>,
    /// Specifies a bucket prefix for your report.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subdirectory: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<TaskPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<TaskPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<TaskPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<TaskPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<TaskPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TaskPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TaskStatus defines the observed state of Task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<TaskStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProvider {
    /// Amazon Resource Name (ARN) of the DataSync Task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Amazon Resource Name (ARN) of the CloudWatch Log Group that is used to monitor and log events in the sync task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub cloudwatch_log_group_arn: Option<String>,
    /// Amazon Resource Name (ARN) of destination DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_location_arn: Option<String>,
    /// Filter rules that determines which files to exclude from a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub excludes: Option<TaskStatusAtProviderExcludes>,
    /// Amazon Resource Name (ARN) of the DataSync Task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Filter rules that determines which files to include in a task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub includes: Option<TaskStatusAtProviderIncludes>,
    /// Name of the DataSync Task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub options: Option<TaskStatusAtProviderOptions>,
    /// Specifies a schedule used to periodically transfer files from a source to a destination location.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub schedule: Option<TaskStatusAtProviderSchedule>,
    /// Amazon Resource Name (ARN) of source DataSync Location.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceLocationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub source_location_arn: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskReportConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub task_report_config: Option<TaskStatusAtProviderTaskReportConfig>,
}

/// Filter rules that determines which files to exclude from a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderExcludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Filter rules that determines which files to include in a task.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderIncludes {
    /// The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "filterType"
    )]
    #[builder(default, setter(strip_option))]
    pub filter_type: Option<String>,
    /// A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderOptions {
    /// A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to BEST_EFFORT, the DataSync Task attempts to preserve the original (that is, the version before sync PREPARING phase) atime attribute on all source files. Valid values: BEST_EFFORT, NONE. Default: BEST_EFFORT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub atime: Option<String>,
    /// Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to 1048576. Value values: -1 or greater. Default: -1 (unlimited).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bytesPerSecond"
    )]
    #[builder(default, setter(strip_option))]
    pub bytes_per_second: Option<f64>,
    /// Group identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub gid: Option<String>,
    /// Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: OFF, BASIC, TRANSFER. Default: OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    #[builder(default, setter(strip_option))]
    pub log_level: Option<String>,
    /// A file metadata that indicates the last time a file was modified (written to) before the sync PREPARING phase. Value values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mtime: Option<String>,
    /// Specifies whether object tags are maintained when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the NONE value. Valid values: PRESERVE, NONE. Default value: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectTags"
    )]
    #[builder(default, setter(strip_option))]
    pub object_tags: Option<String>,
    /// Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: ALWAYS, NEVER. Default: ALWAYS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "overwriteMode"
    )]
    #[builder(default, setter(strip_option))]
    pub overwrite_mode: Option<String>,
    /// Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: NONE, PRESERVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "posixPermissions"
    )]
    #[builder(default, setter(strip_option))]
    pub posix_permissions: Option<String>,
    /// Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: PRESERVE, REMOVE. Default: PRESERVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDeletedFiles"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_deleted_files: Option<String>,
    /// Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task can’t sync the actual contents of such devices, because many of the devices are non-terminal and don’t return an end of file (EOF) marker. Valid values: NONE, PRESERVE. Default: NONE (ignore special devices).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preserveDevices"
    )]
    #[builder(default, setter(strip_option))]
    pub preserve_devices: Option<String>,
    /// Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: NONE, OWNER_DACL, OWNER_DACL_SACL. Default: OWNER_DACL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityDescriptorCopyFlags"
    )]
    #[builder(default, setter(strip_option))]
    pub security_descriptor_copy_flags: Option<String>,
    /// Determines whether tasks should be queued before executing the tasks. Valid values: ENABLED, DISABLED. Default ENABLED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskQueueing"
    )]
    #[builder(default, setter(strip_option))]
    pub task_queueing: Option<String>,
    /// Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: CHANGED, ALL. Default: CHANGED
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transfer_mode: Option<String>,
    /// User identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uid: Option<String>,
    /// Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: NONE, POINT_IN_TIME_CONSISTENT, ONLY_FILES_TRANSFERRED. Default: POINT_IN_TIME_CONSISTENT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifyMode"
    )]
    #[builder(default, setter(strip_option))]
    pub verify_mode: Option<String>,
}

/// Specifies a schedule used to periodically transfer files from a source to a destination location.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderSchedule {
    /// Specifies the schedule you want your task to use for repeated executions. For more information, see Schedule Expressions for Rules.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
}

/// Configuration block containing the configuration of a DataSync Task Report. See task_report_config below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderTaskReportConfig {
    /// Specifies the type of task report you'd like. Valid values: SUMMARY_ONLY and STANDARD.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outputType"
    )]
    #[builder(default, setter(strip_option))]
    pub output_type: Option<String>,
    /// Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub report_level: Option<String>,
    /// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reportOverrides"
    )]
    #[builder(default, setter(strip_option))]
    pub report_overrides: Option<TaskStatusAtProviderTaskReportConfigReportOverrides>,
    /// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Destination"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_destination: Option<TaskStatusAtProviderTaskReportConfigS3Destination>,
    /// Specifies whether your task report includes the new version of each object transferred into an S3 bucket. This only applies if you enable versioning on your bucket. Keep in mind that setting this to INCLUDE can increase the duration of your task execution. Valid values: INCLUDE and NONE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersioning"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_versioning: Option<String>,
}

/// Configuration block containing the configuration of the reporting level for aspects of your task report. See report_overrides below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderTaskReportConfigReportOverrides {
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub deleted_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to skip during your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skippedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub skipped_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transferredOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub transferred_override: Option<String>,
    /// Specifies the level of reporting for the files, objects, and directories that DataSync attempted to verify at the end of your transfer. Valid values: ERRORS_ONLY and SUCCESSES_AND_ERRORS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "verifiedOverride"
    )]
    #[builder(default, setter(strip_option))]
    pub verified_override: Option<String>,
}

/// Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See s3_destination below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct TaskStatusAtProviderTaskReportConfigS3Destination {
    /// Specifies the Amazon Resource Name (ARN) of the IAM policy that allows DataSync to upload a task report to your S3 bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketAccessRoleArn"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_access_role_arn: Option<String>,
    /// Specifies the ARN of the S3 bucket where DataSync uploads your report.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketArn"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_arn: Option<String>,
    /// Specifies a bucket prefix for your report.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subdirectory: Option<String>,
}
