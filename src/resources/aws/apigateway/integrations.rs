// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// IntegrationSpec defines the desired state of Integration
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "apigateway.aws.upbound.io",
    version = "v1beta2",
    kind = "Integration",
    plural = "integrations"
)]
#[kube(status = "IntegrationStatus")]
pub struct IntegrationSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<IntegrationDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: IntegrationForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<IntegrationInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<IntegrationProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<IntegrationPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<IntegrationWriteConnectionSecretToRef>,
}

/// IntegrationSpec defines the desired state of Integration
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProvider {
    /// List of cache key parameters for the integration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheKeyParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_key_parameters: Option<Vec<String>>,
    /// Integration's cache namespace.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheNamespace"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_namespace: Option<String>,
    /// ID of the VpcLink used for the integration. Required if connection_type is VPC_LINK
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id: Option<String>,
    /// Reference to a VPCLink in apigateway to populate connectionId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id_ref: Option<IntegrationForProviderConnectionIdRef>,
    /// Selector for a VPCLink in apigateway to populate connectionId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id_selector: Option<IntegrationForProviderConnectionIdSelector>,
    /// Integration input's connectionType. Valid values are INTERNET (default for connections through the public routable internet), and VPC_LINK (for private connections between API Gateway and a network load balancer in a VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_type: Option<String>,
    /// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentHandling"
    )]
    #[builder(default, setter(strip_option))]
    pub content_handling: Option<String>,
    /// Credentials required for the integration. For AWS integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub credentials: Option<String>,
    /// HTTP method (GET, POST, PUT, DELETE, HEAD, OPTION, ANY)
    /// when calling the associated resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method: Option<String>,
    /// Reference to a Method in apigateway to populate httpMethod.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethodRef"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method_ref: Option<IntegrationForProviderHttpMethodRef>,
    /// Selector for a Method in apigateway to populate httpMethod.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethodSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method_selector: Option<IntegrationForProviderHttpMethodSelector>,
    /// Integration HTTP method
    /// (GET, POST, PUT, DELETE, HEAD, OPTIONs, ANY, PATCH) specifying how API Gateway will interact with the back end.
    /// Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// Not all methods are compatible with all AWS integrations.
    /// e.g., Lambda function can only be invoked via POST.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integrationHttpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub integration_http_method: Option<String>,
    /// Integration passthrough behavior (WHEN_NO_MATCH, WHEN_NO_TEMPLATES, NEVER).  Required if request_templates is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passthroughBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub passthrough_behavior: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Map of request query string parameters and headers that should be passed to the backend responder.
    /// For example: request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub request_parameters: Option<BTreeMap<String, String>>,
    /// Map of the integration's request templates.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestTemplates"
    )]
    #[builder(default, setter(strip_option))]
    pub request_templates: Option<BTreeMap<String, String>>,
    /// API resource ID.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id: Option<String>,
    /// Reference to a Resource in apigateway to populate resourceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id_ref: Option<IntegrationForProviderResourceIdRef>,
    /// Selector for a Resource in apigateway to populate resourceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id_selector: Option<IntegrationForProviderResourceIdSelector>,
    /// ID of the associated REST API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restApiId")]
    #[builder(default, setter(strip_option))]
    pub rest_api_id: Option<String>,
    /// Reference to a RestAPI in apigateway to populate restApiId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restApiIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub rest_api_id_ref: Option<IntegrationForProviderRestApiIdRef>,
    /// Selector for a RestAPI in apigateway to populate restApiId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restApiIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub rest_api_id_selector: Option<IntegrationForProviderRestApiIdSelector>,
    /// Custom timeout between 50 and 300,000 milliseconds. The default value is 29,000 milliseconds. You need to raise a Service Quota Ticket to increase time beyond 29,000 milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMilliseconds"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_milliseconds: Option<f64>,
    /// TLS configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    #[builder(default, setter(strip_option))]
    pub tls_config: Option<IntegrationForProviderTlsConfig>,
    /// Integration input's type. Valid values are HTTP (for HTTP backends), MOCK (not calling any real backend), AWS (for AWS services), AWS_PROXY (for Lambda proxy integration) and HTTP_PROXY (for HTTP proxy integration). An HTTP or HTTP_PROXY integration with a connection_type of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
    /// Input's URI. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}. region, subdomain and service are used to determine the right endpoint.
    /// e.g., arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:123456789012:function:my-func/invocations. For private integrations, the URI parameter is not used for routing requests to your endpoint, but is used for setting the Host header and for certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uri: Option<String>,
    /// Reference to a Function in lambda to populate uri.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uriRef")]
    #[builder(default, setter(strip_option))]
    pub uri_ref: Option<IntegrationForProviderUriRef>,
    /// Selector for a Function in lambda to populate uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "uriSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub uri_selector: Option<IntegrationForProviderUriSelector>,
}

/// Reference to a VPCLink in apigateway to populate connectionId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderConnectionIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderConnectionIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderConnectionIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderConnectionIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderConnectionIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderConnectionIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderConnectionIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCLink in apigateway to populate connectionId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderConnectionIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderConnectionIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderConnectionIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderConnectionIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderConnectionIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderConnectionIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderConnectionIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Method in apigateway to populate httpMethod.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderHttpMethodRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderHttpMethodRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderHttpMethodRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderHttpMethodRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderHttpMethodRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderHttpMethodRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderHttpMethodRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Method in apigateway to populate httpMethod.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderHttpMethodSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderHttpMethodSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderHttpMethodSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderHttpMethodSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderHttpMethodSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderHttpMethodSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderHttpMethodSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Resource in apigateway to populate resourceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderResourceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderResourceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderResourceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderResourceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderResourceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderResourceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderResourceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Resource in apigateway to populate resourceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderResourceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderResourceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderResourceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderResourceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderResourceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderResourceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderResourceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RestAPI in apigateway to populate restApiId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderRestApiIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderRestApiIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderRestApiIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderRestApiIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderRestApiIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderRestApiIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderRestApiIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RestAPI in apigateway to populate restApiId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderRestApiIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderRestApiIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderRestApiIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderRestApiIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderRestApiIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderRestApiIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderRestApiIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// TLS configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderTlsConfig {
    /// Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "insecureSkipVerification"
    )]
    #[builder(default, setter(strip_option))]
    pub insecure_skip_verification: Option<bool>,
}

/// Reference to a Function in lambda to populate uri.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderUriRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderUriRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderUriRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderUriRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderUriRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderUriRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderUriRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate uri.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderUriSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationForProviderUriSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationForProviderUriSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationForProviderUriSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationForProviderUriSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderUriSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationForProviderUriSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProvider {
    /// List of cache key parameters for the integration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheKeyParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_key_parameters: Option<Vec<String>>,
    /// Integration's cache namespace.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheNamespace"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_namespace: Option<String>,
    /// ID of the VpcLink used for the integration. Required if connection_type is VPC_LINK
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id: Option<String>,
    /// Reference to a VPCLink in apigateway to populate connectionId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id_ref: Option<IntegrationInitProviderConnectionIdRef>,
    /// Selector for a VPCLink in apigateway to populate connectionId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id_selector: Option<IntegrationInitProviderConnectionIdSelector>,
    /// Integration input's connectionType. Valid values are INTERNET (default for connections through the public routable internet), and VPC_LINK (for private connections between API Gateway and a network load balancer in a VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_type: Option<String>,
    /// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentHandling"
    )]
    #[builder(default, setter(strip_option))]
    pub content_handling: Option<String>,
    /// Credentials required for the integration. For AWS integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub credentials: Option<String>,
    /// HTTP method (GET, POST, PUT, DELETE, HEAD, OPTION, ANY)
    /// when calling the associated resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method: Option<String>,
    /// Reference to a Method in apigateway to populate httpMethod.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethodRef"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method_ref: Option<IntegrationInitProviderHttpMethodRef>,
    /// Selector for a Method in apigateway to populate httpMethod.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethodSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method_selector: Option<IntegrationInitProviderHttpMethodSelector>,
    /// Integration HTTP method
    /// (GET, POST, PUT, DELETE, HEAD, OPTIONs, ANY, PATCH) specifying how API Gateway will interact with the back end.
    /// Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// Not all methods are compatible with all AWS integrations.
    /// e.g., Lambda function can only be invoked via POST.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integrationHttpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub integration_http_method: Option<String>,
    /// Integration passthrough behavior (WHEN_NO_MATCH, WHEN_NO_TEMPLATES, NEVER).  Required if request_templates is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passthroughBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub passthrough_behavior: Option<String>,
    /// Map of request query string parameters and headers that should be passed to the backend responder.
    /// For example: request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub request_parameters: Option<BTreeMap<String, String>>,
    /// Map of the integration's request templates.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestTemplates"
    )]
    #[builder(default, setter(strip_option))]
    pub request_templates: Option<BTreeMap<String, String>>,
    /// API resource ID.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id: Option<String>,
    /// Reference to a Resource in apigateway to populate resourceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id_ref: Option<IntegrationInitProviderResourceIdRef>,
    /// Selector for a Resource in apigateway to populate resourceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id_selector: Option<IntegrationInitProviderResourceIdSelector>,
    /// ID of the associated REST API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restApiId")]
    #[builder(default, setter(strip_option))]
    pub rest_api_id: Option<String>,
    /// Reference to a RestAPI in apigateway to populate restApiId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restApiIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub rest_api_id_ref: Option<IntegrationInitProviderRestApiIdRef>,
    /// Selector for a RestAPI in apigateway to populate restApiId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restApiIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub rest_api_id_selector: Option<IntegrationInitProviderRestApiIdSelector>,
    /// Custom timeout between 50 and 300,000 milliseconds. The default value is 29,000 milliseconds. You need to raise a Service Quota Ticket to increase time beyond 29,000 milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMilliseconds"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_milliseconds: Option<f64>,
    /// TLS configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    #[builder(default, setter(strip_option))]
    pub tls_config: Option<IntegrationInitProviderTlsConfig>,
    /// Integration input's type. Valid values are HTTP (for HTTP backends), MOCK (not calling any real backend), AWS (for AWS services), AWS_PROXY (for Lambda proxy integration) and HTTP_PROXY (for HTTP proxy integration). An HTTP or HTTP_PROXY integration with a connection_type of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
    /// Input's URI. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}. region, subdomain and service are used to determine the right endpoint.
    /// e.g., arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:123456789012:function:my-func/invocations. For private integrations, the URI parameter is not used for routing requests to your endpoint, but is used for setting the Host header and for certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uri: Option<String>,
    /// Reference to a Function in lambda to populate uri.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uriRef")]
    #[builder(default, setter(strip_option))]
    pub uri_ref: Option<IntegrationInitProviderUriRef>,
    /// Selector for a Function in lambda to populate uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "uriSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub uri_selector: Option<IntegrationInitProviderUriSelector>,
}

/// Reference to a VPCLink in apigateway to populate connectionId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderConnectionIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderConnectionIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderConnectionIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderConnectionIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderConnectionIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderConnectionIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderConnectionIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCLink in apigateway to populate connectionId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderConnectionIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderConnectionIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderConnectionIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderConnectionIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderConnectionIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderConnectionIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderConnectionIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Method in apigateway to populate httpMethod.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderHttpMethodRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderHttpMethodRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderHttpMethodRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderHttpMethodRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderHttpMethodRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderHttpMethodRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderHttpMethodRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Method in apigateway to populate httpMethod.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderHttpMethodSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderHttpMethodSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderHttpMethodSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderHttpMethodSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderHttpMethodSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderHttpMethodSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderHttpMethodSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Resource in apigateway to populate resourceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderResourceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderResourceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderResourceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderResourceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderResourceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderResourceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderResourceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Resource in apigateway to populate resourceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderResourceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderResourceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderResourceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderResourceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderResourceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderResourceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderResourceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RestAPI in apigateway to populate restApiId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderRestApiIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderRestApiIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderRestApiIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderRestApiIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderRestApiIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderRestApiIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderRestApiIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RestAPI in apigateway to populate restApiId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderRestApiIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderRestApiIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderRestApiIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderRestApiIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderRestApiIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderRestApiIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderRestApiIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// TLS configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderTlsConfig {
    /// Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "insecureSkipVerification"
    )]
    #[builder(default, setter(strip_option))]
    pub insecure_skip_verification: Option<bool>,
}

/// Reference to a Function in lambda to populate uri.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderUriRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderUriRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderUriRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderUriRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderUriRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderUriRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderUriRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate uri.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderUriSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationInitProviderUriSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationInitProviderUriSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationInitProviderUriSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationInitProviderUriSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderUriSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationInitProviderUriSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<IntegrationPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<IntegrationPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<IntegrationPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<IntegrationPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<IntegrationPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum IntegrationPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// IntegrationStatus defines the observed state of Integration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<IntegrationStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationStatusAtProvider {
    /// List of cache key parameters for the integration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheKeyParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_key_parameters: Option<Vec<String>>,
    /// Integration's cache namespace.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheNamespace"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_namespace: Option<String>,
    /// ID of the VpcLink used for the integration. Required if connection_type is VPC_LINK
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_id: Option<String>,
    /// Integration input's connectionType. Valid values are INTERNET (default for connections through the public routable internet), and VPC_LINK (for private connections between API Gateway and a network load balancer in a VPC).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionType"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_type: Option<String>,
    /// How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "contentHandling"
    )]
    #[builder(default, setter(strip_option))]
    pub content_handling: Option<String>,
    /// Credentials required for the integration. For AWS integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub credentials: Option<String>,
    /// HTTP method (GET, POST, PUT, DELETE, HEAD, OPTION, ANY)
    /// when calling the associated resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub http_method: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Integration HTTP method
    /// (GET, POST, PUT, DELETE, HEAD, OPTIONs, ANY, PATCH) specifying how API Gateway will interact with the back end.
    /// Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// Not all methods are compatible with all AWS integrations.
    /// e.g., Lambda function can only be invoked via POST.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integrationHttpMethod"
    )]
    #[builder(default, setter(strip_option))]
    pub integration_http_method: Option<String>,
    /// Integration passthrough behavior (WHEN_NO_MATCH, WHEN_NO_TEMPLATES, NEVER).  Required if request_templates is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passthroughBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub passthrough_behavior: Option<String>,
    /// Map of request query string parameters and headers that should be passed to the backend responder.
    /// For example: request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub request_parameters: Option<BTreeMap<String, String>>,
    /// Map of the integration's request templates.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requestTemplates"
    )]
    #[builder(default, setter(strip_option))]
    pub request_templates: Option<BTreeMap<String, String>>,
    /// API resource ID.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_id: Option<String>,
    /// ID of the associated REST API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restApiId")]
    #[builder(default, setter(strip_option))]
    pub rest_api_id: Option<String>,
    /// Custom timeout between 50 and 300,000 milliseconds. The default value is 29,000 milliseconds. You need to raise a Service Quota Ticket to increase time beyond 29,000 milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMilliseconds"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_milliseconds: Option<f64>,
    /// TLS configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    #[builder(default, setter(strip_option))]
    pub tls_config: Option<IntegrationStatusAtProviderTlsConfig>,
    /// Integration input's type. Valid values are HTTP (for HTTP backends), MOCK (not calling any real backend), AWS (for AWS services), AWS_PROXY (for Lambda proxy integration) and HTTP_PROXY (for HTTP proxy integration). An HTTP or HTTP_PROXY integration with a connection_type of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
    /// Input's URI. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY.
    /// For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}. region, subdomain and service are used to determine the right endpoint.
    /// e.g., arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:123456789012:function:my-func/invocations. For private integrations, the URI parameter is not used for routing requests to your endpoint, but is used for setting the Host header and for certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub uri: Option<String>,
}

/// TLS configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct IntegrationStatusAtProviderTlsConfig {
    /// Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "insecureSkipVerification"
    )]
    #[builder(default, setter(strip_option))]
    pub insecure_skip_verification: Option<bool>,
}
