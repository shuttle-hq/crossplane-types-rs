// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "elasticache.aws.upbound.io",
    version = "v1beta1",
    kind = "Cluster",
    plural = "clusters"
)]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProvider {
    /// Whether any database modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon ElastiCache Documentation for more information..
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine type "redis" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use preferred_availability_zones instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// Whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are single-az or cross-az, default is single-az. If you want to choose cross-az, num_cache_nodes must be greater than 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azMode")]
    #[builder(default, setter(strip_option))]
    pub az_mode: Option<String>,
    /// –  Name of the cache engine to be used for this cache cluster. Valid values are memcached and redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// –  Version number of the cache engine to be used.
    /// If not set, defaults to the latest version.
    /// See Describe Cache Engine Versions in the AWS Documentation for supported versions.
    /// When engine is redis and the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// When the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Name of your final cluster snapshot. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// Specifies the destination and format of Redis SLOWLOG or Redis Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration: Option<Vec<ClusterForProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC).
    /// The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// The IP versions for cache cluster connections. IPv6 is supported with Redis engine 6.2 onword or Memcached version 1.6.6 for all Nitro system instances. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// –  The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcached, this value must be between 1 and 40. If this number is reduced on subsequent runs, the highest numbered nodes will be removed.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheNodes"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_nodes: Option<f64>,
    /// Specify the outpost mode that will apply to the cache cluster creation. Valid values are "single-outpost" and "cross-outpost", however AWS currently only supports "single-outpost" mode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outpostMode"
    )]
    #[builder(default, setter(strip_option))]
    pub outpost_mode: Option<String>,
    /// –  The name of the parameter group to associate with this cache cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// Reference to a ParameterGroup in elasticache to populate parameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name_ref: Option<ClusterForProviderParameterGroupNameRef>,
    /// Selector for a ParameterGroup in elasticache to populate parameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name_selector: Option<ClusterForProviderParameterGroupNameSelector>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of the Availability Zones in which cache nodes are created. If you are creating your cluster in an Amazon VPC you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of num_cache_nodes. If you want all the nodes in the same Availability Zone, use availability_zone instead, or repeat the Availability Zone multiple times in the list. Default: System chosen Availability Zones. Detecting drift of existing node availability zone is not currently supported. Updating this argument by itself to migrate existing node availability zones is not currently supported and will show a perpetual difference.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredAvailabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_availability_zones: Option<Vec<String>>,
    /// The outpost ARN in which the cache cluster will be created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredOutpostArn"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_outpost_arn: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// ID of the replication group to which this cluster should belong. If this parameter is specified, the cluster is added to the specified replication group as a read replica; otherwise, the cluster is a standalone primary that is not part of any replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id: Option<String>,
    /// Reference to a ReplicationGroup in elasticache to populate replicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id_ref: Option<ClusterForProviderReplicationGroupIdRef>,
    /// Selector for a ReplicationGroup in elasticache to populate replicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id_selector: Option<ClusterForProviderReplicationGroupIdSelector>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<ClusterForProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<ClusterForProviderSecurityGroupIdSelector>,
    /// –  One or more VPC security groups associated with the cache cluster. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. The object name cannot contain any commas. Changing snapshot_arns forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// create the resource. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_ref: Option<ClusterForProviderSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_selector: Option<ClusterForProviderSubnetGroupNameSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Enable encryption in-transit. Supported only with Memcached versions 1.6.12 and later, running in a VPC. See the ElastiCache in-transit encryption documentation for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}

/// Reference to a ParameterGroup in elasticache to populate parameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ParameterGroup in elasticache to populate parameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ReplicationGroup in elasticache to populate replicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderReplicationGroupIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderReplicationGroupIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderReplicationGroupIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderReplicationGroupIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderReplicationGroupIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderReplicationGroupIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderReplicationGroupIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ReplicationGroup in elasticache to populate replicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderReplicationGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderReplicationGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderReplicationGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderReplicationGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderReplicationGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderReplicationGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderReplicationGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProvider {
    /// Whether any database modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon ElastiCache Documentation for more information..
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine type "redis" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use preferred_availability_zones instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// Whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are single-az or cross-az, default is single-az. If you want to choose cross-az, num_cache_nodes must be greater than 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azMode")]
    #[builder(default, setter(strip_option))]
    pub az_mode: Option<String>,
    /// –  Name of the cache engine to be used for this cache cluster. Valid values are memcached and redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// –  Version number of the cache engine to be used.
    /// If not set, defaults to the latest version.
    /// See Describe Cache Engine Versions in the AWS Documentation for supported versions.
    /// When engine is redis and the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// When the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Name of your final cluster snapshot. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// Specifies the destination and format of Redis SLOWLOG or Redis Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration: Option<Vec<ClusterInitProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC).
    /// The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// The IP versions for cache cluster connections. IPv6 is supported with Redis engine 6.2 onword or Memcached version 1.6.6 for all Nitro system instances. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// –  The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcached, this value must be between 1 and 40. If this number is reduced on subsequent runs, the highest numbered nodes will be removed.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheNodes"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_nodes: Option<f64>,
    /// Specify the outpost mode that will apply to the cache cluster creation. Valid values are "single-outpost" and "cross-outpost", however AWS currently only supports "single-outpost" mode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outpostMode"
    )]
    #[builder(default, setter(strip_option))]
    pub outpost_mode: Option<String>,
    /// –  The name of the parameter group to associate with this cache cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// Reference to a ParameterGroup in elasticache to populate parameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name_ref: Option<ClusterInitProviderParameterGroupNameRef>,
    /// Selector for a ParameterGroup in elasticache to populate parameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name_selector: Option<ClusterInitProviderParameterGroupNameSelector>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of the Availability Zones in which cache nodes are created. If you are creating your cluster in an Amazon VPC you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of num_cache_nodes. If you want all the nodes in the same Availability Zone, use availability_zone instead, or repeat the Availability Zone multiple times in the list. Default: System chosen Availability Zones. Detecting drift of existing node availability zone is not currently supported. Updating this argument by itself to migrate existing node availability zones is not currently supported and will show a perpetual difference.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredAvailabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_availability_zones: Option<Vec<String>>,
    /// The outpost ARN in which the cache cluster will be created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredOutpostArn"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_outpost_arn: Option<String>,
    /// ID of the replication group to which this cluster should belong. If this parameter is specified, the cluster is added to the specified replication group as a read replica; otherwise, the cluster is a standalone primary that is not part of any replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id: Option<String>,
    /// Reference to a ReplicationGroup in elasticache to populate replicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id_ref: Option<ClusterInitProviderReplicationGroupIdRef>,
    /// Selector for a ReplicationGroup in elasticache to populate replicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id_selector: Option<ClusterInitProviderReplicationGroupIdSelector>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<ClusterInitProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<ClusterInitProviderSecurityGroupIdSelector>,
    /// –  One or more VPC security groups associated with the cache cluster. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. The object name cannot contain any commas. Changing snapshot_arns forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// create the resource. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_ref: Option<ClusterInitProviderSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_selector: Option<ClusterInitProviderSubnetGroupNameSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Enable encryption in-transit. Supported only with Memcached versions 1.6.12 and later, running in a VPC. See the ElastiCache in-transit encryption documentation for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}

/// Reference to a ParameterGroup in elasticache to populate parameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ParameterGroup in elasticache to populate parameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ReplicationGroup in elasticache to populate replicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderReplicationGroupIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderReplicationGroupIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderReplicationGroupIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderReplicationGroupIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderReplicationGroupIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderReplicationGroupIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderReplicationGroupIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ReplicationGroup in elasticache to populate replicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderReplicationGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderReplicationGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderReplicationGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderReplicationGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderReplicationGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderReplicationGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderReplicationGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProvider {
    /// Whether any database modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon ElastiCache Documentation for more information..
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// The ARN of the created ElastiCache Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine type "redis" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use preferred_availability_zones instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// Whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are single-az or cross-az, default is single-az. If you want to choose cross-az, num_cache_nodes must be greater than 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azMode")]
    #[builder(default, setter(strip_option))]
    pub az_mode: Option<String>,
    /// List of node objects including id, address, port and availability_zone.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cacheNodes"
    )]
    #[builder(default, setter(strip_option))]
    pub cache_nodes: Option<Vec<ClusterStatusAtProviderCacheNodes>>,
    /// (Memcached only) DNS name of the cache cluster without the port appended.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_address: Option<String>,
    /// (Memcached only) Configuration endpoint to allow host discovery.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub configuration_endpoint: Option<String>,
    /// –  Name of the cache engine to be used for this cache cluster. Valid values are memcached and redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// –  Version number of the cache engine to be used.
    /// If not set, defaults to the latest version.
    /// See Describe Cache Engine Versions in the AWS Documentation for supported versions.
    /// When engine is redis and the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// When the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Because ElastiCache pulls the latest minor or patch for a version, this attribute returns the running version of the cache engine.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersionActual"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version_actual: Option<String>,
    /// Name of your final cluster snapshot. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// Specifies the destination and format of Redis SLOWLOG or Redis Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration: Option<Vec<ClusterStatusAtProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC).
    /// The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// The IP versions for cache cluster connections. IPv6 is supported with Redis engine 6.2 onword or Memcached version 1.6.6 for all Nitro system instances. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// –  The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcached, this value must be between 1 and 40. If this number is reduced on subsequent runs, the highest numbered nodes will be removed.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheNodes"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_nodes: Option<f64>,
    /// Specify the outpost mode that will apply to the cache cluster creation. Valid values are "single-outpost" and "cross-outpost", however AWS currently only supports "single-outpost" mode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outpostMode"
    )]
    #[builder(default, setter(strip_option))]
    pub outpost_mode: Option<String>,
    /// –  The name of the parameter group to associate with this cache cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of the Availability Zones in which cache nodes are created. If you are creating your cluster in an Amazon VPC you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of num_cache_nodes. If you want all the nodes in the same Availability Zone, use availability_zone instead, or repeat the Availability Zone multiple times in the list. Default: System chosen Availability Zones. Detecting drift of existing node availability zone is not currently supported. Updating this argument by itself to migrate existing node availability zones is not currently supported and will show a perpetual difference.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredAvailabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_availability_zones: Option<Vec<String>>,
    /// The outpost ARN in which the cache cluster will be created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredOutpostArn"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_outpost_arn: Option<String>,
    /// ID of the replication group to which this cluster should belong. If this parameter is specified, the cluster is added to the specified replication group as a read replica; otherwise, the cluster is a standalone primary that is not part of any replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_group_id: Option<String>,
    /// –  One or more VPC security groups associated with the cache cluster. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. The object name cannot contain any commas. Changing snapshot_arns forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// create the resource. Cannot be provided with replication_group_id.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Enable encryption in-transit. Supported only with Memcached versions 1.6.12 and later, running in a VPC. See the ElastiCache in-transit encryption documentation for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderCacheNodes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub address: Option<String>,
    /// Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use preferred_availability_zones instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The ARN of the created ElastiCache Cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outpostArn"
    )]
    #[builder(default, setter(strip_option))]
    pub outpost_arn: Option<String>,
    /// create the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}
