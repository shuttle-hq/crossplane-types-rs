// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ReplicationGroupSpec defines the desired state of ReplicationGroup
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "elasticache.aws.upbound.io",
    version = "v1beta2",
    kind = "ReplicationGroup",
    plural = "replicationgroups"
)]
#[kube(status = "ReplicationGroupStatus")]
pub struct ReplicationGroupSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ReplicationGroupDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ReplicationGroupForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ReplicationGroupInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ReplicationGroupProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ReplicationGroupPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ReplicationGroupWriteConnectionSecretToRef>,
}

/// ReplicationGroupSpec defines the desired state of ReplicationGroup
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProvider {
    /// Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Whether to enable encryption at rest.
    /// When engine is redis, default is false.
    /// When engine is valkey, default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atRestEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub at_rest_encryption_enabled: Option<String>,
    /// Password used to access a password protected server. Can be specified only if transit_encryption_enabled = true.
    /// If you set autoGenerateAuthToken to true, the Secret referenced here will be created or updated with generated auth token if it does not already contain one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authTokenSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub auth_token_secret_ref: Option<ReplicationGroupForProviderAuthTokenSecretRef>,
    /// Strategy to use when updating the auth_token. Valid values are SET, ROTATE, and DELETE. Defaults to ROTATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authTokenUpdateStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub auth_token_update_strategy: Option<String>,
    /// Password used to access a password protected server. Can be specified only if transit_encryption_enabled = true.
    /// If true, the auth token will be auto-generated and stored in the Secret referenced by the authTokenSecretRef field.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoGenerateAuthToken"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_generate_auth_token: Option<bool>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine types "redis" and "valkey" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. If enabled, num_cache_clusters must be greater than 1. Must be enabled for Redis (cluster mode enabled) replication groups. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticFailoverEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_failover_enabled: Option<bool>,
    /// Specifies whether cluster mode is enabled or disabled. Valid values are enabled or disabled or compatible
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMode"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_mode: Option<String>,
    /// Enables data tiering. Data tiering is only supported for replication groups using the r6gd node type. This parameter must be set to true when using r6gd nodes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataTieringEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub data_tiering_enabled: Option<bool>,
    /// created description for the replication group. Must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Name of the cache engine to be used for the clusters in this replication group.
    /// Valid values are redis or valkey.
    /// Default is redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// Version number of the cache engine to be used for the cache clusters in this replication group.
    /// If the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// If the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// The name of your final node group (shard) snapshot. ElastiCache creates the snapshot from the primary node in the cluster. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// The ID of the global replication group to which this replication group should belong. If this parameter is specified, the replication group is added to the specified global replication group as a secondary replication group; otherwise, the replication group is not part of any global replication group. If global_replication_group_id is set, the num_node_groups parameter cannot be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id: Option<String>,
    /// Reference to a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id_ref:
        Option<ReplicationGroupForProviderGlobalReplicationGroupIdRef>,
    /// Selector for a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id_selector:
        Option<ReplicationGroupForProviderGlobalReplicationGroupIdSelector>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// The ARN of the key that you wish to use if encrypting at rest. If not supplied, uses service managed encryption. Can be specified only if at_rest_encryption_enabled = true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<ReplicationGroupForProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<ReplicationGroupForProviderKmsKeyIdSelector>,
    /// Specifies the destination and format of Redis OSS/Valkey SLOWLOG or Redis OSS/Valkey Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration:
        Option<Vec<ReplicationGroupForProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// Specifies whether to enable Multi-AZ Support for the replication group.
    /// If true, automatic_failover_enabled must also be enabled.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "multiAzEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub multi_az_enabled: Option<bool>,
    /// The IP versions for cache cluster connections. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Instance class to be used.
    /// See AWS documentation for information on supported node types and guidance on selecting node types.
    /// Required unless global_replication_group_id is set.
    /// Cannot be set if global_replication_group_id is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// 00#.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheClusters"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_clusters: Option<f64>,
    /// Number of node groups (shards) for this Redis replication group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Conflicts with num_cache_clusters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numNodeGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub num_node_groups: Option<f64>,
    /// Name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. To enable "cluster mode", i.e., data sharding, use a parameter group that has the parameter cluster-enabled set to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// –  Port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is considered. The first item in the list will be the primary node. Ignored when updating.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredCacheClusterAzs"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_cache_cluster_azs: Option<Vec<String>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Number of replica nodes in each node group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Valid values are 0 to 5.
    /// Conflicts with num_cache_clusters.
    /// Can only be set if num_node_groups is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicasPerNodeGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub replicas_per_node_group: Option<f64>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<ReplicationGroupForProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<ReplicationGroupForProviderSecurityGroupIdSelector>,
    /// IDs of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// Names of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// –  List of ARNs that identify Redis RDB snapshot files stored in Amazon S3. The names object names cannot contain any commas.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing the snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of snapshot_retention_limit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// Name of the cache subnet group to be used for the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_ref: Option<ReplicationGroupForProviderSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_selector: Option<ReplicationGroupForProviderSubnetGroupNameSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Whether to enable encryption in transit.
    /// Changing this argument with an engine_version < 7.0.5 will force a replacement.
    /// Engine versions prior to 7.0.5 only allow this transit encryption to be configured during creation of the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
    /// A setting that enables clients to migrate to in-transit encryption with no downtime.
    /// Valid values are preferred and required.
    /// When enabling encryption on an existing replication group, this must first be set to preferred before setting it to required in a subsequent apply.
    /// See the TransitEncryptionMode field in the CreateReplicationGroup API documentation for additional details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_mode: Option<String>,
    /// User Group ID to associate with the replication group. Only a maximum of one (1) user group ID is valid. NOTE: This argument is a set because the AWS specification allows for multiple IDs. However, in practice, AWS only allows a maximum size of one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub user_group_ids: Option<Vec<String>>,
}

/// Password used to access a password protected server. Can be specified only if transit_encryption_enabled = true.
/// If you set autoGenerateAuthToken to true, the Secret referenced here will be created or updated with generated auth token if it does not already contain one.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderAuthTokenSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderGlobalReplicationGroupIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderGlobalReplicationGroupIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderGlobalReplicationGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderGlobalReplicationGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupForProviderSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupForProviderSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupForProviderSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupForProviderSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupForProviderSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProvider {
    /// Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Whether to enable encryption at rest.
    /// When engine is redis, default is false.
    /// When engine is valkey, default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atRestEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub at_rest_encryption_enabled: Option<String>,
    /// Password used to access a password protected server. Can be specified only if transit_encryption_enabled = true.
    /// If you set autoGenerateAuthToken to true, the Secret referenced here will be created or updated with generated auth token if it does not already contain one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authTokenSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub auth_token_secret_ref: Option<ReplicationGroupInitProviderAuthTokenSecretRef>,
    /// Strategy to use when updating the auth_token. Valid values are SET, ROTATE, and DELETE. Defaults to ROTATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authTokenUpdateStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub auth_token_update_strategy: Option<String>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine types "redis" and "valkey" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. If enabled, num_cache_clusters must be greater than 1. Must be enabled for Redis (cluster mode enabled) replication groups. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticFailoverEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_failover_enabled: Option<bool>,
    /// Specifies whether cluster mode is enabled or disabled. Valid values are enabled or disabled or compatible
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMode"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_mode: Option<String>,
    /// Enables data tiering. Data tiering is only supported for replication groups using the r6gd node type. This parameter must be set to true when using r6gd nodes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataTieringEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub data_tiering_enabled: Option<bool>,
    /// created description for the replication group. Must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Name of the cache engine to be used for the clusters in this replication group.
    /// Valid values are redis or valkey.
    /// Default is redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// Version number of the cache engine to be used for the cache clusters in this replication group.
    /// If the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// If the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// The name of your final node group (shard) snapshot. ElastiCache creates the snapshot from the primary node in the cluster. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// The ID of the global replication group to which this replication group should belong. If this parameter is specified, the replication group is added to the specified global replication group as a secondary replication group; otherwise, the replication group is not part of any global replication group. If global_replication_group_id is set, the num_node_groups parameter cannot be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id: Option<String>,
    /// Reference to a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id_ref:
        Option<ReplicationGroupInitProviderGlobalReplicationGroupIdRef>,
    /// Selector for a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id_selector:
        Option<ReplicationGroupInitProviderGlobalReplicationGroupIdSelector>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// The ARN of the key that you wish to use if encrypting at rest. If not supplied, uses service managed encryption. Can be specified only if at_rest_encryption_enabled = true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<ReplicationGroupInitProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<ReplicationGroupInitProviderKmsKeyIdSelector>,
    /// Specifies the destination and format of Redis OSS/Valkey SLOWLOG or Redis OSS/Valkey Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration:
        Option<Vec<ReplicationGroupInitProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// Specifies whether to enable Multi-AZ Support for the replication group.
    /// If true, automatic_failover_enabled must also be enabled.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "multiAzEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub multi_az_enabled: Option<bool>,
    /// The IP versions for cache cluster connections. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Instance class to be used.
    /// See AWS documentation for information on supported node types and guidance on selecting node types.
    /// Required unless global_replication_group_id is set.
    /// Cannot be set if global_replication_group_id is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// 00#.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheClusters"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_clusters: Option<f64>,
    /// Number of node groups (shards) for this Redis replication group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Conflicts with num_cache_clusters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numNodeGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub num_node_groups: Option<f64>,
    /// Name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. To enable "cluster mode", i.e., data sharding, use a parameter group that has the parameter cluster-enabled set to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// –  Port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is considered. The first item in the list will be the primary node. Ignored when updating.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredCacheClusterAzs"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_cache_cluster_azs: Option<Vec<String>>,
    /// Number of replica nodes in each node group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Valid values are 0 to 5.
    /// Conflicts with num_cache_clusters.
    /// Can only be set if num_node_groups is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicasPerNodeGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub replicas_per_node_group: Option<f64>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<ReplicationGroupInitProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<ReplicationGroupInitProviderSecurityGroupIdSelector>,
    /// IDs of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// Names of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// –  List of ARNs that identify Redis RDB snapshot files stored in Amazon S3. The names object names cannot contain any commas.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing the snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of snapshot_retention_limit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// Name of the cache subnet group to be used for the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_ref: Option<ReplicationGroupInitProviderSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name_selector: Option<ReplicationGroupInitProviderSubnetGroupNameSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Whether to enable encryption in transit.
    /// Changing this argument with an engine_version < 7.0.5 will force a replacement.
    /// Engine versions prior to 7.0.5 only allow this transit encryption to be configured during creation of the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
    /// A setting that enables clients to migrate to in-transit encryption with no downtime.
    /// Valid values are preferred and required.
    /// When enabling encryption on an existing replication group, this must first be set to preferred before setting it to required in a subsequent apply.
    /// See the TransitEncryptionMode field in the CreateReplicationGroup API documentation for additional details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_mode: Option<String>,
    /// User Group ID to associate with the replication group. Only a maximum of one (1) user group ID is valid. NOTE: This argument is a set because the AWS specification allows for multiple IDs. However, in practice, AWS only allows a maximum size of one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub user_group_ids: Option<Vec<String>>,
}

/// Password used to access a password protected server. Can be specified only if transit_encryption_enabled = true.
/// If you set autoGenerateAuthToken to true, the Secret referenced here will be created or updated with generated auth token if it does not already contain one.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderAuthTokenSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderGlobalReplicationGroupIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderGlobalReplicationGroupIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a GlobalReplicationGroup in elasticache to populate globalReplicationGroupId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderGlobalReplicationGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderGlobalReplicationGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in elasticache to populate subnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupInitProviderSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupInitProviderSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupInitProviderSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupInitProviderSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupInitProviderSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ReplicationGroupPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ReplicationGroupPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ReplicationGroupPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ReplicationGroupPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ReplicationGroupPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicationGroupPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ReplicationGroupStatus defines the observed state of ReplicationGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ReplicationGroupStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupStatusAtProvider {
    /// Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// ARN of the created ElastiCache Replication Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Whether to enable encryption at rest.
    /// When engine is redis, default is false.
    /// When engine is valkey, default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atRestEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub at_rest_encryption_enabled: Option<String>,
    /// Strategy to use when updating the auth_token. Valid values are SET, ROTATE, and DELETE. Defaults to ROTATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authTokenUpdateStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub auth_token_update_strategy: Option<String>,
    /// Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window.
    /// Only supported for engine types "redis" and "valkey" and if the engine version is 6 or higher.
    /// Defaults to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoMinorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_minor_version_upgrade: Option<String>,
    /// Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. If enabled, num_cache_clusters must be greater than 1. Must be enabled for Redis (cluster mode enabled) replication groups. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "automaticFailoverEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub automatic_failover_enabled: Option<bool>,
    /// Indicates if cluster mode is enabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_enabled: Option<bool>,
    /// Specifies whether cluster mode is enabled or disabled. Valid values are enabled or disabled or compatible
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMode"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_mode: Option<String>,
    /// Address of the replication group configuration endpoint when cluster mode is enabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationEndpointAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub configuration_endpoint_address: Option<String>,
    /// Enables data tiering. Data tiering is only supported for replication groups using the r6gd node type. This parameter must be set to true when using r6gd nodes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataTieringEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub data_tiering_enabled: Option<bool>,
    /// created description for the replication group. Must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Name of the cache engine to be used for the clusters in this replication group.
    /// Valid values are redis or valkey.
    /// Default is redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// Version number of the cache engine to be used for the cache clusters in this replication group.
    /// If the version is 7 or higher, the major and minor version should be set, e.g., 7.2.
    /// If the version is 6, the major and minor version can be set, e.g., 6.2,
    /// or the minor version can be unspecified which will use the latest version at creation time, e.g., 6.x.
    /// Otherwise, specify the full version desired, e.g., 5.0.6.
    /// The actual engine version used is returned in the attribute engine_version_actual, see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Because ElastiCache pulls the latest minor or patch for a version, this attribute returns the running version of the cache engine.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersionActual"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version_actual: Option<String>,
    /// The name of your final node group (shard) snapshot. ElastiCache creates the snapshot from the primary node in the cluster. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// The ID of the global replication group to which this replication group should belong. If this parameter is specified, the replication group is added to the specified global replication group as a secondary replication group; otherwise, the replication group is not part of any global replication group. If global_replication_group_id is set, the num_node_groups parameter cannot be set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalReplicationGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub global_replication_group_id: Option<String>,
    /// ID of the ElastiCache Replication Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The IP version to advertise in the discovery protocol. Valid values are ipv4 or ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_discovery: Option<String>,
    /// The ARN of the key that you wish to use if encrypting at rest. If not supplied, uses service managed encryption. Can be specified only if at_rest_encryption_enabled = true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Specifies the destination and format of Redis OSS/Valkey SLOWLOG or Redis OSS/Valkey Engine Log. See the documentation on Amazon ElastiCache. See Log Delivery Configuration below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logDeliveryConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub log_delivery_configuration:
        Option<Vec<ReplicationGroupStatusAtProviderLogDeliveryConfiguration>>,
    /// ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: sun:05:00-sun:09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_window: Option<String>,
    /// Identifiers of all the nodes that are part of this replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memberClusters"
    )]
    #[builder(default, setter(strip_option))]
    pub member_clusters: Option<Vec<String>>,
    /// Specifies whether to enable Multi-AZ Support for the replication group.
    /// If true, automatic_failover_enabled must also be enabled.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "multiAzEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub multi_az_enabled: Option<bool>,
    /// The IP versions for cache cluster connections. Valid values are ipv4, ipv6 or dual_stack.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Instance class to be used.
    /// See AWS documentation for information on supported node types and guidance on selecting node types.
    /// Required unless global_replication_group_id is set.
    /// Cannot be set if global_replication_group_id is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeType")]
    #[builder(default, setter(strip_option))]
    pub node_type: Option<String>,
    /// east-1:012345678999:my_sns_topic
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationTopicArn"
    )]
    #[builder(default, setter(strip_option))]
    pub notification_topic_arn: Option<String>,
    /// 00#.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numCacheClusters"
    )]
    #[builder(default, setter(strip_option))]
    pub num_cache_clusters: Option<f64>,
    /// Number of node groups (shards) for this Redis replication group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Conflicts with num_cache_clusters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numNodeGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub num_node_groups: Option<f64>,
    /// Name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. To enable "cluster mode", i.e., data sharding, use a parameter group that has the parameter cluster-enabled set to true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub parameter_group_name: Option<String>,
    /// –  Port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// List of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is considered. The first item in the list will be the primary node. Ignored when updating.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredCacheClusterAzs"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_cache_cluster_azs: Option<Vec<String>>,
    /// (Redis only) Address of the endpoint for the primary node in the replication group, if the cluster mode is disabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "primaryEndpointAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub primary_endpoint_address: Option<String>,
    /// (Redis only) Address of the endpoint for the reader node in the replication group, if the cluster mode is disabled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readerEndpointAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub reader_endpoint_address: Option<String>,
    /// Number of replica nodes in each node group.
    /// Changing this number will trigger a resizing operation before other settings modifications.
    /// Valid values are 0 to 5.
    /// Conflicts with num_cache_clusters.
    /// Can only be set if num_node_groups is set.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicasPerNodeGroup"
    )]
    #[builder(default, setter(strip_option))]
    pub replicas_per_node_group: Option<f64>,
    /// IDs of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// Names of one or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// –  List of ARNs that identify Redis RDB snapshot files stored in Amazon S3. The names object names cannot contain any commas.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotArns"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_arns: Option<Vec<String>>,
    /// Name of a snapshot from which to restore data into the new node group. Changing the snapshot_name forces a new resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_name: Option<String>,
    /// Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of snapshot_retention_limit is set to zero (0), backups are turned off. Please note that setting a snapshot_retention_limit is not supported on cache.t1.micro cache nodes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotRetentionLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_retention_limit: Option<f64>,
    /// Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: 05:00-09:00
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_window: Option<String>,
    /// Name of the cache subnet group to be used for the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_group_name: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Whether to enable encryption in transit.
    /// Changing this argument with an engine_version < 7.0.5 will force a replacement.
    /// Engine versions prior to 7.0.5 only allow this transit encryption to be configured during creation of the replication group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_enabled: Option<bool>,
    /// A setting that enables clients to migrate to in-transit encryption with no downtime.
    /// Valid values are preferred and required.
    /// When enabling encryption on an existing replication group, this must first be set to preferred before setting it to required in a subsequent apply.
    /// See the TransitEncryptionMode field in the CreateReplicationGroup API documentation for additional details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitEncryptionMode"
    )]
    #[builder(default, setter(strip_option))]
    pub transit_encryption_mode: Option<String>,
    /// User Group ID to associate with the replication group. Only a maximum of one (1) user group ID is valid. NOTE: This argument is a set because the AWS specification allows for multiple IDs. However, in practice, AWS only allows a maximum size of one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub user_group_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ReplicationGroupStatusAtProviderLogDeliveryConfiguration {
    /// Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub destination: Option<String>,
    /// For CloudWatch Logs use cloudwatch-logs or for Kinesis Data Firehose use kinesis-firehose.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "destinationType"
    )]
    #[builder(default, setter(strip_option))]
    pub destination_type: Option<String>,
    /// Valid values are json or text
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// Valid values are  slow-log or engine-log. Max 1 of each.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    #[builder(default, setter(strip_option))]
    pub log_type: Option<String>,
}
