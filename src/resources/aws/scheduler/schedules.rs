// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ScheduleSpec defines the desired state of Schedule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "scheduler.aws.upbound.io",
    version = "v1beta2",
    kind = "Schedule",
    plural = "schedules"
)]
#[kube(status = "ScheduleStatus")]
pub struct ScheduleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ScheduleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ScheduleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ScheduleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ScheduleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<SchedulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ScheduleWriteConnectionSecretToRef>,
}

/// ScheduleSpec defines the desired state of Schedule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProvider {
    /// Brief description of the schedule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the end date you specify. EventBridge Scheduler ignores the end date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endDate")]
    #[builder(default, setter(strip_option))]
    pub end_date: Option<String>,
    /// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flexibleTimeWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub flexible_time_window: Option<ScheduleForProviderFlexibleTimeWindow>,
    /// Name of the schedule group to associate with this schedule. When omitted, the default schedule group is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// ARN for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_ref: Option<ScheduleForProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_selector: Option<ScheduleForProviderKmsKeyArnSelector>,
    /// Name of the schedule. Conflicts with name_prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Defines when the schedule runs. Read more in Schedule types on EventBridge Scheduler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
    /// Timezone in which the scheduling expression is evaluated. Defaults to UTC. Example: Australia/Sydney.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpressionTimezone"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression_timezone: Option<String>,
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the start date you specify. EventBridge Scheduler ignores the start date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startDate")]
    #[builder(default, setter(strip_option))]
    pub start_date: Option<String>,
    /// Specifies whether the schedule is enabled or disabled. One of: ENABLED (default), DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Configures the target of the schedule. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub target: Option<ScheduleForProviderTarget>,
}

/// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderFlexibleTimeWindow {
    /// Maximum time window during which a schedule can be invoked. Ranges from 1 to 1440 minutes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumWindowInMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_window_in_minutes: Option<f64>,
    /// Determines whether the schedule is invoked within a flexible time window. One of: OFF, FLEXIBLE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configures the target of the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTarget {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a Queue in sqs to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ScheduleForProviderTargetArnRef>,
    /// Selector for a Queue in sqs to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ScheduleForProviderTargetArnSelector>,
    /// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<ScheduleForProviderTargetDeadLetterConfig>,
    /// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub ecs_parameters: Option<ScheduleForProviderTargetEcsParameters>,
    /// Templated target type for the EventBridge PutEvents API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventbridgeParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub eventbridge_parameters: Option<ScheduleForProviderTargetEventbridgeParameters>,
    /// Text, or well-formed JSON, passed to the target. Read more in Universal target.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub input: Option<String>,
    /// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kinesisParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub kinesis_parameters: Option<ScheduleForProviderTargetKinesisParameters>,
    /// Information about the retry policy settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<ScheduleForProviderTargetRetryPolicy>,
    /// ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in Set up the execution role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default, setter(strip_option))]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub role_arn_ref: Option<ScheduleForProviderTargetRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_arn_selector: Option<ScheduleForProviderTargetRoleArnSelector>,
    /// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sagemakerPipelineParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sagemaker_pipeline_parameters: Option<ScheduleForProviderTargetSagemakerPipelineParameters>,
    /// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sqs_parameters: Option<ScheduleForProviderTargetSqsParameters>,
}

/// Reference to a Queue in sqs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Queue in sqs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetDeadLetterConfig {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
}

/// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEcsParameters {
    /// Up to 6 capacity provider strategies to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProviderStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider_strategy:
        Option<Vec<ScheduleForProviderTargetEcsParametersCapacityProviderStrategy>>,
    /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableEcsManagedTags"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Specifies whether to enable the execute command functionality for the containers in this task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableExecuteCommand"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_execute_command: Option<bool>,
    /// Specifies an ECS task group for the task. At most 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub group: Option<String>,
    /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: EC2, FARGATE, EXTERNAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "launchType"
    )]
    #[builder(default, setter(strip_option))]
    pub launch_type: Option<String>,
    /// Configures the networking associated with the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub network_configuration: Option<ScheduleForProviderTargetEcsParametersNetworkConfiguration>,
    /// A set of up to 10 placement constraints to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_constraints:
        Option<Vec<ScheduleForProviderTargetEcsParametersPlacementConstraints>>,
    /// A set of up to 5 placement strategies. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_strategy: Option<Vec<ScheduleForProviderTargetEcsParametersPlacementStrategy>>,
    /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "platformVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub platform_version: Option<String>,
    /// Specifies whether to propagate the tags from the task definition to the task. One of: TASK_DEFINITION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<String>,
    /// Reference ID to use for the task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "referenceId"
    )]
    #[builder(default, setter(strip_option))]
    pub reference_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// The number of tasks to create. Ranges from 1 (default) to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskCount")]
    #[builder(default, setter(strip_option))]
    pub task_count: Option<f64>,
    /// ARN of the task definition to use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskDefinitionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub task_definition_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEcsParametersCapacityProviderStrategy {
    /// How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from 0 (default) to 100000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider: Option<String>,
    /// Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from 0 to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Configures the networking associated with the task. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEcsParametersNetworkConfiguration {
    /// Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where true maps to ENABLED and false to DISABLED. You can specify true only when the launch_type is set to FARGATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "assignPublicIp"
    )]
    #[builder(default, setter(strip_option))]
    pub assign_public_ip: Option<bool>,
    /// Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEcsParametersPlacementConstraints {
    /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEcsParametersPlacementStrategy {
    /// The field to apply the placement strategy against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub field: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Templated target type for the EventBridge PutEvents API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetEventbridgeParameters {
    /// Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "detailType"
    )]
    #[builder(default, setter(strip_option))]
    pub detail_type: Option<String>,
    /// Source of the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub source: Option<String>,
}

/// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetKinesisParameters {
    /// Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionKey"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_key: Option<String>,
}

/// Information about the retry policy settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetRetryPolicy {
    /// Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from 60 to 86400 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumEventAgeInSeconds"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_event_age_in_seconds: Option<f64>,
    /// Maximum number of retry attempts to make before the request fails. Ranges from 0 to 185 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumRetryAttempts"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_retry_attempts: Option<f64>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderTargetRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderTargetRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderTargetRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleForProviderTargetRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleForProviderTargetRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleForProviderTargetRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleForProviderTargetRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetSagemakerPipelineParameters {
    /// Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pipelineParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub pipeline_parameter:
        Option<Vec<ScheduleForProviderTargetSagemakerPipelineParametersPipelineParameter>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetSagemakerPipelineParametersPipelineParameter {
    /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleForProviderTargetSqsParameters {
    /// FIFO message group ID to use as the target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub message_group_id: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProvider {
    /// Brief description of the schedule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the end date you specify. EventBridge Scheduler ignores the end date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endDate")]
    #[builder(default, setter(strip_option))]
    pub end_date: Option<String>,
    /// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flexibleTimeWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub flexible_time_window: Option<ScheduleInitProviderFlexibleTimeWindow>,
    /// Name of the schedule group to associate with this schedule. When omitted, the default schedule group is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// ARN for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_ref: Option<ScheduleInitProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_selector: Option<ScheduleInitProviderKmsKeyArnSelector>,
    /// Name of the schedule. Conflicts with name_prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Defines when the schedule runs. Read more in Schedule types on EventBridge Scheduler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
    /// Timezone in which the scheduling expression is evaluated. Defaults to UTC. Example: Australia/Sydney.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpressionTimezone"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression_timezone: Option<String>,
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the start date you specify. EventBridge Scheduler ignores the start date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startDate")]
    #[builder(default, setter(strip_option))]
    pub start_date: Option<String>,
    /// Specifies whether the schedule is enabled or disabled. One of: ENABLED (default), DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Configures the target of the schedule. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub target: Option<ScheduleInitProviderTarget>,
}

/// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderFlexibleTimeWindow {
    /// Maximum time window during which a schedule can be invoked. Ranges from 1 to 1440 minutes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumWindowInMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_window_in_minutes: Option<f64>,
    /// Determines whether the schedule is invoked within a flexible time window. One of: OFF, FLEXIBLE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configures the target of the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTarget {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a Queue in sqs to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<ScheduleInitProviderTargetArnRef>,
    /// Selector for a Queue in sqs to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<ScheduleInitProviderTargetArnSelector>,
    /// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<ScheduleInitProviderTargetDeadLetterConfig>,
    /// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub ecs_parameters: Option<ScheduleInitProviderTargetEcsParameters>,
    /// Templated target type for the EventBridge PutEvents API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventbridgeParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub eventbridge_parameters: Option<ScheduleInitProviderTargetEventbridgeParameters>,
    /// Text, or well-formed JSON, passed to the target. Read more in Universal target.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub input: Option<String>,
    /// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kinesisParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub kinesis_parameters: Option<ScheduleInitProviderTargetKinesisParameters>,
    /// Information about the retry policy settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<ScheduleInitProviderTargetRetryPolicy>,
    /// ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in Set up the execution role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default, setter(strip_option))]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub role_arn_ref: Option<ScheduleInitProviderTargetRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_arn_selector: Option<ScheduleInitProviderTargetRoleArnSelector>,
    /// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sagemakerPipelineParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sagemaker_pipeline_parameters:
        Option<ScheduleInitProviderTargetSagemakerPipelineParameters>,
    /// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sqs_parameters: Option<ScheduleInitProviderTargetSqsParameters>,
}

/// Reference to a Queue in sqs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Queue in sqs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetDeadLetterConfig {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
}

/// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEcsParameters {
    /// Up to 6 capacity provider strategies to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProviderStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider_strategy:
        Option<Vec<ScheduleInitProviderTargetEcsParametersCapacityProviderStrategy>>,
    /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableEcsManagedTags"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Specifies whether to enable the execute command functionality for the containers in this task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableExecuteCommand"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_execute_command: Option<bool>,
    /// Specifies an ECS task group for the task. At most 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub group: Option<String>,
    /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: EC2, FARGATE, EXTERNAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "launchType"
    )]
    #[builder(default, setter(strip_option))]
    pub launch_type: Option<String>,
    /// Configures the networking associated with the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub network_configuration: Option<ScheduleInitProviderTargetEcsParametersNetworkConfiguration>,
    /// A set of up to 10 placement constraints to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_constraints:
        Option<Vec<ScheduleInitProviderTargetEcsParametersPlacementConstraints>>,
    /// A set of up to 5 placement strategies. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_strategy: Option<Vec<ScheduleInitProviderTargetEcsParametersPlacementStrategy>>,
    /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "platformVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub platform_version: Option<String>,
    /// Specifies whether to propagate the tags from the task definition to the task. One of: TASK_DEFINITION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<String>,
    /// Reference ID to use for the task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "referenceId"
    )]
    #[builder(default, setter(strip_option))]
    pub reference_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// The number of tasks to create. Ranges from 1 (default) to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskCount")]
    #[builder(default, setter(strip_option))]
    pub task_count: Option<f64>,
    /// ARN of the task definition to use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskDefinitionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub task_definition_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEcsParametersCapacityProviderStrategy {
    /// How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from 0 (default) to 100000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider: Option<String>,
    /// Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from 0 to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Configures the networking associated with the task. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEcsParametersNetworkConfiguration {
    /// Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where true maps to ENABLED and false to DISABLED. You can specify true only when the launch_type is set to FARGATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "assignPublicIp"
    )]
    #[builder(default, setter(strip_option))]
    pub assign_public_ip: Option<bool>,
    /// Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEcsParametersPlacementConstraints {
    /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEcsParametersPlacementStrategy {
    /// The field to apply the placement strategy against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub field: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Templated target type for the EventBridge PutEvents API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetEventbridgeParameters {
    /// Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "detailType"
    )]
    #[builder(default, setter(strip_option))]
    pub detail_type: Option<String>,
    /// Source of the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub source: Option<String>,
}

/// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetKinesisParameters {
    /// Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionKey"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_key: Option<String>,
}

/// Information about the retry policy settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetRetryPolicy {
    /// Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from 60 to 86400 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumEventAgeInSeconds"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_event_age_in_seconds: Option<f64>,
    /// Maximum number of retry attempts to make before the request fails. Ranges from 0 to 185 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumRetryAttempts"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_retry_attempts: Option<f64>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderTargetRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderTargetRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderTargetRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleInitProviderTargetRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleInitProviderTargetRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleInitProviderTargetRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleInitProviderTargetRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetSagemakerPipelineParameters {
    /// Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pipelineParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub pipeline_parameter:
        Option<Vec<ScheduleInitProviderTargetSagemakerPipelineParametersPipelineParameter>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetSagemakerPipelineParametersPipelineParameter {
    /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleInitProviderTargetSqsParameters {
    /// FIFO message group ID to use as the target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub message_group_id: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ScheduleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ScheduleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ScheduleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ScheduleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct SchedulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<SchedulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<SchedulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct SchedulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<SchedulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct SchedulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<SchedulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<SchedulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SchedulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SchedulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct SchedulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ScheduleStatus defines the observed state of Schedule.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ScheduleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProvider {
    /// ARN of the SQS queue specified as the destination for the dead-letter queue.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Brief description of the schedule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the end date you specify. EventBridge Scheduler ignores the end date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endDate")]
    #[builder(default, setter(strip_option))]
    pub end_date: Option<String>,
    /// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flexibleTimeWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub flexible_time_window: Option<ScheduleStatusAtProviderFlexibleTimeWindow>,
    /// Name of the schedule group to associate with this schedule. When omitted, the default schedule group is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// Name of the schedule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// ARN for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Name of the schedule. Conflicts with name_prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Defines when the schedule runs. Read more in Schedule types on EventBridge Scheduler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpression"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression: Option<String>,
    /// Timezone in which the scheduling expression is evaluated. Defaults to UTC. Example: Australia/Sydney.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduleExpressionTimezone"
    )]
    #[builder(default, setter(strip_option))]
    pub schedule_expression_timezone: Option<String>,
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the start date you specify. EventBridge Scheduler ignores the start date for one-time schedules. Example: 2030-01-01T01:00:00Z.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startDate")]
    #[builder(default, setter(strip_option))]
    pub start_date: Option<String>,
    /// Specifies whether the schedule is enabled or disabled. One of: ENABLED (default), DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Configures the target of the schedule. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub target: Option<ScheduleStatusAtProviderTarget>,
}

/// Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderFlexibleTimeWindow {
    /// Maximum time window during which a schedule can be invoked. Ranges from 1 to 1440 minutes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumWindowInMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_window_in_minutes: Option<f64>,
    /// Determines whether the schedule is invoked within a flexible time window. One of: OFF, FLEXIBLE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Configures the target of the schedule. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTarget {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<ScheduleStatusAtProviderTargetDeadLetterConfig>,
    /// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ecsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub ecs_parameters: Option<ScheduleStatusAtProviderTargetEcsParameters>,
    /// Templated target type for the EventBridge PutEvents API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "eventbridgeParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub eventbridge_parameters: Option<ScheduleStatusAtProviderTargetEventbridgeParameters>,
    /// Text, or well-formed JSON, passed to the target. Read more in Universal target.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub input: Option<String>,
    /// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kinesisParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub kinesis_parameters: Option<ScheduleStatusAtProviderTargetKinesisParameters>,
    /// Information about the retry policy settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<ScheduleStatusAtProviderTargetRetryPolicy>,
    /// ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in Set up the execution role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default, setter(strip_option))]
    pub role_arn: Option<String>,
    /// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sagemakerPipelineParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sagemaker_pipeline_parameters:
        Option<ScheduleStatusAtProviderTargetSagemakerPipelineParameters>,
    /// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqsParameters"
    )]
    #[builder(default, setter(strip_option))]
    pub sqs_parameters: Option<ScheduleStatusAtProviderTargetSqsParameters>,
}

/// Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetDeadLetterConfig {
    /// ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
}

/// Templated target type for the Amazon ECS RunTask API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEcsParameters {
    /// Up to 6 capacity provider strategies to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProviderStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider_strategy:
        Option<Vec<ScheduleStatusAtProviderTargetEcsParametersCapacityProviderStrategy>>,
    /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableEcsManagedTags"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Specifies whether to enable the execute command functionality for the containers in this task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableExecuteCommand"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_execute_command: Option<bool>,
    /// Specifies an ECS task group for the task. At most 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub group: Option<String>,
    /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: EC2, FARGATE, EXTERNAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "launchType"
    )]
    #[builder(default, setter(strip_option))]
    pub launch_type: Option<String>,
    /// Configures the networking associated with the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub network_configuration:
        Option<ScheduleStatusAtProviderTargetEcsParametersNetworkConfiguration>,
    /// A set of up to 10 placement constraints to use for the task. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementConstraints"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_constraints:
        Option<Vec<ScheduleStatusAtProviderTargetEcsParametersPlacementConstraints>>,
    /// A set of up to 5 placement strategies. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "placementStrategy"
    )]
    #[builder(default, setter(strip_option))]
    pub placement_strategy:
        Option<Vec<ScheduleStatusAtProviderTargetEcsParametersPlacementStrategy>>,
    /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "platformVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub platform_version: Option<String>,
    /// Specifies whether to propagate the tags from the task definition to the task. One of: TASK_DEFINITION.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propagateTags"
    )]
    #[builder(default, setter(strip_option))]
    pub propagate_tags: Option<String>,
    /// Reference ID to use for the task.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "referenceId"
    )]
    #[builder(default, setter(strip_option))]
    pub reference_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// The number of tasks to create. Ranges from 1 (default) to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskCount")]
    #[builder(default, setter(strip_option))]
    pub task_count: Option<f64>,
    /// ARN of the task definition to use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "taskDefinitionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub task_definition_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEcsParametersCapacityProviderStrategy {
    /// How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from 0 (default) to 100000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_provider: Option<String>,
    /// Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from 0 to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Configures the networking associated with the task. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEcsParametersNetworkConfiguration {
    /// Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where true maps to ENABLED and false to DISABLED. You can specify true only when the launch_type is set to FARGATE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "assignPublicIp"
    )]
    #[builder(default, setter(strip_option))]
    pub assign_public_ip: Option<bool>,
    /// Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub subnets: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEcsParametersPlacementConstraints {
    /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expression: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEcsParametersPlacementStrategy {
    /// The field to apply the placement strategy against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub field: Option<String>,
    /// The type of placement strategy. One of: random, spread, binpack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Templated target type for the EventBridge PutEvents API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetEventbridgeParameters {
    /// Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "detailType"
    )]
    #[builder(default, setter(strip_option))]
    pub detail_type: Option<String>,
    /// Source of the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub source: Option<String>,
}

/// Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetKinesisParameters {
    /// Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionKey"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_key: Option<String>,
}

/// Information about the retry policy settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetRetryPolicy {
    /// Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from 60 to 86400 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumEventAgeInSeconds"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_event_age_in_seconds: Option<f64>,
    /// Maximum number of retry attempts to make before the request fails. Ranges from 0 to 185 (default).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maximumRetryAttempts"
    )]
    #[builder(default, setter(strip_option))]
    pub maximum_retry_attempts: Option<f64>,
}

/// Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetSagemakerPipelineParameters {
    /// Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pipelineParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub pipeline_parameter:
        Option<Vec<ScheduleStatusAtProviderTargetSagemakerPipelineParametersPipelineParameter>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetSagemakerPipelineParametersPipelineParameter {
    /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ScheduleStatusAtProviderTargetSqsParameters {
    /// FIFO message group ID to use as the target.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "messageGroupId"
    )]
    #[builder(default, setter(strip_option))]
    pub message_group_id: Option<String>,
}
