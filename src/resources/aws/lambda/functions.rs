// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// FunctionSpec defines the desired state of Function
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "lambda.aws.upbound.io",
    version = "v1beta2",
    kind = "Function",
    plural = "functions"
)]
#[kube(status = "FunctionStatus")]
pub struct FunctionSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<FunctionDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: FunctionForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<FunctionInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<FunctionProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<FunctionPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<FunctionWriteConnectionSecretToRef>,
}

/// FunctionSpec defines the desired state of Function
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProvider {
    /// Instruction set architecture for your Lambda function. Valid values are ["x86_64"] and ["arm64"]. Default is ["x86_64"]. Removing this attribute, function's architecture stay the same.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub architectures: Option<Vec<String>>,
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeSigningConfigArn"
    )]
    #[builder(default, setter(strip_option))]
    pub code_signing_config_arn: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<FunctionForProviderDeadLetterConfig>,
    /// Description of what your Lambda Function does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub environment: Option<FunctionForProviderEnvironment>,
    /// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ephemeralStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub ephemeral_storage: Option<FunctionForProviderEphemeralStorage>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fileSystemConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub file_system_config: Option<FunctionForProviderFileSystemConfig>,
    /// Function entrypoint in your code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub handler: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub image_config: Option<FunctionForProviderImageConfig>,
    /// ECR image URI containing the function's deployment package. Exactly one of filename, image_uri,  or s3_bucket must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageUri")]
    #[builder(default, setter(strip_option))]
    pub image_uri: Option<String>,
    /// Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. To fix the perpetual difference, remove this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_ref: Option<FunctionForProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_selector: Option<FunctionForProviderKmsKeyArnSelector>,
    /// List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function. See Lambda Layers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub layers: Option<Vec<String>>,
    /// References to LayerVersion in lambda to populate layers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "layersRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub layers_refs: Option<Vec<FunctionForProviderLayersRefs>>,
    /// Selector for a list of LayerVersion in lambda to populate layers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "layersSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub layers_selector: Option<FunctionForProviderLayersSelector>,
    /// Configuration block used to specify advanced logging settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_config: Option<FunctionForProviderLoggingConfig>,
    /// Amount of memory in MB your Lambda Function can use at runtime. Defaults to 128. See Limits
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_size: Option<f64>,
    /// Lambda deployment package type. Valid values are Zip and Image. Defaults to Zip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "packageType"
    )]
    #[builder(default, setter(strip_option))]
    pub package_type: Option<String>,
    /// Whether to publish creation/change as new Lambda Function Version. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub publish: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Whether to replace the security groups on the function's VPC configuration prior to destruction.
    /// Removing these security group associations prior to function destruction can speed up security group deletion times of AWS's internal cleanup operations.
    /// By default, the security groups will be replaced with the default security group in the function's configured VPC.
    /// Set the replacement_security_group_ids attribute to use a custom list of security groups for replacement.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replaceSecurityGroupsOnDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub replace_security_groups_on_destroy: Option<bool>,
    /// References to SecurityGroup in ec2 to populate replacementSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_id_refs:
        Option<Vec<FunctionForProviderReplacementSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_id_selector:
        Option<FunctionForProviderReplacementSecurityGroupIdSelector>,
    /// List of security group IDs to assign to the function's VPC configuration prior to destruction.
    /// replace_security_groups_on_destroy must be set to true to use this attribute.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_ids: Option<Vec<String>>,
    /// Amount of reserved concurrent executions for this lambda function. A value of 0 disables lambda from being triggered and -1 removes any concurrency limitations. Defaults to Unreserved Concurrency Limits -1. See Managing Concurrency
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reservedConcurrentExecutions"
    )]
    #[builder(default, setter(strip_option))]
    pub reserved_concurrent_executions: Option<f64>,
    /// Amazon Resource Name (ARN) of the function's execution role. The role provides the function's identity and access to AWS services and resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// Reference to a Role in iam to populate role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleRef")]
    #[builder(default, setter(strip_option))]
    pub role_ref: Option<FunctionForProviderRoleRef>,
    /// Selector for a Role in iam to populate role.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_selector: Option<FunctionForProviderRoleSelector>,
    /// Identifier of the function's runtime. See Runtimes for valid values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub runtime: Option<String>,
    /// S3 bucket location containing the function's deployment package. This bucket must reside in the same AWS region where you are creating the Lambda function. Exactly one of filename, image_uri, or s3_bucket must be specified. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default, setter(strip_option))]
    pub s3_bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate s3Bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketRef"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_ref: Option<FunctionForProviderS3BucketRef>,
    /// Selector for a Bucket in s3 to populate s3Bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_selector: Option<FunctionForProviderS3BucketSelector>,
    /// S3 key of an object containing the function's deployment package. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Key")]
    #[builder(default, setter(strip_option))]
    pub s3_key: Option<String>,
    /// Object version containing the function's deployment package. Conflicts with filename and image_uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_version: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_destroy: Option<bool>,
    /// Snap start settings block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapStart")]
    #[builder(default, setter(strip_option))]
    pub snap_start: Option<FunctionForProviderSnapStart>,
    /// Used to trigger updates. Must be set to a base64 encoded SHA256 hash of the package file specified with either filename or s3_key. If you have specified this field manually, it should be the actual (computed) hash of the underlying lambda function specified in the filename, image_uri, s3_bucket fields.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceCodeHash"
    )]
    #[builder(default, setter(strip_option))]
    pub source_code_hash: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Amount of time your Lambda Function has to run in seconds. Defaults to 3. See Limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<f64>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tracingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub tracing_config: Option<FunctionForProviderTracingConfig>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default, setter(strip_option))]
    pub vpc_config: Option<FunctionForProviderVpcConfig>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderDeadLetterConfig {
    /// ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the sns:Publish or sqs:SendMessage action on this ARN, depending on which service is targeted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    #[builder(default, setter(strip_option))]
    pub target_arn: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderEnvironment {
    /// Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub variables: Option<BTreeMap<String, String>>,
}

/// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderEphemeralStorage {
    /// The size of the Lambda function Ephemeral storage(/tmp) represented in MB. The minimum supported ephemeral_storage value defaults to 512MB and the maximum supported value is 10240MB.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub size: Option<f64>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderFileSystemConfig {
    /// Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a AccessPoint in efs to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<FunctionForProviderFileSystemConfigArnRef>,
    /// Selector for a AccessPoint in efs to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<FunctionForProviderFileSystemConfigArnSelector>,
    /// Path where the function can access the file system, starting with /mnt/.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localMountPath"
    )]
    #[builder(default, setter(strip_option))]
    pub local_mount_path: Option<String>,
}

/// Reference to a AccessPoint in efs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderFileSystemConfigArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderFileSystemConfigArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderFileSystemConfigArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderFileSystemConfigArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderFileSystemConfigArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderFileSystemConfigArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderFileSystemConfigArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a AccessPoint in efs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderFileSystemConfigArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderFileSystemConfigArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderFileSystemConfigArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderFileSystemConfigArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderFileSystemConfigArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderFileSystemConfigArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderFileSystemConfigArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderImageConfig {
    /// Parameters that you want to pass in with entry_point.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub command: Option<Vec<String>>,
    /// Entry point to your application, which is typically the location of the runtime executable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "entryPoint"
    )]
    #[builder(default, setter(strip_option))]
    pub entry_point: Option<Vec<String>>,
    /// Working directory.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workingDirectory"
    )]
    #[builder(default, setter(strip_option))]
    pub working_directory: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderLayersRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderLayersRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderLayersRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderLayersRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderLayersRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderLayersRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderLayersRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of LayerVersion in lambda to populate layers.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderLayersSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderLayersSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderLayersSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderLayersSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderLayersSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderLayersSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderLayersSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block used to specify advanced logging settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderLoggingConfig {
    /// for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub application_log_level: Option<String>,
    /// select between Text and structured JSON format for your function's logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// the CloudWatch log group your function sends logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
    /// for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as ERROR, DEBUG, or INFO.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "systemLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub system_log_level: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderReplacementSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderReplacementSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderReplacementSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderReplacementSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderReplacementSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderReplacementSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderReplacementSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderReplacementSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderReplacementSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderReplacementSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderReplacementSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderReplacementSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderReplacementSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderReplacementSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Bucket in s3 to populate s3Bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate s3Bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Snap start settings block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderSnapStart {
    /// Conditions where snap start is enabled. Valid values are PublishedVersions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyOn")]
    #[builder(default, setter(strip_option))]
    pub apply_on: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderTracingConfig {
    /// Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are PassThrough and Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfig {
    /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AllowedForDualStack"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_allowed_for_dual_stack: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<FunctionForProviderVpcConfigSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<FunctionForProviderVpcConfigSecurityGroupIdSelector>,
    /// List of security group IDs associated with the Lambda function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<FunctionForProviderVpcConfigSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<FunctionForProviderVpcConfigSubnetIdSelector>,
    /// List of subnet IDs associated with the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderVpcConfigSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderVpcConfigSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderVpcConfigSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderVpcConfigSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderVpcConfigSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderVpcConfigSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionForProviderVpcConfigSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionForProviderVpcConfigSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionForProviderVpcConfigSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionForProviderVpcConfigSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderVpcConfigSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProvider {
    /// Instruction set architecture for your Lambda function. Valid values are ["x86_64"] and ["arm64"]. Default is ["x86_64"]. Removing this attribute, function's architecture stay the same.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub architectures: Option<Vec<String>>,
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeSigningConfigArn"
    )]
    #[builder(default, setter(strip_option))]
    pub code_signing_config_arn: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<FunctionInitProviderDeadLetterConfig>,
    /// Description of what your Lambda Function does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub environment: Option<FunctionInitProviderEnvironment>,
    /// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ephemeralStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub ephemeral_storage: Option<FunctionInitProviderEphemeralStorage>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fileSystemConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub file_system_config: Option<FunctionInitProviderFileSystemConfig>,
    /// Function entrypoint in your code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub handler: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub image_config: Option<FunctionInitProviderImageConfig>,
    /// ECR image URI containing the function's deployment package. Exactly one of filename, image_uri,  or s3_bucket must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageUri")]
    #[builder(default, setter(strip_option))]
    pub image_uri: Option<String>,
    /// Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. To fix the perpetual difference, remove this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_ref: Option<FunctionInitProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyArnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn_selector: Option<FunctionInitProviderKmsKeyArnSelector>,
    /// List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function. See Lambda Layers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub layers: Option<Vec<String>>,
    /// References to LayerVersion in lambda to populate layers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "layersRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub layers_refs: Option<Vec<FunctionInitProviderLayersRefs>>,
    /// Selector for a list of LayerVersion in lambda to populate layers.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "layersSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub layers_selector: Option<FunctionInitProviderLayersSelector>,
    /// Configuration block used to specify advanced logging settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_config: Option<FunctionInitProviderLoggingConfig>,
    /// Amount of memory in MB your Lambda Function can use at runtime. Defaults to 128. See Limits
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_size: Option<f64>,
    /// Lambda deployment package type. Valid values are Zip and Image. Defaults to Zip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "packageType"
    )]
    #[builder(default, setter(strip_option))]
    pub package_type: Option<String>,
    /// Whether to publish creation/change as new Lambda Function Version. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub publish: Option<bool>,
    /// Whether to replace the security groups on the function's VPC configuration prior to destruction.
    /// Removing these security group associations prior to function destruction can speed up security group deletion times of AWS's internal cleanup operations.
    /// By default, the security groups will be replaced with the default security group in the function's configured VPC.
    /// Set the replacement_security_group_ids attribute to use a custom list of security groups for replacement.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replaceSecurityGroupsOnDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub replace_security_groups_on_destroy: Option<bool>,
    /// References to SecurityGroup in ec2 to populate replacementSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_id_refs:
        Option<Vec<FunctionInitProviderReplacementSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_id_selector:
        Option<FunctionInitProviderReplacementSecurityGroupIdSelector>,
    /// List of security group IDs to assign to the function's VPC configuration prior to destruction.
    /// replace_security_groups_on_destroy must be set to true to use this attribute.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_ids: Option<Vec<String>>,
    /// Amount of reserved concurrent executions for this lambda function. A value of 0 disables lambda from being triggered and -1 removes any concurrency limitations. Defaults to Unreserved Concurrency Limits -1. See Managing Concurrency
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reservedConcurrentExecutions"
    )]
    #[builder(default, setter(strip_option))]
    pub reserved_concurrent_executions: Option<f64>,
    /// Amazon Resource Name (ARN) of the function's execution role. The role provides the function's identity and access to AWS services and resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// Reference to a Role in iam to populate role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleRef")]
    #[builder(default, setter(strip_option))]
    pub role_ref: Option<FunctionInitProviderRoleRef>,
    /// Selector for a Role in iam to populate role.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub role_selector: Option<FunctionInitProviderRoleSelector>,
    /// Identifier of the function's runtime. See Runtimes for valid values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub runtime: Option<String>,
    /// S3 bucket location containing the function's deployment package. This bucket must reside in the same AWS region where you are creating the Lambda function. Exactly one of filename, image_uri, or s3_bucket must be specified. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default, setter(strip_option))]
    pub s3_bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate s3Bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketRef"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_ref: Option<FunctionInitProviderS3BucketRef>,
    /// Selector for a Bucket in s3 to populate s3Bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3BucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_bucket_selector: Option<FunctionInitProviderS3BucketSelector>,
    /// S3 key of an object containing the function's deployment package. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Key")]
    #[builder(default, setter(strip_option))]
    pub s3_key: Option<String>,
    /// Object version containing the function's deployment package. Conflicts with filename and image_uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_version: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_destroy: Option<bool>,
    /// Snap start settings block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapStart")]
    #[builder(default, setter(strip_option))]
    pub snap_start: Option<FunctionInitProviderSnapStart>,
    /// Used to trigger updates. Must be set to a base64 encoded SHA256 hash of the package file specified with either filename or s3_key. If you have specified this field manually, it should be the actual (computed) hash of the underlying lambda function specified in the filename, image_uri, s3_bucket fields.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceCodeHash"
    )]
    #[builder(default, setter(strip_option))]
    pub source_code_hash: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Amount of time your Lambda Function has to run in seconds. Defaults to 3. See Limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<f64>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tracingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub tracing_config: Option<FunctionInitProviderTracingConfig>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default, setter(strip_option))]
    pub vpc_config: Option<FunctionInitProviderVpcConfig>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderDeadLetterConfig {
    /// ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the sns:Publish or sqs:SendMessage action on this ARN, depending on which service is targeted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    #[builder(default, setter(strip_option))]
    pub target_arn: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderEnvironment {
    /// Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub variables: Option<BTreeMap<String, String>>,
}

/// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderEphemeralStorage {
    /// The size of the Lambda function Ephemeral storage(/tmp) represented in MB. The minimum supported ephemeral_storage value defaults to 512MB and the maximum supported value is 10240MB.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub size: Option<f64>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderFileSystemConfig {
    /// Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a AccessPoint in efs to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<FunctionInitProviderFileSystemConfigArnRef>,
    /// Selector for a AccessPoint in efs to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<FunctionInitProviderFileSystemConfigArnSelector>,
    /// Path where the function can access the file system, starting with /mnt/.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localMountPath"
    )]
    #[builder(default, setter(strip_option))]
    pub local_mount_path: Option<String>,
}

/// Reference to a AccessPoint in efs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderFileSystemConfigArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderFileSystemConfigArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderFileSystemConfigArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderFileSystemConfigArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderFileSystemConfigArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderFileSystemConfigArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderFileSystemConfigArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a AccessPoint in efs to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderFileSystemConfigArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderFileSystemConfigArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderFileSystemConfigArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderFileSystemConfigArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderFileSystemConfigArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderFileSystemConfigArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderFileSystemConfigArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderImageConfig {
    /// Parameters that you want to pass in with entry_point.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub command: Option<Vec<String>>,
    /// Entry point to your application, which is typically the location of the runtime executable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "entryPoint"
    )]
    #[builder(default, setter(strip_option))]
    pub entry_point: Option<Vec<String>>,
    /// Working directory.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workingDirectory"
    )]
    #[builder(default, setter(strip_option))]
    pub working_directory: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderLayersRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderLayersRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderLayersRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderLayersRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderLayersRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderLayersRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderLayersRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of LayerVersion in lambda to populate layers.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderLayersSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderLayersSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderLayersSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderLayersSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderLayersSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderLayersSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderLayersSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block used to specify advanced logging settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderLoggingConfig {
    /// for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub application_log_level: Option<String>,
    /// select between Text and structured JSON format for your function's logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// the CloudWatch log group your function sends logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
    /// for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as ERROR, DEBUG, or INFO.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "systemLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub system_log_level: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderReplacementSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderReplacementSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderReplacementSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderReplacementSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderReplacementSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderReplacementSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderReplacementSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderReplacementSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderReplacementSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderReplacementSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderReplacementSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderReplacementSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderReplacementSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderReplacementSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate role.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Bucket in s3 to populate s3Bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate s3Bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Snap start settings block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderSnapStart {
    /// Conditions where snap start is enabled. Valid values are PublishedVersions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyOn")]
    #[builder(default, setter(strip_option))]
    pub apply_on: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderTracingConfig {
    /// Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are PassThrough and Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfig {
    /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AllowedForDualStack"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_allowed_for_dual_stack: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_refs: Option<Vec<FunctionInitProviderVpcConfigSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_id_selector: Option<FunctionInitProviderVpcConfigSecurityGroupIdSelector>,
    /// List of security group IDs associated with the Lambda function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_refs: Option<Vec<FunctionInitProviderVpcConfigSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<FunctionInitProviderVpcConfigSubnetIdSelector>,
    /// List of subnet IDs associated with the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderVpcConfigSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderVpcConfigSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderVpcConfigSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionInitProviderVpcConfigSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionInitProviderVpcConfigSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionInitProviderVpcConfigSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionInitProviderVpcConfigSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderVpcConfigSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<FunctionPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<FunctionPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<FunctionPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<FunctionPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<FunctionPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// FunctionStatus defines the observed state of Function.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<FunctionStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProvider {
    /// Instruction set architecture for your Lambda function. Valid values are ["x86_64"] and ["arm64"]. Default is ["x86_64"]. Removing this attribute, function's architecture stay the same.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub architectures: Option<Vec<String>>,
    /// Amazon Resource Name (ARN) identifying your Lambda Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Base64-encoded representation of raw SHA-256 sum of the zip file.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeSha256"
    )]
    #[builder(default, setter(strip_option))]
    pub code_sha256: Option<String>,
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeSigningConfigArn"
    )]
    #[builder(default, setter(strip_option))]
    pub code_signing_config_arn: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deadLetterConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub dead_letter_config: Option<FunctionStatusAtProviderDeadLetterConfig>,
    /// Description of what your Lambda Function does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub environment: Option<FunctionStatusAtProviderEnvironment>,
    /// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ephemeralStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub ephemeral_storage: Option<FunctionStatusAtProviderEphemeralStorage>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fileSystemConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub file_system_config: Option<FunctionStatusAtProviderFileSystemConfig>,
    /// Function entrypoint in your code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub handler: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub image_config: Option<FunctionStatusAtProviderImageConfig>,
    /// ECR image URI containing the function's deployment package. Exactly one of filename, image_uri,  or s3_bucket must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageUri")]
    #[builder(default, setter(strip_option))]
    pub image_uri: Option<String>,
    /// ARN to be used for invoking Lambda Function from API Gateway - to be used in aws_api_gateway_integration's uri.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invokeArn")]
    #[builder(default, setter(strip_option))]
    pub invoke_arn: Option<String>,
    /// Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. To fix the perpetual difference, remove this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default, setter(strip_option))]
    pub kms_key_arn: Option<String>,
    /// Date this resource was last modified.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastModified"
    )]
    #[builder(default, setter(strip_option))]
    pub last_modified: Option<String>,
    /// List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function. See Lambda Layers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub layers: Option<Vec<String>>,
    /// Configuration block used to specify advanced logging settings. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub logging_config: Option<FunctionStatusAtProviderLoggingConfig>,
    /// Amount of memory in MB your Lambda Function can use at runtime. Defaults to 128. See Limits
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memorySize"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_size: Option<f64>,
    /// Lambda deployment package type. Valid values are Zip and Image. Defaults to Zip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "packageType"
    )]
    #[builder(default, setter(strip_option))]
    pub package_type: Option<String>,
    /// Whether to publish creation/change as new Lambda Function Version. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub publish: Option<bool>,
    /// ARN identifying your Lambda Function Version (if versioning is enabled via publish = true).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "qualifiedArn"
    )]
    #[builder(default, setter(strip_option))]
    pub qualified_arn: Option<String>,
    /// Qualified ARN (ARN with lambda version number) to be used for invoking Lambda Function from API Gateway - to be used in aws_api_gateway_integration's uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "qualifiedInvokeArn"
    )]
    #[builder(default, setter(strip_option))]
    pub qualified_invoke_arn: Option<String>,
    /// Whether to replace the security groups on the function's VPC configuration prior to destruction.
    /// Removing these security group associations prior to function destruction can speed up security group deletion times of AWS's internal cleanup operations.
    /// By default, the security groups will be replaced with the default security group in the function's configured VPC.
    /// Set the replacement_security_group_ids attribute to use a custom list of security groups for replacement.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replaceSecurityGroupsOnDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub replace_security_groups_on_destroy: Option<bool>,
    /// List of security group IDs to assign to the function's VPC configuration prior to destruction.
    /// replace_security_groups_on_destroy must be set to true to use this attribute.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replacementSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub replacement_security_group_ids: Option<Vec<String>>,
    /// Amount of reserved concurrent executions for this lambda function. A value of 0 disables lambda from being triggered and -1 removes any concurrency limitations. Defaults to Unreserved Concurrency Limits -1. See Managing Concurrency
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "reservedConcurrentExecutions"
    )]
    #[builder(default, setter(strip_option))]
    pub reserved_concurrent_executions: Option<f64>,
    /// Amazon Resource Name (ARN) of the function's execution role. The role provides the function's identity and access to AWS services and resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub role: Option<String>,
    /// Identifier of the function's runtime. See Runtimes for valid values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub runtime: Option<String>,
    /// S3 bucket location containing the function's deployment package. This bucket must reside in the same AWS region where you are creating the Lambda function. Exactly one of filename, image_uri, or s3_bucket must be specified. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default, setter(strip_option))]
    pub s3_bucket: Option<String>,
    /// S3 key of an object containing the function's deployment package. When s3_bucket is set, s3_key is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Key")]
    #[builder(default, setter(strip_option))]
    pub s3_key: Option<String>,
    /// Object version containing the function's deployment package. Conflicts with filename and image_uri.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3ObjectVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub s3_object_version: Option<String>,
    /// ARN of the signing job.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "signingJobArn"
    )]
    #[builder(default, setter(strip_option))]
    pub signing_job_arn: Option<String>,
    /// ARN of the signing profile version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "signingProfileVersionArn"
    )]
    #[builder(default, setter(strip_option))]
    pub signing_profile_version_arn: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipDestroy"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_destroy: Option<bool>,
    /// Snap start settings block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapStart")]
    #[builder(default, setter(strip_option))]
    pub snap_start: Option<FunctionStatusAtProviderSnapStart>,
    /// Used to trigger updates. Must be set to a base64 encoded SHA256 hash of the package file specified with either filename or s3_key. If you have specified this field manually, it should be the actual (computed) hash of the underlying lambda function specified in the filename, image_uri, s3_bucket fields.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceCodeHash"
    )]
    #[builder(default, setter(strip_option))]
    pub source_code_hash: Option<String>,
    /// Size in bytes of the function .zip file.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceCodeSize"
    )]
    #[builder(default, setter(strip_option))]
    pub source_code_size: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Amount of time your Lambda Function has to run in seconds. Defaults to 3. See Limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<f64>,
    /// Configuration block. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tracingConfig"
    )]
    #[builder(default, setter(strip_option))]
    pub tracing_config: Option<FunctionStatusAtProviderTracingConfig>,
    /// Latest published version of your Lambda Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub version: Option<String>,
    /// Configuration block. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default, setter(strip_option))]
    pub vpc_config: Option<FunctionStatusAtProviderVpcConfig>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderDeadLetterConfig {
    /// ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the sns:Publish or sqs:SendMessage action on this ARN, depending on which service is targeted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    #[builder(default, setter(strip_option))]
    pub target_arn: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderEnvironment {
    /// Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub variables: Option<BTreeMap<String, String>>,
}

/// The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderEphemeralStorage {
    /// The size of the Lambda function Ephemeral storage(/tmp) represented in MB. The minimum supported ephemeral_storage value defaults to 512MB and the maximum supported value is 10240MB.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub size: Option<f64>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderFileSystemConfig {
    /// Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Path where the function can access the file system, starting with /mnt/.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localMountPath"
    )]
    #[builder(default, setter(strip_option))]
    pub local_mount_path: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderImageConfig {
    /// Parameters that you want to pass in with entry_point.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub command: Option<Vec<String>>,
    /// Entry point to your application, which is typically the location of the runtime executable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "entryPoint"
    )]
    #[builder(default, setter(strip_option))]
    pub entry_point: Option<Vec<String>>,
    /// Working directory.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workingDirectory"
    )]
    #[builder(default, setter(strip_option))]
    pub working_directory: Option<String>,
}

/// Configuration block used to specify advanced logging settings. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderLoggingConfig {
    /// for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub application_log_level: Option<String>,
    /// select between Text and structured JSON format for your function's logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default, setter(strip_option))]
    pub log_format: Option<String>,
    /// the CloudWatch log group your function sends logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default, setter(strip_option))]
    pub log_group: Option<String>,
    /// for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as ERROR, DEBUG, or INFO.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "systemLogLevel"
    )]
    #[builder(default, setter(strip_option))]
    pub system_log_level: Option<String>,
}

/// Snap start settings block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderSnapStart {
    /// Conditions where snap start is enabled. Valid values are PublishedVersions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyOn")]
    #[builder(default, setter(strip_option))]
    pub apply_on: Option<String>,
    /// Optimization status of the snap start configuration. Valid values are On and Off.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "optimizationStatus"
    )]
    #[builder(default, setter(strip_option))]
    pub optimization_status: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderTracingConfig {
    /// Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are PassThrough and Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
}

/// Configuration block. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct FunctionStatusAtProviderVpcConfig {
    /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AllowedForDualStack"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_allowed_for_dual_stack: Option<bool>,
    /// List of security group IDs associated with the Lambda function.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// List of subnet IDs associated with the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// ID of the VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
}
