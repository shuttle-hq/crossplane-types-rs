// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// RouteSpec defines the desired state of Route
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "appmesh.aws.upbound.io",
    version = "v1beta2",
    kind = "Route",
    plural = "routes"
)]
#[kube(status = "RouteStatus")]
pub struct RouteSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<RouteDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RouteForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<RouteInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<RouteProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<RoutePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<RouteWriteConnectionSecretToRef>,
}

/// RouteSpec defines the desired state of Route
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProvider {
    /// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// Reference to a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_ref: Option<RouteForProviderMeshNameRef>,
    /// Selector for a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_selector: Option<RouteForProviderMeshNameSelector>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Route specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<RouteForProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name: Option<String>,
    /// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name_ref: Option<RouteForProviderVirtualRouterNameRef>,
    /// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name_selector: Option<RouteForProviderVirtualRouterNameSelector>,
}

/// Reference to a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderMeshNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderMeshNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderMeshNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteForProviderMeshNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteForProviderMeshNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderMeshNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderMeshNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderMeshNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderMeshNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderMeshNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteForProviderMeshNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteForProviderMeshNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderMeshNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderMeshNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Route specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpec {
    /// GRPC routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcRoute")]
    #[builder(default, setter(strip_option))]
    pub grpc_route: Option<RouteForProviderSpecGrpcRoute>,
    /// HTTP/2 routing information for the route.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "http2Route"
    )]
    #[builder(default, setter(strip_option))]
    pub http2_route: Option<RouteForProviderSpecHttp2Route>,
    /// HTTP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpRoute")]
    #[builder(default, setter(strip_option))]
    pub http_route: Option<RouteForProviderSpecHttpRoute>,
    /// Priority for the route, between 0 and 1000.
    /// Routes are matched based on the specified value, where 0 is the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// TCP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpRoute")]
    #[builder(default, setter(strip_option))]
    pub tcp_route: Option<RouteForProviderSpecTcpRoute>,
}

/// GRPC routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteForProviderSpecGrpcRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecGrpcRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteForProviderSpecGrpcRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteForProviderSpecGrpcRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteForProviderSpecGrpcRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteMatch {
    /// Data to match from the gRPC request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<Vec<RouteForProviderSpecGrpcRouteMatchMetadata>>,
    /// Method name to match from the request. If you specify a name, you must also specify a service_name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "methodName"
    )]
    #[builder(default, setter(strip_option))]
    pub method_name: Option<String>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Fully qualified domain name for the service to match from the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteMatchMetadata {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecGrpcRouteMatchMetadataMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteMatchMetadataMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteForProviderSpecGrpcRouteMatchMetadataMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteMatchMetadataMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteRetryPolicy {
    /// List of gRPC retry events.
    /// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grpcRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub grpc_retry_events: Option<Vec<String>>,
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteForProviderSpecGrpcRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteForProviderSpecGrpcRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecGrpcRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP/2 routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2Route {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteForProviderSpecHttp2RouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttp2RouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteForProviderSpecHttp2RouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteForProviderSpecHttp2RouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteForProviderSpecHttp2RouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteForProviderSpecHttp2RouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteForProviderSpecHttp2RouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteForProviderSpecHttp2RouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttp2RouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteForProviderSpecHttp2RouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttp2RouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteForProviderSpecHttp2RouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteForProviderSpecHttp2RouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttp2RouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteForProviderSpecHttpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttpRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteForProviderSpecHttpRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteForProviderSpecHttpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteForProviderSpecHttpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Reference to a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_ref: Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef>,
    /// Selector for a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_selector:
        Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteForProviderSpecHttpRouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteForProviderSpecHttpRouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteForProviderSpecHttpRouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttpRouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteForProviderSpecHttpRouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecHttpRouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteForProviderSpecHttpRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteForProviderSpecHttpRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteForProviderSpecHttpRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecHttpRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// TCP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteForProviderSpecTcpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteForProviderSpecTcpRouteMatch>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteForProviderSpecTcpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteForProviderSpecTcpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Reference to a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_ref: Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef>,
    /// Selector for a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_selector:
        Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteMatch {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteForProviderSpecTcpRouteTimeoutIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderSpecTcpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderVirtualRouterNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderVirtualRouterNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderVirtualRouterNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteForProviderVirtualRouterNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteForProviderVirtualRouterNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVirtualRouterNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVirtualRouterNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderVirtualRouterNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteForProviderVirtualRouterNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteForProviderVirtualRouterNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteForProviderVirtualRouterNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteForProviderVirtualRouterNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVirtualRouterNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVirtualRouterNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProvider {
    /// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// Reference to a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_ref: Option<RouteInitProviderMeshNameRef>,
    /// Selector for a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_selector: Option<RouteInitProviderMeshNameSelector>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Route specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<RouteInitProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name: Option<String>,
    /// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name_ref: Option<RouteInitProviderVirtualRouterNameRef>,
    /// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name_selector: Option<RouteInitProviderVirtualRouterNameSelector>,
}

/// Reference to a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderMeshNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderMeshNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderMeshNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteInitProviderMeshNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteInitProviderMeshNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderMeshNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderMeshNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderMeshNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderMeshNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderMeshNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteInitProviderMeshNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteInitProviderMeshNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderMeshNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderMeshNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Route specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpec {
    /// GRPC routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcRoute")]
    #[builder(default, setter(strip_option))]
    pub grpc_route: Option<RouteInitProviderSpecGrpcRoute>,
    /// HTTP/2 routing information for the route.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "http2Route"
    )]
    #[builder(default, setter(strip_option))]
    pub http2_route: Option<RouteInitProviderSpecHttp2Route>,
    /// HTTP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpRoute")]
    #[builder(default, setter(strip_option))]
    pub http_route: Option<RouteInitProviderSpecHttpRoute>,
    /// Priority for the route, between 0 and 1000.
    /// Routes are matched based on the specified value, where 0 is the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// TCP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpRoute")]
    #[builder(default, setter(strip_option))]
    pub tcp_route: Option<RouteInitProviderSpecTcpRoute>,
}

/// GRPC routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteInitProviderSpecGrpcRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecGrpcRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteInitProviderSpecGrpcRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteInitProviderSpecGrpcRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteInitProviderSpecGrpcRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteMatch {
    /// Data to match from the gRPC request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<Vec<RouteInitProviderSpecGrpcRouteMatchMetadata>>,
    /// Method name to match from the request. If you specify a name, you must also specify a service_name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "methodName"
    )]
    #[builder(default, setter(strip_option))]
    pub method_name: Option<String>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Fully qualified domain name for the service to match from the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteMatchMetadata {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecGrpcRouteMatchMetadataMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteMatchMetadataMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteInitProviderSpecGrpcRouteMatchMetadataMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteMatchMetadataMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteRetryPolicy {
    /// List of gRPC retry events.
    /// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grpcRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub grpc_retry_events: Option<Vec<String>>,
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteInitProviderSpecGrpcRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteInitProviderSpecGrpcRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecGrpcRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP/2 routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2Route {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteInitProviderSpecHttp2RouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttp2RouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteInitProviderSpecHttp2RouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteInitProviderSpecHttp2RouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteInitProviderSpecHttp2RouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteInitProviderSpecHttp2RouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteInitProviderSpecHttp2RouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteInitProviderSpecHttp2RouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttp2RouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteInitProviderSpecHttp2RouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttp2RouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteInitProviderSpecHttp2RouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteInitProviderSpecHttp2RouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttp2RouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteInitProviderSpecHttpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttpRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteInitProviderSpecHttpRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteInitProviderSpecHttpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteInitProviderSpecHttpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Reference to a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_ref: Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef>,
    /// Selector for a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_selector:
        Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteInitProviderSpecHttpRouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteInitProviderSpecHttpRouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteInitProviderSpecHttpRouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttpRouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteInitProviderSpecHttpRouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecHttpRouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteInitProviderSpecHttpRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteInitProviderSpecHttpRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecHttpRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// TCP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteInitProviderSpecTcpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteInitProviderSpecTcpRouteMatch>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteInitProviderSpecTcpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteInitProviderSpecTcpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Reference to a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeRef"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_ref: Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef>,
    /// Selector for a VirtualNode in appmesh to populate virtualNode.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNodeSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node_selector:
        Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Reference to a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualNode in appmesh to populate virtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteMatch {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteInitProviderSpecTcpRouteTimeoutIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderSpecTcpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderVirtualRouterNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderVirtualRouterNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderVirtualRouterNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteInitProviderVirtualRouterNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteInitProviderVirtualRouterNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVirtualRouterNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVirtualRouterNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderVirtualRouterNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteInitProviderVirtualRouterNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteInitProviderVirtualRouterNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteInitProviderVirtualRouterNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteInitProviderVirtualRouterNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVirtualRouterNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVirtualRouterNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RouteProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RouteProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RouteProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RoutePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<RoutePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<RoutePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RoutePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<RoutePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RoutePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<RoutePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<RoutePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RoutePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RouteStatus defines the observed state of Route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<RouteStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProvider {
    /// ARN of the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Creation date of the route.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createdDate"
    )]
    #[builder(default, setter(strip_option))]
    pub created_date: Option<String>,
    /// ID of the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Last update date of the route.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastUpdatedDate"
    )]
    #[builder(default, setter(strip_option))]
    pub last_updated_date: Option<String>,
    /// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Resource owner's AWS account ID.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_owner: Option<String>,
    /// Route specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<RouteStatusAtProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualRouterName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_router_name: Option<String>,
}

/// Route specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpec {
    /// GRPC routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcRoute")]
    #[builder(default, setter(strip_option))]
    pub grpc_route: Option<RouteStatusAtProviderSpecGrpcRoute>,
    /// HTTP/2 routing information for the route.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "http2Route"
    )]
    #[builder(default, setter(strip_option))]
    pub http2_route: Option<RouteStatusAtProviderSpecHttp2Route>,
    /// HTTP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpRoute")]
    #[builder(default, setter(strip_option))]
    pub http_route: Option<RouteStatusAtProviderSpecHttpRoute>,
    /// Priority for the route, between 0 and 1000.
    /// Routes are matched based on the specified value, where 0 is the highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub priority: Option<f64>,
    /// TCP routing information for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpRoute")]
    #[builder(default, setter(strip_option))]
    pub tcp_route: Option<RouteStatusAtProviderSpecTcpRoute>,
}

/// GRPC routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteStatusAtProviderSpecGrpcRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecGrpcRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteStatusAtProviderSpecGrpcRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteStatusAtProviderSpecGrpcRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteStatusAtProviderSpecGrpcRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteMatch {
    /// Data to match from the gRPC request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<Vec<RouteStatusAtProviderSpecGrpcRouteMatchMetadata>>,
    /// Method name to match from the request. If you specify a name, you must also specify a service_name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "methodName"
    )]
    #[builder(default, setter(strip_option))]
    pub method_name: Option<String>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Fully qualified domain name for the service to match from the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteMatchMetadata {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecGrpcRouteMatchMetadataMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteMatchMetadataMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteStatusAtProviderSpecGrpcRouteMatchMetadataMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteMatchMetadataMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteRetryPolicy {
    /// List of gRPC retry events.
    /// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "grpcRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub grpc_retry_events: Option<Vec<String>>,
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteStatusAtProviderSpecGrpcRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteStatusAtProviderSpecGrpcRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteStatusAtProviderSpecGrpcRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecGrpcRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP/2 routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2Route {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteStatusAtProviderSpecHttp2RouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttp2RouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteStatusAtProviderSpecHttp2RouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteStatusAtProviderSpecHttp2RouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteStatusAtProviderSpecHttp2RouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteStatusAtProviderSpecHttp2RouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteStatusAtProviderSpecHttp2RouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteStatusAtProviderSpecHttp2RouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttp2RouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteStatusAtProviderSpecHttp2RouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttp2RouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteStatusAtProviderSpecHttp2RouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteStatusAtProviderSpecHttp2RouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteStatusAtProviderSpecHttp2RouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttp2RouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// HTTP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteStatusAtProviderSpecHttpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttpRouteMatch>,
    /// Retry policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retryPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub retry_policy: Option<RouteStatusAtProviderSpecHttpRouteRetryPolicy>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteStatusAtProviderSpecHttpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteStatusAtProviderSpecHttpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatch {
    /// Client request headers to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub header: Option<Vec<RouteStatusAtProviderSpecHttpRouteMatchHeader>>,
    /// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub method: Option<String>,
    /// Client request path to match on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<RouteStatusAtProviderSpecHttpRouteMatchPath>,
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Client request query parameters to match on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "queryParameter"
    )]
    #[builder(default, setter(strip_option))]
    pub query_parameter: Option<Vec<RouteStatusAtProviderSpecHttpRouteMatchQueryParameter>>,
    /// Client request header scheme to match on. Valid values: http, https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchHeader {
    /// If true, the match is on the opposite of the match criteria. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub invert: Option<bool>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttpRouteMatchHeaderMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchHeaderMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Object that specifies the range of numbers that the value sent by the client must be included in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub range: Option<RouteStatusAtProviderSpecHttpRouteMatchHeaderMatchRange>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
    /// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub suffix: Option<String>,
}

/// Object that specifies the range of numbers that the value sent by the client must be included in.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchHeaderMatchRange {
    /// End of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub end: Option<f64>,
    /// (Requited) Start of the range.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub start: Option<f64>,
}

/// Client request path to match on.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchPath {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
    /// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchQueryParameter {
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecHttpRouteMatchQueryParameterMatch>,
    /// Name to use for the route. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteMatchQueryParameterMatch {
    /// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<String>,
}

/// Retry policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteRetryPolicy {
    /// List of HTTP retry events.
    /// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub http_retry_events: Option<Vec<String>>,
    /// Maximum number of retries.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    #[builder(default, setter(strip_option))]
    pub max_retries: Option<f64>,
    /// Per-retry timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRetryTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub per_retry_timeout: Option<RouteStatusAtProviderSpecHttpRouteRetryPolicyPerRetryTimeout>,
    /// List of TCP retry events. The only valid value is connection-error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpRetryEvents"
    )]
    #[builder(default, setter(strip_option))]
    pub tcp_retry_events: Option<Vec<String>>,
}

/// Per-retry timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteRetryPolicyPerRetryTimeout {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteStatusAtProviderSpecHttpRouteTimeoutIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<RouteStatusAtProviderSpecHttpRouteTimeoutPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecHttpRouteTimeoutPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// TCP routing information for the route.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRoute {
    /// Action to take if a match is determined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub action: Option<RouteStatusAtProviderSpecTcpRouteAction>,
    /// Criteria for determining an gRPC request match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<RouteStatusAtProviderSpecTcpRouteMatch>,
    /// Types of timeouts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<RouteStatusAtProviderSpecTcpRouteTimeout>,
}

/// Action to take if a match is determined.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRouteAction {
    /// Targets that traffic is routed to when a request matches the route.
    /// You can specify one or more targets and their relative weights with which to distribute traffic.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "weightedTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub weighted_target: Option<Vec<RouteStatusAtProviderSpecTcpRouteActionWeightedTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRouteActionWeightedTarget {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualNode"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_node: Option<String>,
    /// Relative weight of the weighted target. An integer between 0 and 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub weight: Option<f64>,
}

/// Criteria for determining an gRPC request match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRouteMatch {
    /// The port number to match from the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
}

/// Types of timeouts.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRouteTimeout {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<RouteStatusAtProviderSpecTcpRouteTimeoutIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct RouteStatusAtProviderSpecTcpRouteTimeoutIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// Number of time units. Minimum value of 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}
