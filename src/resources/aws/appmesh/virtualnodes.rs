// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// VirtualNodeSpec defines the desired state of VirtualNode
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "appmesh.aws.upbound.io",
    version = "v1beta2",
    kind = "VirtualNode",
    plural = "virtualnodes"
)]
#[kube(status = "VirtualNodeStatus")]
pub struct VirtualNodeSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<VirtualNodeDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: VirtualNodeForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<VirtualNodeInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<VirtualNodeProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<VirtualNodePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<VirtualNodeWriteConnectionSecretToRef>,
}

/// VirtualNodeSpec defines the desired state of VirtualNode
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProvider {
    /// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// Reference to a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_ref: Option<VirtualNodeForProviderMeshNameRef>,
    /// Selector for a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_selector: Option<VirtualNodeForProviderMeshNameSelector>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Virtual node specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<VirtualNodeForProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Reference to a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderMeshNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeForProviderMeshNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderMeshNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodeForProviderMeshNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodeForProviderMeshNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderMeshNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderMeshNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderMeshNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeForProviderMeshNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderMeshNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodeForProviderMeshNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodeForProviderMeshNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderMeshNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderMeshNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Virtual node specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpec {
    /// Backends to which the virtual node is expected to send outbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub backend: Option<Vec<VirtualNodeForProviderSpecBackend>>,
    /// Defaults for backends.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backendDefaults"
    )]
    #[builder(default, setter(strip_option))]
    pub backend_defaults: Option<VirtualNodeForProviderSpecBackendDefaults>,
    /// Listeners from which the virtual node is expected to receive inbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub listener: Option<Vec<VirtualNodeForProviderSpecListener>>,
    /// Inbound and outbound access logging information for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logging: Option<VirtualNodeForProviderSpecLogging>,
    /// Service discovery information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub service_discovery: Option<VirtualNodeForProviderSpecServiceDiscovery>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackend {
    /// Virtual service to use as a backend for a virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualService"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service: Option<VirtualNodeForProviderSpecBackendVirtualService>,
}

/// Virtual service to use as a backend for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualService {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicy>,
    /// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualServiceName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service_name: Option<String>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate:
        Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation:
        Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAlternativeNames")]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm:
        Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file:
        Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds:
        Option<VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Defaults for backends.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaults {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicy>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAlternativeNames"
    )]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<
        VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames,
    >,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListener {
    /// Connection pool information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionPool"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_pool: Option<VirtualNodeForProviderSpecListenerConnectionPool>,
    /// Health check information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthCheck"
    )]
    #[builder(default, setter(strip_option))]
    pub health_check: Option<VirtualNodeForProviderSpecListenerHealthCheck>,
    /// Outlier detection information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outlierDetection"
    )]
    #[builder(default, setter(strip_option))]
    pub outlier_detection: Option<VirtualNodeForProviderSpecListenerOutlierDetection>,
    /// Port mapping information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "portMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub port_mapping: Option<VirtualNodeForProviderSpecListenerPortMapping>,
    /// Timeouts for different protocols.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<VirtualNodeForProviderSpecListenerTimeout>,
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeForProviderSpecListenerTls>,
}

/// Connection pool information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerConnectionPool {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeForProviderSpecListenerConnectionPoolGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<Vec<VirtualNodeForProviderSpecListenerConnectionPoolHttp>>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<Vec<VirtualNodeForProviderSpecListenerConnectionPoolHttp2>>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<Vec<VirtualNodeForProviderSpecListenerConnectionPoolTcp>>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerConnectionPoolGrpc {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerConnectionPoolHttp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
    /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxPendingRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_pending_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerConnectionPoolHttp2 {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerConnectionPoolTcp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
}

/// Health check information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerHealthCheck {
    /// Number of consecutive successful health checks that must occur before declaring listener healthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub healthy_threshold: Option<f64>,
    /// Time period in milliseconds between each health check execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "intervalMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub interval_millis: Option<f64>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// Amount of time to wait when receiving a response from the health check, in milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_millis: Option<f64>,
    /// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "unhealthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub unhealthy_threshold: Option<f64>,
}

/// Outlier detection information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerOutlierDetection {
    /// Base amount of time for which a host is ejected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baseEjectionDuration"
    )]
    #[builder(default, setter(strip_option))]
    pub base_ejection_duration:
        Option<VirtualNodeForProviderSpecListenerOutlierDetectionBaseEjectionDuration>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub interval: Option<VirtualNodeForProviderSpecListenerOutlierDetectionInterval>,
    /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
    /// Minimum value of 0. Maximum value of 100.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxEjectionPercent"
    )]
    #[builder(default, setter(strip_option))]
    pub max_ejection_percent: Option<f64>,
    /// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxServerErrors"
    )]
    #[builder(default, setter(strip_option))]
    pub max_server_errors: Option<f64>,
}

/// Base amount of time for which a host is ejected.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerOutlierDetectionBaseEjectionDuration {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Time interval between ejection sweep analysis.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerOutlierDetectionInterval {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Port mapping information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerPortMapping {
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
}

/// Timeouts for different protocols.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeout {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeForProviderSpecListenerTimeoutGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<VirtualNodeForProviderSpecListenerTimeoutHttp>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<VirtualNodeForProviderSpecListenerTimeoutHttp2>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<VirtualNodeForProviderSpecListenerTimeoutTcp>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutGrpc {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeForProviderSpecListenerTimeoutGrpcIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeForProviderSpecListenerTimeoutGrpcPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutGrpcIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutGrpcPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeForProviderSpecListenerTimeoutHttpIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeForProviderSpecListenerTimeoutHttpPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttpPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP2 listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttp2 {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeForProviderSpecListenerTimeoutHttp2Idle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeForProviderSpecListenerTimeoutHttp2PerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttp2Idle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutHttp2PerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for TCP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutTcp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeForProviderSpecListenerTimeoutTcpIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTimeoutTcpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<VirtualNodeForProviderSpecListenerTlsCertificate>,
    /// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeForProviderSpecListenerTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsCertificate {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<VirtualNodeForProviderSpecListenerTlsCertificateAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecListenerTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeForProviderSpecListenerTlsCertificateSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsCertificateAcm {
    /// ARN for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateArn"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_arn: Option<String>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAlternativeNames"
    )]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names:
        Option<VirtualNodeForProviderSpecListenerTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeForProviderSpecListenerTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match:
        Option<VirtualNodeForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidationTrust {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecListenerTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeForProviderSpecListenerTlsValidationTrustSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecListenerTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Inbound and outbound access logging information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecLogging {
    /// Access log configuration for a virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    #[builder(default, setter(strip_option))]
    pub access_log: Option<VirtualNodeForProviderSpecLoggingAccessLog>,
}

/// Access log configuration for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecLoggingAccessLog {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeForProviderSpecLoggingAccessLogFile>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecLoggingAccessLogFile {
    /// The specified format for the logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub format: Option<VirtualNodeForProviderSpecLoggingAccessLogFileFormat>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// The specified format for the logs.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecLoggingAccessLogFileFormat {
    /// The logging format for JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub json: Option<Vec<VirtualNodeForProviderSpecLoggingAccessLogFileFormatJson>>,
    /// The logging format for text. Must be between 1 and 1000 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub text: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecLoggingAccessLogFileFormatJson {
    /// The specified key for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Service discovery information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscovery {
    /// Any AWS Cloud Map information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsCloudMap"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_cloud_map: Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMap>,
    /// DNS service name for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub dns: Option<VirtualNodeForProviderSpecServiceDiscoveryDns>,
}

/// Any AWS Cloud Map information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMap {
    /// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attributes: Option<BTreeMap<String, String>>,
    /// Name of the AWS Cloud Map namespace to use.
    /// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceName"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name: Option<String>,
    /// Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name_ref:
        Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef>,
    /// Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name_selector:
        Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector>,
    /// attribute of the dns object to hostname.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

/// Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// DNS service name for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeForProviderSpecServiceDiscoveryDns {
    /// DNS host name for your virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hostname: Option<String>,
    /// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_preference: Option<String>,
    /// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "responseType"
    )]
    #[builder(default, setter(strip_option))]
    pub response_type: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProvider {
    /// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// Reference to a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_ref: Option<VirtualNodeInitProviderMeshNameRef>,
    /// Selector for a Mesh in appmesh to populate meshName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "meshNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub mesh_name_selector: Option<VirtualNodeInitProviderMeshNameSelector>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Virtual node specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<VirtualNodeInitProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Reference to a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderMeshNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeInitProviderMeshNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderMeshNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodeInitProviderMeshNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodeInitProviderMeshNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderMeshNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderMeshNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Mesh in appmesh to populate meshName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderMeshNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeInitProviderMeshNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderMeshNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodeInitProviderMeshNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodeInitProviderMeshNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderMeshNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderMeshNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Virtual node specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpec {
    /// Backends to which the virtual node is expected to send outbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub backend: Option<Vec<VirtualNodeInitProviderSpecBackend>>,
    /// Defaults for backends.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backendDefaults"
    )]
    #[builder(default, setter(strip_option))]
    pub backend_defaults: Option<VirtualNodeInitProviderSpecBackendDefaults>,
    /// Listeners from which the virtual node is expected to receive inbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub listener: Option<Vec<VirtualNodeInitProviderSpecListener>>,
    /// Inbound and outbound access logging information for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logging: Option<VirtualNodeInitProviderSpecLogging>,
    /// Service discovery information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub service_discovery: Option<VirtualNodeInitProviderSpecServiceDiscovery>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackend {
    /// Virtual service to use as a backend for a virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualService"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service: Option<VirtualNodeInitProviderSpecBackendVirtualService>,
}

/// Virtual service to use as a backend for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualService {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicy>,
    /// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualServiceName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service_name: Option<String>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAlternativeNames")]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds:
        Option<VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Defaults for backends.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaults {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicy>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAlternativeNames"
    )]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<
        VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames,
    >,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListener {
    /// Connection pool information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionPool"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_pool: Option<VirtualNodeInitProviderSpecListenerConnectionPool>,
    /// Health check information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthCheck"
    )]
    #[builder(default, setter(strip_option))]
    pub health_check: Option<VirtualNodeInitProviderSpecListenerHealthCheck>,
    /// Outlier detection information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outlierDetection"
    )]
    #[builder(default, setter(strip_option))]
    pub outlier_detection: Option<VirtualNodeInitProviderSpecListenerOutlierDetection>,
    /// Port mapping information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "portMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub port_mapping: Option<VirtualNodeInitProviderSpecListenerPortMapping>,
    /// Timeouts for different protocols.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<VirtualNodeInitProviderSpecListenerTimeout>,
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeInitProviderSpecListenerTls>,
}

/// Connection pool information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerConnectionPool {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeInitProviderSpecListenerConnectionPoolGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<Vec<VirtualNodeInitProviderSpecListenerConnectionPoolHttp>>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<Vec<VirtualNodeInitProviderSpecListenerConnectionPoolHttp2>>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<Vec<VirtualNodeInitProviderSpecListenerConnectionPoolTcp>>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerConnectionPoolGrpc {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerConnectionPoolHttp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
    /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxPendingRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_pending_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerConnectionPoolHttp2 {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerConnectionPoolTcp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
}

/// Health check information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerHealthCheck {
    /// Number of consecutive successful health checks that must occur before declaring listener healthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub healthy_threshold: Option<f64>,
    /// Time period in milliseconds between each health check execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "intervalMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub interval_millis: Option<f64>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// Amount of time to wait when receiving a response from the health check, in milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_millis: Option<f64>,
    /// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "unhealthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub unhealthy_threshold: Option<f64>,
}

/// Outlier detection information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerOutlierDetection {
    /// Base amount of time for which a host is ejected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baseEjectionDuration"
    )]
    #[builder(default, setter(strip_option))]
    pub base_ejection_duration:
        Option<VirtualNodeInitProviderSpecListenerOutlierDetectionBaseEjectionDuration>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub interval: Option<VirtualNodeInitProviderSpecListenerOutlierDetectionInterval>,
    /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
    /// Minimum value of 0. Maximum value of 100.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxEjectionPercent"
    )]
    #[builder(default, setter(strip_option))]
    pub max_ejection_percent: Option<f64>,
    /// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxServerErrors"
    )]
    #[builder(default, setter(strip_option))]
    pub max_server_errors: Option<f64>,
}

/// Base amount of time for which a host is ejected.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerOutlierDetectionBaseEjectionDuration {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Time interval between ejection sweep analysis.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerOutlierDetectionInterval {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Port mapping information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerPortMapping {
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
}

/// Timeouts for different protocols.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeout {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeInitProviderSpecListenerTimeoutGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<VirtualNodeInitProviderSpecListenerTimeoutHttp>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<VirtualNodeInitProviderSpecListenerTimeoutHttp2>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<VirtualNodeInitProviderSpecListenerTimeoutTcp>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutGrpc {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeInitProviderSpecListenerTimeoutGrpcIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeInitProviderSpecListenerTimeoutGrpcPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutGrpcIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutGrpcPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeInitProviderSpecListenerTimeoutHttpIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeInitProviderSpecListenerTimeoutHttpPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttpPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP2 listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttp2 {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeInitProviderSpecListenerTimeoutHttp2Idle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeInitProviderSpecListenerTimeoutHttp2PerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttp2Idle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutHttp2PerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for TCP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutTcp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeInitProviderSpecListenerTimeoutTcpIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTimeoutTcpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<VirtualNodeInitProviderSpecListenerTlsCertificate>,
    /// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeInitProviderSpecListenerTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsCertificate {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<VirtualNodeInitProviderSpecListenerTlsCertificateAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeInitProviderSpecListenerTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeInitProviderSpecListenerTlsCertificateSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsCertificateAcm {
    /// ARN for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateArn"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_arn: Option<String>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAlternativeNames"
    )]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names:
        Option<VirtualNodeInitProviderSpecListenerTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeInitProviderSpecListenerTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match:
        Option<VirtualNodeInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidationTrust {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeInitProviderSpecListenerTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeInitProviderSpecListenerTlsValidationTrustSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecListenerTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Inbound and outbound access logging information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecLogging {
    /// Access log configuration for a virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    #[builder(default, setter(strip_option))]
    pub access_log: Option<VirtualNodeInitProviderSpecLoggingAccessLog>,
}

/// Access log configuration for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecLoggingAccessLog {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeInitProviderSpecLoggingAccessLogFile>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecLoggingAccessLogFile {
    /// The specified format for the logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub format: Option<VirtualNodeInitProviderSpecLoggingAccessLogFileFormat>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// The specified format for the logs.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecLoggingAccessLogFileFormat {
    /// The logging format for JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub json: Option<Vec<VirtualNodeInitProviderSpecLoggingAccessLogFileFormatJson>>,
    /// The logging format for text. Must be between 1 and 1000 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub text: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecLoggingAccessLogFileFormatJson {
    /// The specified key for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Service discovery information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscovery {
    /// Any AWS Cloud Map information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsCloudMap"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_cloud_map: Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMap>,
    /// DNS service name for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub dns: Option<VirtualNodeInitProviderSpecServiceDiscoveryDns>,
}

/// Any AWS Cloud Map information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMap {
    /// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attributes: Option<BTreeMap<String, String>>,
    /// Name of the AWS Cloud Map namespace to use.
    /// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceName"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name: Option<String>,
    /// Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name_ref:
        Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef>,
    /// Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name_selector:
        Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector>,
    /// attribute of the dns object to hostname.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

/// Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<
        VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeInitProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// DNS service name for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeInitProviderSpecServiceDiscoveryDns {
    /// DNS host name for your virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hostname: Option<String>,
    /// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_preference: Option<String>,
    /// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "responseType"
    )]
    #[builder(default, setter(strip_option))]
    pub response_type: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodeProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodeProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodeProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodeProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<VirtualNodePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<VirtualNodePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VirtualNodePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VirtualNodePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VirtualNodePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VirtualNodePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// VirtualNodeStatus defines the observed state of VirtualNode.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<VirtualNodeStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProvider {
    /// ARN of the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Creation date of the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createdDate"
    )]
    #[builder(default, setter(strip_option))]
    pub created_date: Option<String>,
    /// ID of the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Last update date of the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastUpdatedDate"
    )]
    #[builder(default, setter(strip_option))]
    pub last_updated_date: Option<String>,
    /// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    #[builder(default, setter(strip_option))]
    pub mesh_name: Option<String>,
    /// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshOwner")]
    #[builder(default, setter(strip_option))]
    pub mesh_owner: Option<String>,
    /// Name to use for the virtual node. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Resource owner's AWS account ID.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_owner: Option<String>,
    /// Virtual node specification to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub spec: Option<VirtualNodeStatusAtProviderSpec>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
}

/// Virtual node specification to apply.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpec {
    /// Backends to which the virtual node is expected to send outbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub backend: Option<Vec<VirtualNodeStatusAtProviderSpecBackend>>,
    /// Defaults for backends.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backendDefaults"
    )]
    #[builder(default, setter(strip_option))]
    pub backend_defaults: Option<VirtualNodeStatusAtProviderSpecBackendDefaults>,
    /// Listeners from which the virtual node is expected to receive inbound traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub listener: Option<Vec<VirtualNodeStatusAtProviderSpecListener>>,
    /// Inbound and outbound access logging information for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub logging: Option<VirtualNodeStatusAtProviderSpecLogging>,
    /// Service discovery information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceDiscovery"
    )]
    #[builder(default, setter(strip_option))]
    pub service_discovery: Option<VirtualNodeStatusAtProviderSpecServiceDiscovery>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackend {
    /// Virtual service to use as a backend for a virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualService"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service: Option<VirtualNodeStatusAtProviderSpecBackendVirtualService>,
}

/// Virtual service to use as a backend for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualService {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicy>,
    /// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualServiceName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_service_name: Option<String>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate:
        Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation:
        Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file:
        Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds:
        Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAlternativeNames")]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<
        VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm,
    >,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<
        VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile,
    >,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<
        VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds,
    >,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Defaults for backends.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaults {
    /// Client policy for the backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub client_policy: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicy>,
}

/// Client policy for the backend.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicy {
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTls>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate:
        Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificate>,
    /// Whether the policy is enforced. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enforce: Option<bool>,
    /// One or more ports that the policy is enforced for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ports: Option<Vec<f64>>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificate {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificateSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAlternativeNames")]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match: Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
{
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm:
        Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file:
        Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds:
        Option<VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    /// One or more ACM ARNs.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListener {
    /// Connection pool information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionPool"
    )]
    #[builder(default, setter(strip_option))]
    pub connection_pool: Option<VirtualNodeStatusAtProviderSpecListenerConnectionPool>,
    /// Health check information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthCheck"
    )]
    #[builder(default, setter(strip_option))]
    pub health_check: Option<VirtualNodeStatusAtProviderSpecListenerHealthCheck>,
    /// Outlier detection information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outlierDetection"
    )]
    #[builder(default, setter(strip_option))]
    pub outlier_detection: Option<VirtualNodeStatusAtProviderSpecListenerOutlierDetection>,
    /// Port mapping information for the listener.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "portMapping"
    )]
    #[builder(default, setter(strip_option))]
    pub port_mapping: Option<VirtualNodeStatusAtProviderSpecListenerPortMapping>,
    /// Timeouts for different protocols.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub timeout: Option<VirtualNodeStatusAtProviderSpecListenerTimeout>,
    /// Transport Layer Security (TLS) client policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tls: Option<VirtualNodeStatusAtProviderSpecListenerTls>,
}

/// Connection pool information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerConnectionPool {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeStatusAtProviderSpecListenerConnectionPoolGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<Vec<VirtualNodeStatusAtProviderSpecListenerConnectionPoolHttp>>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<Vec<VirtualNodeStatusAtProviderSpecListenerConnectionPoolHttp2>>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<Vec<VirtualNodeStatusAtProviderSpecListenerConnectionPoolTcp>>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerConnectionPoolGrpc {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerConnectionPoolHttp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
    /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxPendingRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_pending_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerConnectionPoolHttp2 {
    /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequests"
    )]
    #[builder(default, setter(strip_option))]
    pub max_requests: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerConnectionPoolTcp {
    /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    #[builder(default, setter(strip_option))]
    pub max_connections: Option<f64>,
}

/// Health check information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerHealthCheck {
    /// Number of consecutive successful health checks that must occur before declaring listener healthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "healthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub healthy_threshold: Option<f64>,
    /// Time period in milliseconds between each health check execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "intervalMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub interval_millis: Option<f64>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
    /// Amount of time to wait when receiving a response from the health check, in milliseconds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutMillis"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_millis: Option<f64>,
    /// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "unhealthyThreshold"
    )]
    #[builder(default, setter(strip_option))]
    pub unhealthy_threshold: Option<f64>,
}

/// Outlier detection information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerOutlierDetection {
    /// Base amount of time for which a host is ejected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baseEjectionDuration"
    )]
    #[builder(default, setter(strip_option))]
    pub base_ejection_duration:
        Option<VirtualNodeStatusAtProviderSpecListenerOutlierDetectionBaseEjectionDuration>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub interval: Option<VirtualNodeStatusAtProviderSpecListenerOutlierDetectionInterval>,
    /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
    /// Minimum value of 0. Maximum value of 100.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxEjectionPercent"
    )]
    #[builder(default, setter(strip_option))]
    pub max_ejection_percent: Option<f64>,
    /// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxServerErrors"
    )]
    #[builder(default, setter(strip_option))]
    pub max_server_errors: Option<f64>,
}

/// Base amount of time for which a host is ejected.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerOutlierDetectionBaseEjectionDuration {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Time interval between ejection sweep analysis.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerOutlierDetectionInterval {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Port mapping information for the listener.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerPortMapping {
    /// Port used for the port mapping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub protocol: Option<String>,
}

/// Timeouts for different protocols.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeout {
    /// Connection pool information for gRPC listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub grpc: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutGrpc>,
    /// Connection pool information for HTTP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttp>,
    /// Connection pool information for HTTP2 listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub http2: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2>,
    /// Connection pool information for TCP listeners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tcp: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutTcp>,
}

/// Connection pool information for gRPC listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutGrpc {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutGrpcIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutGrpcPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutGrpcIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutGrpcPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttpIdle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttpPerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttpPerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for HTTP2 listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2 {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2Idle>,
    /// Per request timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perRequest"
    )]
    #[builder(default, setter(strip_option))]
    pub per_request: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2PerRequest>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2Idle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Per request timeout.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutHttp2PerRequest {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Connection pool information for TCP listeners.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutTcp {
    /// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub idle: Option<VirtualNodeStatusAtProviderSpecListenerTimeoutTcpIdle>,
}

/// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTimeoutTcpIdle {
    /// Unit of time. Valid values: ms, s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub unit: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<f64>,
}

/// Transport Layer Security (TLS) client policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTls {
    /// Virtual node's client's Transport Layer Security (TLS) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub certificate: Option<VirtualNodeStatusAtProviderSpecListenerTlsCertificate>,
    /// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub mode: Option<String>,
    /// TLS validation context.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub validation: Option<VirtualNodeStatusAtProviderSpecListenerTlsValidation>,
}

/// Virtual node's client's Transport Layer Security (TLS) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsCertificate {
    /// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub acm: Option<VirtualNodeStatusAtProviderSpecListenerTlsCertificateAcm>,
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeStatusAtProviderSpecListenerTlsCertificateFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeStatusAtProviderSpecListenerTlsCertificateSds>,
}

/// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsCertificateAcm {
    /// ARN for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateArn"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_arn: Option<String>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsCertificateFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
    /// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    #[builder(default, setter(strip_option))]
    pub private_key: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsCertificateSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidation {
    /// SANs for a TLS validation context.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAlternativeNames"
    )]
    #[builder(default, setter(strip_option))]
    pub subject_alternative_names:
        Option<VirtualNodeStatusAtProviderSpecListenerTlsValidationSubjectAlternativeNames>,
    /// TLS validation context trust.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub trust: Option<VirtualNodeStatusAtProviderSpecListenerTlsValidationTrust>,
}

/// SANs for a TLS validation context.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidationSubjectAlternativeNames {
    /// Criteria for determining a SAN's match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    #[builder(default, setter(strip_option))]
    pub r#match:
        Option<VirtualNodeStatusAtProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch>,
}

/// Criteria for determining a SAN's match.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
    /// Values sent must match the specified values exactly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub exact: Option<Vec<String>>,
}

/// TLS validation context trust.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidationTrust {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeStatusAtProviderSpecListenerTlsValidationTrustFile>,
    /// A Secret Discovery Service certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub sds: Option<VirtualNodeStatusAtProviderSpecListenerTlsValidationTrustSds>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidationTrustFile {
    /// Certificate chain for the certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateChain"
    )]
    #[builder(default, setter(strip_option))]
    pub certificate_chain: Option<String>,
}

/// A Secret Discovery Service certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecListenerTlsValidationTrustSds {
    /// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretName"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_name: Option<String>,
}

/// Inbound and outbound access logging information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecLogging {
    /// Access log configuration for a virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    #[builder(default, setter(strip_option))]
    pub access_log: Option<VirtualNodeStatusAtProviderSpecLoggingAccessLog>,
}

/// Access log configuration for a virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecLoggingAccessLog {
    /// Local file certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub file: Option<VirtualNodeStatusAtProviderSpecLoggingAccessLogFile>,
}

/// Local file certificate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecLoggingAccessLogFile {
    /// The specified format for the logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub format: Option<VirtualNodeStatusAtProviderSpecLoggingAccessLogFileFormat>,
    /// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub path: Option<String>,
}

/// The specified format for the logs.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecLoggingAccessLogFileFormat {
    /// The logging format for JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub json: Option<Vec<VirtualNodeStatusAtProviderSpecLoggingAccessLogFileFormatJson>>,
    /// The logging format for text. Must be between 1 and 1000 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub text: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecLoggingAccessLogFileFormatJson {
    /// The specified key for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// The specified value for the JSON. Must be between 1 and 100 characters in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Service discovery information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecServiceDiscovery {
    /// Any AWS Cloud Map information for the virtual node.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsCloudMap"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_cloud_map: Option<VirtualNodeStatusAtProviderSpecServiceDiscoveryAwsCloudMap>,
    /// DNS service name for the virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub dns: Option<VirtualNodeStatusAtProviderSpecServiceDiscoveryDns>,
}

/// Any AWS Cloud Map information for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecServiceDiscoveryAwsCloudMap {
    /// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub attributes: Option<BTreeMap<String, String>>,
    /// Name of the AWS Cloud Map namespace to use.
    /// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespaceName"
    )]
    #[builder(default, setter(strip_option))]
    pub namespace_name: Option<String>,
    /// attribute of the dns object to hostname.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
}

/// DNS service name for the virtual node.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VirtualNodeStatusAtProviderSpecServiceDiscoveryDns {
    /// DNS host name for your virtual node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub hostname: Option<String>,
    /// The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_preference: Option<String>,
    /// The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "responseType"
    )]
    #[builder(default, setter(strip_option))]
    pub response_type: Option<String>,
}
