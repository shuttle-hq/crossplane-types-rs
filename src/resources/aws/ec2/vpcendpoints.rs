// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// VPCEndpointSpec defines the desired state of VPCEndpoint
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "ec2.aws.upbound.io",
    version = "v1beta2",
    kind = "VPCEndpoint",
    plural = "vpcendpoints"
)]
#[kube(status = "VPCEndpointStatus")]
pub struct VPCEndpointSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<VPCEndpointDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: VPCEndpointForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<VPCEndpointInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<VPCEndpointProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<VPCEndpointPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<VPCEndpointWriteConnectionSecretToRef>,
}

/// VPCEndpointSpec defines the desired state of VPCEndpoint
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProvider {
    /// Accept the VPC endpoint (the VPC endpoint and service need to be in the same AWS account).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoAccept"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_accept: Option<bool>,
    /// The DNS options for the endpoint. See dns_options below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_options: Option<VPCEndpointForProviderDnsOptions>,
    /// The IP address type for the endpoint. Valid values are ipv4, dualstack, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// A policy to attach to the endpoint that controls access to the service. This is a JSON formatted string. Defaults to full access. All Gateway and some Interface endpoints support policies - see the relevant AWS documentation for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<String>,
    /// Whether or not to associate a private hosted zone with the specified VPC. Applicable for endpoints of type Interface. Most users will want this enabled to allow services within the VPC to automatically use the endpoint.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_enabled: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The service name. For AWS services the service name is usually in the form com.amazonaws.<region>.<service> (the SageMaker Notebook service is an exception to this rule, the service name is in the form aws.sagemaker.<region>.notebook).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
    /// Reference to a VPCEndpointService in ec2 to populate serviceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name_ref: Option<VPCEndpointForProviderServiceNameRef>,
    /// Selector for a VPCEndpointService in ec2 to populate serviceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name_selector: Option<VPCEndpointForProviderServiceNameSelector>,
    /// - The AWS region of the VPC Endpoint Service. If specified, the VPC endpoint will connect to the service in the provided region. Applicable for endpoints of type Interface.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub service_region: Option<String>,
    /// Subnet configuration for the endpoint, used to select specific IPv4 and/or IPv6 addresses to the endpoint. See subnet_configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_configuration: Option<Vec<VPCEndpointForProviderSubnetConfiguration>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// The VPC endpoint type, Gateway, GatewayLoadBalancer, or Interface. Defaults to Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_type: Option<String>,
    /// The ID of the VPC in which the endpoint will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default, setter(strip_option))]
    pub vpc_id_ref: Option<VPCEndpointForProviderVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_id_selector: Option<VPCEndpointForProviderVpcIdSelector>,
}

/// The DNS options for the endpoint. See dns_options below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderDnsOptions {
    /// The DNS records created for the endpoint. Valid values are ipv4, dualstack, service-defined, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordIpType"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_ip_type: Option<String>,
    /// Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is false. Can only be specified if private_dns_enabled is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsOnlyForInboundResolverEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_only_for_inbound_resolver_endpoint: Option<bool>,
}

/// Reference to a VPCEndpointService in ec2 to populate serviceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderServiceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderServiceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderServiceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointForProviderServiceNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderServiceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderServiceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderServiceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCEndpointService in ec2 to populate serviceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderServiceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderServiceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderServiceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointForProviderServiceNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderServiceNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderServiceNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderServiceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderSubnetConfiguration {
    /// The IPv4 address to assign to the endpoint network interface in the subnet. You must provide an IPv4 address if the VPC endpoint supports IPv4.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv4: Option<String>,
    /// The IPv6 address to assign to the endpoint network interface in the subnet. You must provide an IPv6 address if the VPC endpoint supports IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv6: Option<String>,
    /// The ID of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdSelector>,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderSubnetConfigurationSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderSubnetConfigurationSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderSubnetConfigurationSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderSubnetConfigurationSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointForProviderVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointForProviderVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointForProviderVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointForProviderVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointForProviderVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointForProviderVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProvider {
    /// Accept the VPC endpoint (the VPC endpoint and service need to be in the same AWS account).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoAccept"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_accept: Option<bool>,
    /// The DNS options for the endpoint. See dns_options below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_options: Option<VPCEndpointInitProviderDnsOptions>,
    /// The IP address type for the endpoint. Valid values are ipv4, dualstack, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// A policy to attach to the endpoint that controls access to the service. This is a JSON formatted string. Defaults to full access. All Gateway and some Interface endpoints support policies - see the relevant AWS documentation for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<String>,
    /// Whether or not to associate a private hosted zone with the specified VPC. Applicable for endpoints of type Interface. Most users will want this enabled to allow services within the VPC to automatically use the endpoint.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_enabled: Option<bool>,
    /// The service name. For AWS services the service name is usually in the form com.amazonaws.<region>.<service> (the SageMaker Notebook service is an exception to this rule, the service name is in the form aws.sagemaker.<region>.notebook).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
    /// Reference to a VPCEndpointService in ec2 to populate serviceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name_ref: Option<VPCEndpointInitProviderServiceNameRef>,
    /// Selector for a VPCEndpointService in ec2 to populate serviceName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name_selector: Option<VPCEndpointInitProviderServiceNameSelector>,
    /// - The AWS region of the VPC Endpoint Service. If specified, the VPC endpoint will connect to the service in the provided region. Applicable for endpoints of type Interface.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub service_region: Option<String>,
    /// Subnet configuration for the endpoint, used to select specific IPv4 and/or IPv6 addresses to the endpoint. See subnet_configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_configuration: Option<Vec<VPCEndpointInitProviderSubnetConfiguration>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// The VPC endpoint type, Gateway, GatewayLoadBalancer, or Interface. Defaults to Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_type: Option<String>,
    /// The ID of the VPC in which the endpoint will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
    /// Reference to a VPC in ec2 to populate vpcId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcIdRef")]
    #[builder(default, setter(strip_option))]
    pub vpc_id_ref: Option<VPCEndpointInitProviderVpcIdRef>,
    /// Selector for a VPC in ec2 to populate vpcId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_id_selector: Option<VPCEndpointInitProviderVpcIdSelector>,
}

/// The DNS options for the endpoint. See dns_options below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderDnsOptions {
    /// The DNS records created for the endpoint. Valid values are ipv4, dualstack, service-defined, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordIpType"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_ip_type: Option<String>,
    /// Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is false. Can only be specified if private_dns_enabled is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsOnlyForInboundResolverEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_only_for_inbound_resolver_endpoint: Option<bool>,
}

/// Reference to a VPCEndpointService in ec2 to populate serviceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderServiceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderServiceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderServiceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointInitProviderServiceNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderServiceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderServiceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderServiceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCEndpointService in ec2 to populate serviceName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderServiceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderServiceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderServiceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointInitProviderServiceNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderServiceNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderServiceNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderServiceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderSubnetConfiguration {
    /// The IPv4 address to assign to the endpoint network interface in the subnet. You must provide an IPv4 address if the VPC endpoint supports IPv4.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv4: Option<String>,
    /// The IPv6 address to assign to the endpoint network interface in the subnet. You must provide an IPv6 address if the VPC endpoint supports IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv6: Option<String>,
    /// The ID of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdSelector>,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderSubnetConfigurationSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderSubnetConfigurationSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderSubnetConfigurationSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderSubnetConfigurationSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderVpcIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderVpcIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderVpcIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointInitProviderVpcIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderVpcIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderVpcIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderVpcIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPC in ec2 to populate vpcId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderVpcIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointInitProviderVpcIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointInitProviderVpcIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointInitProviderVpcIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointInitProviderVpcIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderVpcIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointInitProviderVpcIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<VPCEndpointPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<VPCEndpointPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCEndpointPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCEndpointPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCEndpointPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCEndpointPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// VPCEndpointStatus defines the observed state of VPCEndpoint.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<VPCEndpointStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointStatusAtProvider {
    /// The Amazon Resource Name (ARN) of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Accept the VPC endpoint (the VPC endpoint and service need to be in the same AWS account).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoAccept"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_accept: Option<bool>,
    /// The list of CIDR blocks for the exposed AWS service. Applicable for endpoints of type Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cidrBlocks"
    )]
    #[builder(default, setter(strip_option))]
    pub cidr_blocks: Option<Vec<String>>,
    /// The DNS entries for the VPC Endpoint. Applicable for endpoints of type Interface. DNS blocks are documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsEntry")]
    #[builder(default, setter(strip_option))]
    pub dns_entry: Option<Vec<VPCEndpointStatusAtProviderDnsEntry>>,
    /// The DNS options for the endpoint. See dns_options below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_options: Option<VPCEndpointStatusAtProviderDnsOptions>,
    /// The ID of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The IP address type for the endpoint. Valid values are ipv4, dualstack, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipAddressType"
    )]
    #[builder(default, setter(strip_option))]
    pub ip_address_type: Option<String>,
    /// One or more network interfaces for the VPC Endpoint. Applicable for endpoints of type Interface.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIds"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_ids: Option<Vec<String>>,
    /// The ID of the AWS account that owns the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerId")]
    #[builder(default, setter(strip_option))]
    pub owner_id: Option<String>,
    /// A policy to attach to the endpoint that controls access to the service. This is a JSON formatted string. Defaults to full access. All Gateway and some Interface endpoints support policies - see the relevant AWS documentation for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<String>,
    /// The prefix list ID of the exposed AWS service. Applicable for endpoints of type Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "prefixListId"
    )]
    #[builder(default, setter(strip_option))]
    pub prefix_list_id: Option<String>,
    /// Whether or not to associate a private hosted zone with the specified VPC. Applicable for endpoints of type Interface. Most users will want this enabled to allow services within the VPC to automatically use the endpoint.
    /// Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_enabled: Option<bool>,
    /// Whether or not the VPC Endpoint is being managed by its service - true or false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requesterManaged"
    )]
    #[builder(default, setter(strip_option))]
    pub requester_managed: Option<bool>,
    /// One or more route table IDs. Applicable for endpoints of type Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "routeTableIds"
    )]
    #[builder(default, setter(strip_option))]
    pub route_table_ids: Option<Vec<String>>,
    /// The ID of one or more security groups to associate with the network interface. Applicable for endpoints of type Interface.
    /// If no security groups are specified, the VPC's default security group is associated with the endpoint.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_ids: Option<Vec<String>>,
    /// The service name. For AWS services the service name is usually in the form com.amazonaws.<region>.<service> (the SageMaker Notebook service is an exception to this rule, the service name is in the form aws.sagemaker.<region>.notebook).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub service_name: Option<String>,
    /// - The AWS region of the VPC Endpoint Service. If specified, the VPC endpoint will connect to the service in the provided region. Applicable for endpoints of type Interface.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub service_region: Option<String>,
    /// The state of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Subnet configuration for the endpoint, used to select specific IPv4 and/or IPv6 addresses to the endpoint. See subnet_configuration below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_configuration: Option<Vec<VPCEndpointStatusAtProviderSubnetConfiguration>>,
    /// The ID of one or more subnets in which to create a network interface for the endpoint. Applicable for endpoints of type GatewayLoadBalancer and Interface. Interface type endpoints cannot function without being assigned to a subnet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default, setter(strip_option))]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// The VPC endpoint type, Gateway, GatewayLoadBalancer, or Interface. Defaults to Gateway.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcEndpointType"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_endpoint_type: Option<String>,
    /// The ID of the VPC in which the endpoint will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default, setter(strip_option))]
    pub vpc_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointStatusAtProviderDnsEntry {
    /// The DNS name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default, setter(strip_option))]
    pub dns_name: Option<String>,
    /// The ID of the private hosted zone.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostedZoneId"
    )]
    #[builder(default, setter(strip_option))]
    pub hosted_zone_id: Option<String>,
}

/// The DNS options for the endpoint. See dns_options below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointStatusAtProviderDnsOptions {
    /// The DNS records created for the endpoint. Valid values are ipv4, dualstack, service-defined, and ipv6.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dnsRecordIpType"
    )]
    #[builder(default, setter(strip_option))]
    pub dns_record_ip_type: Option<String>,
    /// Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is false. Can only be specified if private_dns_enabled is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsOnlyForInboundResolverEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_only_for_inbound_resolver_endpoint: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCEndpointStatusAtProviderSubnetConfiguration {
    /// The IPv4 address to assign to the endpoint network interface in the subnet. You must provide an IPv4 address if the VPC endpoint supports IPv4.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv4: Option<String>,
    /// The IPv6 address to assign to the endpoint network interface in the subnet. You must provide an IPv6 address if the VPC endpoint supports IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ipv6: Option<String>,
    /// The ID of the VPC endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
}
