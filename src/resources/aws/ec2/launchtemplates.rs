// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// LaunchTemplateSpec defines the desired state of LaunchTemplate
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "ec2.aws.upbound.io",
    version = "v1beta2",
    kind = "LaunchTemplate",
    plural = "launchtemplates"
)]
#[kube(status = "LaunchTemplateStatus")]
pub struct LaunchTemplateSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<LaunchTemplateDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: LaunchTemplateForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<LaunchTemplateInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<LaunchTemplateProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<LaunchTemplatePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<LaunchTemplateWriteConnectionSecretToRef>,
}

/// LaunchTemplateSpec defines the desired state of LaunchTemplate
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProvider {
    /// Specify volumes to attach to the instance besides the volumes specified by the AMI.
    /// See Block Devices below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDeviceMappings"
    )]
    #[builder(default, setter(strip_option))]
    pub block_device_mappings: Option<Vec<LaunchTemplateForProviderBlockDeviceMappings>>,
    /// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_specification:
        Option<LaunchTemplateForProviderCapacityReservationSpecification>,
    /// The CPU options for the instance. See CPU Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_options: Option<LaunchTemplateForProviderCpuOptions>,
    /// Customize the credit specification of the instance. See Credit
    /// Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "creditSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub credit_specification: Option<LaunchTemplateForProviderCreditSpecification>,
    /// Default Version of the launch template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub default_version: Option<f64>,
    /// Description of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// If true, enables EC2 Instance Stop Protection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiStop"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_stop: Option<bool>,
    /// If true, enables EC2 Instance
    /// Termination Protection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_termination: Option<bool>,
    /// If true, the launched EC2 instance will be EBS-optimized.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsOptimized"
    )]
    #[builder(default, setter(strip_option))]
    pub ebs_optimized: Option<String>,
    /// The elastic GPU to attach to the instance. See Elastic GPU
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticGpuSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_gpu_specifications: Option<Vec<LaunchTemplateForProviderElasticGpuSpecifications>>,
    /// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticInferenceAccelerator"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_inference_accelerator: Option<LaunchTemplateForProviderElasticInferenceAccelerator>,
    /// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enclaveOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub enclave_options: Option<LaunchTemplateForProviderEnclaveOptions>,
    /// The hibernation options for the instance. See Hibernation Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hibernationOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub hibernation_options: Option<LaunchTemplateForProviderHibernationOptions>,
    /// The IAM Instance Profile to launch the instance with. See Instance Profile
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamInstanceProfile"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_instance_profile: Option<LaunchTemplateForProviderIamInstanceProfile>,
    /// The AMI from which to launch the instance or use a Systems Manager parameter convention e.g. resolve:ssm:parameter-name. See docs for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageId")]
    #[builder(default, setter(strip_option))]
    pub image_id: Option<String>,
    /// Shutdown behavior for the instance. Can be stop or terminate.
    /// (Default: stop).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInitiatedShutdownBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_initiated_shutdown_behavior: Option<String>,
    /// The market (purchasing) option for the instance. See Market Options
    /// below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMarketOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_market_options: Option<LaunchTemplateForProviderInstanceMarketOptions>,
    /// The attribute requirements for the type of instance. If present then instance_type cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceRequirements"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_requirements: Option<LaunchTemplateForProviderInstanceRequirements>,
    /// The type of the instance. If present then instance_requirements cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_type: Option<String>,
    /// The kernel ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelId")]
    #[builder(default, setter(strip_option))]
    pub kernel_id: Option<String>,
    /// The key name to use for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default, setter(strip_option))]
    pub key_name: Option<String>,
    /// A list of license specifications to associate with. See License Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub license_specification: Option<Vec<LaunchTemplateForProviderLicenseSpecification>>,
    /// The maintenance options for the instance. See Maintenance Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_options: Option<LaunchTemplateForProviderMaintenanceOptions>,
    /// Customize the metadata options for the instance. See Metadata Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metadataOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub metadata_options: Option<LaunchTemplateForProviderMetadataOptions>,
    /// The monitoring option for the instance. See Monitoring below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub monitoring: Option<LaunchTemplateForProviderMonitoring>,
    /// The name of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Customize network interfaces to be attached at instance boot time. See Network
    /// Interfaces below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaces"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interfaces: Option<Vec<LaunchTemplateForProviderNetworkInterfaces>>,
    /// The placement of the instance. See Placement below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub placement: Option<LaunchTemplateForProviderPlacement>,
    /// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsNameOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_name_options: Option<LaunchTemplateForProviderPrivateDnsNameOptions>,
    /// The ID of the RAM disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ramDiskId")]
    #[builder(default, setter(strip_option))]
    pub ram_disk_id: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// References to SecurityGroup in ec2 to populate securityGroupNames.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNameRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_name_refs: Option<Vec<LaunchTemplateForProviderSecurityGroupNameRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupNames.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_name_selector: Option<LaunchTemplateForProviderSecurityGroupNameSelector>,
    /// A list of security group names to associate with. If you are creating Instances in a VPC, use
    /// vpc_security_group_ids instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// The tags to apply to the resources during launch. See Tag Specifications below for more details. Default tags are currently not propagated to ASG created resources so you may wish to inject your default tags into this variable against the relevant child resource types created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tagSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub tag_specifications: Option<Vec<LaunchTemplateForProviderTagSpecifications>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Whether to update Default Version each update. Conflicts with default_version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateDefaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub update_default_version: Option<bool>,
    /// The base64-encoded user data to provide when launching the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default, setter(strip_option))]
    pub user_data: Option<String>,
    /// References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_refs: Option<Vec<LaunchTemplateForProviderVpcSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_selector: Option<LaunchTemplateForProviderVpcSecurityGroupIdSelector>,
    /// A list of security group IDs to associate with. Conflicts with network_interfaces.security_groups
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappings {
    /// The name of the device to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub device_name: Option<String>,
    /// Configure EBS volume properties.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ebs: Option<LaunchTemplateForProviderBlockDeviceMappingsEbs>,
    /// Suppresses the specified device included in the AMI's block device mapping.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noDevice")]
    #[builder(default, setter(strip_option))]
    pub no_device: Option<String>,
    /// The Instance Store Device
    /// Name
    /// (e.g., "ephemeral0").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_name: Option<String>,
}

/// Configure EBS volume properties.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappingsEbs {
    /// Whether the volume should be destroyed on instance termination.
    /// See Preserving Amazon EBS Volumes on Instance Termination for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Enables EBS encryption on the volume.
    /// Cannot be used with snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encrypted: Option<String>,
    /// The amount of provisioned IOPS.
    /// This must be set with a volume_type of "io1/io2/gp3".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
    /// encrypted must be set to true when this is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector:
        Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelector>,
    /// The Snapshot ID to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotId"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_id: Option<String>,
    /// The throughput to provision for a gp3 volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub throughput: Option<f64>,
    /// The size of the volume in gigabytes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_size: Option<f64>,
    /// The volume type.
    /// Can be one of standard, gp2, gp3, io1, io2, sc1 or st1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeType"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_type: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderCapacityReservationSpecification {
    /// Indicates the instance's Capacity Reservation preferences. Can be open or none. (Default none).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_preference: Option<String>,
    /// Used to target a specific Capacity Reservation:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_target:
        Option<LaunchTemplateForProviderCapacityReservationSpecificationCapacityReservationTarget>,
}

/// Used to target a specific Capacity Reservation:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderCapacityReservationSpecificationCapacityReservationTarget {
    /// The ID of the Capacity Reservation in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationId"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_id: Option<String>,
    /// The ARN of the Capacity Reservation resource group in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_resource_group_arn: Option<String>,
}

/// The CPU options for the instance. See CPU Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderCpuOptions {
    /// Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are enabled and disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amdSevSnp")]
    #[builder(default, setter(strip_option))]
    pub amd_sev_snp: Option<String>,
    /// The number of CPU cores for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreCount")]
    #[builder(default, setter(strip_option))]
    pub core_count: Option<f64>,
    /// The number of threads per CPU core.
    /// To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
    /// Otherwise, specify the default value of 2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "threadsPerCore"
    )]
    #[builder(default, setter(strip_option))]
    pub threads_per_core: Option<f64>,
}

/// Customize the credit specification of the instance. See Credit
/// Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderCreditSpecification {
    /// The credit option for CPU usage.
    /// Can be standard or unlimited.
    /// T3 instances are launched as unlimited by default.
    /// T2 instances are launched as standard by default.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuCredits"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_credits: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderElasticGpuSpecifications {
    /// The Elastic GPU Type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderElasticInferenceAccelerator {
    /// Accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderEnclaveOptions {
    /// If set to true, Nitro Enclaves will be enabled on the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// The hibernation options for the instance. See Hibernation Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderHibernationOptions {
    /// If set to true, the launched EC2 instance will hibernation enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configured: Option<bool>,
}

/// The IAM Instance Profile to launch the instance with. See Instance Profile
/// below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfile {
    /// The Amazon Resource Name (ARN) of the instance profile. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a InstanceProfile in iam to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<LaunchTemplateForProviderIamInstanceProfileArnRef>,
    /// Selector for a InstanceProfile in iam to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<LaunchTemplateForProviderIamInstanceProfileArnSelector>,
    /// The name of the instance profile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a InstanceProfile in iam to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<LaunchTemplateForProviderIamInstanceProfileNameRef>,
    /// Selector for a InstanceProfile in iam to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<LaunchTemplateForProviderIamInstanceProfileNameSelector>,
}

/// Reference to a InstanceProfile in iam to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderIamInstanceProfileArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderIamInstanceProfileArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderIamInstanceProfileArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a InstanceProfile in iam to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderIamInstanceProfileNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderIamInstanceProfileNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderIamInstanceProfileNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderIamInstanceProfileNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The market (purchasing) option for the instance. See Market Options
/// below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceMarketOptions {
    /// The market type. Can be spot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "marketType"
    )]
    #[builder(default, setter(strip_option))]
    pub market_type: Option<String>,
    /// The options for Spot Instance
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_options: Option<LaunchTemplateForProviderInstanceMarketOptionsSpotOptions>,
}

/// The options for Spot Instance
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceMarketOptionsSpotOptions {
    /// The required duration in minutes. This value must be a multiple of 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDurationMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub block_duration_minutes: Option<f64>,
    /// The behavior when a Spot Instance is interrupted. Can be hibernate,
    /// stop, or terminate. (Default: terminate).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInterruptionBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_interruption_behavior: Option<String>,
    /// The maximum hourly price you're willing to pay for the Spot Instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPrice")]
    #[builder(default, setter(strip_option))]
    pub max_price: Option<String>,
    /// The Spot Instance request type. Can be one-time, or persistent.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_instance_type: Option<String>,
    /// The end date of the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "validUntil"
    )]
    #[builder(default, setter(strip_option))]
    pub valid_until: Option<String>,
}

/// The attribute requirements for the type of instance. If present then instance_type cannot be present.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorCount"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_count: Option<LaunchTemplateForProviderInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorNames"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTotalMemoryMib"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_total_memory_mib:
        Option<LaunchTemplateForProviderInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default, setter(strip_option))]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baselineEbsBandwidthMbps"
    )]
    #[builder(default, setter(strip_option))]
    pub baseline_ebs_bandwidth_mbps:
        Option<LaunchTemplateForProviderInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "burstablePerformance"
    )]
    #[builder(default, setter(strip_option))]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceGenerations"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorageTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage_types: Option<Vec<String>>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with spot_max_price_percentage_over_lowest_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxSpotPriceAsPercentageOfOptimalOnDemandPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub max_spot_price_as_percentage_of_optimal_on_demand_price: Option<f64>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memoryGibPerVcpu"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_gib_per_vcpu: Option<LaunchTemplateForProviderInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default, setter(strip_option))]
    pub memory_mib: Option<LaunchTemplateForProviderInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkBandwidthGbps"
    )]
    #[builder(default, setter(strip_option))]
    pub network_bandwidth_gbps:
        Option<LaunchTemplateForProviderInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceCount"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_count:
        Option<LaunchTemplateForProviderInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireHibernateSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with max_spot_price_as_percentage_of_optimal_on_demand_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "totalLocalStorageGb"
    )]
    #[builder(default, setter(strip_option))]
    pub total_local_storage_gb:
        Option<LaunchTemplateForProviderInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default, setter(strip_option))]
    pub vcpu_count: Option<LaunchTemplateForProviderInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderLicenseSpecification {
    /// ARN of the license configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseConfigurationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub license_configuration_arn: Option<String>,
}

/// The maintenance options for the instance. See Maintenance Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderMaintenanceOptions {
    /// Disables the automatic recovery behavior of your instance or sets it to default. Can be "default" or "disabled". See Recover your instance for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_recovery: Option<String>,
}

/// Customize the metadata options for the instance. See Metadata Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderMetadataOptions {
    /// Whether the metadata service is available. Can be "enabled" or "disabled". (Default: "enabled").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub http_endpoint: Option<String>,
    /// Enables or disables the IPv6 endpoint for the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpProtocolIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub http_protocol_ipv6: Option<String>,
    /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from 1 to 64. (Default: 1).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpPutResponseHopLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub http_put_response_hop_limit: Option<f64>,
    /// Whether or not the metadata service requires session tokens, also referred to as Instance Metadata Service Version 2 (IMDSv2). Can be "optional" or "required". (Default: "optional").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub http_tokens: Option<String>,
    /// Enables or disables access to instance tags from the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMetadataTags"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_metadata_tags: Option<String>,
}

/// The monitoring option for the instance. See Monitoring below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderMonitoring {
    /// If true, the launched EC2 instance will have detailed monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfaces {
    /// Associate a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associateCarrierIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_carrier_ip_address: Option<String>,
    /// Associate a public ip address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associatePublicIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_public_ip_address: Option<String>,
    /// Whether the network interface should be destroyed on instance termination.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Description of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The integer index of the network interface attachment.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub device_index: Option<f64>,
    /// The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "interfaceType"
    )]
    #[builder(default, setter(strip_option))]
    pub interface_type: Option<String>,
    /// The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with ipv4_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_address_count: Option<f64>,
    /// One or more private IPv4 addresses to associate. Conflicts with ipv4_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_addresses: Option<Vec<String>>,
    /// The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with ipv4_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes to be assigned to the network interface. Conflicts with ipv4_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// The number of IPv6 addresses to assign to a network interface. Conflicts with ipv6_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address_count: Option<f64>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with ipv6_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_addresses: Option<Vec<String>>,
    /// The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with ipv6_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes to be assigned to the network interface. Conflicts with ipv6_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefixes: Option<Vec<String>>,
    /// The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkCardIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub network_card_index: Option<f64>,
    /// The ID of the network interface to attach.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceId"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id: Option<String>,
    /// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id_ref:
        Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRef>,
    /// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id_selector:
        Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelector>,
    /// Whether the first IPv6 GUA will be made the primary IPv6 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "primaryIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub primary_ipv6: Option<String>,
    /// The primary private IPv4 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ip_address: Option<String>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs:
        Option<Vec<LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector:
        Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelector>,
    /// A list of security group IDs to associate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// The VPC Subnet ID to associate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdSelector>,
}

/// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderNetworkInterfacesSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The placement of the instance. See Placement below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderPlacement {
    /// The affinity setting for an instance on a Dedicated Host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub affinity: Option<String>,
    /// The Availability Zone for the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// The name of the placement group for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// The ID of the Dedicated Host for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostId")]
    #[builder(default, setter(strip_option))]
    pub host_id: Option<String>,
    /// The ARN of the Host Resource Group in which to launch instances.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub host_resource_group_arn: Option<String>,
    /// The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionNumber"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_number: Option<f64>,
    /// Reserved for future use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spreadDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub spread_domain: Option<String>,
    /// The tenancy of the instance (if the instance is running in a VPC). Can be default, dedicated, or host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tenancy: Option<String>,
}

/// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderPrivateDnsNameOptions {
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsARecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_a_record: Option<bool>,
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsAaaaRecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_aaaa_record: Option<bool>,
    /// The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: ip-name and resource-name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostnameType"
    )]
    #[builder(default, setter(strip_option))]
    pub hostname_type: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderSecurityGroupNameRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderSecurityGroupNameRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderSecurityGroupNameRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderSecurityGroupNameRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderSecurityGroupNameRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderSecurityGroupNameRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderSecurityGroupNameRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupNames.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderSecurityGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderSecurityGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderSecurityGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderSecurityGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderSecurityGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderSecurityGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderSecurityGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderTagSpecifications {
    /// The type of resource to tag.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
    /// A map of tags to assign to the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderVpcSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderVpcSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderVpcSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateForProviderVpcSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProvider {
    /// Specify volumes to attach to the instance besides the volumes specified by the AMI.
    /// See Block Devices below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDeviceMappings"
    )]
    #[builder(default, setter(strip_option))]
    pub block_device_mappings: Option<Vec<LaunchTemplateInitProviderBlockDeviceMappings>>,
    /// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_specification:
        Option<LaunchTemplateInitProviderCapacityReservationSpecification>,
    /// The CPU options for the instance. See CPU Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_options: Option<LaunchTemplateInitProviderCpuOptions>,
    /// Customize the credit specification of the instance. See Credit
    /// Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "creditSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub credit_specification: Option<LaunchTemplateInitProviderCreditSpecification>,
    /// Default Version of the launch template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub default_version: Option<f64>,
    /// Description of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// If true, enables EC2 Instance Stop Protection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiStop"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_stop: Option<bool>,
    /// If true, enables EC2 Instance
    /// Termination Protection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_termination: Option<bool>,
    /// If true, the launched EC2 instance will be EBS-optimized.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsOptimized"
    )]
    #[builder(default, setter(strip_option))]
    pub ebs_optimized: Option<String>,
    /// The elastic GPU to attach to the instance. See Elastic GPU
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticGpuSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_gpu_specifications: Option<Vec<LaunchTemplateInitProviderElasticGpuSpecifications>>,
    /// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticInferenceAccelerator"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_inference_accelerator:
        Option<LaunchTemplateInitProviderElasticInferenceAccelerator>,
    /// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enclaveOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub enclave_options: Option<LaunchTemplateInitProviderEnclaveOptions>,
    /// The hibernation options for the instance. See Hibernation Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hibernationOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub hibernation_options: Option<LaunchTemplateInitProviderHibernationOptions>,
    /// The IAM Instance Profile to launch the instance with. See Instance Profile
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamInstanceProfile"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_instance_profile: Option<LaunchTemplateInitProviderIamInstanceProfile>,
    /// The AMI from which to launch the instance or use a Systems Manager parameter convention e.g. resolve:ssm:parameter-name. See docs for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageId")]
    #[builder(default, setter(strip_option))]
    pub image_id: Option<String>,
    /// Shutdown behavior for the instance. Can be stop or terminate.
    /// (Default: stop).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInitiatedShutdownBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_initiated_shutdown_behavior: Option<String>,
    /// The market (purchasing) option for the instance. See Market Options
    /// below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMarketOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_market_options: Option<LaunchTemplateInitProviderInstanceMarketOptions>,
    /// The attribute requirements for the type of instance. If present then instance_type cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceRequirements"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_requirements: Option<LaunchTemplateInitProviderInstanceRequirements>,
    /// The type of the instance. If present then instance_requirements cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_type: Option<String>,
    /// The kernel ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelId")]
    #[builder(default, setter(strip_option))]
    pub kernel_id: Option<String>,
    /// The key name to use for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default, setter(strip_option))]
    pub key_name: Option<String>,
    /// A list of license specifications to associate with. See License Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub license_specification: Option<Vec<LaunchTemplateInitProviderLicenseSpecification>>,
    /// The maintenance options for the instance. See Maintenance Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_options: Option<LaunchTemplateInitProviderMaintenanceOptions>,
    /// Customize the metadata options for the instance. See Metadata Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metadataOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub metadata_options: Option<LaunchTemplateInitProviderMetadataOptions>,
    /// The monitoring option for the instance. See Monitoring below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub monitoring: Option<LaunchTemplateInitProviderMonitoring>,
    /// The name of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Customize network interfaces to be attached at instance boot time. See Network
    /// Interfaces below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaces"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interfaces: Option<Vec<LaunchTemplateInitProviderNetworkInterfaces>>,
    /// The placement of the instance. See Placement below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub placement: Option<LaunchTemplateInitProviderPlacement>,
    /// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsNameOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_name_options: Option<LaunchTemplateInitProviderPrivateDnsNameOptions>,
    /// The ID of the RAM disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ramDiskId")]
    #[builder(default, setter(strip_option))]
    pub ram_disk_id: Option<String>,
    /// References to SecurityGroup in ec2 to populate securityGroupNames.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNameRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_name_refs: Option<Vec<LaunchTemplateInitProviderSecurityGroupNameRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupNames.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_name_selector: Option<LaunchTemplateInitProviderSecurityGroupNameSelector>,
    /// A list of security group names to associate with. If you are creating Instances in a VPC, use
    /// vpc_security_group_ids instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// The tags to apply to the resources during launch. See Tag Specifications below for more details. Default tags are currently not propagated to ASG created resources so you may wish to inject your default tags into this variable against the relevant child resource types created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tagSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub tag_specifications: Option<Vec<LaunchTemplateInitProviderTagSpecifications>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Whether to update Default Version each update. Conflicts with default_version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateDefaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub update_default_version: Option<bool>,
    /// The base64-encoded user data to provide when launching the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default, setter(strip_option))]
    pub user_data: Option<String>,
    /// References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_refs: Option<Vec<LaunchTemplateInitProviderVpcSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_selector:
        Option<LaunchTemplateInitProviderVpcSecurityGroupIdSelector>,
    /// A list of security group IDs to associate with. Conflicts with network_interfaces.security_groups
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappings {
    /// The name of the device to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub device_name: Option<String>,
    /// Configure EBS volume properties.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ebs: Option<LaunchTemplateInitProviderBlockDeviceMappingsEbs>,
    /// Suppresses the specified device included in the AMI's block device mapping.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noDevice")]
    #[builder(default, setter(strip_option))]
    pub no_device: Option<String>,
    /// The Instance Store Device
    /// Name
    /// (e.g., "ephemeral0").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_name: Option<String>,
}

/// Configure EBS volume properties.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappingsEbs {
    /// Whether the volume should be destroyed on instance termination.
    /// See Preserving Amazon EBS Volumes on Instance Termination for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Enables EBS encryption on the volume.
    /// Cannot be used with snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encrypted: Option<String>,
    /// The amount of provisioned IOPS.
    /// This must be set with a volume_type of "io1/io2/gp3".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
    /// encrypted must be set to true when this is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector:
        Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelector>,
    /// The Snapshot ID to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotId"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_id: Option<String>,
    /// The throughput to provision for a gp3 volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub throughput: Option<f64>,
    /// The size of the volume in gigabytes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_size: Option<f64>,
    /// The volume type.
    /// Can be one of standard, gp2, gp3, io1, io2, sc1 or st1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeType"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_type: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderCapacityReservationSpecification {
    /// Indicates the instance's Capacity Reservation preferences. Can be open or none. (Default none).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_preference: Option<String>,
    /// Used to target a specific Capacity Reservation:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_target:
        Option<LaunchTemplateInitProviderCapacityReservationSpecificationCapacityReservationTarget>,
}

/// Used to target a specific Capacity Reservation:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderCapacityReservationSpecificationCapacityReservationTarget {
    /// The ID of the Capacity Reservation in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationId"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_id: Option<String>,
    /// The ARN of the Capacity Reservation resource group in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_resource_group_arn: Option<String>,
}

/// The CPU options for the instance. See CPU Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderCpuOptions {
    /// Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are enabled and disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amdSevSnp")]
    #[builder(default, setter(strip_option))]
    pub amd_sev_snp: Option<String>,
    /// The number of CPU cores for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreCount")]
    #[builder(default, setter(strip_option))]
    pub core_count: Option<f64>,
    /// The number of threads per CPU core.
    /// To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
    /// Otherwise, specify the default value of 2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "threadsPerCore"
    )]
    #[builder(default, setter(strip_option))]
    pub threads_per_core: Option<f64>,
}

/// Customize the credit specification of the instance. See Credit
/// Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderCreditSpecification {
    /// The credit option for CPU usage.
    /// Can be standard or unlimited.
    /// T3 instances are launched as unlimited by default.
    /// T2 instances are launched as standard by default.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuCredits"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_credits: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderElasticGpuSpecifications {
    /// The Elastic GPU Type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderElasticInferenceAccelerator {
    /// Accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderEnclaveOptions {
    /// If set to true, Nitro Enclaves will be enabled on the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// The hibernation options for the instance. See Hibernation Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderHibernationOptions {
    /// If set to true, the launched EC2 instance will hibernation enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configured: Option<bool>,
}

/// The IAM Instance Profile to launch the instance with. See Instance Profile
/// below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfile {
    /// The Amazon Resource Name (ARN) of the instance profile. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Reference to a InstanceProfile in iam to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default, setter(strip_option))]
    pub arn_ref: Option<LaunchTemplateInitProviderIamInstanceProfileArnRef>,
    /// Selector for a InstanceProfile in iam to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub arn_selector: Option<LaunchTemplateInitProviderIamInstanceProfileArnSelector>,
    /// The name of the instance profile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Reference to a InstanceProfile in iam to populate name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameRef")]
    #[builder(default, setter(strip_option))]
    pub name_ref: Option<LaunchTemplateInitProviderIamInstanceProfileNameRef>,
    /// Selector for a InstanceProfile in iam to populate name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub name_selector: Option<LaunchTemplateInitProviderIamInstanceProfileNameSelector>,
}

/// Reference to a InstanceProfile in iam to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderIamInstanceProfileArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderIamInstanceProfileArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderIamInstanceProfileArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a InstanceProfile in iam to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderIamInstanceProfileNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderIamInstanceProfileNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderIamInstanceProfileNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate name.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderIamInstanceProfileNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The market (purchasing) option for the instance. See Market Options
/// below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceMarketOptions {
    /// The market type. Can be spot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "marketType"
    )]
    #[builder(default, setter(strip_option))]
    pub market_type: Option<String>,
    /// The options for Spot Instance
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_options: Option<LaunchTemplateInitProviderInstanceMarketOptionsSpotOptions>,
}

/// The options for Spot Instance
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceMarketOptionsSpotOptions {
    /// The required duration in minutes. This value must be a multiple of 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDurationMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub block_duration_minutes: Option<f64>,
    /// The behavior when a Spot Instance is interrupted. Can be hibernate,
    /// stop, or terminate. (Default: terminate).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInterruptionBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_interruption_behavior: Option<String>,
    /// The maximum hourly price you're willing to pay for the Spot Instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPrice")]
    #[builder(default, setter(strip_option))]
    pub max_price: Option<String>,
    /// The Spot Instance request type. Can be one-time, or persistent.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_instance_type: Option<String>,
    /// The end date of the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "validUntil"
    )]
    #[builder(default, setter(strip_option))]
    pub valid_until: Option<String>,
}

/// The attribute requirements for the type of instance. If present then instance_type cannot be present.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorCount"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_count: Option<LaunchTemplateInitProviderInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorNames"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTotalMemoryMib"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_total_memory_mib:
        Option<LaunchTemplateInitProviderInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default, setter(strip_option))]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baselineEbsBandwidthMbps"
    )]
    #[builder(default, setter(strip_option))]
    pub baseline_ebs_bandwidth_mbps:
        Option<LaunchTemplateInitProviderInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "burstablePerformance"
    )]
    #[builder(default, setter(strip_option))]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceGenerations"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorageTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage_types: Option<Vec<String>>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with spot_max_price_percentage_over_lowest_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxSpotPriceAsPercentageOfOptimalOnDemandPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub max_spot_price_as_percentage_of_optimal_on_demand_price: Option<f64>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memoryGibPerVcpu"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_gib_per_vcpu: Option<LaunchTemplateInitProviderInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default, setter(strip_option))]
    pub memory_mib: Option<LaunchTemplateInitProviderInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkBandwidthGbps"
    )]
    #[builder(default, setter(strip_option))]
    pub network_bandwidth_gbps:
        Option<LaunchTemplateInitProviderInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceCount"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_count:
        Option<LaunchTemplateInitProviderInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireHibernateSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with max_spot_price_as_percentage_of_optimal_on_demand_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "totalLocalStorageGb"
    )]
    #[builder(default, setter(strip_option))]
    pub total_local_storage_gb:
        Option<LaunchTemplateInitProviderInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default, setter(strip_option))]
    pub vcpu_count: Option<LaunchTemplateInitProviderInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderLicenseSpecification {
    /// ARN of the license configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseConfigurationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub license_configuration_arn: Option<String>,
}

/// The maintenance options for the instance. See Maintenance Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderMaintenanceOptions {
    /// Disables the automatic recovery behavior of your instance or sets it to default. Can be "default" or "disabled". See Recover your instance for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_recovery: Option<String>,
}

/// Customize the metadata options for the instance. See Metadata Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderMetadataOptions {
    /// Whether the metadata service is available. Can be "enabled" or "disabled". (Default: "enabled").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub http_endpoint: Option<String>,
    /// Enables or disables the IPv6 endpoint for the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpProtocolIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub http_protocol_ipv6: Option<String>,
    /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from 1 to 64. (Default: 1).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpPutResponseHopLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub http_put_response_hop_limit: Option<f64>,
    /// Whether or not the metadata service requires session tokens, also referred to as Instance Metadata Service Version 2 (IMDSv2). Can be "optional" or "required". (Default: "optional").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub http_tokens: Option<String>,
    /// Enables or disables access to instance tags from the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMetadataTags"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_metadata_tags: Option<String>,
}

/// The monitoring option for the instance. See Monitoring below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderMonitoring {
    /// If true, the launched EC2 instance will have detailed monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfaces {
    /// Associate a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associateCarrierIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_carrier_ip_address: Option<String>,
    /// Associate a public ip address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associatePublicIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_public_ip_address: Option<String>,
    /// Whether the network interface should be destroyed on instance termination.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Description of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The integer index of the network interface attachment.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub device_index: Option<f64>,
    /// The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "interfaceType"
    )]
    #[builder(default, setter(strip_option))]
    pub interface_type: Option<String>,
    /// The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with ipv4_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_address_count: Option<f64>,
    /// One or more private IPv4 addresses to associate. Conflicts with ipv4_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_addresses: Option<Vec<String>>,
    /// The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with ipv4_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes to be assigned to the network interface. Conflicts with ipv4_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// The number of IPv6 addresses to assign to a network interface. Conflicts with ipv6_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address_count: Option<f64>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with ipv6_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_addresses: Option<Vec<String>>,
    /// The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with ipv6_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes to be assigned to the network interface. Conflicts with ipv6_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefixes: Option<Vec<String>>,
    /// The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkCardIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub network_card_index: Option<f64>,
    /// The ID of the network interface to attach.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceId"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id: Option<String>,
    /// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id_ref:
        Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRef>,
    /// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id_selector:
        Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelector>,
    /// Whether the first IPv6 GUA will be made the primary IPv6 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "primaryIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub primary_ipv6: Option<String>,
    /// The primary private IPv4 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ip_address: Option<String>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_refs:
        Option<Vec<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_selector:
        Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelector>,
    /// A list of security group IDs to associate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// The VPC Subnet ID to associate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_ref: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub subnet_id_selector: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelector>,
}

/// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesNetworkInterfaceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderNetworkInterfacesSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The placement of the instance. See Placement below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderPlacement {
    /// The affinity setting for an instance on a Dedicated Host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub affinity: Option<String>,
    /// The Availability Zone for the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// The name of the placement group for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// The ID of the Dedicated Host for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostId")]
    #[builder(default, setter(strip_option))]
    pub host_id: Option<String>,
    /// The ARN of the Host Resource Group in which to launch instances.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub host_resource_group_arn: Option<String>,
    /// The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionNumber"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_number: Option<f64>,
    /// Reserved for future use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spreadDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub spread_domain: Option<String>,
    /// The tenancy of the instance (if the instance is running in a VPC). Can be default, dedicated, or host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tenancy: Option<String>,
}

/// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderPrivateDnsNameOptions {
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsARecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_a_record: Option<bool>,
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsAaaaRecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_aaaa_record: Option<bool>,
    /// The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: ip-name and resource-name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostnameType"
    )]
    #[builder(default, setter(strip_option))]
    pub hostname_type: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderSecurityGroupNameRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderSecurityGroupNameRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderSecurityGroupNameRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderSecurityGroupNameRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderSecurityGroupNameRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderSecurityGroupNameRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderSecurityGroupNameRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupNames.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderSecurityGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderSecurityGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderSecurityGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderSecurityGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderSecurityGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderSecurityGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderSecurityGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderTagSpecifications {
    /// The type of resource to tag.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
    /// A map of tags to assign to the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderVpcSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderVpcSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderVpcSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateInitProviderVpcSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplateProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplateProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplateProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplateProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplatePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<LaunchTemplatePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<LaunchTemplatePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplatePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<LaunchTemplatePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplatePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<LaunchTemplatePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<LaunchTemplatePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplatePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LaunchTemplatePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplatePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// LaunchTemplateStatus defines the observed state of LaunchTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<LaunchTemplateStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProvider {
    /// Amazon Resource Name (ARN) of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// Specify volumes to attach to the instance besides the volumes specified by the AMI.
    /// See Block Devices below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDeviceMappings"
    )]
    #[builder(default, setter(strip_option))]
    pub block_device_mappings: Option<Vec<LaunchTemplateStatusAtProviderBlockDeviceMappings>>,
    /// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_specification:
        Option<LaunchTemplateStatusAtProviderCapacityReservationSpecification>,
    /// The CPU options for the instance. See CPU Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_options: Option<LaunchTemplateStatusAtProviderCpuOptions>,
    /// Customize the credit specification of the instance. See Credit
    /// Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "creditSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub credit_specification: Option<LaunchTemplateStatusAtProviderCreditSpecification>,
    /// Default Version of the launch template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "defaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub default_version: Option<f64>,
    /// Description of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// If true, enables EC2 Instance Stop Protection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiStop"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_stop: Option<bool>,
    /// If true, enables EC2 Instance
    /// Termination Protection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableApiTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub disable_api_termination: Option<bool>,
    /// If true, the launched EC2 instance will be EBS-optimized.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsOptimized"
    )]
    #[builder(default, setter(strip_option))]
    pub ebs_optimized: Option<String>,
    /// The elastic GPU to attach to the instance. See Elastic GPU
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticGpuSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_gpu_specifications:
        Option<Vec<LaunchTemplateStatusAtProviderElasticGpuSpecifications>>,
    /// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "elasticInferenceAccelerator"
    )]
    #[builder(default, setter(strip_option))]
    pub elastic_inference_accelerator:
        Option<LaunchTemplateStatusAtProviderElasticInferenceAccelerator>,
    /// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enclaveOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub enclave_options: Option<LaunchTemplateStatusAtProviderEnclaveOptions>,
    /// The hibernation options for the instance. See Hibernation Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hibernationOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub hibernation_options: Option<LaunchTemplateStatusAtProviderHibernationOptions>,
    /// The IAM Instance Profile to launch the instance with. See Instance Profile
    /// below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamInstanceProfile"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_instance_profile: Option<LaunchTemplateStatusAtProviderIamInstanceProfile>,
    /// The ID of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The AMI from which to launch the instance or use a Systems Manager parameter convention e.g. resolve:ssm:parameter-name. See docs for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageId")]
    #[builder(default, setter(strip_option))]
    pub image_id: Option<String>,
    /// Shutdown behavior for the instance. Can be stop or terminate.
    /// (Default: stop).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInitiatedShutdownBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_initiated_shutdown_behavior: Option<String>,
    /// The market (purchasing) option for the instance. See Market Options
    /// below for details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMarketOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_market_options: Option<LaunchTemplateStatusAtProviderInstanceMarketOptions>,
    /// The attribute requirements for the type of instance. If present then instance_type cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceRequirements"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_requirements: Option<LaunchTemplateStatusAtProviderInstanceRequirements>,
    /// The type of the instance. If present then instance_requirements cannot be present.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_type: Option<String>,
    /// The kernel ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelId")]
    #[builder(default, setter(strip_option))]
    pub kernel_id: Option<String>,
    /// The key name to use for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default, setter(strip_option))]
    pub key_name: Option<String>,
    /// The latest version of the launch template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "latestVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub latest_version: Option<f64>,
    /// A list of license specifications to associate with. See License Specification below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseSpecification"
    )]
    #[builder(default, setter(strip_option))]
    pub license_specification: Option<Vec<LaunchTemplateStatusAtProviderLicenseSpecification>>,
    /// The maintenance options for the instance. See Maintenance Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maintenanceOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub maintenance_options: Option<LaunchTemplateStatusAtProviderMaintenanceOptions>,
    /// Customize the metadata options for the instance. See Metadata Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metadataOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub metadata_options: Option<LaunchTemplateStatusAtProviderMetadataOptions>,
    /// The monitoring option for the instance. See Monitoring below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub monitoring: Option<LaunchTemplateStatusAtProviderMonitoring>,
    /// The name of the launch template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
    /// Customize network interfaces to be attached at instance boot time. See Network
    /// Interfaces below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaces"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interfaces: Option<Vec<LaunchTemplateStatusAtProviderNetworkInterfaces>>,
    /// The placement of the instance. See Placement below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub placement: Option<LaunchTemplateStatusAtProviderPlacement>,
    /// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateDnsNameOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub private_dns_name_options: Option<LaunchTemplateStatusAtProviderPrivateDnsNameOptions>,
    /// The ID of the RAM disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ramDiskId")]
    #[builder(default, setter(strip_option))]
    pub ram_disk_id: Option<String>,
    /// A list of security group names to associate with. If you are creating Instances in a VPC, use
    /// vpc_security_group_ids instead.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupNames"
    )]
    #[builder(default, setter(strip_option))]
    pub security_group_names: Option<Vec<String>>,
    /// The tags to apply to the resources during launch. See Tag Specifications below for more details. Default tags are currently not propagated to ASG created resources so you may wish to inject your default tags into this variable against the relevant child resource types created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tagSpecifications"
    )]
    #[builder(default, setter(strip_option))]
    pub tag_specifications: Option<Vec<LaunchTemplateStatusAtProviderTagSpecifications>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// Whether to update Default Version each update. Conflicts with default_version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateDefaultVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub update_default_version: Option<bool>,
    /// The base64-encoded user data to provide when launching the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default, setter(strip_option))]
    pub user_data: Option<String>,
    /// A list of security group IDs to associate with. Conflicts with network_interfaces.security_groups
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderBlockDeviceMappings {
    /// The name of the device to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceName"
    )]
    #[builder(default, setter(strip_option))]
    pub device_name: Option<String>,
    /// Configure EBS volume properties.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub ebs: Option<LaunchTemplateStatusAtProviderBlockDeviceMappingsEbs>,
    /// Suppresses the specified device included in the AMI's block device mapping.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noDevice")]
    #[builder(default, setter(strip_option))]
    pub no_device: Option<String>,
    /// The Instance Store Device
    /// Name
    /// (e.g., "ephemeral0").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "virtualName"
    )]
    #[builder(default, setter(strip_option))]
    pub virtual_name: Option<String>,
}

/// Configure EBS volume properties.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderBlockDeviceMappingsEbs {
    /// Whether the volume should be destroyed on instance termination.
    /// See Preserving Amazon EBS Volumes on Instance Termination for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Enables EBS encryption on the volume.
    /// Cannot be used with snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub encrypted: Option<String>,
    /// The amount of provisioned IOPS.
    /// This must be set with a volume_type of "io1/io2/gp3".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
    /// encrypted must be set to true when this is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// The Snapshot ID to mount.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotId"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_id: Option<String>,
    /// The throughput to provision for a gp3 volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub throughput: Option<f64>,
    /// The size of the volume in gigabytes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_size: Option<f64>,
    /// The volume type.
    /// Can be one of standard, gp2, gp3, io1, io2, sc1 or st1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeType"
    )]
    #[builder(default, setter(strip_option))]
    pub volume_type: Option<String>,
}

/// Targeting for EC2 capacity reservations. See Capacity Reservation Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderCapacityReservationSpecification {
    /// Indicates the instance's Capacity Reservation preferences. Can be open or none. (Default none).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationPreference"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_preference: Option<String>,
    /// Used to target a specific Capacity Reservation:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationTarget"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_target: Option<
        LaunchTemplateStatusAtProviderCapacityReservationSpecificationCapacityReservationTarget,
    >,
}

/// Used to target a specific Capacity Reservation:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderCapacityReservationSpecificationCapacityReservationTarget {
    /// The ID of the Capacity Reservation in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationId"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_id: Option<String>,
    /// The ARN of the Capacity Reservation resource group in which to run the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "capacityReservationResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub capacity_reservation_resource_group_arn: Option<String>,
}

/// The CPU options for the instance. See CPU Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderCpuOptions {
    /// Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are enabled and disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amdSevSnp")]
    #[builder(default, setter(strip_option))]
    pub amd_sev_snp: Option<String>,
    /// The number of CPU cores for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreCount")]
    #[builder(default, setter(strip_option))]
    pub core_count: Option<f64>,
    /// The number of threads per CPU core.
    /// To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
    /// Otherwise, specify the default value of 2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "threadsPerCore"
    )]
    #[builder(default, setter(strip_option))]
    pub threads_per_core: Option<f64>,
}

/// Customize the credit specification of the instance. See Credit
/// Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderCreditSpecification {
    /// The credit option for CPU usage.
    /// Can be standard or unlimited.
    /// T3 instances are launched as unlimited by default.
    /// T2 instances are launched as standard by default.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuCredits"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_credits: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderElasticGpuSpecifications {
    /// The Elastic GPU Type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Configuration block containing an Elastic Inference Accelerator to attach to the instance. See Elastic Inference Accelerator below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderElasticInferenceAccelerator {
    /// Accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// Enable Nitro Enclaves on launched instances. See Enclave Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderEnclaveOptions {
    /// If set to true, Nitro Enclaves will be enabled on the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

/// The hibernation options for the instance. See Hibernation Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderHibernationOptions {
    /// If set to true, the launched EC2 instance will hibernation enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub configured: Option<bool>,
}

/// The IAM Instance Profile to launch the instance with. See Instance Profile
/// below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderIamInstanceProfile {
    /// The Amazon Resource Name (ARN) of the instance profile. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// The name of the instance profile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub name: Option<String>,
}

/// The market (purchasing) option for the instance. See Market Options
/// below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceMarketOptions {
    /// The market type. Can be spot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "marketType"
    )]
    #[builder(default, setter(strip_option))]
    pub market_type: Option<String>,
    /// The options for Spot Instance
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotOptions"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_options: Option<LaunchTemplateStatusAtProviderInstanceMarketOptionsSpotOptions>,
}

/// The options for Spot Instance
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceMarketOptionsSpotOptions {
    /// The required duration in minutes. This value must be a multiple of 60.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "blockDurationMinutes"
    )]
    #[builder(default, setter(strip_option))]
    pub block_duration_minutes: Option<f64>,
    /// The behavior when a Spot Instance is interrupted. Can be hibernate,
    /// stop, or terminate. (Default: terminate).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceInterruptionBehavior"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_interruption_behavior: Option<String>,
    /// The maximum hourly price you're willing to pay for the Spot Instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPrice")]
    #[builder(default, setter(strip_option))]
    pub max_price: Option<String>,
    /// The Spot Instance request type. Can be one-time, or persistent.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotInstanceType"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_instance_type: Option<String>,
    /// The end date of the request.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "validUntil"
    )]
    #[builder(default, setter(strip_option))]
    pub valid_until: Option<String>,
}

/// The attribute requirements for the type of instance. If present then instance_type cannot be present.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorCount"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_count:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorNames"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTotalMemoryMib"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_total_memory_mib:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "acceleratorTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default, setter(strip_option))]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baselineEbsBandwidthMbps"
    )]
    #[builder(default, setter(strip_option))]
    pub baseline_ebs_bandwidth_mbps:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "burstablePerformance"
    )]
    #[builder(default, setter(strip_option))]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cpuManufacturers"
    )]
    #[builder(default, setter(strip_option))]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "excludedInstanceTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceGenerations"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localStorageTypes"
    )]
    #[builder(default, setter(strip_option))]
    pub local_storage_types: Option<Vec<String>>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with spot_max_price_percentage_over_lowest_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxSpotPriceAsPercentageOfOptimalOnDemandPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub max_spot_price_as_percentage_of_optimal_on_demand_price: Option<f64>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "memoryGibPerVcpu"
    )]
    #[builder(default, setter(strip_option))]
    pub memory_gib_per_vcpu:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default, setter(strip_option))]
    pub memory_mib: Option<LaunchTemplateStatusAtProviderInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkBandwidthGbps"
    )]
    #[builder(default, setter(strip_option))]
    pub network_bandwidth_gbps:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceCount"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_count:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "onDemandMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "requireHibernateSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with max_spot_price_as_percentage_of_optimal_on_demand_price
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spotMaxPricePercentageOverLowestPrice"
    )]
    #[builder(default, setter(strip_option))]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "totalLocalStorageGb"
    )]
    #[builder(default, setter(strip_option))]
    pub total_local_storage_gb:
        Option<LaunchTemplateStatusAtProviderInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default, setter(strip_option))]
    pub vcpu_count: Option<LaunchTemplateStatusAtProviderInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub min: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderLicenseSpecification {
    /// ARN of the license configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "licenseConfigurationArn"
    )]
    #[builder(default, setter(strip_option))]
    pub license_configuration_arn: Option<String>,
}

/// The maintenance options for the instance. See Maintenance Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderMaintenanceOptions {
    /// Disables the automatic recovery behavior of your instance or sets it to default. Can be "default" or "disabled". See Recover your instance for more details.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoRecovery"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_recovery: Option<String>,
}

/// Customize the metadata options for the instance. See Metadata Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderMetadataOptions {
    /// Whether the metadata service is available. Can be "enabled" or "disabled". (Default: "enabled").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub http_endpoint: Option<String>,
    /// Enables or disables the IPv6 endpoint for the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpProtocolIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub http_protocol_ipv6: Option<String>,
    /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from 1 to 64. (Default: 1).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpPutResponseHopLimit"
    )]
    #[builder(default, setter(strip_option))]
    pub http_put_response_hop_limit: Option<f64>,
    /// Whether or not the metadata service requires session tokens, also referred to as Instance Metadata Service Version 2 (IMDSv2). Can be "optional" or "required". (Default: "optional").
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpTokens"
    )]
    #[builder(default, setter(strip_option))]
    pub http_tokens: Option<String>,
    /// Enables or disables access to instance tags from the instance metadata service. Can be "enabled" or "disabled".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceMetadataTags"
    )]
    #[builder(default, setter(strip_option))]
    pub instance_metadata_tags: Option<String>,
}

/// The monitoring option for the instance. See Monitoring below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderMonitoring {
    /// If true, the launched EC2 instance will have detailed monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderNetworkInterfaces {
    /// Associate a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associateCarrierIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_carrier_ip_address: Option<String>,
    /// Associate a public ip address with the network interface. Boolean value, can be left unset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "associatePublicIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub associate_public_ip_address: Option<String>,
    /// Whether the network interface should be destroyed on instance termination.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteOnTermination"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_on_termination: Option<String>,
    /// Description of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The integer index of the network interface attachment.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deviceIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub device_index: Option<f64>,
    /// The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "interfaceType"
    )]
    #[builder(default, setter(strip_option))]
    pub interface_type: Option<String>,
    /// The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with ipv4_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_address_count: Option<f64>,
    /// One or more private IPv4 addresses to associate. Conflicts with ipv4_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_addresses: Option<Vec<String>>,
    /// The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with ipv4_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes to be assigned to the network interface. Conflicts with ipv4_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv4Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// The number of IPv6 addresses to assign to a network interface. Conflicts with ipv6_addresses
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6AddressCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_address_count: Option<f64>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with ipv6_address_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Addresses"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_addresses: Option<Vec<String>>,
    /// The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with ipv6_prefixes
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6PrefixCount"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes to be assigned to the network interface. Conflicts with ipv6_prefix_count
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipv6Prefixes"
    )]
    #[builder(default, setter(strip_option))]
    pub ipv6_prefixes: Option<Vec<String>>,
    /// The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkCardIndex"
    )]
    #[builder(default, setter(strip_option))]
    pub network_card_index: Option<f64>,
    /// The ID of the network interface to attach.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkInterfaceId"
    )]
    #[builder(default, setter(strip_option))]
    pub network_interface_id: Option<String>,
    /// Whether the first IPv6 GUA will be made the primary IPv6 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "primaryIpv6"
    )]
    #[builder(default, setter(strip_option))]
    pub primary_ipv6: Option<String>,
    /// The primary private IPv4 address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateIpAddress"
    )]
    #[builder(default, setter(strip_option))]
    pub private_ip_address: Option<String>,
    /// A list of security group IDs to associate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default, setter(strip_option))]
    pub security_groups: Option<Vec<String>>,
    /// The VPC Subnet ID to associate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default, setter(strip_option))]
    pub subnet_id: Option<String>,
}

/// The placement of the instance. See Placement below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderPlacement {
    /// The affinity setting for an instance on a Dedicated Host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub affinity: Option<String>,
    /// The Availability Zone for the instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZone"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zone: Option<String>,
    /// The name of the placement group for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupName")]
    #[builder(default, setter(strip_option))]
    pub group_name: Option<String>,
    /// The ID of the Dedicated Host for the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostId")]
    #[builder(default, setter(strip_option))]
    pub host_id: Option<String>,
    /// The ARN of the Host Resource Group in which to launch instances.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostResourceGroupArn"
    )]
    #[builder(default, setter(strip_option))]
    pub host_resource_group_arn: Option<String>,
    /// The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partitionNumber"
    )]
    #[builder(default, setter(strip_option))]
    pub partition_number: Option<f64>,
    /// Reserved for future use.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "spreadDomain"
    )]
    #[builder(default, setter(strip_option))]
    pub spread_domain: Option<String>,
    /// The tenancy of the instance (if the instance is running in a VPC). Can be default, dedicated, or host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tenancy: Option<String>,
}

/// The options for the instance hostname. The default values are inherited from the subnet. See Private DNS Name Options below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderPrivateDnsNameOptions {
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsARecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_a_record: Option<bool>,
    /// Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableResourceNameDnsAaaaRecord"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_resource_name_dns_aaaa_record: Option<bool>,
    /// The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: ip-name and resource-name.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostnameType"
    )]
    #[builder(default, setter(strip_option))]
    pub hostname_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct LaunchTemplateStatusAtProviderTagSpecifications {
    /// The type of resource to tag.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceType"
    )]
    #[builder(default, setter(strip_option))]
    pub resource_type: Option<String>,
    /// A map of tags to assign to the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}
