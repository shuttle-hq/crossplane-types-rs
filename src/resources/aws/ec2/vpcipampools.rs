// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// VPCIpamPoolSpec defines the desired state of VPCIpamPool
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "ec2.aws.upbound.io",
    version = "v1beta1",
    kind = "VPCIpamPool",
    plural = "vpcipampools"
)]
#[kube(status = "VPCIpamPoolStatus")]
pub struct VPCIpamPoolSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<VPCIpamPoolDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: VPCIpamPoolForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<VPCIpamPoolInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<VPCIpamPoolProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<VPCIpamPoolPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<VPCIpamPoolWriteConnectionSecretToRef>,
}

/// VPCIpamPoolSpec defines the desired state of VPCIpamPool
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProvider {
    /// The IP protocol assigned to this pool. You must choose either IPv4 or IPv6 protocol for a pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressFamily"
    )]
    #[builder(default, setter(strip_option))]
    pub address_family: Option<String>,
    /// A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16 (unless you provide a different netmask value when you create the new allocation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationDefaultNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_default_netmask_length: Option<f64>,
    /// The maximum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMaxNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_max_netmask_length: Option<f64>,
    /// The minimum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMinNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_min_netmask_length: Option<f64>,
    /// Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationResourceTags"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_resource_tags: Option<BTreeMap<String, String>>,
    /// If you include this argument, IPAM automatically imports any VPCs you have in your scope that fall
    /// within the CIDR range in the pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoImport"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_import: Option<bool>,
    /// Limits which AWS service the pool can be used in. Only useable on public scopes. Valid Values: ec2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsService"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_service: Option<String>,
    /// Enables you to quickly delete an IPAM pool and all resources within that pool, including provisioned CIDRs, allocations, and other pools.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub cascade: Option<bool>,
    /// A description for the IPAM pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The ID of the scope in which you would like to create the IPAM pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeId"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id: Option<String>,
    /// Reference to a VPCIpamScope in ec2 to populate ipamScopeId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id_ref: Option<VPCIpamPoolForProviderIpamScopeIdRef>,
    /// Selector for a VPCIpamScope in ec2 to populate ipamScopeId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id_selector: Option<VPCIpamPoolForProviderIpamScopeIdSelector>,
    /// The locale in which you would like to create the IPAM pool. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. Possible values: Any AWS region, such as us-east-1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub locale: Option<String>,
    /// The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Valid values are byoip or amazon. Default is byoip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicIpSource"
    )]
    #[builder(default, setter(strip_option))]
    pub public_ip_source: Option<String>,
    /// Defines whether or not IPv6 pool space is publicly advertisable over the internet. This argument is required if address_family = "ipv6" and public_ip_source = "byoip", default is false. This option is not available for IPv4 pool space or if public_ip_source = "amazon". Setting this argument to true when it is not available may result in erroneous differences being reported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAdvertisable"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_advertisable: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The ID of the source IPAM pool. Use this argument to create a child pool within an existing pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id: Option<String>,
    /// Reference to a VPCIpamPool in ec2 to populate sourceIpamPoolId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id_ref: Option<VPCIpamPoolForProviderSourceIpamPoolIdRef>,
    /// Selector for a VPCIpamPool in ec2 to populate sourceIpamPoolId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id_selector: Option<VPCIpamPoolForProviderSourceIpamPoolIdSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Reference to a VPCIpamScope in ec2 to populate ipamScopeId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderIpamScopeIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolForProviderIpamScopeIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderIpamScopeIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolForProviderIpamScopeIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolForProviderIpamScopeIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderIpamScopeIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderIpamScopeIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCIpamScope in ec2 to populate ipamScopeId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderIpamScopeIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolForProviderIpamScopeIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderIpamScopeIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolForProviderIpamScopeIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolForProviderIpamScopeIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderIpamScopeIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderIpamScopeIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCIpamPool in ec2 to populate sourceIpamPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderSourceIpamPoolIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolForProviderSourceIpamPoolIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderSourceIpamPoolIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolForProviderSourceIpamPoolIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolForProviderSourceIpamPoolIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderSourceIpamPoolIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderSourceIpamPoolIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCIpamPool in ec2 to populate sourceIpamPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderSourceIpamPoolIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolForProviderSourceIpamPoolIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProvider {
    /// The IP protocol assigned to this pool. You must choose either IPv4 or IPv6 protocol for a pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressFamily"
    )]
    #[builder(default, setter(strip_option))]
    pub address_family: Option<String>,
    /// A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16 (unless you provide a different netmask value when you create the new allocation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationDefaultNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_default_netmask_length: Option<f64>,
    /// The maximum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMaxNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_max_netmask_length: Option<f64>,
    /// The minimum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMinNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_min_netmask_length: Option<f64>,
    /// Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationResourceTags"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_resource_tags: Option<BTreeMap<String, String>>,
    /// If you include this argument, IPAM automatically imports any VPCs you have in your scope that fall
    /// within the CIDR range in the pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoImport"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_import: Option<bool>,
    /// Limits which AWS service the pool can be used in. Only useable on public scopes. Valid Values: ec2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsService"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_service: Option<String>,
    /// Enables you to quickly delete an IPAM pool and all resources within that pool, including provisioned CIDRs, allocations, and other pools.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub cascade: Option<bool>,
    /// A description for the IPAM pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The ID of the scope in which you would like to create the IPAM pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeId"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id: Option<String>,
    /// Reference to a VPCIpamScope in ec2 to populate ipamScopeId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id_ref: Option<VPCIpamPoolInitProviderIpamScopeIdRef>,
    /// Selector for a VPCIpamScope in ec2 to populate ipamScopeId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id_selector: Option<VPCIpamPoolInitProviderIpamScopeIdSelector>,
    /// The locale in which you would like to create the IPAM pool. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. Possible values: Any AWS region, such as us-east-1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub locale: Option<String>,
    /// The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Valid values are byoip or amazon. Default is byoip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicIpSource"
    )]
    #[builder(default, setter(strip_option))]
    pub public_ip_source: Option<String>,
    /// Defines whether or not IPv6 pool space is publicly advertisable over the internet. This argument is required if address_family = "ipv6" and public_ip_source = "byoip", default is false. This option is not available for IPv4 pool space or if public_ip_source = "amazon". Setting this argument to true when it is not available may result in erroneous differences being reported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAdvertisable"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_advertisable: Option<bool>,
    /// The ID of the source IPAM pool. Use this argument to create a child pool within an existing pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id: Option<String>,
    /// Reference to a VPCIpamPool in ec2 to populate sourceIpamPoolId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id_ref: Option<VPCIpamPoolInitProviderSourceIpamPoolIdRef>,
    /// Selector for a VPCIpamPool in ec2 to populate sourceIpamPoolId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id_selector: Option<VPCIpamPoolInitProviderSourceIpamPoolIdSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Reference to a VPCIpamScope in ec2 to populate ipamScopeId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderIpamScopeIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolInitProviderIpamScopeIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderIpamScopeIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolInitProviderIpamScopeIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolInitProviderIpamScopeIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderIpamScopeIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderIpamScopeIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCIpamScope in ec2 to populate ipamScopeId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderIpamScopeIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolInitProviderIpamScopeIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderIpamScopeIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolInitProviderIpamScopeIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolInitProviderIpamScopeIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderIpamScopeIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderIpamScopeIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCIpamPool in ec2 to populate sourceIpamPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderSourceIpamPoolIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderSourceIpamPoolIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCIpamPool in ec2 to populate sourceIpamPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderSourceIpamPoolIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolInitProviderSourceIpamPoolIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<VPCIpamPoolPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<VPCIpamPoolPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<VPCIpamPoolPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<VPCIpamPoolPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<VPCIpamPoolPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum VPCIpamPoolPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// VPCIpamPoolStatus defines the observed state of VPCIpamPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<VPCIpamPoolStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct VPCIpamPoolStatusAtProvider {
    /// The IP protocol assigned to this pool. You must choose either IPv4 or IPv6 protocol for a pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "addressFamily"
    )]
    #[builder(default, setter(strip_option))]
    pub address_family: Option<String>,
    /// A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16 (unless you provide a different netmask value when you create the new allocation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationDefaultNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_default_netmask_length: Option<f64>,
    /// The maximum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMaxNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_max_netmask_length: Option<f64>,
    /// The minimum netmask length that will be required for CIDR allocations in this pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationMinNetmaskLength"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_min_netmask_length: Option<f64>,
    /// Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocationResourceTags"
    )]
    #[builder(default, setter(strip_option))]
    pub allocation_resource_tags: Option<BTreeMap<String, String>>,
    /// Amazon Resource Name (ARN) of IPAM
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// If you include this argument, IPAM automatically imports any VPCs you have in your scope that fall
    /// within the CIDR range in the pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoImport"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_import: Option<bool>,
    /// Limits which AWS service the pool can be used in. Only useable on public scopes. Valid Values: ec2.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "awsService"
    )]
    #[builder(default, setter(strip_option))]
    pub aws_service: Option<String>,
    /// Enables you to quickly delete an IPAM pool and all resources within that pool, including provisioned CIDRs, allocations, and other pools.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub cascade: Option<bool>,
    /// A description for the IPAM pool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub description: Option<String>,
    /// The ID of the IPAM
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// The ID of the scope in which you would like to create the IPAM pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeId"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_id: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ipamScopeType"
    )]
    #[builder(default, setter(strip_option))]
    pub ipam_scope_type: Option<String>,
    /// The locale in which you would like to create the IPAM pool. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. Possible values: Any AWS region, such as us-east-1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub locale: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "poolDepth")]
    #[builder(default, setter(strip_option))]
    pub pool_depth: Option<f64>,
    /// The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Valid values are byoip or amazon. Default is byoip.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicIpSource"
    )]
    #[builder(default, setter(strip_option))]
    pub public_ip_source: Option<String>,
    /// Defines whether or not IPv6 pool space is publicly advertisable over the internet. This argument is required if address_family = "ipv6" and public_ip_source = "byoip", default is false. This option is not available for IPv4 pool space or if public_ip_source = "amazon". Setting this argument to true when it is not available may result in erroneous differences being reported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publiclyAdvertisable"
    )]
    #[builder(default, setter(strip_option))]
    pub publicly_advertisable: Option<bool>,
    /// The ID of the source IPAM pool. Use this argument to create a child pool within an existing pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceIpamPoolId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_ipam_pool_id: Option<String>,
    /// The ID of the IPAM
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub state: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
}
