// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "rds.aws.upbound.io",
    version = "v1beta2",
    kind = "Cluster",
    plural = "clusters"
)]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProvider {
    /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocatedStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub allocated_storage: Option<f64>,
    /// Enable to allow major engine version upgrades when changing engine versions. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowMajorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_major_version_upgrade: Option<bool>,
    /// Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// If true, the password will be auto-generated and stored in the Secret referenced by the masterPasswordSecretRef field.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoGeneratePassword"
    )]
    #[builder(default, setter(strip_option))]
    pub auto_generate_password: Option<bool>,
    /// List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created.
    /// We recommend specifying 3 AZs or using the  if necessary.
    /// A maximum of 3 AZs can be configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zones: Option<Vec<String>>,
    /// Target backtrack window, in seconds. Only available for aurora and aurora-mysql engines currently. To disable backtracking, set this value to 0. Defaults to 0. Must be between 0 and 259200 (72 hours)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backtrackWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub backtrack_window: Option<f64>,
    /// Days to retain backups for. Default 1
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub backup_retention_period: Option<f64>,
    /// The CA certificate identifier to use for the DB cluster's server certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caCertificateIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub ca_certificate_identifier: Option<String>,
    /// – List of RDS Instances that are a part of this cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMembers"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_members: Option<Vec<String>>,
    /// –  Copy all Cluster tags to snapshots. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "copyTagsToSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub copy_tags_to_snapshot: Option<bool>,
    /// Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: RDS Naming Constraints
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterInstanceClass"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_instance_class: Option<String>,
    /// A cluster parameter group to associate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name: Option<String>,
    /// Reference to a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name_ref:
        Option<ClusterForProviderDbClusterParameterGroupNameRef>,
    /// Selector for a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name_selector:
        Option<ClusterForProviderDbClusterParameterGroupNameSelector>,
    /// Instance parameter group to associate with all instances of the DB cluster. The db_instance_parameter_group_name parameter is only valid in combination with the allow_major_version_upgrade parameter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name: Option<String>,
    /// Reference to a ParameterGroup in rds to populate dbInstanceParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name_ref:
        Option<ClusterForProviderDbInstanceParameterGroupNameRef>,
    /// Selector for a ParameterGroup in rds to populate dbInstanceParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name_selector:
        Option<ClusterForProviderDbInstanceParameterGroupNameSelector>,
    /// DB subnet group to associate with this DB cluster.
    /// NOTE: This must match the db_subnet_group_name specified on every aws_rds_cluster_instance in the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in rds to populate dbSubnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name_ref: Option<ClusterForProviderDbSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in rds to populate dbSubnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name_selector: Option<ClusterForProviderDbSubnetGroupNameSelector>,
    /// For use with RDS Custom.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSystemId"
    )]
    #[builder(default, setter(strip_option))]
    pub db_system_id: Option<String>,
    /// Specifies whether to remove automated backups immediately after the DB cluster is deleted. Default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteAutomatedBackups"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_automated_backups: Option<bool>,
    /// If the DB cluster should have deletion protection enabled.
    /// The database can't be deleted when this value is set to true.
    /// The default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<bool>,
    /// The ID of the Directory Service Active Directory domain to create the cluster in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The name of the IAM role to be used when making API calls to the Directory Service.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainIamRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_iam_role_name: Option<String>,
    /// Whether cluster should forward writes to an associated global cluster. Applied to secondary clusters to enable them to forward writes to an aws_rds_global_cluster's primary cluster. See the User Guide for Aurora for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableGlobalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_global_write_forwarding: Option<bool>,
    /// Enable HTTP endpoint (data API). Only valid for some combinations of engine_mode, engine and engine_version and only available in some regions. See the Region and version availability section of the documentation. This option also does not work with any of these options specified: snapshot_identifier, replication_source_identifier, s3_import.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http_endpoint: Option<bool>,
    /// Whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances.. See the User Guide for Aurora for more information. NOTE: Local write forwarding requires Aurora MySQL version 3.04 or higher.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableLocalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_local_write_forwarding: Option<bool>,
    /// Set of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, error, general, slowquery, postgresql (PostgreSQL).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledCloudwatchLogsExports"
    )]
    #[builder(default, setter(strip_option))]
    pub enabled_cloudwatch_logs_exports: Option<Vec<String>>,
    /// Name of the database engine to be used for this DB cluster. Valid Values: aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// The life cycle type for this DB instance. This setting is valid for cluster types Aurora DB clusters and Multi-AZ DB clusters. Valid values are open-source-rds-extended-support, open-source-rds-extended-support-disabled. Default value is open-source-rds-extended-support. [Using Amazon RDS Extended Support]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/extended-support.html
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineLifecycleSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_lifecycle_support: Option<String>,
    /// Database engine mode. Valid values: global (only valid for Aurora MySQL 1.21 and earlier), parallelquery, provisioned, serverless. Defaults to: provisioned. See the RDS User Guide for limitations when using serverless.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineMode"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_mode: Option<String>,
    /// Database engine version. Updating this argument results in an outage. See the Aurora MySQL and Aurora Postgres documentation for your configured engine to determine this value, or by running aws rds describe-db-engine-versions. For example with Aurora MySQL 2, a potential value for this argument is 5.7.mysql_aurora.2.03.2. The value can contain a partial version where supported by the API. The actual engine version used is returned in the attribute engine_version_actual, , see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// Global cluster identifier specified on aws_rds_global_cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub global_cluster_identifier: Option<String>,
    /// Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. Please see AWS Documentation for availability and limitations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamDatabaseAuthenticationEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_database_authentication_enabled: Option<bool>,
    /// Amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see Amazon RDS Provisioned IOPS storage to improve performance in the Amazon RDS User Guide. (This setting is required to create a Multi-AZ DB cluster). Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// ARN for the KMS encryption key. When specifying kms_key_id, storage_encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<ClusterForProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<ClusterForProviderKmsKeyIdSelector>,
    /// Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if master_password is provided.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "manageMasterUserPassword"
    )]
    #[builder(default, setter(strip_option))]
    pub manage_master_user_password: Option<bool>,
    /// Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
    /// Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub master_password_secret_ref: Option<ClusterForProviderMasterPasswordSecretRef>,
    /// Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If not specified, the default KMS key for your Amazon Web Services account is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate masterUserSecretKmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id_ref: Option<ClusterForProviderMasterUserSecretKmsKeyIdRef>,
    /// Selector for a Key in kms to populate masterUserSecretKmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id_selector:
        Option<ClusterForProviderMasterUserSecretKmsKeyIdSelector>,
    /// Username for the master DB user. Please refer to the RDS Naming Constraints. This argument does not support in-place updates and cannot be changed during a restore from snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub master_username: Option<String>,
    /// Network type of the cluster. Valid values: IPV4, DUAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Enables Performance Insights for the RDS Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_enabled: Option<bool>,
    /// Specifies the KMS Key ID to encrypt Performance Insights data. If not specified, the default RDS KMS key will be used (aws/rds).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_kms_key_id: Option<String>,
    /// Specifies the amount of time to retain performance insights data for. Defaults to 7 days if Performance Insights are enabled. Valid values are 7, month * 31 (where month is a number of months from 1-23), and 731. See here for more information on retention periods.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_retention_period: Option<f64>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per region, e.g. 04:00-09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredBackupWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_backup_window: Option<String>,
    /// Weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredMaintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_maintenance_window: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica. Note: Removing this attribute after creation will promote the read replica to a standalone cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationSourceIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_source_identifier: Option<String>,
    /// Nested attribute for point in time restore. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToPointInTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_point_in_time: Option<ClusterForProviderRestoreToPointInTime>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Import")]
    #[builder(default, setter(strip_option))]
    pub s3_import: Option<ClusterForProviderS3Import>,
    /// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub scaling_configuration: Option<ClusterForProviderScalingConfiguration>,
    /// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverlessv2ScalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub serverlessv2_scaling_configuration:
        Option<ClusterForProviderServerlessv2ScalingConfiguration>,
    /// Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipFinalSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_final_snapshot: Option<bool>,
    /// Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot. Conflicts with global_cluster_identifier. Clusters cannot be restored from snapshot and joined to an existing global cluster in a single operation. See the AWS documentation or the Global Cluster Restored From Snapshot example for instructions on building a global cluster starting with a snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_identifier: Option<String>,
    /// The source region for an encrypted replica DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_region: Option<String>,
    /// Specifies whether the DB cluster is encrypted. The default is false for provisioned engine_mode and true for serverless engine_mode. When restoring an unencrypted snapshot_identifier, the kms_key_id argument must be provided to encrypt the restored cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageEncrypted"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_encrypted: Option<bool>,
    /// (Forces new for Multi-AZ DB clusters) Specifies the storage type to be associated with the DB cluster. For Aurora DB clusters, storage_type modifications can be done in-place. For Multi-AZ DB Clusters, the iops argument must also be set. Valid values are: "", aurora-iopt1 (Aurora DB Clusters); io1, io2 (Multi-AZ DB Clusters). Default: "" (Aurora DB Clusters); io1 (Multi-AZ DB Clusters).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_refs: Option<Vec<ClusterForProviderVpcSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_selector: Option<ClusterForProviderVpcSecurityGroupIdSelector>,
    /// List of VPC security groups to associate with the Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

/// Reference to a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbClusterParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbClusterParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbClusterParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbClusterParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbClusterParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbClusterParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbClusterParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbClusterParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbClusterParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbClusterParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbClusterParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbClusterParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbClusterParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbClusterParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ParameterGroup in rds to populate dbInstanceParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbInstanceParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbInstanceParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbInstanceParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbInstanceParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbInstanceParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbInstanceParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbInstanceParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ParameterGroup in rds to populate dbInstanceParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbInstanceParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbInstanceParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbInstanceParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbInstanceParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbInstanceParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbInstanceParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbInstanceParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in rds to populate dbSubnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in rds to populate dbSubnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderDbSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderDbSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderDbSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderDbSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderDbSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
/// Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderMasterPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Key in kms to populate masterUserSecretKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderMasterUserSecretKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderMasterUserSecretKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderMasterUserSecretKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderMasterUserSecretKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderMasterUserSecretKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderMasterUserSecretKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderMasterUserSecretKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate masterUserSecretKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderMasterUserSecretKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Nested attribute for point in time restore. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderRestoreToPointInTime {
    /// Date and time in UTC format to restore the database cluster to. Conflicts with use_latest_restorable_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_time: Option<String>,
    /// Type of restore to be performed.
    /// Valid options are full-copy (default) and copy-on-write.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreType"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_type: Option<String>,
    /// Identifier of the source database cluster from which to restore. When restoring from a cluster in another AWS account, the identifier is the ARN of that cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier: Option<String>,
    /// Reference to a Cluster in rds to populate sourceClusterIdentifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifierRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier_ref:
        Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRef>,
    /// Selector for a Cluster in rds to populate sourceClusterIdentifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifierSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier_selector:
        Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelector>,
    /// Cluster resource ID of the source database cluster from which to restore. To be used for restoring a deleted cluster in the same account which still has a retained automatic backup available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterResourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_resource_id: Option<String>,
    /// Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with restore_to_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLatestRestorableTime"
    )]
    #[builder(default, setter(strip_option))]
    pub use_latest_restorable_time: Option<bool>,
}

/// Reference to a Cluster in rds to populate sourceClusterIdentifier.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in rds to populate sourceClusterIdentifier.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Port on which the DB accepts connections.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderS3Import {
    /// Bucket name where your backup is stored
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name_ref: Option<ClusterForProviderS3ImportBucketNameRef>,
    /// Selector for a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name_selector: Option<ClusterForProviderS3ImportBucketNameSelector>,
    /// Can be blank, but is the path to your backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_prefix: Option<String>,
    /// Role applied to load the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ingestionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ingestion_role: Option<String>,
    /// Source engine for the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngine"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine: Option<String>,
    /// Version of the source engine used to make the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine_version: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderS3ImportBucketNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderS3ImportBucketNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderS3ImportBucketNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderS3ImportBucketNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderS3ImportBucketNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderS3ImportBucketNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderS3ImportBucketNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderS3ImportBucketNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderS3ImportBucketNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderS3ImportBucketNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderS3ImportBucketNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderS3ImportBucketNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderS3ImportBucketNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderS3ImportBucketNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderScalingConfiguration {
    /// Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoPause")]
    #[builder(default, setter(strip_option))]
    pub auto_pause: Option<bool>,
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. Valid values are 60 through 600. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsBeforeTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_before_timeout: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
    /// Action to take when the timeout is reached. Valid values: ForceApplyCapacityChange, RollbackCapacityChange. Defaults to RollbackCapacityChange. See documentation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutAction"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_action: Option<String>,
}

/// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderServerlessv2ScalingConfiguration {
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderVpcSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderVpcSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderVpcSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderVpcSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderVpcSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderVpcSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderVpcSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderVpcSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterForProviderVpcSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterForProviderVpcSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterForProviderVpcSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterForProviderVpcSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderVpcSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderVpcSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProvider {
    /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocatedStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub allocated_storage: Option<f64>,
    /// Enable to allow major engine version upgrades when changing engine versions. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowMajorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_major_version_upgrade: Option<bool>,
    /// Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created.
    /// We recommend specifying 3 AZs or using the  if necessary.
    /// A maximum of 3 AZs can be configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zones: Option<Vec<String>>,
    /// Target backtrack window, in seconds. Only available for aurora and aurora-mysql engines currently. To disable backtracking, set this value to 0. Defaults to 0. Must be between 0 and 259200 (72 hours)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backtrackWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub backtrack_window: Option<f64>,
    /// Days to retain backups for. Default 1
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub backup_retention_period: Option<f64>,
    /// The CA certificate identifier to use for the DB cluster's server certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caCertificateIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub ca_certificate_identifier: Option<String>,
    /// – List of RDS Instances that are a part of this cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMembers"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_members: Option<Vec<String>>,
    /// –  Copy all Cluster tags to snapshots. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "copyTagsToSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub copy_tags_to_snapshot: Option<bool>,
    /// Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: RDS Naming Constraints
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterInstanceClass"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_instance_class: Option<String>,
    /// A cluster parameter group to associate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name: Option<String>,
    /// Reference to a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name_ref:
        Option<ClusterInitProviderDbClusterParameterGroupNameRef>,
    /// Selector for a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name_selector:
        Option<ClusterInitProviderDbClusterParameterGroupNameSelector>,
    /// Instance parameter group to associate with all instances of the DB cluster. The db_instance_parameter_group_name parameter is only valid in combination with the allow_major_version_upgrade parameter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name: Option<String>,
    /// Reference to a ParameterGroup in rds to populate dbInstanceParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name_ref:
        Option<ClusterInitProviderDbInstanceParameterGroupNameRef>,
    /// Selector for a ParameterGroup in rds to populate dbInstanceParameterGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name_selector:
        Option<ClusterInitProviderDbInstanceParameterGroupNameSelector>,
    /// DB subnet group to associate with this DB cluster.
    /// NOTE: This must match the db_subnet_group_name specified on every aws_rds_cluster_instance in the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name: Option<String>,
    /// Reference to a SubnetGroup in rds to populate dbSubnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name_ref: Option<ClusterInitProviderDbSubnetGroupNameRef>,
    /// Selector for a SubnetGroup in rds to populate dbSubnetGroupName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name_selector: Option<ClusterInitProviderDbSubnetGroupNameSelector>,
    /// For use with RDS Custom.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSystemId"
    )]
    #[builder(default, setter(strip_option))]
    pub db_system_id: Option<String>,
    /// Specifies whether to remove automated backups immediately after the DB cluster is deleted. Default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteAutomatedBackups"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_automated_backups: Option<bool>,
    /// If the DB cluster should have deletion protection enabled.
    /// The database can't be deleted when this value is set to true.
    /// The default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<bool>,
    /// The ID of the Directory Service Active Directory domain to create the cluster in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The name of the IAM role to be used when making API calls to the Directory Service.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainIamRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_iam_role_name: Option<String>,
    /// Whether cluster should forward writes to an associated global cluster. Applied to secondary clusters to enable them to forward writes to an aws_rds_global_cluster's primary cluster. See the User Guide for Aurora for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableGlobalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_global_write_forwarding: Option<bool>,
    /// Enable HTTP endpoint (data API). Only valid for some combinations of engine_mode, engine and engine_version and only available in some regions. See the Region and version availability section of the documentation. This option also does not work with any of these options specified: snapshot_identifier, replication_source_identifier, s3_import.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http_endpoint: Option<bool>,
    /// Whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances.. See the User Guide for Aurora for more information. NOTE: Local write forwarding requires Aurora MySQL version 3.04 or higher.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableLocalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_local_write_forwarding: Option<bool>,
    /// Set of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, error, general, slowquery, postgresql (PostgreSQL).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledCloudwatchLogsExports"
    )]
    #[builder(default, setter(strip_option))]
    pub enabled_cloudwatch_logs_exports: Option<Vec<String>>,
    /// Name of the database engine to be used for this DB cluster. Valid Values: aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// The life cycle type for this DB instance. This setting is valid for cluster types Aurora DB clusters and Multi-AZ DB clusters. Valid values are open-source-rds-extended-support, open-source-rds-extended-support-disabled. Default value is open-source-rds-extended-support. [Using Amazon RDS Extended Support]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/extended-support.html
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineLifecycleSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_lifecycle_support: Option<String>,
    /// Database engine mode. Valid values: global (only valid for Aurora MySQL 1.21 and earlier), parallelquery, provisioned, serverless. Defaults to: provisioned. See the RDS User Guide for limitations when using serverless.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineMode"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_mode: Option<String>,
    /// Database engine version. Updating this argument results in an outage. See the Aurora MySQL and Aurora Postgres documentation for your configured engine to determine this value, or by running aws rds describe-db-engine-versions. For example with Aurora MySQL 2, a potential value for this argument is 5.7.mysql_aurora.2.03.2. The value can contain a partial version where supported by the API. The actual engine version used is returned in the attribute engine_version_actual, , see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// Global cluster identifier specified on aws_rds_global_cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub global_cluster_identifier: Option<String>,
    /// Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. Please see AWS Documentation for availability and limitations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamDatabaseAuthenticationEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_database_authentication_enabled: Option<bool>,
    /// Amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see Amazon RDS Provisioned IOPS storage to improve performance in the Amazon RDS User Guide. (This setting is required to create a Multi-AZ DB cluster). Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// ARN for the KMS encryption key. When specifying kms_key_id, storage_encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_ref: Option<ClusterInitProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub kms_key_id_selector: Option<ClusterInitProviderKmsKeyIdSelector>,
    /// Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if master_password is provided.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "manageMasterUserPassword"
    )]
    #[builder(default, setter(strip_option))]
    pub manage_master_user_password: Option<bool>,
    /// Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
    /// Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterPasswordSecretRef"
    )]
    #[builder(default, setter(strip_option))]
    pub master_password_secret_ref: Option<ClusterInitProviderMasterPasswordSecretRef>,
    /// Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If not specified, the default KMS key for your Amazon Web Services account is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate masterUserSecretKmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyIdRef"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id_ref: Option<ClusterInitProviderMasterUserSecretKmsKeyIdRef>,
    /// Selector for a Key in kms to populate masterUserSecretKmsKeyId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id_selector:
        Option<ClusterInitProviderMasterUserSecretKmsKeyIdSelector>,
    /// Username for the master DB user. Please refer to the RDS Naming Constraints. This argument does not support in-place updates and cannot be changed during a restore from snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub master_username: Option<String>,
    /// Network type of the cluster. Valid values: IPV4, DUAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Enables Performance Insights for the RDS Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_enabled: Option<bool>,
    /// Specifies the KMS Key ID to encrypt Performance Insights data. If not specified, the default RDS KMS key will be used (aws/rds).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_kms_key_id: Option<String>,
    /// Specifies the amount of time to retain performance insights data for. Defaults to 7 days if Performance Insights are enabled. Valid values are 7, month * 31 (where month is a number of months from 1-23), and 731. See here for more information on retention periods.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_retention_period: Option<f64>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per region, e.g. 04:00-09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredBackupWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_backup_window: Option<String>,
    /// Weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredMaintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_maintenance_window: Option<String>,
    /// ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica. Note: Removing this attribute after creation will promote the read replica to a standalone cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationSourceIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_source_identifier: Option<String>,
    /// Nested attribute for point in time restore. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToPointInTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_point_in_time: Option<ClusterInitProviderRestoreToPointInTime>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Import")]
    #[builder(default, setter(strip_option))]
    pub s3_import: Option<ClusterInitProviderS3Import>,
    /// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub scaling_configuration: Option<ClusterInitProviderScalingConfiguration>,
    /// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverlessv2ScalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub serverlessv2_scaling_configuration:
        Option<ClusterInitProviderServerlessv2ScalingConfiguration>,
    /// Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipFinalSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_final_snapshot: Option<bool>,
    /// Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot. Conflicts with global_cluster_identifier. Clusters cannot be restored from snapshot and joined to an existing global cluster in a single operation. See the AWS documentation or the Global Cluster Restored From Snapshot example for instructions on building a global cluster starting with a snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_identifier: Option<String>,
    /// The source region for an encrypted replica DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_region: Option<String>,
    /// Specifies whether the DB cluster is encrypted. The default is false for provisioned engine_mode and true for serverless engine_mode. When restoring an unencrypted snapshot_identifier, the kms_key_id argument must be provided to encrypt the restored cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageEncrypted"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_encrypted: Option<bool>,
    /// (Forces new for Multi-AZ DB clusters) Specifies the storage type to be associated with the DB cluster. For Aurora DB clusters, storage_type modifications can be done in-place. For Multi-AZ DB Clusters, the iops argument must also be set. Valid values are: "", aurora-iopt1 (Aurora DB Clusters); io1, io2 (Multi-AZ DB Clusters). Default: "" (Aurora DB Clusters); io1 (Multi-AZ DB Clusters).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdRefs"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_refs: Option<Vec<ClusterInitProviderVpcSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIdSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_id_selector: Option<ClusterInitProviderVpcSecurityGroupIdSelector>,
    /// List of VPC security groups to associate with the Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

/// Reference to a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbClusterParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbClusterParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbClusterParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbClusterParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbClusterParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbClusterParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbClusterParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ClusterParameterGroup in rds to populate dbClusterParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbClusterParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbClusterParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbClusterParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbClusterParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbClusterParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbClusterParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbClusterParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ParameterGroup in rds to populate dbInstanceParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbInstanceParameterGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbInstanceParameterGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbInstanceParameterGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbInstanceParameterGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbInstanceParameterGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbInstanceParameterGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbInstanceParameterGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ParameterGroup in rds to populate dbInstanceParameterGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbInstanceParameterGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbInstanceParameterGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a SubnetGroup in rds to populate dbSubnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbSubnetGroupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbSubnetGroupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbSubnetGroupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbSubnetGroupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbSubnetGroupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbSubnetGroupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbSubnetGroupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SubnetGroup in rds to populate dbSubnetGroupName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbSubnetGroupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderDbSubnetGroupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderDbSubnetGroupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderDbSubnetGroupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderDbSubnetGroupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbSubnetGroupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderDbSubnetGroupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
/// Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderMasterPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a Key in kms to populate masterUserSecretKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderMasterUserSecretKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderMasterUserSecretKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate masterUserSecretKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderMasterUserSecretKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Nested attribute for point in time restore. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderRestoreToPointInTime {
    /// Date and time in UTC format to restore the database cluster to. Conflicts with use_latest_restorable_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_time: Option<String>,
    /// Type of restore to be performed.
    /// Valid options are full-copy (default) and copy-on-write.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreType"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_type: Option<String>,
    /// Identifier of the source database cluster from which to restore. When restoring from a cluster in another AWS account, the identifier is the ARN of that cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier: Option<String>,
    /// Reference to a Cluster in rds to populate sourceClusterIdentifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifierRef"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier_ref:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRef>,
    /// Selector for a Cluster in rds to populate sourceClusterIdentifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifierSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier_selector:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelector>,
    /// Cluster resource ID of the source database cluster from which to restore. To be used for restoring a deleted cluster in the same account which still has a retained automatic backup available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterResourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_resource_id: Option<String>,
    /// Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with restore_to_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLatestRestorableTime"
    )]
    #[builder(default, setter(strip_option))]
    pub use_latest_restorable_time: Option<bool>,
}

/// Reference to a Cluster in rds to populate sourceClusterIdentifier.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in rds to populate sourceClusterIdentifier.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<
        ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Port on which the DB accepts connections.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderS3Import {
    /// Bucket name where your backup is stored
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameRef"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name_ref: Option<ClusterInitProviderS3ImportBucketNameRef>,
    /// Selector for a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name_selector: Option<ClusterInitProviderS3ImportBucketNameSelector>,
    /// Can be blank, but is the path to your backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_prefix: Option<String>,
    /// Role applied to load the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ingestionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ingestion_role: Option<String>,
    /// Source engine for the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngine"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine: Option<String>,
    /// Version of the source engine used to make the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine_version: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderS3ImportBucketNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderS3ImportBucketNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderS3ImportBucketNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderS3ImportBucketNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderS3ImportBucketNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderS3ImportBucketNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderS3ImportBucketNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderS3ImportBucketNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderS3ImportBucketNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderS3ImportBucketNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderS3ImportBucketNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderS3ImportBucketNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderS3ImportBucketNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderS3ImportBucketNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderScalingConfiguration {
    /// Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoPause")]
    #[builder(default, setter(strip_option))]
    pub auto_pause: Option<bool>,
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. Valid values are 60 through 600. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsBeforeTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_before_timeout: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
    /// Action to take when the timeout is reached. Valid values: ForceApplyCapacityChange, RollbackCapacityChange. Defaults to RollbackCapacityChange. See documentation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutAction"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_action: Option<String>,
}

/// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderServerlessv2ScalingConfiguration {
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderVpcSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderVpcSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderVpcSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderVpcSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderVpcSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderVpcSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderVpcSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderVpcSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterInitProviderVpcSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterInitProviderVpcSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterInitProviderVpcSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterInitProviderVpcSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderVpcSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderVpcSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProvider {
    /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allocatedStorage"
    )]
    #[builder(default, setter(strip_option))]
    pub allocated_storage: Option<f64>,
    /// Enable to allow major engine version upgrades when changing engine versions. Defaults to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowMajorVersionUpgrade"
    )]
    #[builder(default, setter(strip_option))]
    pub allow_major_version_upgrade: Option<bool>,
    /// Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applyImmediately"
    )]
    #[builder(default, setter(strip_option))]
    pub apply_immediately: Option<bool>,
    /// Amazon Resource Name (ARN) of cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub arn: Option<String>,
    /// List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created.
    /// We recommend specifying 3 AZs or using the  if necessary.
    /// A maximum of 3 AZs can be configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "availabilityZones"
    )]
    #[builder(default, setter(strip_option))]
    pub availability_zones: Option<Vec<String>>,
    /// Target backtrack window, in seconds. Only available for aurora and aurora-mysql engines currently. To disable backtracking, set this value to 0. Defaults to 0. Must be between 0 and 259200 (72 hours)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backtrackWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub backtrack_window: Option<f64>,
    /// Days to retain backups for. Default 1
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub backup_retention_period: Option<f64>,
    /// The CA certificate identifier to use for the DB cluster's server certificate.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caCertificateIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub ca_certificate_identifier: Option<String>,
    /// Expiration date of the DB instance’s server certificate
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caCertificateValidTill"
    )]
    #[builder(default, setter(strip_option))]
    pub ca_certificate_valid_till: Option<String>,
    /// – List of RDS Instances that are a part of this cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterMembers"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_members: Option<Vec<String>>,
    /// RDS Cluster Resource ID
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterResourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub cluster_resource_id: Option<String>,
    /// –  Copy all Cluster tags to snapshots. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "copyTagsToSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub copy_tags_to_snapshot: Option<bool>,
    /// Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: RDS Naming Constraints
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseName"
    )]
    #[builder(default, setter(strip_option))]
    pub database_name: Option<String>,
    /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterInstanceClass"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_instance_class: Option<String>,
    /// A cluster parameter group to associate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbClusterParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_cluster_parameter_group_name: Option<String>,
    /// Instance parameter group to associate with all instances of the DB cluster. The db_instance_parameter_group_name parameter is only valid in combination with the allow_major_version_upgrade parameter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbInstanceParameterGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_instance_parameter_group_name: Option<String>,
    /// DB subnet group to associate with this DB cluster.
    /// NOTE: This must match the db_subnet_group_name specified on every aws_rds_cluster_instance in the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSubnetGroupName"
    )]
    #[builder(default, setter(strip_option))]
    pub db_subnet_group_name: Option<String>,
    /// For use with RDS Custom.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dbSystemId"
    )]
    #[builder(default, setter(strip_option))]
    pub db_system_id: Option<String>,
    /// Specifies whether to remove automated backups immediately after the DB cluster is deleted. Default is true.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deleteAutomatedBackups"
    )]
    #[builder(default, setter(strip_option))]
    pub delete_automated_backups: Option<bool>,
    /// If the DB cluster should have deletion protection enabled.
    /// The database can't be deleted when this value is set to true.
    /// The default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionProtection"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_protection: Option<bool>,
    /// The ID of the Directory Service Active Directory domain to create the cluster in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub domain: Option<String>,
    /// The name of the IAM role to be used when making API calls to the Directory Service.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "domainIamRoleName"
    )]
    #[builder(default, setter(strip_option))]
    pub domain_iam_role_name: Option<String>,
    /// Whether cluster should forward writes to an associated global cluster. Applied to secondary clusters to enable them to forward writes to an aws_rds_global_cluster's primary cluster. See the User Guide for Aurora for more information.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableGlobalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_global_write_forwarding: Option<bool>,
    /// Enable HTTP endpoint (data API). Only valid for some combinations of engine_mode, engine and engine_version and only available in some regions. See the Region and version availability section of the documentation. This option also does not work with any of these options specified: snapshot_identifier, replication_source_identifier, s3_import.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableHttpEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_http_endpoint: Option<bool>,
    /// Whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances.. See the User Guide for Aurora for more information. NOTE: Local write forwarding requires Aurora MySQL version 3.04 or higher.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enableLocalWriteForwarding"
    )]
    #[builder(default, setter(strip_option))]
    pub enable_local_write_forwarding: Option<bool>,
    /// Set of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, error, general, slowquery, postgresql (PostgreSQL).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledCloudwatchLogsExports"
    )]
    #[builder(default, setter(strip_option))]
    pub enabled_cloudwatch_logs_exports: Option<Vec<String>>,
    /// DNS address of the RDS instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub endpoint: Option<String>,
    /// Name of the database engine to be used for this DB cluster. Valid Values: aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub engine: Option<String>,
    /// The life cycle type for this DB instance. This setting is valid for cluster types Aurora DB clusters and Multi-AZ DB clusters. Valid values are open-source-rds-extended-support, open-source-rds-extended-support-disabled. Default value is open-source-rds-extended-support. [Using Amazon RDS Extended Support]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/extended-support.html
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineLifecycleSupport"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_lifecycle_support: Option<String>,
    /// Database engine mode. Valid values: global (only valid for Aurora MySQL 1.21 and earlier), parallelquery, provisioned, serverless. Defaults to: provisioned. See the RDS User Guide for limitations when using serverless.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineMode"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_mode: Option<String>,
    /// Database engine version. Updating this argument results in an outage. See the Aurora MySQL and Aurora Postgres documentation for your configured engine to determine this value, or by running aws rds describe-db-engine-versions. For example with Aurora MySQL 2, a potential value for this argument is 5.7.mysql_aurora.2.03.2. The value can contain a partial version where supported by the API. The actual engine version used is returned in the attribute engine_version_actual, , see Attribute Reference below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version: Option<String>,
    /// Running version of the database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "engineVersionActual"
    )]
    #[builder(default, setter(strip_option))]
    pub engine_version_actual: Option<String>,
    /// Name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "finalSnapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub final_snapshot_identifier: Option<String>,
    /// Global cluster identifier specified on aws_rds_global_cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "globalClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub global_cluster_identifier: Option<String>,
    /// Route53 Hosted Zone ID of the endpoint
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostedZoneId"
    )]
    #[builder(default, setter(strip_option))]
    pub hosted_zone_id: Option<String>,
    /// Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. Please see AWS Documentation for availability and limitations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "iamDatabaseAuthenticationEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub iam_database_authentication_enabled: Option<bool>,
    /// List of ARNs for the IAM roles to associate to the RDS Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoles")]
    #[builder(default, setter(strip_option))]
    pub iam_roles: Option<Vec<String>>,
    /// RDS Cluster Identifier
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see Amazon RDS Provisioned IOPS storage to improve performance in the Amazon RDS User Guide. (This setting is required to create a Multi-AZ DB cluster). Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub iops: Option<f64>,
    /// ARN for the KMS encryption key. When specifying kms_key_id, storage_encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if master_password is provided.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "manageMasterUserPassword"
    )]
    #[builder(default, setter(strip_option))]
    pub manage_master_user_password: Option<bool>,
    /// Block that specifies the master user secret. Only available when manage_master_user_password is set to true. Documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecret"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret: Option<Vec<ClusterStatusAtProviderMasterUserSecret>>,
    /// Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If not specified, the default KMS key for your Amazon Web Services account is used.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUserSecretKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub master_user_secret_kms_key_id: Option<String>,
    /// Username for the master DB user. Please refer to the RDS Naming Constraints. This argument does not support in-place updates and cannot be changed during a restore from snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "masterUsername"
    )]
    #[builder(default, setter(strip_option))]
    pub master_username: Option<String>,
    /// Network type of the cluster. Valid values: IPV4, DUAL.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "networkType"
    )]
    #[builder(default, setter(strip_option))]
    pub network_type: Option<String>,
    /// Enables Performance Insights for the RDS Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsEnabled"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_enabled: Option<bool>,
    /// Specifies the KMS Key ID to encrypt Performance Insights data. If not specified, the default RDS KMS key will be used (aws/rds).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsKmsKeyId"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_kms_key_id: Option<String>,
    /// Specifies the amount of time to retain performance insights data for. Defaults to 7 days if Performance Insights are enabled. Valid values are 7, month * 31 (where month is a number of months from 1-23), and 731. See here for more information on retention periods.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "performanceInsightsRetentionPeriod"
    )]
    #[builder(default, setter(strip_option))]
    pub performance_insights_retention_period: Option<f64>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub port: Option<f64>,
    /// Daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per region, e.g. 04:00-09:00.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredBackupWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_backup_window: Option<String>,
    /// Weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preferredMaintenanceWindow"
    )]
    #[builder(default, setter(strip_option))]
    pub preferred_maintenance_window: Option<String>,
    /// Read-only endpoint for the Aurora cluster, automatically
    /// load-balanced across replicas
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readerEndpoint"
    )]
    #[builder(default, setter(strip_option))]
    pub reader_endpoint: Option<String>,
    /// ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica. Note: Removing this attribute after creation will promote the read replica to a standalone cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicationSourceIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub replication_source_identifier: Option<String>,
    /// Nested attribute for point in time restore. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToPointInTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_point_in_time: Option<ClusterStatusAtProviderRestoreToPointInTime>,
    /// Port on which the DB accepts connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Import")]
    #[builder(default, setter(strip_option))]
    pub s3_import: Option<ClusterStatusAtProviderS3Import>,
    /// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub scaling_configuration: Option<ClusterStatusAtProviderScalingConfiguration>,
    /// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverlessv2ScalingConfiguration"
    )]
    #[builder(default, setter(strip_option))]
    pub serverlessv2_scaling_configuration:
        Option<ClusterStatusAtProviderServerlessv2ScalingConfiguration>,
    /// Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "skipFinalSnapshot"
    )]
    #[builder(default, setter(strip_option))]
    pub skip_final_snapshot: Option<bool>,
    /// Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot. Conflicts with global_cluster_identifier. Clusters cannot be restored from snapshot and joined to an existing global cluster in a single operation. See the AWS documentation or the Global Cluster Restored From Snapshot example for instructions on building a global cluster starting with a snapshot.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub snapshot_identifier: Option<String>,
    /// The source region for an encrypted replica DB cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceRegion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_region: Option<String>,
    /// Specifies whether the DB cluster is encrypted. The default is false for provisioned engine_mode and true for serverless engine_mode. When restoring an unencrypted snapshot_identifier, the kms_key_id argument must be provided to encrypt the restored cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageEncrypted"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_encrypted: Option<bool>,
    /// (Forces new for Multi-AZ DB clusters) Specifies the storage type to be associated with the DB cluster. For Aurora DB clusters, storage_type modifications can be done in-place. For Multi-AZ DB Clusters, the iops argument must also be set. Valid values are: "", aurora-iopt1 (Aurora DB Clusters); io1, io2 (Multi-AZ DB Clusters). Default: "" (Aurora DB Clusters); io1 (Multi-AZ DB Clusters).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageType"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default, setter(strip_option))]
    pub tags_all: Option<BTreeMap<String, String>>,
    /// List of VPC security groups to associate with the Cluster
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcSecurityGroupIds"
    )]
    #[builder(default, setter(strip_option))]
    pub vpc_security_group_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderMasterUserSecret {
    /// Amazon Web Services KMS key identifier that is used to encrypt the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default, setter(strip_option))]
    pub kms_key_id: Option<String>,
    /// Amazon Resource Name (ARN) of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretArn")]
    #[builder(default, setter(strip_option))]
    pub secret_arn: Option<String>,
    /// Status of the secret. Valid Values: creating | active | rotating | impaired.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretStatus"
    )]
    #[builder(default, setter(strip_option))]
    pub secret_status: Option<String>,
}

/// Nested attribute for point in time restore. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderRestoreToPointInTime {
    /// Date and time in UTC format to restore the database cluster to. Conflicts with use_latest_restorable_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreToTime"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_to_time: Option<String>,
    /// Type of restore to be performed.
    /// Valid options are full-copy (default) and copy-on-write.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreType"
    )]
    #[builder(default, setter(strip_option))]
    pub restore_type: Option<String>,
    /// Identifier of the source database cluster from which to restore. When restoring from a cluster in another AWS account, the identifier is the ARN of that cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterIdentifier"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_identifier: Option<String>,
    /// Cluster resource ID of the source database cluster from which to restore. To be used for restoring a deleted cluster in the same account which still has a retained automatic backup available.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceClusterResourceId"
    )]
    #[builder(default, setter(strip_option))]
    pub source_cluster_resource_id: Option<String>,
    /// Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with restore_to_time.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useLatestRestorableTime"
    )]
    #[builder(default, setter(strip_option))]
    pub use_latest_restorable_time: Option<bool>,
}

/// Port on which the DB accepts connections.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderS3Import {
    /// Bucket name where your backup is stored
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_name: Option<String>,
    /// Can be blank, but is the path to your backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketPrefix"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_prefix: Option<String>,
    /// Role applied to load the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ingestionRole"
    )]
    #[builder(default, setter(strip_option))]
    pub ingestion_role: Option<String>,
    /// Source engine for the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngine"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine: Option<String>,
    /// Version of the source engine used to make the backup
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sourceEngineVersion"
    )]
    #[builder(default, setter(strip_option))]
    pub source_engine_version: Option<String>,
}

/// Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderScalingConfiguration {
    /// Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoPause")]
    #[builder(default, setter(strip_option))]
    pub auto_pause: Option<bool>,
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. Valid values are 60 through 600. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsBeforeTimeout"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_before_timeout: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
    /// Action to take when the timeout is reached. Valid values: ForceApplyCapacityChange, RollbackCapacityChange. Defaults to RollbackCapacityChange. See documentation.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutAction"
    )]
    #[builder(default, setter(strip_option))]
    pub timeout_action: Option<String>,
}

/// Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct ClusterStatusAtProviderServerlessv2ScalingConfiguration {
    /// Maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub max_capacity: Option<f64>,
    /// Minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minCapacity"
    )]
    #[builder(default, setter(strip_option))]
    pub min_capacity: Option<f64>,
    /// Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secondsUntilAutoPause"
    )]
    #[builder(default, setter(strip_option))]
    pub seconds_until_auto_pause: Option<f64>,
}
