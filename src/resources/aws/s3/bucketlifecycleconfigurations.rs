// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::BTreeMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// BucketLifecycleConfigurationSpec defines the desired state of BucketLifecycleConfiguration
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[kube(
    group = "s3.aws.upbound.io",
    version = "v1beta2",
    kind = "BucketLifecycleConfiguration",
    plural = "bucketlifecycleconfigurations"
)]
#[kube(status = "BucketLifecycleConfigurationStatus")]
pub struct BucketLifecycleConfigurationSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default, setter(strip_option))]
    pub deletion_policy: Option<BucketLifecycleConfigurationDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: BucketLifecycleConfigurationForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub init_provider: Option<BucketLifecycleConfigurationInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default, setter(strip_option))]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default, setter(strip_option))]
    pub provider_config_ref: Option<BucketLifecycleConfigurationProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default, setter(strip_option))]
    pub publish_connection_details_to:
        Option<BucketLifecycleConfigurationPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default, setter(strip_option))]
    pub write_connection_secret_to_ref:
        Option<BucketLifecycleConfigurationWriteConnectionSecretToRef>,
}

/// BucketLifecycleConfigurationSpec defines the desired state of BucketLifecycleConfiguration
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProvider {
    /// Name of the source S3 bucket you want Amazon S3 to monitor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<BucketLifecycleConfigurationForProviderBucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<BucketLifecycleConfigurationForProviderBucketSelector>,
    /// Account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expectedBucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub expected_bucket_owner: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// List of configuration blocks describing the rules managing the replication. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub rule: Option<Vec<BucketLifecycleConfigurationForProviderRule>>,
    /// The default minimum object size behavior applied to the lifecycle configuration. Valid values: all_storage_classes_128K (default), varies_by_storage_class. To customize the minimum object size for any transition you can add a filter that specifies a custom object_size_greater_than or object_size_less_than value. Custom filters always take precedence over the default transition behavior.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitionDefaultMinimumObjectSize"
    )]
    #[builder(default, setter(strip_option))]
    pub transition_default_minimum_object_size: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationForProviderBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BucketLifecycleConfigurationForProviderBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BucketLifecycleConfigurationForProviderBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationForProviderBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationForProviderBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationForProviderBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BucketLifecycleConfigurationForProviderBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BucketLifecycleConfigurationForProviderBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationForProviderBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationForProviderBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRule {
    /// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "abortIncompleteMultipartUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub abort_incomplete_multipart_upload:
        Option<BucketLifecycleConfigurationForProviderRuleAbortIncompleteMultipartUpload>,
    /// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expiration: Option<BucketLifecycleConfigurationForProviderRuleExpiration>,
    /// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub filter: Option<BucketLifecycleConfigurationForProviderRuleFilter>,
    /// Unique identifier for the rule. The value cannot be longer than 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block that specifies when noncurrent object versions expire. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionExpiration"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_expiration:
        Option<BucketLifecycleConfigurationForProviderRuleNoncurrentVersionExpiration>,
    /// Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionTransition"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_transition:
        Option<Vec<BucketLifecycleConfigurationForProviderRuleNoncurrentVersionTransition>>,
    /// DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Whether the rule is currently being applied. Valid values: Enabled or Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub status: Option<String>,
    /// Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub transition: Option<Vec<BucketLifecycleConfigurationForProviderRuleTransition>>,
}

/// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleAbortIncompleteMultipartUpload {
    /// Number of days after which Amazon S3 aborts an incomplete multipart upload.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysAfterInitiation"
    )]
    #[builder(default, setter(strip_option))]
    pub days_after_initiation: Option<f64>,
}

/// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleExpiration {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expiredObjectDeleteMarker"
    )]
    #[builder(default, setter(strip_option))]
    pub expired_object_delete_marker: Option<bool>,
}

/// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleFilter {
    /// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub and: Option<BucketLifecycleConfigurationForProviderRuleFilterAnd>,
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<String>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<String>,
    /// Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Configuration block for specifying a tag key and value. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tag: Option<BucketLifecycleConfigurationForProviderRuleFilterTag>,
}

/// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleFilterAnd {
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<f64>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<f64>,
    /// Prefix identifying one or more objects to which the rule applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Configuration block for specifying a tag key and value. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleFilterTag {
    /// Name of the object key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Value of the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block that specifies when noncurrent object versions expire. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleNoncurrentVersionExpiration {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleNoncurrentVersionTransition {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationForProviderRuleTransition {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProvider {
    /// Name of the source S3 bucket you want Amazon S3 to monitor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default, setter(strip_option))]
    pub bucket_ref: Option<BucketLifecycleConfigurationInitProviderBucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default, setter(strip_option))]
    pub bucket_selector: Option<BucketLifecycleConfigurationInitProviderBucketSelector>,
    /// Account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expectedBucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub expected_bucket_owner: Option<String>,
    /// List of configuration blocks describing the rules managing the replication. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub rule: Option<Vec<BucketLifecycleConfigurationInitProviderRule>>,
    /// The default minimum object size behavior applied to the lifecycle configuration. Valid values: all_storage_classes_128K (default), varies_by_storage_class. To customize the minimum object size for any transition you can add a filter that specifies a custom object_size_greater_than or object_size_less_than value. Custom filters always take precedence over the default transition behavior.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitionDefaultMinimumObjectSize"
    )]
    #[builder(default, setter(strip_option))]
    pub transition_default_minimum_object_size: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationInitProviderBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BucketLifecycleConfigurationInitProviderBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BucketLifecycleConfigurationInitProviderBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationInitProviderBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationInitProviderBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default, setter(strip_option))]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default, setter(strip_option))]
    pub match_labels: Option<BTreeMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationInitProviderBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BucketLifecycleConfigurationInitProviderBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BucketLifecycleConfigurationInitProviderBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationInitProviderBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationInitProviderBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRule {
    /// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "abortIncompleteMultipartUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub abort_incomplete_multipart_upload:
        Option<BucketLifecycleConfigurationInitProviderRuleAbortIncompleteMultipartUpload>,
    /// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expiration: Option<BucketLifecycleConfigurationInitProviderRuleExpiration>,
    /// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub filter: Option<BucketLifecycleConfigurationInitProviderRuleFilter>,
    /// Unique identifier for the rule. The value cannot be longer than 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block that specifies when noncurrent object versions expire. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionExpiration"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_expiration:
        Option<BucketLifecycleConfigurationInitProviderRuleNoncurrentVersionExpiration>,
    /// Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionTransition"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_transition:
        Option<Vec<BucketLifecycleConfigurationInitProviderRuleNoncurrentVersionTransition>>,
    /// DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Whether the rule is currently being applied. Valid values: Enabled or Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub status: Option<String>,
    /// Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub transition: Option<Vec<BucketLifecycleConfigurationInitProviderRuleTransition>>,
}

/// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleAbortIncompleteMultipartUpload {
    /// Number of days after which Amazon S3 aborts an incomplete multipart upload.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysAfterInitiation"
    )]
    #[builder(default, setter(strip_option))]
    pub days_after_initiation: Option<f64>,
}

/// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleExpiration {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expiredObjectDeleteMarker"
    )]
    #[builder(default, setter(strip_option))]
    pub expired_object_delete_marker: Option<bool>,
}

/// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleFilter {
    /// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub and: Option<BucketLifecycleConfigurationInitProviderRuleFilterAnd>,
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<String>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<String>,
    /// Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Configuration block for specifying a tag key and value. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tag: Option<BucketLifecycleConfigurationInitProviderRuleFilterTag>,
}

/// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleFilterAnd {
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<f64>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<f64>,
    /// Prefix identifying one or more objects to which the rule applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Configuration block for specifying a tag key and value. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleFilterTag {
    /// Name of the object key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Value of the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block that specifies when noncurrent object versions expire. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleNoncurrentVersionExpiration {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleNoncurrentVersionTransition {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationInitProviderRuleTransition {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution: Option<BucketLifecycleConfigurationProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve: Option<BucketLifecycleConfigurationProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default, setter(strip_option))]
    pub config_ref: Option<BucketLifecycleConfigurationPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub metadata: Option<BucketLifecycleConfigurationPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub policy: Option<BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolution:
        Option<BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub resolve:
        Option<BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BucketLifecycleConfigurationPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub labels: Option<BTreeMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default, setter(strip_option))]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// BucketLifecycleConfigurationStatus defines the observed state of BucketLifecycleConfiguration.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default, setter(strip_option))]
    pub at_provider: Option<BucketLifecycleConfigurationStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default, setter(strip_option))]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProvider {
    /// Name of the source S3 bucket you want Amazon S3 to monitor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub bucket: Option<String>,
    /// Account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expectedBucketOwner"
    )]
    #[builder(default, setter(strip_option))]
    pub expected_bucket_owner: Option<String>,
    /// and status)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// List of configuration blocks describing the rules managing the replication. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub rule: Option<Vec<BucketLifecycleConfigurationStatusAtProviderRule>>,
    /// The default minimum object size behavior applied to the lifecycle configuration. Valid values: all_storage_classes_128K (default), varies_by_storage_class. To customize the minimum object size for any transition you can add a filter that specifies a custom object_size_greater_than or object_size_less_than value. Custom filters always take precedence over the default transition behavior.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "transitionDefaultMinimumObjectSize"
    )]
    #[builder(default, setter(strip_option))]
    pub transition_default_minimum_object_size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRule {
    /// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "abortIncompleteMultipartUpload"
    )]
    #[builder(default, setter(strip_option))]
    pub abort_incomplete_multipart_upload:
        Option<BucketLifecycleConfigurationStatusAtProviderRuleAbortIncompleteMultipartUpload>,
    /// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub expiration: Option<BucketLifecycleConfigurationStatusAtProviderRuleExpiration>,
    /// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub filter: Option<BucketLifecycleConfigurationStatusAtProviderRuleFilter>,
    /// Unique identifier for the rule. The value cannot be longer than 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub id: Option<String>,
    /// Configuration block that specifies when noncurrent object versions expire. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionExpiration"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_expiration:
        Option<BucketLifecycleConfigurationStatusAtProviderRuleNoncurrentVersionExpiration>,
    /// Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentVersionTransition"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_version_transition:
        Option<Vec<BucketLifecycleConfigurationStatusAtProviderRuleNoncurrentVersionTransition>>,
    /// DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Whether the rule is currently being applied. Valid values: Enabled or Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub status: Option<String>,
    /// Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub transition: Option<Vec<BucketLifecycleConfigurationStatusAtProviderRuleTransition>>,
}

/// Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleAbortIncompleteMultipartUpload {
    /// Number of days after which Amazon S3 aborts an incomplete multipart upload.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysAfterInitiation"
    )]
    #[builder(default, setter(strip_option))]
    pub days_after_initiation: Option<f64>,
}

/// Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleExpiration {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expiredObjectDeleteMarker"
    )]
    #[builder(default, setter(strip_option))]
    pub expired_object_delete_marker: Option<bool>,
}

/// Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleFilter {
    /// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub and: Option<BucketLifecycleConfigurationStatusAtProviderRuleFilterAnd>,
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<String>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<String>,
    /// Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Configuration block for specifying a tag key and value. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tag: Option<BucketLifecycleConfigurationStatusAtProviderRuleFilterTag>,
}

/// Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleFilterAnd {
    /// Minimum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeGreaterThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_greater_than: Option<f64>,
    /// Maximum object size (in bytes) to which the rule applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectSizeLessThan"
    )]
    #[builder(default, setter(strip_option))]
    pub object_size_less_than: Option<f64>,
    /// Prefix identifying one or more objects to which the rule applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub prefix: Option<String>,
    /// Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub tags: Option<BTreeMap<String, String>>,
}

/// Configuration block for specifying a tag key and value. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleFilterTag {
    /// Name of the object key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub key: Option<String>,
    /// Value of the tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub value: Option<String>,
}

/// Configuration block that specifies when noncurrent object versions expire. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleNoncurrentVersionExpiration {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleNoncurrentVersionTransition {
    /// Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "newerNoncurrentVersions"
    )]
    #[builder(default, setter(strip_option))]
    pub newer_noncurrent_versions: Option<String>,
    /// Number of days an object is noncurrent before Amazon S3 can perform the associated action.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "noncurrentDays"
    )]
    #[builder(default, setter(strip_option))]
    pub noncurrent_days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
pub struct BucketLifecycleConfigurationStatusAtProviderRuleTransition {
    /// Date objects are transitioned to the specified storage class. The date value must be in RFC3339 full-date format e.g. 2023-08-22.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub date: Option<String>,
    /// Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(strip_option))]
    pub days: Option<f64>,
    /// Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClass"
    )]
    #[builder(default, setter(strip_option))]
    pub storage_class: Option<String>,
}
