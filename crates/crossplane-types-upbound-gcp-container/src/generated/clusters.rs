// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "container.gcp.upbound.io", version = "v1beta2", kind = "Cluster", plural = "clusters")]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProvider {
    /// The configuration for addons supported by GKE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addonsConfig")]
    pub addons_config: Option<ClusterForProviderAddonsConfig>,
    /// Enable NET_ADMIN for the cluster. Defaults to
    /// false. This field should only be enabled for Autopilot clusters (enable_autopilot
    /// set to true).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowNetAdmin")]
    pub allow_net_admin: Option<bool>,
    /// Configuration for the
    /// Google Groups for GKE feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticatorGroupsConfig")]
    pub authenticator_groups_config: Option<ClusterForProviderAuthenticatorGroupsConfig>,
    /// Configuration options for the Binary
    /// Authorization feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterForProviderBinaryAuthorization>,
    /// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
    /// automatically adjust the size of the cluster and create/delete node pools based
    /// on the current needs of the cluster's workload. See the
    /// guide to using Node Auto-Provisioning
    /// for more details. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterAutoscaling")]
    pub cluster_autoscaling: Option<ClusterForProviderClusterAutoscaling>,
    /// The IP address range of the Kubernetes pods
    /// in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
    /// automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
    /// default a new cluster to routes-based, where ip_allocation_policy is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4Cidr")]
    pub cluster_ipv4_cidr: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterForProviderConfidentialNodes>,
    /// Configuration for the
    /// Cost Allocation feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "costManagementConfig")]
    pub cost_management_config: Option<ClusterForProviderCostManagementConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseEncryption")]
    pub database_encryption: Option<ClusterForProviderDatabaseEncryption>,
    /// The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datapathProvider")]
    pub datapath_provider: Option<String>,
    /// The default maximum number of pods
    /// per node in this cluster. This doesn't work on "routes-based" clusters, clusters
    /// that don't have IP Aliasing enabled. See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMaxPodsPerNode")]
    pub default_max_pods_per_node: Option<f64>,
    /// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultSnatStatus")]
    pub default_snat_status: Option<ClusterForProviderDefaultSnatStatus>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    /// Description of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Configuration for Using Cloud DNS for GKE. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ClusterForProviderDnsConfig>,
    /// Enable Autopilot for this cluster. Defaults to false.
    /// Note that when this option is enabled, certain features of Standard GKE are not available.
    /// See the official documentation
    /// for available features.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutopilot")]
    pub enable_autopilot: Option<bool>,
    /// Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCiliumClusterwideNetworkPolicy")]
    pub enable_cilium_clusterwide_network_policy: Option<bool>,
    /// Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntranodeVisibility")]
    pub enable_intranode_visibility: Option<bool>,
    /// Configuration for Kubernetes Beta APIs.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableK8SBetaApis")]
    pub enable_k8s_beta_apis: Option<ClusterForProviderEnableK8sBetaApis>,
    /// Whether to enable Kubernetes Alpha features for
    /// this cluster. Note that when this option is enabled, the cluster cannot be upgraded
    /// and will be automatically deleted after 30 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableKubernetesAlpha")]
    pub enable_kubernetes_alpha: Option<bool>,
    /// Whether L4ILB Subsetting is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableL4IlbSubsetting")]
    pub enable_l4_ilb_subsetting: Option<bool>,
    /// Whether the ABAC authorizer is enabled for this cluster.
    /// When enabled, identities in the system, including service accounts, nodes, and controllers,
    /// will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
    /// Defaults to false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLegacyAbac")]
    pub enable_legacy_abac: Option<bool>,
    /// Whether multi-networking is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMultiNetworking")]
    pub enable_multi_networking: Option<bool>,
    /// Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShieldedNodes")]
    pub enable_shielded_nodes: Option<bool>,
    /// Whether to enable Cloud TPU resources in this cluster.
    /// See the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTpu")]
    pub enable_tpu: Option<bool>,
    /// Fleet configuration for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterForProviderFleet>,
    /// Configuration for GKE Gateway API controller. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayApiConfig")]
    pub gateway_api_config: Option<ClusterForProviderGatewayApiConfig>,
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityServiceConfig")]
    pub identity_service_config: Option<ClusterForProviderIdentityServiceConfig>,
    /// The number of nodes to create in this
    /// cluster's default node pool. In regional or multi-zonal clusters, this is the
    /// number of nodes per zone. Must be set if node_pool is not set. If you're using
    /// google_container_node_pool objects with no default node pool, you'll need to
    /// set this to a value of at least 1, alongside setting
    /// remove_default_node_pool to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    pub initial_node_count: Option<f64>,
    /// Configuration of cluster IP allocation for
    /// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAllocationPolicy")]
    pub ip_allocation_policy: Option<ClusterForProviderIpAllocationPolicy>,
    /// The location (region or zone) in which the cluster
    /// master will be created, as well as the default node location. If you specify a
    /// zone (such as us-central1-a), the cluster will be a zonal cluster with a
    /// single cluster master. If you specify a region (such as us-west1), the
    /// cluster will be a regional cluster with multiple masters spread across zones in
    /// the region, and with default node locations in those zones as well
    pub location: String,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterForProviderLoggingConfig>,
    /// The logging service that the cluster should
    /// write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
    /// logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingService")]
    pub logging_service: Option<String>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenancePolicy")]
    pub maintenance_policy: Option<ClusterForProviderMaintenancePolicy>,
    /// The authentication information for accessing the
    /// Kubernetes master. Some values in this block are only returned by the API if
    /// your service account has permission to get credentials for your GKE cluster. If
    /// you see an unexpected diff unsetting your client cert, ensure you have the
    /// container.clusters.getCredentials permission.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuth")]
    pub master_auth: Option<ClusterForProviderMasterAuth>,
    /// The desired
    /// configuration options for master authorized networks. Omit the
    /// nested cidr_blocks attribute to disallow external access (except
    /// the cluster node IPs, which GKE automatically whitelists).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuthorizedNetworksConfig")]
    pub master_authorized_networks_config: Option<ClusterForProviderMasterAuthorizedNetworksConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshCertificates")]
    pub mesh_certificates: Option<ClusterForProviderMeshCertificates>,
    /// The minimum version of the master. GKE
    /// will auto-update the master to new versions, so this does not guarantee the
    /// current master version--use the read-only master_version field to obtain that.
    /// If unset, the cluster's version will be set by GKE to the version of the most recent
    /// official release (which is not necessarily the latest version). If you intend to specify versions manually,
    /// the docs
    /// describe the various acceptable formats for this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minMasterVersion")]
    pub min_master_version: Option<String>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterForProviderMonitoringConfig>,
    /// The monitoring service that the cluster
    /// should write metrics to.
    /// Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
    /// VM metrics will be collected by Google Compute Engine regardless of this setting
    /// Available options include
    /// monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
    /// Defaults to monitoring.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringService")]
    pub monitoring_service: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// network to which the cluster is connected. For Shared VPC, set this to the self link of the
    /// shared network.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Configuration options for the
    /// NetworkPolicy
    /// feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicy")]
    pub network_policy: Option<ClusterForProviderNetworkPolicy>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterForProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterForProviderNetworkSelector>,
    /// Determines whether alias IPs or routes will be used for pod IPs in the cluster.
    /// Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkingMode")]
    pub networking_mode: Option<String>,
    /// Parameters used in creating the default node pool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    pub node_config: Option<ClusterForProviderNodeConfig>,
    /// The list of zones in which the cluster's nodes
    /// are located. Nodes must be in the region of their regional cluster or in the
    /// same region as their cluster's zone for zonal clusters. If this is specified for
    /// a zonal cluster, omit the cluster's zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    pub node_locations: Option<Vec<String>>,
    /// Node pool configs that apply to auto-provisioned node pools in
    /// autopilot clusters and
    /// node auto-provisioning-enabled clusters. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolAutoConfig")]
    pub node_pool_auto_config: Option<ClusterForProviderNodePoolAutoConfig>,
    /// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolDefaults")]
    pub node_pool_defaults: Option<ClusterForProviderNodePoolDefaults>,
    /// The Kubernetes version on the nodes. Must either be unset
    /// or set to the same value as min_master_version on create. Defaults to the default
    /// version set by GKE which is not necessarily the latest version. This only affects
    /// nodes in the default node pool.
    /// To update nodes in other node pools, use the version attribute on the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVersion")]
    pub node_version: Option<String>,
    /// Configuration for the cluster upgrade notifications feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfig")]
    pub notification_config: Option<ClusterForProviderNotificationConfig>,
    /// Configuration for private clusters,
    /// clusters with private nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateClusterConfig")]
    pub private_cluster_config: Option<ClusterForProviderPrivateClusterConfig>,
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpv6GoogleAccess")]
    pub private_ipv6_google_access: Option<String>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration options for the Release channel
    /// feature, which provide more control over automatic upgrades of your GKE clusters.
    /// When updating this field, GKE imposes specific version requirements. See
    /// Selecting a new release channel
    /// for more details; the google_container_engine_versions datasource can provide
    /// the default version for a channel. Instead, use the "UNSPECIFIED"
    /// channel. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    pub release_channel: Option<ClusterForProviderReleaseChannel>,
    /// If true, deletes the default node
    /// pool upon cluster creation. If you're using google_container_node_pool
    /// resources with no default node pool, this should be set to true, alongside
    /// setting initial_node_count to at least 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeDefaultNodePool")]
    pub remove_default_node_pool: Option<bool>,
    /// The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// Configuration for the
    /// ResourceUsageExportConfig feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceUsageExportConfig")]
    pub resource_usage_export_config: Option<ClusterForProviderResourceUsageExportConfig>,
    /// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityPostureConfig")]
    pub security_posture_config: Option<ClusterForProviderSecurityPostureConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExternalIpsConfig")]
    pub service_external_ips_config: Option<ClusterForProviderServiceExternalIpsConfig>,
    /// The name or self_link of the Google Compute Engine
    /// subnetwork in which the cluster's instances are launched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    pub subnetwork_ref: Option<ClusterForProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    pub subnetwork_selector: Option<ClusterForProviderSubnetworkSelector>,
    /// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verticalPodAutoscaling")]
    pub vertical_pod_autoscaling: Option<ClusterForProviderVerticalPodAutoscaling>,
    /// Workload Identity allows Kubernetes service accounts to act as a user-managed
    /// Google IAM Service Account.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentityConfig")]
    pub workload_identity_config: Option<ClusterForProviderWorkloadIdentityConfig>,
}

/// The configuration for addons supported by GKE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfig {
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudrunConfig")]
    pub cloudrun_config: Option<ClusterForProviderAddonsConfigCloudrunConfig>,
    /// .
    /// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configConnectorConfig")]
    pub config_connector_config: Option<ClusterForProviderAddonsConfigConfigConnectorConfig>,
    /// .
    /// The status of the NodeLocal DNSCache addon. It is disabled by default.
    /// Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsCacheConfig")]
    pub dns_cache_config: Option<ClusterForProviderAddonsConfigDnsCacheConfig>,
    /// .
    /// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDiskCsiDriverConfig")]
    pub gce_persistent_disk_csi_driver_config: Option<ClusterForProviderAddonsConfigGcePersistentDiskCsiDriverConfig>,
    /// The status of the Filestore CSI driver addon,
    /// which allows the usage of filestore instance as volumes.
    /// It is disabled by default; set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpFilestoreCsiDriverConfig")]
    pub gcp_filestore_csi_driver_config: Option<ClusterForProviderAddonsConfigGcpFilestoreCsiDriverConfig>,
    /// The status of the GCSFuse CSI driver addon,
    /// which allows the usage of a gcs bucket as volumes.
    /// It is disabled by default for Standard clusters; set enabled = true to enable.
    /// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
    /// See Enable the Cloud Storage FUSE CSI driver for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsFuseCsiDriverConfig")]
    pub gcs_fuse_csi_driver_config: Option<ClusterForProviderAddonsConfigGcsFuseCsiDriverConfig>,
    /// .
    /// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gkeBackupAgentConfig")]
    pub gke_backup_agent_config: Option<ClusterForProviderAddonsConfigGkeBackupAgentConfig>,
    /// The status of the Horizontal Pod Autoscaling
    /// addon, which increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    /// It is enabled by default;
    /// set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "horizontalPodAutoscaling")]
    pub horizontal_pod_autoscaling: Option<ClusterForProviderAddonsConfigHorizontalPodAutoscaling>,
    /// The status of the HTTP (L7) load balancing
    /// controller addon, which makes it easy to set up HTTP load balancers for services in a
    /// cluster. It is enabled by default; set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpLoadBalancing")]
    pub http_load_balancing: Option<ClusterForProviderAddonsConfigHttpLoadBalancing>,
    /// Whether we should enable the network policy addon
    /// for the master.  This must be enabled in order to enable network policy for the nodes.
    /// To enable this, you must also define a network_policy block,
    /// otherwise nothing will happen.
    /// It can only be disabled if the nodes already do not have network policies enabled.
    /// Defaults to disabled; set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicyConfig")]
    pub network_policy_config: Option<ClusterForProviderAddonsConfigNetworkPolicyConfig>,
    /// . The status of the Ray Operator
    /// addon.
    /// It is disabled by default. Set enabled = true to enable. The minimum
    /// cluster version to enable Ray is 1.30.0-gke.1747000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayOperatorConfig")]
    pub ray_operator_config: Option<Vec<ClusterForProviderAddonsConfigRayOperatorConfig>>,
    /// .
    /// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
    /// It is disabled by default for Standard clusters. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulHaConfig")]
    pub stateful_ha_config: Option<ClusterForProviderAddonsConfigStatefulHaConfig>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigCloudrunConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// The load balancer type of CloudRun ingress service. It is external load balancer by default.
    /// Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerType")]
    pub load_balancer_type: Option<String>,
}

/// .
/// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigConfigConnectorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the NodeLocal DNSCache addon. It is disabled by default.
/// Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigDnsCacheConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Filestore CSI driver addon,
/// which allows the usage of filestore instance as volumes.
/// It is disabled by default; set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigGcpFilestoreCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the GCSFuse CSI driver addon,
/// which allows the usage of a gcs bucket as volumes.
/// It is disabled by default for Standard clusters; set enabled = true to enable.
/// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
/// See Enable the Cloud Storage FUSE CSI driver for more information.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigGcsFuseCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigGkeBackupAgentConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Horizontal Pod Autoscaling
/// addon, which increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
/// It is enabled by default;
/// set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigHorizontalPodAutoscaling {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// The status of the HTTP (L7) load balancing
/// controller addon, which makes it easy to set up HTTP load balancers for services in a
/// cluster. It is enabled by default; set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigHttpLoadBalancing {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Whether we should enable the network policy addon
/// for the master.  This must be enabled in order to enable network policy for the nodes.
/// To enable this, you must also define a network_policy block,
/// otherwise nothing will happen.
/// It can only be disabled if the nodes already do not have network policies enabled.
/// Defaults to disabled; set disabled = false to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigNetworkPolicyConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigRayOperatorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterLoggingConfig")]
    pub ray_cluster_logging_config: Option<ClusterForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterMonitoringConfig")]
    pub ray_cluster_monitoring_config: Option<ClusterForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
/// It is disabled by default for Standard clusters. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAddonsConfigStatefulHaConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Google Groups for GKE feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAuthenticatorGroupsConfig {
    /// The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroup")]
    pub security_group: Option<String>,
}

/// Configuration options for the Binary
/// Authorization feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderBinaryAuthorization {
    /// (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
    /// and PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

/// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
/// automatically adjust the size of the cluster and create/delete node pools based
/// on the current needs of the cluster's workload. See the
/// guide to using Node Auto-Provisioning
/// for more details. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscaling {
    /// Contains defaults for a node pool created by NAP. A subset of fields also apply to
    /// GKE Autopilot clusters.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningDefaults")]
    pub auto_provisioning_defaults: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaults>,
    /// The list of Google Compute Engine
    /// zones in which the
    /// NodePool's nodes can be created by NAP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningLocations")]
    pub auto_provisioning_locations: Option<Vec<String>>,
    /// Configuration
    /// options for the Autoscaling profile
    /// feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
    /// when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoscalingProfile")]
    pub autoscaling_profile: Option<String>,
    /// Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
    /// for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Global constraints for machine resources in the
    /// cluster. Configuring the cpu and memory types is required if node
    /// auto-provisioning is enabled. These limits will apply to node pool autoscaling
    /// in addition to node auto-provisioning. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLimits")]
    pub resource_limits: Option<Vec<ClusterForProviderClusterAutoscalingResourceLimits>>,
}

/// Contains defaults for a node pool created by NAP. A subset of fields also apply to
/// GKE Autopilot clusters.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaults {
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSize")]
    pub disk_size: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// NodeManagement configuration for this NodePool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub management: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsManagement>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig>,
    /// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    pub upgrade_settings: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings>,
}

/// NodeManagement configuration for this NodePool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
    /// Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    pub auto_repair: Option<bool>,
    /// Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    pub auto_upgrade: Option<bool>,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
    /// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    pub blue_green_settings: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings>,
    /// The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<f64>,
    /// The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<f64>,
    /// Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    pub node_pool_soak_duration: Option<String>,
    /// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    pub standard_rollout_policy: Option<ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    pub batch_node_count: Option<f64>,
    /// :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    pub batch_percentage: Option<f64>,
    /// Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    pub batch_soak_duration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderClusterAutoscalingResourceLimits {
    /// Maximum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
    /// Minimum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    /// The type of the resource. For example, cpu and
    /// memory.  See the guide to using Node Auto-Provisioning
    /// for a list of types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderConfidentialNodes {
    /// Enable Confidential GKE Nodes for this node pool, to
    /// enforce encryption of data in-use.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Cost Allocation feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderCostManagementConfig {
    /// Whether to enable the cost allocation feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderDatabaseEncryption {
    /// the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    pub key_name: Option<String>,
    /// ENCRYPTED or DECRYPTED
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderDefaultSnatStatus {
    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Configuration for Using Cloud DNS for GKE. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderDnsConfig {
    /// Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDns")]
    pub cluster_dns: Option<String>,
    /// The suffix used for all cluster service records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsDomain")]
    pub cluster_dns_domain: Option<String>,
    /// The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED (default) or CLUSTER_SCOPE or VPC_SCOPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsScope")]
    pub cluster_dns_scope: Option<String>,
}

/// Configuration for Kubernetes Beta APIs.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderEnableK8sBetaApis {
    /// Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledApis")]
    pub enabled_apis: Option<Vec<String>>,
}

/// Fleet configuration for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderFleet {
    /// The name of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Configuration for GKE Gateway API controller. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderGatewayApiConfig {
    /// Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderIdentityServiceConfig {
    /// Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration of cluster IP allocation for
/// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderIpAllocationPolicy {
    /// The configuration for additional pod secondary ranges at
    /// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
    /// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodRangesConfig")]
    pub additional_pod_ranges_config: Option<ClusterForProviderIpAllocationPolicyAdditionalPodRangesConfig>,
    /// The IP address range for the cluster pod IPs.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4CidrBlock")]
    pub cluster_ipv4_cidr_block: Option<String>,
    /// The name of the existing secondary
    /// range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
    /// cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSecondaryRangeName")]
    pub cluster_secondary_range_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    pub pod_cidr_overprovision_config: Option<ClusterForProviderIpAllocationPolicyPodCidrOverprovisionConfig>,
    /// The IP address range of the services IPs in this cluster.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesIpv4CidrBlock")]
    pub services_ipv4_cidr_block: Option<String>,
    /// The name of the existing
    /// secondary range in the cluster's subnetwork to use for service ClusterIPs.
    /// Alternatively, services_ipv4_cidr_block can be used to automatically create a
    /// GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesSecondaryRangeName")]
    pub services_secondary_range_name: Option<String>,
    /// The IP Stack Type of the cluster.
    /// Default value is IPV4.
    /// Possible values are IPV4 and IPV4_IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
}

/// The configuration for additional pod secondary ranges at
/// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
/// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderIpAllocationPolicyAdditionalPodRangesConfig {
    /// The names of the Pod ranges to add to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRangeNames")]
    pub pod_range_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderIpAllocationPolicyPodCidrOverprovisionConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderLoggingConfig {
    /// The GKE components exposing logs. Supported values include:
    /// SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenancePolicy {
    /// structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyMaintenanceWindow")]
    pub daily_maintenance_window: Option<ClusterForProviderMaintenancePolicyDailyMaintenanceWindow>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceExclusion")]
    pub maintenance_exclusion: Option<Vec<ClusterForProviderMaintenancePolicyMaintenanceExclusion>>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringWindow")]
    pub recurring_window: Option<ClusterForProviderMaintenancePolicyRecurringWindow>,
}

/// structure documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenancePolicyDailyMaintenanceWindow {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenancePolicyMaintenanceExclusion {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// The name of the cluster, unique within the project and
    /// location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionName")]
    pub exclusion_name: Option<String>,
    /// MaintenanceExclusionOptions provides maintenance exclusion related options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionOptions")]
    pub exclusion_options: Option<ClusterForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// MaintenanceExclusionOptions provides maintenance exclusion related options.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
    /// The scope of automatic upgrades to restrict in the exclusion window. One of: NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// structure documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenancePolicyRecurringWindow {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recurrence: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The authentication information for accessing the
/// Kubernetes master. Some values in this block are only returned by the API if
/// your service account has permission to get credentials for your GKE cluster. If
/// you see an unexpected diff unsetting your client cert, ensure you have the
/// container.clusters.getCredentials permission.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMasterAuth {
    /// Whether client certificate authorization is enabled for this cluster.  For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificateConfig")]
    pub client_certificate_config: Option<ClusterForProviderMasterAuthClientCertificateConfig>,
}

/// Whether client certificate authorization is enabled for this cluster.  For example:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMasterAuthClientCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issueClientCertificate")]
    pub issue_client_certificate: Option<bool>,
}

/// The desired
/// configuration options for master authorized networks. Omit the
/// nested cidr_blocks attribute to disallow external access (except
/// the cluster node IPs, which GKE automatically whitelists).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMasterAuthorizedNetworksConfig {
    /// External networks that can access the
    /// Kubernetes cluster master through HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlocks")]
    pub cidr_blocks: Option<Vec<ClusterForProviderMasterAuthorizedNetworksConfigCidrBlocks>>,
    /// Whether Kubernetes master is
    /// accessible via Google Compute Engine Public IPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpPublicCidrsAccessEnabled")]
    pub gcp_public_cidrs_access_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMasterAuthorizedNetworksConfigCidrBlocks {
    /// External network that can access Kubernetes master through HTTPS.
    /// Must be specified in CIDR notation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlock")]
    pub cidr_block: Option<String>,
    /// Field for users to identify CIDR blocks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMeshCertificates {
    /// Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCertificates")]
    pub enable_certificates: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMonitoringConfig {
    /// Configuration for Advanced Datapath Monitoring. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedDatapathObservabilityConfig")]
    pub advanced_datapath_observability_config: Option<ClusterForProviderMonitoringConfigAdvancedDatapathObservabilityConfig>,
    /// The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR and DCGM. In beta provider, WORKLOADS is supported on top of those 12 values. (WORKLOADS is deprecated and removed in GKE 1.24.) KUBELET and CADVISOR are only supported in GKE 1.29.3-gke.1093000 and above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
    /// Configuration for Managed Service for Prometheus. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheus")]
    pub managed_prometheus: Option<ClusterForProviderMonitoringConfigManagedPrometheus>,
}

/// Configuration for Advanced Datapath Monitoring. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
    /// Whether or not to enable advanced datapath metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMetrics")]
    pub enable_metrics: Option<bool>,
    /// Whether or not Relay is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRelay")]
    pub enable_relay: Option<bool>,
    /// Mode used to make Relay available. Deprecated in favor of enable_relay field. Remove this attribute's configuration as this field will be removed in the next major release and enable_relay will become a required field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relayMode")]
    pub relay_mode: Option<String>,
}

/// Configuration for Managed Service for Prometheus. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMonitoringConfigManagedPrometheus {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration options for the
/// NetworkPolicy
/// feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkPolicy {
    /// Whether network policy is enabled on the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Parameters used in creating the default node pool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfig {
    /// Specifies options for controlling
    /// advanced machine features. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<ClusterForProviderNodeConfigAdvancedMachineFeatures>,
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterForProviderNodeConfigConfidentialNodes>,
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterForProviderNodeConfigContainerdConfig>,
    /// Size of the disk attached to each node, specified
    /// in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    pub disk_size_gb: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    pub enable_confidential_storage: Option<bool>,
    /// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    pub ephemeral_storage_local_ssd_config: Option<ClusterForProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    /// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
    /// Node Pool must enable gvnic.
    /// GKE version 1.25.2-gke.1700 or later.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    pub fast_socket: Option<ClusterForProviderNodeConfigFastSocket>,
    /// Parameters for the Google Container Filesystem (GCFS).
    /// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
    /// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
    /// A machine_type that has more than 16 GiB of memory is also recommended.
    /// GCFS must be enabled in order to use image streaming.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    pub gcfs_config: Option<ClusterForProviderNodeConfigGcfsConfig>,
    /// List of the type and count of accelerator cards attached to the instance.
    /// Structure documented below.12 this field is an
    /// Attribute as Block
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<ClusterForProviderNodeConfigGuestAccelerator>>,
    /// Google Virtual NIC (gVNIC) is a virtual network interface.
    /// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
    /// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
    /// GKE node version 1.15.11-gke.15 or later
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gvnic: Option<ClusterForProviderNodeConfigGvnic>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    pub host_maintenance_policy: Option<ClusterForProviderNodeConfigHostMaintenancePolicy>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// Kubelet configuration, currently supported attributes can be found here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    pub kubelet_config: Option<ClusterForProviderNodeConfigKubeletConfig>,
    /// The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
    /// reserved by Kubernetes Core components and cannot be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters that can be configured on Linux nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    pub linux_node_config: Option<ClusterForProviderNodeConfigLinuxNodeConfig>,
    /// Parameters for the local NVMe SSDs. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    pub local_nvme_ssd_block_config: Option<ClusterForProviderNodeConfigLocalNvmeSsdBlockConfig>,
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
    /// wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
    /// The name of a Google Compute Engine machine type.
    /// Defaults to e2-medium. To create a custom machine type, value should be set as specified
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    /// The metadata key/value pairs assigned to instances in
    /// the cluster. From GKE 1. To avoid this, set the
    /// value in your config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    pub node_group: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// A boolean that represents whether or not the underlying node VMs
    /// are preemptible. See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<ClusterForProviderNodeConfigReservationAffinity>,
    /// The GCP labels (key/value pairs) to be applied to each node. Refer here
    /// for how these labels are applied to clusters, node pools and nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    pub secondary_boot_disks: Option<Vec<ClusterForProviderNodeConfigSecondaryBootDisks>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterForProviderNodeConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    pub service_account_selector: Option<ClusterForProviderNodeConfigServiceAccountSelector>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterForProviderNodeConfigShieldedInstanceConfig>,
    /// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    pub sole_tenant_config: Option<ClusterForProviderNodeConfigSoleTenantConfig>,
    /// A boolean that represents whether the underlying node VMs are spot.
    /// See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spot: Option<bool>,
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// A list of
    /// Kubernetes taints
    /// to apply to nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taint: Option<Vec<ClusterForProviderNodeConfigTaint>>,
    /// Metadata configuration to expose to workloads on the node pool.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    pub workload_metadata_config: Option<ClusterForProviderNodeConfigWorkloadMetadataConfig>,
}

/// Specifies options for controlling
/// advanced machine features. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigConfidentialNodes {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

/// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigEphemeralStorageLocalSsdConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
/// Node Pool must enable gvnic.
/// GKE version 1.25.2-gke.1700 or later.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigFastSocket {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters for the Google Container Filesystem (GCFS).
/// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
/// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
/// A machine_type that has more than 16 GiB of memory is also recommended.
/// GCFS must be enabled in order to use image streaming.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigGcfsConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Configuration for auto installation of GPU driver. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    pub gpu_driver_installation_config: Option<ClusterForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    /// Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    pub gpu_partition_size: Option<String>,
    /// Configuration for GPU sharing. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    pub gpu_sharing_config: Option<ClusterForProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for auto installation of GPU driver. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    pub gpu_driver_version: Option<String>,
}

/// Configuration for GPU sharing. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    pub gpu_sharing_strategy: Option<String>,
    /// The maximum number of containers that can share a GPU.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    pub max_shared_clients_per_gpu: Option<f64>,
}

/// Google Virtual NIC (gVNIC) is a virtual network interface.
/// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
/// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
/// GKE node version 1.15.11-gke.15 or later
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigGvnic {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    pub maintenance_interval: Option<String>,
}

/// Kubelet configuration, currently supported attributes can be found here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigKubeletConfig {
    /// If true, enables CPU CFS quota enforcement for
    /// containers that specify CPU limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    pub cpu_cfs_quota: Option<bool>,
    /// The CPU CFS quota period value. Specified
    /// as a sequence of decimal numbers, each with optional fraction and a unit suffix,
    /// such as "300ms". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m",
    /// "h". The value must be a positive duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    pub cpu_cfs_quota_period: Option<String>,
    /// The CPU management policy on the node. See
    /// K8S CPU Management Policies.
    /// One of "none" or "static". Defaults to none when kubelet_config is unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    pub cpu_manager_policy: Option<String>,
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters that can be configured on Linux nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigLinuxNodeConfig {
    /// Possible cgroup modes that can be used.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    pub cgroup_mode: Option<String>,
    /// The Linux kernel parameters to be applied to the nodes
    /// and all pods running on the nodes. Specified as a map from the key, such as
    /// net.core.wmem_max, to a string value. Currently supported attributes can be found here.
    /// Note that validations happen all server side. All attributes are optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<HashMap<String, String>>,
}

/// Parameters for the local NVMe SSDs. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigLocalNvmeSsdBlockConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    pub consume_reservation_type: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigSecondaryBootDisks {
    /// Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    pub disk_image: Option<String>,
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNodeConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNodeConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNodeConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNodeConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNodeConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNodeConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNodeConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNodeConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNodeConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNodeConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<Vec<ClusterForProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigTaint {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Metadata configuration to expose to workloads on the node pool.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodeConfigWorkloadMetadataConfig {
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Node pool configs that apply to auto-provisioned node pools in
/// autopilot clusters and
/// node auto-provisioning-enabled clusters. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolAutoConfig {
    /// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTags")]
    pub network_tags: Option<ClusterForProviderNodePoolAutoConfigNetworkTags>,
    /// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeKubeletConfig")]
    pub node_kubelet_config: Option<ClusterForProviderNodePoolAutoConfigNodeKubeletConfig>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolAutoConfigNetworkTags {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolAutoConfigNodeKubeletConfig {
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
}

/// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfigDefaults")]
    pub node_config_defaults: Option<ClusterForProviderNodePoolDefaultsNodeConfigDefaults>,
}

/// Subset of NodeConfig message that has defaults.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaultsNodeConfigDefaults {
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig>,
    /// only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

/// Configuration for the cluster upgrade notifications feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNotificationConfig {
    /// The pubsub config for the cluster's upgrade notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pubsub: Option<ClusterForProviderNotificationConfigPubsub>,
}

/// The pubsub config for the cluster's upgrade notifications.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNotificationConfigPubsub {
    /// Whether or not the notification config is enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ClusterForProviderNotificationConfigPubsubFilter>,
    /// The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNotificationConfigPubsubFilter {
    /// Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT and SECURITY_BULLETIN_EVENT. See Filtering notifications for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<Vec<String>>,
}

/// Configuration for private clusters,
/// clusters with private nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfig {
    /// When true, the cluster's private
    /// endpoint is used as the cluster endpoint and access through the public endpoint
    /// is disabled. When false, either endpoint can be used. This field only applies
    /// to private clusters, when enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateEndpoint")]
    pub enable_private_endpoint: Option<bool>,
    /// Enables the private cluster feature,
    /// creating a private endpoint on the cluster. In a private cluster, nodes only
    /// have RFC 1918 private addresses and communicate with the master's private
    /// endpoint via private networking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    pub enable_private_nodes: Option<bool>,
    /// Controls cluster master global
    /// access settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterGlobalAccessConfig")]
    pub master_global_access_config: Option<ClusterForProviderPrivateClusterConfigMasterGlobalAccessConfig>,
    /// The IP range in CIDR notation to use for
    /// the hosted master network. This range will be used for assigning private IP
    /// addresses to the cluster master(s) and the ILB VIP. This range must not overlap
    /// with any other ranges in use within the cluster's network, and it must be a /28
    /// subnet. See Private Cluster Limitations
    /// for more details. This field only applies to private clusters, when
    /// enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterIpv4CidrBlock")]
    pub master_ipv4_cidr_block: Option<String>,
    /// Subnetwork in cluster's network where master's endpoint will be provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetwork")]
    pub private_endpoint_subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetworkRef")]
    pub private_endpoint_subnetwork_ref: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetworkSelector")]
    pub private_endpoint_subnetwork_selector: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector>,
}

/// Controls cluster master global
/// access settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfigMasterGlobalAccessConfig {
    /// Whether the cluster master is accessible globally or
    /// not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration options for the Release channel
/// feature, which provide more control over automatic upgrades of your GKE clusters.
/// When updating this field, GKE imposes specific version requirements. See
/// Selecting a new release channel
/// for more details; the google_container_engine_versions datasource can provide
/// the default version for a channel. Instead, use the "UNSPECIFIED"
/// channel. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderReleaseChannel {
    /// The selected release channel.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// Configuration for the
/// ResourceUsageExportConfig feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderResourceUsageExportConfig {
    /// Parameters for using BigQuery as the destination of resource usage export.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryDestination")]
    pub bigquery_destination: Option<ClusterForProviderResourceUsageExportConfigBigqueryDestination>,
    /// Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
    /// in the cluster to meter network egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNetworkEgressMetering")]
    pub enable_network_egress_metering: Option<bool>,
    /// Whether to enable resource
    /// consumption metering on this cluster. When enabled, a table will be created in
    /// the resource export BigQuery dataset to store resource consumption data. The
    /// resulting table can be joined with the resource usage table or with BigQuery
    /// billing export. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceConsumptionMetering")]
    pub enable_resource_consumption_metering: Option<bool>,
}

/// Parameters for using BigQuery as the destination of resource usage export.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderResourceUsageExportConfigBigqueryDestination {
    /// The ID of a BigQuery Dataset. For Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
}

/// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecurityPostureConfig {
    /// Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vulnerabilityMode")]
    pub vulnerability_mode: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderServiceExternalIpsConfig {
    /// Controls whether external ips specified by a service will be allowed. It is enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderVerticalPodAutoscaling {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Workload Identity allows Kubernetes service accounts to act as a user-managed
/// Google IAM Service Account.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderWorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadPool")]
    pub workload_pool: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProvider {
    /// The configuration for addons supported by GKE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addonsConfig")]
    pub addons_config: Option<ClusterInitProviderAddonsConfig>,
    /// Enable NET_ADMIN for the cluster. Defaults to
    /// false. This field should only be enabled for Autopilot clusters (enable_autopilot
    /// set to true).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowNetAdmin")]
    pub allow_net_admin: Option<bool>,
    /// Configuration for the
    /// Google Groups for GKE feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticatorGroupsConfig")]
    pub authenticator_groups_config: Option<ClusterInitProviderAuthenticatorGroupsConfig>,
    /// Configuration options for the Binary
    /// Authorization feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterInitProviderBinaryAuthorization>,
    /// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
    /// automatically adjust the size of the cluster and create/delete node pools based
    /// on the current needs of the cluster's workload. See the
    /// guide to using Node Auto-Provisioning
    /// for more details. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterAutoscaling")]
    pub cluster_autoscaling: Option<ClusterInitProviderClusterAutoscaling>,
    /// The IP address range of the Kubernetes pods
    /// in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
    /// automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
    /// default a new cluster to routes-based, where ip_allocation_policy is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4Cidr")]
    pub cluster_ipv4_cidr: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterInitProviderConfidentialNodes>,
    /// Configuration for the
    /// Cost Allocation feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "costManagementConfig")]
    pub cost_management_config: Option<ClusterInitProviderCostManagementConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseEncryption")]
    pub database_encryption: Option<ClusterInitProviderDatabaseEncryption>,
    /// The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datapathProvider")]
    pub datapath_provider: Option<String>,
    /// The default maximum number of pods
    /// per node in this cluster. This doesn't work on "routes-based" clusters, clusters
    /// that don't have IP Aliasing enabled. See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMaxPodsPerNode")]
    pub default_max_pods_per_node: Option<f64>,
    /// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultSnatStatus")]
    pub default_snat_status: Option<ClusterInitProviderDefaultSnatStatus>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    /// Description of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Configuration for Using Cloud DNS for GKE. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ClusterInitProviderDnsConfig>,
    /// Enable Autopilot for this cluster. Defaults to false.
    /// Note that when this option is enabled, certain features of Standard GKE are not available.
    /// See the official documentation
    /// for available features.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutopilot")]
    pub enable_autopilot: Option<bool>,
    /// Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCiliumClusterwideNetworkPolicy")]
    pub enable_cilium_clusterwide_network_policy: Option<bool>,
    /// Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntranodeVisibility")]
    pub enable_intranode_visibility: Option<bool>,
    /// Configuration for Kubernetes Beta APIs.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableK8SBetaApis")]
    pub enable_k8s_beta_apis: Option<ClusterInitProviderEnableK8sBetaApis>,
    /// Whether to enable Kubernetes Alpha features for
    /// this cluster. Note that when this option is enabled, the cluster cannot be upgraded
    /// and will be automatically deleted after 30 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableKubernetesAlpha")]
    pub enable_kubernetes_alpha: Option<bool>,
    /// Whether L4ILB Subsetting is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableL4IlbSubsetting")]
    pub enable_l4_ilb_subsetting: Option<bool>,
    /// Whether the ABAC authorizer is enabled for this cluster.
    /// When enabled, identities in the system, including service accounts, nodes, and controllers,
    /// will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
    /// Defaults to false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLegacyAbac")]
    pub enable_legacy_abac: Option<bool>,
    /// Whether multi-networking is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMultiNetworking")]
    pub enable_multi_networking: Option<bool>,
    /// Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShieldedNodes")]
    pub enable_shielded_nodes: Option<bool>,
    /// Whether to enable Cloud TPU resources in this cluster.
    /// See the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTpu")]
    pub enable_tpu: Option<bool>,
    /// Fleet configuration for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterInitProviderFleet>,
    /// Configuration for GKE Gateway API controller. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayApiConfig")]
    pub gateway_api_config: Option<ClusterInitProviderGatewayApiConfig>,
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityServiceConfig")]
    pub identity_service_config: Option<ClusterInitProviderIdentityServiceConfig>,
    /// The number of nodes to create in this
    /// cluster's default node pool. In regional or multi-zonal clusters, this is the
    /// number of nodes per zone. Must be set if node_pool is not set. If you're using
    /// google_container_node_pool objects with no default node pool, you'll need to
    /// set this to a value of at least 1, alongside setting
    /// remove_default_node_pool to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    pub initial_node_count: Option<f64>,
    /// Configuration of cluster IP allocation for
    /// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAllocationPolicy")]
    pub ip_allocation_policy: Option<ClusterInitProviderIpAllocationPolicy>,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterInitProviderLoggingConfig>,
    /// The logging service that the cluster should
    /// write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
    /// logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingService")]
    pub logging_service: Option<String>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenancePolicy")]
    pub maintenance_policy: Option<ClusterInitProviderMaintenancePolicy>,
    /// The authentication information for accessing the
    /// Kubernetes master. Some values in this block are only returned by the API if
    /// your service account has permission to get credentials for your GKE cluster. If
    /// you see an unexpected diff unsetting your client cert, ensure you have the
    /// container.clusters.getCredentials permission.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuth")]
    pub master_auth: Option<ClusterInitProviderMasterAuth>,
    /// The desired
    /// configuration options for master authorized networks. Omit the
    /// nested cidr_blocks attribute to disallow external access (except
    /// the cluster node IPs, which GKE automatically whitelists).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuthorizedNetworksConfig")]
    pub master_authorized_networks_config: Option<ClusterInitProviderMasterAuthorizedNetworksConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshCertificates")]
    pub mesh_certificates: Option<ClusterInitProviderMeshCertificates>,
    /// The minimum version of the master. GKE
    /// will auto-update the master to new versions, so this does not guarantee the
    /// current master version--use the read-only master_version field to obtain that.
    /// If unset, the cluster's version will be set by GKE to the version of the most recent
    /// official release (which is not necessarily the latest version). If you intend to specify versions manually,
    /// the docs
    /// describe the various acceptable formats for this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minMasterVersion")]
    pub min_master_version: Option<String>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterInitProviderMonitoringConfig>,
    /// The monitoring service that the cluster
    /// should write metrics to.
    /// Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
    /// VM metrics will be collected by Google Compute Engine regardless of this setting
    /// Available options include
    /// monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
    /// Defaults to monitoring.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringService")]
    pub monitoring_service: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// network to which the cluster is connected. For Shared VPC, set this to the self link of the
    /// shared network.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Configuration options for the
    /// NetworkPolicy
    /// feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicy")]
    pub network_policy: Option<ClusterInitProviderNetworkPolicy>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterInitProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterInitProviderNetworkSelector>,
    /// Determines whether alias IPs or routes will be used for pod IPs in the cluster.
    /// Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkingMode")]
    pub networking_mode: Option<String>,
    /// Parameters used in creating the default node pool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    pub node_config: Option<ClusterInitProviderNodeConfig>,
    /// The list of zones in which the cluster's nodes
    /// are located. Nodes must be in the region of their regional cluster or in the
    /// same region as their cluster's zone for zonal clusters. If this is specified for
    /// a zonal cluster, omit the cluster's zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    pub node_locations: Option<Vec<String>>,
    /// Node pool configs that apply to auto-provisioned node pools in
    /// autopilot clusters and
    /// node auto-provisioning-enabled clusters. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolAutoConfig")]
    pub node_pool_auto_config: Option<ClusterInitProviderNodePoolAutoConfig>,
    /// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolDefaults")]
    pub node_pool_defaults: Option<ClusterInitProviderNodePoolDefaults>,
    /// The Kubernetes version on the nodes. Must either be unset
    /// or set to the same value as min_master_version on create. Defaults to the default
    /// version set by GKE which is not necessarily the latest version. This only affects
    /// nodes in the default node pool.
    /// To update nodes in other node pools, use the version attribute on the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVersion")]
    pub node_version: Option<String>,
    /// Configuration for the cluster upgrade notifications feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfig")]
    pub notification_config: Option<ClusterInitProviderNotificationConfig>,
    /// Configuration for private clusters,
    /// clusters with private nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateClusterConfig")]
    pub private_cluster_config: Option<ClusterInitProviderPrivateClusterConfig>,
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpv6GoogleAccess")]
    pub private_ipv6_google_access: Option<String>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration options for the Release channel
    /// feature, which provide more control over automatic upgrades of your GKE clusters.
    /// When updating this field, GKE imposes specific version requirements. See
    /// Selecting a new release channel
    /// for more details; the google_container_engine_versions datasource can provide
    /// the default version for a channel. Instead, use the "UNSPECIFIED"
    /// channel. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    pub release_channel: Option<ClusterInitProviderReleaseChannel>,
    /// If true, deletes the default node
    /// pool upon cluster creation. If you're using google_container_node_pool
    /// resources with no default node pool, this should be set to true, alongside
    /// setting initial_node_count to at least 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeDefaultNodePool")]
    pub remove_default_node_pool: Option<bool>,
    /// The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// Configuration for the
    /// ResourceUsageExportConfig feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceUsageExportConfig")]
    pub resource_usage_export_config: Option<ClusterInitProviderResourceUsageExportConfig>,
    /// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityPostureConfig")]
    pub security_posture_config: Option<ClusterInitProviderSecurityPostureConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExternalIpsConfig")]
    pub service_external_ips_config: Option<ClusterInitProviderServiceExternalIpsConfig>,
    /// The name or self_link of the Google Compute Engine
    /// subnetwork in which the cluster's instances are launched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    pub subnetwork_ref: Option<ClusterInitProviderSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    pub subnetwork_selector: Option<ClusterInitProviderSubnetworkSelector>,
    /// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verticalPodAutoscaling")]
    pub vertical_pod_autoscaling: Option<ClusterInitProviderVerticalPodAutoscaling>,
    /// Workload Identity allows Kubernetes service accounts to act as a user-managed
    /// Google IAM Service Account.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentityConfig")]
    pub workload_identity_config: Option<ClusterInitProviderWorkloadIdentityConfig>,
}

/// The configuration for addons supported by GKE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfig {
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudrunConfig")]
    pub cloudrun_config: Option<ClusterInitProviderAddonsConfigCloudrunConfig>,
    /// .
    /// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configConnectorConfig")]
    pub config_connector_config: Option<ClusterInitProviderAddonsConfigConfigConnectorConfig>,
    /// .
    /// The status of the NodeLocal DNSCache addon. It is disabled by default.
    /// Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsCacheConfig")]
    pub dns_cache_config: Option<ClusterInitProviderAddonsConfigDnsCacheConfig>,
    /// .
    /// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDiskCsiDriverConfig")]
    pub gce_persistent_disk_csi_driver_config: Option<ClusterInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig>,
    /// The status of the Filestore CSI driver addon,
    /// which allows the usage of filestore instance as volumes.
    /// It is disabled by default; set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpFilestoreCsiDriverConfig")]
    pub gcp_filestore_csi_driver_config: Option<ClusterInitProviderAddonsConfigGcpFilestoreCsiDriverConfig>,
    /// The status of the GCSFuse CSI driver addon,
    /// which allows the usage of a gcs bucket as volumes.
    /// It is disabled by default for Standard clusters; set enabled = true to enable.
    /// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
    /// See Enable the Cloud Storage FUSE CSI driver for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsFuseCsiDriverConfig")]
    pub gcs_fuse_csi_driver_config: Option<ClusterInitProviderAddonsConfigGcsFuseCsiDriverConfig>,
    /// .
    /// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gkeBackupAgentConfig")]
    pub gke_backup_agent_config: Option<ClusterInitProviderAddonsConfigGkeBackupAgentConfig>,
    /// The status of the Horizontal Pod Autoscaling
    /// addon, which increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    /// It is enabled by default;
    /// set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "horizontalPodAutoscaling")]
    pub horizontal_pod_autoscaling: Option<ClusterInitProviderAddonsConfigHorizontalPodAutoscaling>,
    /// The status of the HTTP (L7) load balancing
    /// controller addon, which makes it easy to set up HTTP load balancers for services in a
    /// cluster. It is enabled by default; set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpLoadBalancing")]
    pub http_load_balancing: Option<ClusterInitProviderAddonsConfigHttpLoadBalancing>,
    /// Whether we should enable the network policy addon
    /// for the master.  This must be enabled in order to enable network policy for the nodes.
    /// To enable this, you must also define a network_policy block,
    /// otherwise nothing will happen.
    /// It can only be disabled if the nodes already do not have network policies enabled.
    /// Defaults to disabled; set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicyConfig")]
    pub network_policy_config: Option<ClusterInitProviderAddonsConfigNetworkPolicyConfig>,
    /// . The status of the Ray Operator
    /// addon.
    /// It is disabled by default. Set enabled = true to enable. The minimum
    /// cluster version to enable Ray is 1.30.0-gke.1747000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayOperatorConfig")]
    pub ray_operator_config: Option<Vec<ClusterInitProviderAddonsConfigRayOperatorConfig>>,
    /// .
    /// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
    /// It is disabled by default for Standard clusters. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulHaConfig")]
    pub stateful_ha_config: Option<ClusterInitProviderAddonsConfigStatefulHaConfig>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigCloudrunConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// The load balancer type of CloudRun ingress service. It is external load balancer by default.
    /// Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerType")]
    pub load_balancer_type: Option<String>,
}

/// .
/// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigConfigConnectorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the NodeLocal DNSCache addon. It is disabled by default.
/// Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigDnsCacheConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Filestore CSI driver addon,
/// which allows the usage of filestore instance as volumes.
/// It is disabled by default; set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigGcpFilestoreCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the GCSFuse CSI driver addon,
/// which allows the usage of a gcs bucket as volumes.
/// It is disabled by default for Standard clusters; set enabled = true to enable.
/// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
/// See Enable the Cloud Storage FUSE CSI driver for more information.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigGcsFuseCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigGkeBackupAgentConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Horizontal Pod Autoscaling
/// addon, which increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
/// It is enabled by default;
/// set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigHorizontalPodAutoscaling {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// The status of the HTTP (L7) load balancing
/// controller addon, which makes it easy to set up HTTP load balancers for services in a
/// cluster. It is enabled by default; set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigHttpLoadBalancing {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Whether we should enable the network policy addon
/// for the master.  This must be enabled in order to enable network policy for the nodes.
/// To enable this, you must also define a network_policy block,
/// otherwise nothing will happen.
/// It can only be disabled if the nodes already do not have network policies enabled.
/// Defaults to disabled; set disabled = false to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigNetworkPolicyConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigRayOperatorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterLoggingConfig")]
    pub ray_cluster_logging_config: Option<ClusterInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterMonitoringConfig")]
    pub ray_cluster_monitoring_config: Option<ClusterInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
/// It is disabled by default for Standard clusters. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAddonsConfigStatefulHaConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Google Groups for GKE feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAuthenticatorGroupsConfig {
    /// The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroup")]
    pub security_group: Option<String>,
}

/// Configuration options for the Binary
/// Authorization feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderBinaryAuthorization {
    /// (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
    /// and PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

/// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
/// automatically adjust the size of the cluster and create/delete node pools based
/// on the current needs of the cluster's workload. See the
/// guide to using Node Auto-Provisioning
/// for more details. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscaling {
    /// Contains defaults for a node pool created by NAP. A subset of fields also apply to
    /// GKE Autopilot clusters.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningDefaults")]
    pub auto_provisioning_defaults: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaults>,
    /// The list of Google Compute Engine
    /// zones in which the
    /// NodePool's nodes can be created by NAP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningLocations")]
    pub auto_provisioning_locations: Option<Vec<String>>,
    /// Configuration
    /// options for the Autoscaling profile
    /// feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
    /// when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoscalingProfile")]
    pub autoscaling_profile: Option<String>,
    /// Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
    /// for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Global constraints for machine resources in the
    /// cluster. Configuring the cpu and memory types is required if node
    /// auto-provisioning is enabled. These limits will apply to node pool autoscaling
    /// in addition to node auto-provisioning. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLimits")]
    pub resource_limits: Option<Vec<ClusterInitProviderClusterAutoscalingResourceLimits>>,
}

/// Contains defaults for a node pool created by NAP. A subset of fields also apply to
/// GKE Autopilot clusters.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaults {
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSize")]
    pub disk_size: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// NodeManagement configuration for this NodePool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub management: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig>,
    /// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    pub upgrade_settings: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings>,
}

/// NodeManagement configuration for this NodePool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
    /// Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    pub auto_repair: Option<bool>,
    /// Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    pub auto_upgrade: Option<bool>,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
    /// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    pub blue_green_settings: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings>,
    /// The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<f64>,
    /// The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<f64>,
    /// Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    pub node_pool_soak_duration: Option<String>,
    /// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    pub standard_rollout_policy: Option<ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    pub batch_node_count: Option<f64>,
    /// :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    pub batch_percentage: Option<f64>,
    /// Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    pub batch_soak_duration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderClusterAutoscalingResourceLimits {
    /// Maximum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
    /// Minimum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    /// The type of the resource. For example, cpu and
    /// memory.  See the guide to using Node Auto-Provisioning
    /// for a list of types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderConfidentialNodes {
    /// Enable Confidential GKE Nodes for this node pool, to
    /// enforce encryption of data in-use.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Cost Allocation feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderCostManagementConfig {
    /// Whether to enable the cost allocation feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderDatabaseEncryption {
    /// the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    pub key_name: Option<String>,
    /// ENCRYPTED or DECRYPTED
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderDefaultSnatStatus {
    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Configuration for Using Cloud DNS for GKE. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderDnsConfig {
    /// Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDns")]
    pub cluster_dns: Option<String>,
    /// The suffix used for all cluster service records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsDomain")]
    pub cluster_dns_domain: Option<String>,
    /// The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED (default) or CLUSTER_SCOPE or VPC_SCOPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsScope")]
    pub cluster_dns_scope: Option<String>,
}

/// Configuration for Kubernetes Beta APIs.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderEnableK8sBetaApis {
    /// Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledApis")]
    pub enabled_apis: Option<Vec<String>>,
}

/// Fleet configuration for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderFleet {
    /// The name of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Configuration for GKE Gateway API controller. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderGatewayApiConfig {
    /// Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderIdentityServiceConfig {
    /// Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration of cluster IP allocation for
/// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderIpAllocationPolicy {
    /// The configuration for additional pod secondary ranges at
    /// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
    /// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodRangesConfig")]
    pub additional_pod_ranges_config: Option<ClusterInitProviderIpAllocationPolicyAdditionalPodRangesConfig>,
    /// The IP address range for the cluster pod IPs.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4CidrBlock")]
    pub cluster_ipv4_cidr_block: Option<String>,
    /// The name of the existing secondary
    /// range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
    /// cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSecondaryRangeName")]
    pub cluster_secondary_range_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    pub pod_cidr_overprovision_config: Option<ClusterInitProviderIpAllocationPolicyPodCidrOverprovisionConfig>,
    /// The IP address range of the services IPs in this cluster.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesIpv4CidrBlock")]
    pub services_ipv4_cidr_block: Option<String>,
    /// The name of the existing
    /// secondary range in the cluster's subnetwork to use for service ClusterIPs.
    /// Alternatively, services_ipv4_cidr_block can be used to automatically create a
    /// GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesSecondaryRangeName")]
    pub services_secondary_range_name: Option<String>,
    /// The IP Stack Type of the cluster.
    /// Default value is IPV4.
    /// Possible values are IPV4 and IPV4_IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
}

/// The configuration for additional pod secondary ranges at
/// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
/// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderIpAllocationPolicyAdditionalPodRangesConfig {
    /// The names of the Pod ranges to add to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRangeNames")]
    pub pod_range_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderIpAllocationPolicyPodCidrOverprovisionConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderLoggingConfig {
    /// The GKE components exposing logs. Supported values include:
    /// SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenancePolicy {
    /// structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyMaintenanceWindow")]
    pub daily_maintenance_window: Option<ClusterInitProviderMaintenancePolicyDailyMaintenanceWindow>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceExclusion")]
    pub maintenance_exclusion: Option<Vec<ClusterInitProviderMaintenancePolicyMaintenanceExclusion>>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringWindow")]
    pub recurring_window: Option<ClusterInitProviderMaintenancePolicyRecurringWindow>,
}

/// structure documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenancePolicyDailyMaintenanceWindow {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenancePolicyMaintenanceExclusion {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// The name of the cluster, unique within the project and
    /// location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionName")]
    pub exclusion_name: Option<String>,
    /// MaintenanceExclusionOptions provides maintenance exclusion related options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionOptions")]
    pub exclusion_options: Option<ClusterInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// MaintenanceExclusionOptions provides maintenance exclusion related options.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
    /// The scope of automatic upgrades to restrict in the exclusion window. One of: NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// structure documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenancePolicyRecurringWindow {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recurrence: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The authentication information for accessing the
/// Kubernetes master. Some values in this block are only returned by the API if
/// your service account has permission to get credentials for your GKE cluster. If
/// you see an unexpected diff unsetting your client cert, ensure you have the
/// container.clusters.getCredentials permission.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMasterAuth {
    /// Whether client certificate authorization is enabled for this cluster.  For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificateConfig")]
    pub client_certificate_config: Option<ClusterInitProviderMasterAuthClientCertificateConfig>,
}

/// Whether client certificate authorization is enabled for this cluster.  For example:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMasterAuthClientCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issueClientCertificate")]
    pub issue_client_certificate: Option<bool>,
}

/// The desired
/// configuration options for master authorized networks. Omit the
/// nested cidr_blocks attribute to disallow external access (except
/// the cluster node IPs, which GKE automatically whitelists).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMasterAuthorizedNetworksConfig {
    /// External networks that can access the
    /// Kubernetes cluster master through HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlocks")]
    pub cidr_blocks: Option<Vec<ClusterInitProviderMasterAuthorizedNetworksConfigCidrBlocks>>,
    /// Whether Kubernetes master is
    /// accessible via Google Compute Engine Public IPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpPublicCidrsAccessEnabled")]
    pub gcp_public_cidrs_access_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMasterAuthorizedNetworksConfigCidrBlocks {
    /// External network that can access Kubernetes master through HTTPS.
    /// Must be specified in CIDR notation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlock")]
    pub cidr_block: Option<String>,
    /// Field for users to identify CIDR blocks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMeshCertificates {
    /// Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCertificates")]
    pub enable_certificates: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMonitoringConfig {
    /// Configuration for Advanced Datapath Monitoring. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedDatapathObservabilityConfig")]
    pub advanced_datapath_observability_config: Option<ClusterInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig>,
    /// The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR and DCGM. In beta provider, WORKLOADS is supported on top of those 12 values. (WORKLOADS is deprecated and removed in GKE 1.24.) KUBELET and CADVISOR are only supported in GKE 1.29.3-gke.1093000 and above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
    /// Configuration for Managed Service for Prometheus. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheus")]
    pub managed_prometheus: Option<ClusterInitProviderMonitoringConfigManagedPrometheus>,
}

/// Configuration for Advanced Datapath Monitoring. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
    /// Whether or not to enable advanced datapath metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMetrics")]
    pub enable_metrics: Option<bool>,
    /// Whether or not Relay is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRelay")]
    pub enable_relay: Option<bool>,
    /// Mode used to make Relay available. Deprecated in favor of enable_relay field. Remove this attribute's configuration as this field will be removed in the next major release and enable_relay will become a required field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relayMode")]
    pub relay_mode: Option<String>,
}

/// Configuration for Managed Service for Prometheus. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMonitoringConfigManagedPrometheus {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration options for the
/// NetworkPolicy
/// feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkPolicy {
    /// Whether network policy is enabled on the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Parameters used in creating the default node pool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfig {
    /// Specifies options for controlling
    /// advanced machine features. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<ClusterInitProviderNodeConfigAdvancedMachineFeatures>,
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterInitProviderNodeConfigConfidentialNodes>,
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterInitProviderNodeConfigContainerdConfig>,
    /// Size of the disk attached to each node, specified
    /// in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    pub disk_size_gb: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    pub enable_confidential_storage: Option<bool>,
    /// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    pub ephemeral_storage_local_ssd_config: Option<ClusterInitProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    /// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
    /// Node Pool must enable gvnic.
    /// GKE version 1.25.2-gke.1700 or later.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    pub fast_socket: Option<ClusterInitProviderNodeConfigFastSocket>,
    /// Parameters for the Google Container Filesystem (GCFS).
    /// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
    /// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
    /// A machine_type that has more than 16 GiB of memory is also recommended.
    /// GCFS must be enabled in order to use image streaming.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    pub gcfs_config: Option<ClusterInitProviderNodeConfigGcfsConfig>,
    /// List of the type and count of accelerator cards attached to the instance.
    /// Structure documented below.12 this field is an
    /// Attribute as Block
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<ClusterInitProviderNodeConfigGuestAccelerator>>,
    /// Google Virtual NIC (gVNIC) is a virtual network interface.
    /// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
    /// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
    /// GKE node version 1.15.11-gke.15 or later
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gvnic: Option<ClusterInitProviderNodeConfigGvnic>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    pub host_maintenance_policy: Option<ClusterInitProviderNodeConfigHostMaintenancePolicy>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// Kubelet configuration, currently supported attributes can be found here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    pub kubelet_config: Option<ClusterInitProviderNodeConfigKubeletConfig>,
    /// The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
    /// reserved by Kubernetes Core components and cannot be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters that can be configured on Linux nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    pub linux_node_config: Option<ClusterInitProviderNodeConfigLinuxNodeConfig>,
    /// Parameters for the local NVMe SSDs. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    pub local_nvme_ssd_block_config: Option<ClusterInitProviderNodeConfigLocalNvmeSsdBlockConfig>,
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
    /// wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
    /// The name of a Google Compute Engine machine type.
    /// Defaults to e2-medium. To create a custom machine type, value should be set as specified
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    /// The metadata key/value pairs assigned to instances in
    /// the cluster. From GKE 1. To avoid this, set the
    /// value in your config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    pub node_group: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// A boolean that represents whether or not the underlying node VMs
    /// are preemptible. See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<ClusterInitProviderNodeConfigReservationAffinity>,
    /// The GCP labels (key/value pairs) to be applied to each node. Refer here
    /// for how these labels are applied to clusters, node pools and nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    pub secondary_boot_disks: Option<Vec<ClusterInitProviderNodeConfigSecondaryBootDisks>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterInitProviderNodeConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    pub service_account_selector: Option<ClusterInitProviderNodeConfigServiceAccountSelector>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterInitProviderNodeConfigShieldedInstanceConfig>,
    /// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    pub sole_tenant_config: Option<ClusterInitProviderNodeConfigSoleTenantConfig>,
    /// A boolean that represents whether the underlying node VMs are spot.
    /// See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spot: Option<bool>,
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// A list of
    /// Kubernetes taints
    /// to apply to nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taint: Option<Vec<ClusterInitProviderNodeConfigTaint>>,
    /// Metadata configuration to expose to workloads on the node pool.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    pub workload_metadata_config: Option<ClusterInitProviderNodeConfigWorkloadMetadataConfig>,
}

/// Specifies options for controlling
/// advanced machine features. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigConfidentialNodes {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

/// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
/// Node Pool must enable gvnic.
/// GKE version 1.25.2-gke.1700 or later.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigFastSocket {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters for the Google Container Filesystem (GCFS).
/// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
/// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
/// A machine_type that has more than 16 GiB of memory is also recommended.
/// GCFS must be enabled in order to use image streaming.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigGcfsConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Configuration for auto installation of GPU driver. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    pub gpu_driver_installation_config: Option<ClusterInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    /// Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    pub gpu_partition_size: Option<String>,
    /// Configuration for GPU sharing. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    pub gpu_sharing_config: Option<ClusterInitProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for auto installation of GPU driver. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    pub gpu_driver_version: Option<String>,
}

/// Configuration for GPU sharing. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    pub gpu_sharing_strategy: Option<String>,
    /// The maximum number of containers that can share a GPU.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    pub max_shared_clients_per_gpu: Option<f64>,
}

/// Google Virtual NIC (gVNIC) is a virtual network interface.
/// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
/// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
/// GKE node version 1.15.11-gke.15 or later
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigGvnic {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    pub maintenance_interval: Option<String>,
}

/// Kubelet configuration, currently supported attributes can be found here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigKubeletConfig {
    /// If true, enables CPU CFS quota enforcement for
    /// containers that specify CPU limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    pub cpu_cfs_quota: Option<bool>,
    /// The CPU CFS quota period value. Specified
    /// as a sequence of decimal numbers, each with optional fraction and a unit suffix,
    /// such as "300ms". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m",
    /// "h". The value must be a positive duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    pub cpu_cfs_quota_period: Option<String>,
    /// The CPU management policy on the node. See
    /// K8S CPU Management Policies.
    /// One of "none" or "static". Defaults to none when kubelet_config is unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    pub cpu_manager_policy: Option<String>,
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters that can be configured on Linux nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigLinuxNodeConfig {
    /// Possible cgroup modes that can be used.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    pub cgroup_mode: Option<String>,
    /// The Linux kernel parameters to be applied to the nodes
    /// and all pods running on the nodes. Specified as a map from the key, such as
    /// net.core.wmem_max, to a string value. Currently supported attributes can be found here.
    /// Note that validations happen all server side. All attributes are optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<HashMap<String, String>>,
}

/// Parameters for the local NVMe SSDs. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigLocalNvmeSsdBlockConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    pub consume_reservation_type: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigSecondaryBootDisks {
    /// Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    pub disk_image: Option<String>,
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNodeConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNodeConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNodeConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNodeConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNodeConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNodeConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNodeConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNodeConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<Vec<ClusterInitProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigTaint {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Metadata configuration to expose to workloads on the node pool.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodeConfigWorkloadMetadataConfig {
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Node pool configs that apply to auto-provisioned node pools in
/// autopilot clusters and
/// node auto-provisioning-enabled clusters. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolAutoConfig {
    /// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTags")]
    pub network_tags: Option<ClusterInitProviderNodePoolAutoConfigNetworkTags>,
    /// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeKubeletConfig")]
    pub node_kubelet_config: Option<ClusterInitProviderNodePoolAutoConfigNodeKubeletConfig>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolAutoConfigNetworkTags {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolAutoConfigNodeKubeletConfig {
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
}

/// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfigDefaults")]
    pub node_config_defaults: Option<ClusterInitProviderNodePoolDefaultsNodeConfigDefaults>,
}

/// Subset of NodeConfig message that has defaults.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaultsNodeConfigDefaults {
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig>,
    /// only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

/// Configuration for the cluster upgrade notifications feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNotificationConfig {
    /// The pubsub config for the cluster's upgrade notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pubsub: Option<ClusterInitProviderNotificationConfigPubsub>,
}

/// The pubsub config for the cluster's upgrade notifications.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNotificationConfigPubsub {
    /// Whether or not the notification config is enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ClusterInitProviderNotificationConfigPubsubFilter>,
    /// The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNotificationConfigPubsubFilter {
    /// Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT and SECURITY_BULLETIN_EVENT. See Filtering notifications for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<Vec<String>>,
}

/// Configuration for private clusters,
/// clusters with private nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfig {
    /// When true, the cluster's private
    /// endpoint is used as the cluster endpoint and access through the public endpoint
    /// is disabled. When false, either endpoint can be used. This field only applies
    /// to private clusters, when enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateEndpoint")]
    pub enable_private_endpoint: Option<bool>,
    /// Enables the private cluster feature,
    /// creating a private endpoint on the cluster. In a private cluster, nodes only
    /// have RFC 1918 private addresses and communicate with the master's private
    /// endpoint via private networking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    pub enable_private_nodes: Option<bool>,
    /// Controls cluster master global
    /// access settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterGlobalAccessConfig")]
    pub master_global_access_config: Option<ClusterInitProviderPrivateClusterConfigMasterGlobalAccessConfig>,
    /// The IP range in CIDR notation to use for
    /// the hosted master network. This range will be used for assigning private IP
    /// addresses to the cluster master(s) and the ILB VIP. This range must not overlap
    /// with any other ranges in use within the cluster's network, and it must be a /28
    /// subnet. See Private Cluster Limitations
    /// for more details. This field only applies to private clusters, when
    /// enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterIpv4CidrBlock")]
    pub master_ipv4_cidr_block: Option<String>,
    /// Subnetwork in cluster's network where master's endpoint will be provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetwork")]
    pub private_endpoint_subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetworkRef")]
    pub private_endpoint_subnetwork_ref: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetworkSelector")]
    pub private_endpoint_subnetwork_selector: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector>,
}

/// Controls cluster master global
/// access settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfigMasterGlobalAccessConfig {
    /// Whether the cluster master is accessible globally or
    /// not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration options for the Release channel
/// feature, which provide more control over automatic upgrades of your GKE clusters.
/// When updating this field, GKE imposes specific version requirements. See
/// Selecting a new release channel
/// for more details; the google_container_engine_versions datasource can provide
/// the default version for a channel. Instead, use the "UNSPECIFIED"
/// channel. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderReleaseChannel {
    /// The selected release channel.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// Configuration for the
/// ResourceUsageExportConfig feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderResourceUsageExportConfig {
    /// Parameters for using BigQuery as the destination of resource usage export.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryDestination")]
    pub bigquery_destination: Option<ClusterInitProviderResourceUsageExportConfigBigqueryDestination>,
    /// Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
    /// in the cluster to meter network egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNetworkEgressMetering")]
    pub enable_network_egress_metering: Option<bool>,
    /// Whether to enable resource
    /// consumption metering on this cluster. When enabled, a table will be created in
    /// the resource export BigQuery dataset to store resource consumption data. The
    /// resulting table can be joined with the resource usage table or with BigQuery
    /// billing export. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceConsumptionMetering")]
    pub enable_resource_consumption_metering: Option<bool>,
}

/// Parameters for using BigQuery as the destination of resource usage export.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderResourceUsageExportConfigBigqueryDestination {
    /// The ID of a BigQuery Dataset. For Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
}

/// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecurityPostureConfig {
    /// Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vulnerabilityMode")]
    pub vulnerability_mode: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderServiceExternalIpsConfig {
    /// Controls whether external ips specified by a service will be allowed. It is enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderVerticalPodAutoscaling {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Workload Identity allows Kubernetes service accounts to act as a user-managed
/// Google IAM Service Account.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderWorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadPool")]
    pub workload_pool: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProvider {
    /// The configuration for addons supported by GKE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addonsConfig")]
    pub addons_config: Option<ClusterStatusAtProviderAddonsConfig>,
    /// Enable NET_ADMIN for the cluster. Defaults to
    /// false. This field should only be enabled for Autopilot clusters (enable_autopilot
    /// set to true).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowNetAdmin")]
    pub allow_net_admin: Option<bool>,
    /// Configuration for the
    /// Google Groups for GKE feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticatorGroupsConfig")]
    pub authenticator_groups_config: Option<ClusterStatusAtProviderAuthenticatorGroupsConfig>,
    /// Configuration options for the Binary
    /// Authorization feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterStatusAtProviderBinaryAuthorization>,
    /// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
    /// automatically adjust the size of the cluster and create/delete node pools based
    /// on the current needs of the cluster's workload. See the
    /// guide to using Node Auto-Provisioning
    /// for more details. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterAutoscaling")]
    pub cluster_autoscaling: Option<ClusterStatusAtProviderClusterAutoscaling>,
    /// The IP address range of the Kubernetes pods
    /// in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
    /// automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
    /// default a new cluster to routes-based, where ip_allocation_policy is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4Cidr")]
    pub cluster_ipv4_cidr: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterStatusAtProviderConfidentialNodes>,
    /// Configuration for the
    /// Cost Allocation feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "costManagementConfig")]
    pub cost_management_config: Option<ClusterStatusAtProviderCostManagementConfig>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseEncryption")]
    pub database_encryption: Option<ClusterStatusAtProviderDatabaseEncryption>,
    /// The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datapathProvider")]
    pub datapath_provider: Option<String>,
    /// The default maximum number of pods
    /// per node in this cluster. This doesn't work on "routes-based" clusters, clusters
    /// that don't have IP Aliasing enabled. See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMaxPodsPerNode")]
    pub default_max_pods_per_node: Option<f64>,
    /// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultSnatStatus")]
    pub default_snat_status: Option<ClusterStatusAtProviderDefaultSnatStatus>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    /// Description of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Configuration for Using Cloud DNS for GKE. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ClusterStatusAtProviderDnsConfig>,
    /// Enable Autopilot for this cluster. Defaults to false.
    /// Note that when this option is enabled, certain features of Standard GKE are not available.
    /// See the official documentation
    /// for available features.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutopilot")]
    pub enable_autopilot: Option<bool>,
    /// Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCiliumClusterwideNetworkPolicy")]
    pub enable_cilium_clusterwide_network_policy: Option<bool>,
    /// Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntranodeVisibility")]
    pub enable_intranode_visibility: Option<bool>,
    /// Configuration for Kubernetes Beta APIs.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableK8SBetaApis")]
    pub enable_k8s_beta_apis: Option<ClusterStatusAtProviderEnableK8sBetaApis>,
    /// Whether to enable Kubernetes Alpha features for
    /// this cluster. Note that when this option is enabled, the cluster cannot be upgraded
    /// and will be automatically deleted after 30 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableKubernetesAlpha")]
    pub enable_kubernetes_alpha: Option<bool>,
    /// Whether L4ILB Subsetting is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableL4IlbSubsetting")]
    pub enable_l4_ilb_subsetting: Option<bool>,
    /// Whether the ABAC authorizer is enabled for this cluster.
    /// When enabled, identities in the system, including service accounts, nodes, and controllers,
    /// will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
    /// Defaults to false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLegacyAbac")]
    pub enable_legacy_abac: Option<bool>,
    /// Whether multi-networking is enabled for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMultiNetworking")]
    pub enable_multi_networking: Option<bool>,
    /// Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShieldedNodes")]
    pub enable_shielded_nodes: Option<bool>,
    /// Whether to enable Cloud TPU resources in this cluster.
    /// See the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTpu")]
    pub enable_tpu: Option<bool>,
    /// The IP address of this cluster's Kubernetes master.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Fleet configuration for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterStatusAtProviderFleet>,
    /// Configuration for GKE Gateway API controller. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayApiConfig")]
    pub gateway_api_config: Option<ClusterStatusAtProviderGatewayApiConfig>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{zone}}/clusters/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityServiceConfig")]
    pub identity_service_config: Option<ClusterStatusAtProviderIdentityServiceConfig>,
    /// The number of nodes to create in this
    /// cluster's default node pool. In regional or multi-zonal clusters, this is the
    /// number of nodes per zone. Must be set if node_pool is not set. If you're using
    /// google_container_node_pool objects with no default node pool, you'll need to
    /// set this to a value of at least 1, alongside setting
    /// remove_default_node_pool to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    pub initial_node_count: Option<f64>,
    /// Configuration of cluster IP allocation for
    /// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAllocationPolicy")]
    pub ip_allocation_policy: Option<ClusterStatusAtProviderIpAllocationPolicy>,
    /// The fingerprint of the set of labels for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelFingerprint")]
    pub label_fingerprint: Option<String>,
    /// The location (region or zone) in which the cluster
    /// master will be created, as well as the default node location. If you specify a
    /// zone (such as us-central1-a), the cluster will be a zonal cluster with a
    /// single cluster master. If you specify a region (such as us-west1), the
    /// cluster will be a regional cluster with multiple masters spread across zones in
    /// the region, and with default node locations in those zones as well
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterStatusAtProviderLoggingConfig>,
    /// The logging service that the cluster should
    /// write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
    /// logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingService")]
    pub logging_service: Option<String>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenancePolicy")]
    pub maintenance_policy: Option<ClusterStatusAtProviderMaintenancePolicy>,
    /// The authentication information for accessing the
    /// Kubernetes master. Some values in this block are only returned by the API if
    /// your service account has permission to get credentials for your GKE cluster. If
    /// you see an unexpected diff unsetting your client cert, ensure you have the
    /// container.clusters.getCredentials permission.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuth")]
    pub master_auth: Option<ClusterStatusAtProviderMasterAuth>,
    /// The desired
    /// configuration options for master authorized networks. Omit the
    /// nested cidr_blocks attribute to disallow external access (except
    /// the cluster node IPs, which GKE automatically whitelists).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterAuthorizedNetworksConfig")]
    pub master_authorized_networks_config: Option<ClusterStatusAtProviderMasterAuthorizedNetworksConfig>,
    /// The current version of the master in the cluster. This may
    /// be different than the min_master_version set in the config if the master
    /// has been updated by GKE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterVersion")]
    pub master_version: Option<String>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshCertificates")]
    pub mesh_certificates: Option<ClusterStatusAtProviderMeshCertificates>,
    /// The minimum version of the master. GKE
    /// will auto-update the master to new versions, so this does not guarantee the
    /// current master version--use the read-only master_version field to obtain that.
    /// If unset, the cluster's version will be set by GKE to the version of the most recent
    /// official release (which is not necessarily the latest version). If you intend to specify versions manually,
    /// the docs
    /// describe the various acceptable formats for this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minMasterVersion")]
    pub min_master_version: Option<String>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterStatusAtProviderMonitoringConfig>,
    /// The monitoring service that the cluster
    /// should write metrics to.
    /// Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
    /// VM metrics will be collected by Google Compute Engine regardless of this setting
    /// Available options include
    /// monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
    /// Defaults to monitoring.googleapis.com/kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringService")]
    pub monitoring_service: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// network to which the cluster is connected. For Shared VPC, set this to the self link of the
    /// shared network.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Configuration options for the
    /// NetworkPolicy
    /// feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicy")]
    pub network_policy: Option<ClusterStatusAtProviderNetworkPolicy>,
    /// Determines whether alias IPs or routes will be used for pod IPs in the cluster.
    /// Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkingMode")]
    pub networking_mode: Option<String>,
    /// Parameters used in creating the default node pool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    pub node_config: Option<ClusterStatusAtProviderNodeConfig>,
    /// The list of zones in which the cluster's nodes
    /// are located. Nodes must be in the region of their regional cluster or in the
    /// same region as their cluster's zone for zonal clusters. If this is specified for
    /// a zonal cluster, omit the cluster's zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    pub node_locations: Option<Vec<String>>,
    /// List of node pools associated with this cluster.
    /// See google_container_node_pool for schema.
    /// Warning: node pools defined inside a cluster can't be changed (or added/removed) after
    /// cluster creation without deleting and recreating the entire cluster. Unless you absolutely need the ability
    /// to say "these are the only node pools associated with this cluster", use the
    /// google_container_node_pool resource instead of this property.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePool")]
    pub node_pool: Option<Vec<ClusterStatusAtProviderNodePool>>,
    /// Node pool configs that apply to auto-provisioned node pools in
    /// autopilot clusters and
    /// node auto-provisioning-enabled clusters. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolAutoConfig")]
    pub node_pool_auto_config: Option<ClusterStatusAtProviderNodePoolAutoConfig>,
    /// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolDefaults")]
    pub node_pool_defaults: Option<ClusterStatusAtProviderNodePoolDefaults>,
    /// The Kubernetes version on the nodes. Must either be unset
    /// or set to the same value as min_master_version on create. Defaults to the default
    /// version set by GKE which is not necessarily the latest version. This only affects
    /// nodes in the default node pool.
    /// To update nodes in other node pools, use the version attribute on the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVersion")]
    pub node_version: Option<String>,
    /// Configuration for the cluster upgrade notifications feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfig")]
    pub notification_config: Option<ClusterStatusAtProviderNotificationConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// Configuration for private clusters,
    /// clusters with private nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateClusterConfig")]
    pub private_cluster_config: Option<ClusterStatusAtProviderPrivateClusterConfig>,
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpv6GoogleAccess")]
    pub private_ipv6_google_access: Option<String>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration options for the Release channel
    /// feature, which provide more control over automatic upgrades of your GKE clusters.
    /// When updating this field, GKE imposes specific version requirements. See
    /// Selecting a new release channel
    /// for more details; the google_container_engine_versions datasource can provide
    /// the default version for a channel. Instead, use the "UNSPECIFIED"
    /// channel. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    pub release_channel: Option<ClusterStatusAtProviderReleaseChannel>,
    /// If true, deletes the default node
    /// pool upon cluster creation. If you're using google_container_node_pool
    /// resources with no default node pool, this should be set to true, alongside
    /// setting initial_node_count to at least 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeDefaultNodePool")]
    pub remove_default_node_pool: Option<bool>,
    /// The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// Configuration for the
    /// ResourceUsageExportConfig feature.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceUsageExportConfig")]
    pub resource_usage_export_config: Option<ClusterStatusAtProviderResourceUsageExportConfig>,
    /// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityPostureConfig")]
    pub security_posture_config: Option<ClusterStatusAtProviderSecurityPostureConfig>,
    /// The server-defined URL for the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    pub self_link: Option<String>,
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExternalIpsConfig")]
    pub service_external_ips_config: Option<ClusterStatusAtProviderServiceExternalIpsConfig>,
    /// The IP address range of the Kubernetes services in this
    /// cluster, in CIDR
    /// notation (e.g. 1.2.3.4/29). Service addresses are typically put in the last
    /// /16 from the container CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesIpv4Cidr")]
    pub services_ipv4_cidr: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// subnetwork in which the cluster's instances are launched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    /// The IP address range of the Cloud TPUs in this cluster, in
    /// CIDR
    /// notation (e.g. 1.2.3.4/29).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tpuIpv4CidrBlock")]
    pub tpu_ipv4_cidr_block: Option<String>,
    /// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verticalPodAutoscaling")]
    pub vertical_pod_autoscaling: Option<ClusterStatusAtProviderVerticalPodAutoscaling>,
    /// Workload Identity allows Kubernetes service accounts to act as a user-managed
    /// Google IAM Service Account.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentityConfig")]
    pub workload_identity_config: Option<ClusterStatusAtProviderWorkloadIdentityConfig>,
}

/// The configuration for addons supported by GKE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfig {
    /// . Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudrunConfig")]
    pub cloudrun_config: Option<ClusterStatusAtProviderAddonsConfigCloudrunConfig>,
    /// .
    /// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configConnectorConfig")]
    pub config_connector_config: Option<ClusterStatusAtProviderAddonsConfigConfigConnectorConfig>,
    /// .
    /// The status of the NodeLocal DNSCache addon. It is disabled by default.
    /// Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsCacheConfig")]
    pub dns_cache_config: Option<ClusterStatusAtProviderAddonsConfigDnsCacheConfig>,
    /// .
    /// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDiskCsiDriverConfig")]
    pub gce_persistent_disk_csi_driver_config: Option<ClusterStatusAtProviderAddonsConfigGcePersistentDiskCsiDriverConfig>,
    /// The status of the Filestore CSI driver addon,
    /// which allows the usage of filestore instance as volumes.
    /// It is disabled by default; set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpFilestoreCsiDriverConfig")]
    pub gcp_filestore_csi_driver_config: Option<ClusterStatusAtProviderAddonsConfigGcpFilestoreCsiDriverConfig>,
    /// The status of the GCSFuse CSI driver addon,
    /// which allows the usage of a gcs bucket as volumes.
    /// It is disabled by default for Standard clusters; set enabled = true to enable.
    /// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
    /// See Enable the Cloud Storage FUSE CSI driver for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsFuseCsiDriverConfig")]
    pub gcs_fuse_csi_driver_config: Option<ClusterStatusAtProviderAddonsConfigGcsFuseCsiDriverConfig>,
    /// .
    /// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gkeBackupAgentConfig")]
    pub gke_backup_agent_config: Option<ClusterStatusAtProviderAddonsConfigGkeBackupAgentConfig>,
    /// The status of the Horizontal Pod Autoscaling
    /// addon, which increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    /// It is enabled by default;
    /// set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "horizontalPodAutoscaling")]
    pub horizontal_pod_autoscaling: Option<ClusterStatusAtProviderAddonsConfigHorizontalPodAutoscaling>,
    /// The status of the HTTP (L7) load balancing
    /// controller addon, which makes it easy to set up HTTP load balancers for services in a
    /// cluster. It is enabled by default; set disabled = true to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpLoadBalancing")]
    pub http_load_balancing: Option<ClusterStatusAtProviderAddonsConfigHttpLoadBalancing>,
    /// Whether we should enable the network policy addon
    /// for the master.  This must be enabled in order to enable network policy for the nodes.
    /// To enable this, you must also define a network_policy block,
    /// otherwise nothing will happen.
    /// It can only be disabled if the nodes already do not have network policies enabled.
    /// Defaults to disabled; set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPolicyConfig")]
    pub network_policy_config: Option<ClusterStatusAtProviderAddonsConfigNetworkPolicyConfig>,
    /// . The status of the Ray Operator
    /// addon.
    /// It is disabled by default. Set enabled = true to enable. The minimum
    /// cluster version to enable Ray is 1.30.0-gke.1747000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayOperatorConfig")]
    pub ray_operator_config: Option<Vec<ClusterStatusAtProviderAddonsConfigRayOperatorConfig>>,
    /// .
    /// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
    /// It is disabled by default for Standard clusters. Set enabled = true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulHaConfig")]
    pub stateful_ha_config: Option<ClusterStatusAtProviderAddonsConfigStatefulHaConfig>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigCloudrunConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// The load balancer type of CloudRun ingress service. It is external load balancer by default.
    /// Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerType")]
    pub load_balancer_type: Option<String>,
}

/// .
/// The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigConfigConnectorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the NodeLocal DNSCache addon. It is disabled by default.
/// Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigDnsCacheConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Filestore CSI driver addon,
/// which allows the usage of filestore instance as volumes.
/// It is disabled by default; set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigGcpFilestoreCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the GCSFuse CSI driver addon,
/// which allows the usage of a gcs bucket as volumes.
/// It is disabled by default for Standard clusters; set enabled = true to enable.
/// It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
/// See Enable the Cloud Storage FUSE CSI driver for more information.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigGcsFuseCsiDriverConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigGkeBackupAgentConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The status of the Horizontal Pod Autoscaling
/// addon, which increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
/// It is enabled by default;
/// set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigHorizontalPodAutoscaling {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// The status of the HTTP (L7) load balancing
/// controller addon, which makes it easy to set up HTTP load balancers for services in a
/// cluster. It is enabled by default; set disabled = true to disable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigHttpLoadBalancing {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Whether we should enable the network policy addon
/// for the master.  This must be enabled in order to enable network policy for the nodes.
/// To enable this, you must also define a network_policy block,
/// otherwise nothing will happen.
/// It can only be disabled if the nodes already do not have network policies enabled.
/// Defaults to disabled; set disabled = false to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigNetworkPolicyConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigRayOperatorConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Logging configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterLoggingConfig")]
    pub ray_cluster_logging_config: Option<ClusterStatusAtProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig>,
    /// Monitoring configuration for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rayClusterMonitoringConfig")]
    pub ray_cluster_monitoring_config: Option<ClusterStatusAtProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// .
/// The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
/// It is disabled by default for Standard clusters. Set enabled = true to enable.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAddonsConfigStatefulHaConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Google Groups for GKE feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAuthenticatorGroupsConfig {
    /// The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroup")]
    pub security_group: Option<String>,
}

/// Configuration options for the Binary
/// Authorization feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderBinaryAuthorization {
    /// (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
    /// and PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

/// Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
/// automatically adjust the size of the cluster and create/delete node pools based
/// on the current needs of the cluster's workload. See the
/// guide to using Node Auto-Provisioning
/// for more details. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscaling {
    /// Contains defaults for a node pool created by NAP. A subset of fields also apply to
    /// GKE Autopilot clusters.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningDefaults")]
    pub auto_provisioning_defaults: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaults>,
    /// The list of Google Compute Engine
    /// zones in which the
    /// NodePool's nodes can be created by NAP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoProvisioningLocations")]
    pub auto_provisioning_locations: Option<Vec<String>>,
    /// Configuration
    /// options for the Autoscaling profile
    /// feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
    /// when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoscalingProfile")]
    pub autoscaling_profile: Option<String>,
    /// Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
    /// for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Global constraints for machine resources in the
    /// cluster. Configuring the cpu and memory types is required if node
    /// auto-provisioning is enabled. These limits will apply to node pool autoscaling
    /// in addition to node auto-provisioning. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLimits")]
    pub resource_limits: Option<Vec<ClusterStatusAtProviderClusterAutoscalingResourceLimits>>,
}

/// Contains defaults for a node pool created by NAP. A subset of fields also apply to
/// GKE Autopilot clusters.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaults {
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSize")]
    pub disk_size: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// NodeManagement configuration for this NodePool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub management: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsManagement>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig>,
    /// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    pub upgrade_settings: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings>,
}

/// NodeManagement configuration for this NodePool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
    /// Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    pub auto_repair: Option<bool>,
    /// Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    pub auto_upgrade: Option<bool>,
    /// Specifies the Auto Upgrade knobs for the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeOptions")]
    pub upgrade_options: Option<Vec<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgradeStartTime")]
    pub auto_upgrade_start_time: Option<String>,
    /// Description of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
    /// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    pub blue_green_settings: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings>,
    /// The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<f64>,
    /// The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<f64>,
    /// Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    pub node_pool_soak_duration: Option<String>,
    /// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    pub standard_rollout_policy: Option<ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    pub batch_node_count: Option<f64>,
    /// :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    pub batch_percentage: Option<f64>,
    /// Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    pub batch_soak_duration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderClusterAutoscalingResourceLimits {
    /// Maximum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
    /// Minimum amount of the resource in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    /// The type of the resource. For example, cpu and
    /// memory.  See the guide to using Node Auto-Provisioning
    /// for a list of types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderConfidentialNodes {
    /// Enable Confidential GKE Nodes for this node pool, to
    /// enforce encryption of data in-use.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration for the
/// Cost Allocation feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderCostManagementConfig {
    /// Whether to enable the cost allocation feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderDatabaseEncryption {
    /// the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    pub key_name: Option<String>,
    /// ENCRYPTED or DECRYPTED
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderDefaultSnatStatus {
    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Configuration for Using Cloud DNS for GKE. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderDnsConfig {
    /// Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDns")]
    pub cluster_dns: Option<String>,
    /// The suffix used for all cluster service records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsDomain")]
    pub cluster_dns_domain: Option<String>,
    /// The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED (default) or CLUSTER_SCOPE or VPC_SCOPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDnsScope")]
    pub cluster_dns_scope: Option<String>,
}

/// Configuration for Kubernetes Beta APIs.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderEnableK8sBetaApis {
    /// Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledApis")]
    pub enabled_apis: Option<Vec<String>>,
}

/// Fleet configuration for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderFleet {
    /// The resource name of the fleet Membership resource associated to this cluster with format //gkehub.googleapis.com/projects/{{project}}/locations/{{location}}/memberships/{{name}}. See the official doc for fleet management.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership: Option<String>,
    /// The short name of the fleet membership, extracted from fleet.0.membership. You can use this field to configure membership_id under google_gkehub_feature_membership.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipId")]
    pub membership_id: Option<String>,
    /// The location of the fleet membership,  extracted from fleet.0.membership. You can use this field to configure membership_location under google_gkehub_feature_membership.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipLocation")]
    pub membership_location: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preRegistered")]
    pub pre_registered: Option<bool>,
    /// The name of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Configuration for GKE Gateway API controller. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderGatewayApiConfig {
    /// Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// . Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderIdentityServiceConfig {
    /// Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration of cluster IP allocation for
/// VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderIpAllocationPolicy {
    /// The configuration for additional pod secondary ranges at
    /// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
    /// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodRangesConfig")]
    pub additional_pod_ranges_config: Option<ClusterStatusAtProviderIpAllocationPolicyAdditionalPodRangesConfig>,
    /// The IP address range for the cluster pod IPs.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIpv4CidrBlock")]
    pub cluster_ipv4_cidr_block: Option<String>,
    /// The name of the existing secondary
    /// range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
    /// cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSecondaryRangeName")]
    pub cluster_secondary_range_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    pub pod_cidr_overprovision_config: Option<ClusterStatusAtProviderIpAllocationPolicyPodCidrOverprovisionConfig>,
    /// The IP address range of the services IPs in this cluster.
    /// Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
    /// to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
    /// from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
    /// pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesIpv4CidrBlock")]
    pub services_ipv4_cidr_block: Option<String>,
    /// The name of the existing
    /// secondary range in the cluster's subnetwork to use for service ClusterIPs.
    /// Alternatively, services_ipv4_cidr_block can be used to automatically create a
    /// GKE-managed one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesSecondaryRangeName")]
    pub services_secondary_range_name: Option<String>,
    /// The IP Stack Type of the cluster.
    /// Default value is IPV4.
    /// Possible values are IPV4 and IPV4_IPV6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
}

/// The configuration for additional pod secondary ranges at
/// the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
/// secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderIpAllocationPolicyAdditionalPodRangesConfig {
    /// The names of the Pod ranges to add to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRangeNames")]
    pub pod_range_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderIpAllocationPolicyPodCidrOverprovisionConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Logging configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderLoggingConfig {
    /// The GKE components exposing logs. Supported values include:
    /// SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenancePolicy {
    /// structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyMaintenanceWindow")]
    pub daily_maintenance_window: Option<ClusterStatusAtProviderMaintenancePolicyDailyMaintenanceWindow>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceExclusion")]
    pub maintenance_exclusion: Option<Vec<ClusterStatusAtProviderMaintenancePolicyMaintenanceExclusion>>,
    /// structure documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringWindow")]
    pub recurring_window: Option<ClusterStatusAtProviderMaintenancePolicyRecurringWindow>,
}

/// structure documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenancePolicyDailyMaintenanceWindow {
    /// Duration of the time window, automatically chosen to be
    /// smallest possible in the given scenario.
    /// Duration will be in RFC3339 format "PTnHnMnS".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenancePolicyMaintenanceExclusion {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// The name of the cluster, unique within the project and
    /// location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionName")]
    pub exclusion_name: Option<String>,
    /// MaintenanceExclusionOptions provides maintenance exclusion related options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionOptions")]
    pub exclusion_options: Option<ClusterStatusAtProviderMaintenancePolicyMaintenanceExclusionExclusionOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// MaintenanceExclusionOptions provides maintenance exclusion related options.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
    /// The scope of automatic upgrades to restrict in the exclusion window. One of: NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// structure documented below
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenancePolicyRecurringWindow {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recurrence: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The authentication information for accessing the
/// Kubernetes master. Some values in this block are only returned by the API if
/// your service account has permission to get credentials for your GKE cluster. If
/// you see an unexpected diff unsetting your client cert, ensure you have the
/// container.clusters.getCredentials permission.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMasterAuth {
    /// Base64 encoded public certificate
    /// used by clients to authenticate to the cluster endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    /// Whether client certificate authorization is enabled for this cluster.  For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificateConfig")]
    pub client_certificate_config: Option<ClusterStatusAtProviderMasterAuthClientCertificateConfig>,
    /// Base64 encoded public certificate
    /// that is the root certificate of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterCaCertificate")]
    pub cluster_ca_certificate: Option<String>,
}

/// Whether client certificate authorization is enabled for this cluster.  For example:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMasterAuthClientCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issueClientCertificate")]
    pub issue_client_certificate: Option<bool>,
}

/// The desired
/// configuration options for master authorized networks. Omit the
/// nested cidr_blocks attribute to disallow external access (except
/// the cluster node IPs, which GKE automatically whitelists).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMasterAuthorizedNetworksConfig {
    /// External networks that can access the
    /// Kubernetes cluster master through HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlocks")]
    pub cidr_blocks: Option<Vec<ClusterStatusAtProviderMasterAuthorizedNetworksConfigCidrBlocks>>,
    /// Whether Kubernetes master is
    /// accessible via Google Compute Engine Public IPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpPublicCidrsAccessEnabled")]
    pub gcp_public_cidrs_access_enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMasterAuthorizedNetworksConfigCidrBlocks {
    /// External network that can access Kubernetes master through HTTPS.
    /// Must be specified in CIDR notation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrBlock")]
    pub cidr_block: Option<String>,
    /// Field for users to identify CIDR blocks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMeshCertificates {
    /// Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCertificates")]
    pub enable_certificates: Option<bool>,
}

/// Monitoring configuration for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMonitoringConfig {
    /// Configuration for Advanced Datapath Monitoring. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedDatapathObservabilityConfig")]
    pub advanced_datapath_observability_config: Option<ClusterStatusAtProviderMonitoringConfigAdvancedDatapathObservabilityConfig>,
    /// The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR and DCGM. In beta provider, WORKLOADS is supported on top of those 12 values. (WORKLOADS is deprecated and removed in GKE 1.24.) KUBELET and CADVISOR are only supported in GKE 1.29.3-gke.1093000 and above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
    /// Configuration for Managed Service for Prometheus. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheus")]
    pub managed_prometheus: Option<ClusterStatusAtProviderMonitoringConfigManagedPrometheus>,
}

/// Configuration for Advanced Datapath Monitoring. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
    /// Whether or not to enable advanced datapath metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMetrics")]
    pub enable_metrics: Option<bool>,
    /// Whether or not Relay is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRelay")]
    pub enable_relay: Option<bool>,
    /// Mode used to make Relay available. Deprecated in favor of enable_relay field. Remove this attribute's configuration as this field will be removed in the next major release and enable_relay will become a required field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relayMode")]
    pub relay_mode: Option<String>,
}

/// Configuration for Managed Service for Prometheus. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMonitoringConfigManagedPrometheus {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration options for the
/// NetworkPolicy
/// feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNetworkPolicy {
    /// Whether network policy is enabled on the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}

/// Parameters used in creating the default node pool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfig {
    /// Specifies options for controlling
    /// advanced machine features. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<ClusterStatusAtProviderNodeConfigAdvancedMachineFeatures>,
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterStatusAtProviderNodeConfigConfidentialNodes>,
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterStatusAtProviderNodeConfigContainerdConfig>,
    /// Size of the disk attached to each node, specified
    /// in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    pub disk_size_gb: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// List of kubernetes taints applied to each node. Structure is documented above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveTaints")]
    pub effective_taints: Option<Vec<ClusterStatusAtProviderNodeConfigEffectiveTaints>>,
    /// Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    pub enable_confidential_storage: Option<bool>,
    /// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    pub ephemeral_storage_local_ssd_config: Option<ClusterStatusAtProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    /// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
    /// Node Pool must enable gvnic.
    /// GKE version 1.25.2-gke.1700 or later.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    pub fast_socket: Option<ClusterStatusAtProviderNodeConfigFastSocket>,
    /// Parameters for the Google Container Filesystem (GCFS).
    /// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
    /// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
    /// A machine_type that has more than 16 GiB of memory is also recommended.
    /// GCFS must be enabled in order to use image streaming.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    pub gcfs_config: Option<ClusterStatusAtProviderNodeConfigGcfsConfig>,
    /// List of the type and count of accelerator cards attached to the instance.
    /// Structure documented below.12 this field is an
    /// Attribute as Block
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<ClusterStatusAtProviderNodeConfigGuestAccelerator>>,
    /// Google Virtual NIC (gVNIC) is a virtual network interface.
    /// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
    /// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
    /// GKE node version 1.15.11-gke.15 or later
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gvnic: Option<ClusterStatusAtProviderNodeConfigGvnic>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    pub host_maintenance_policy: Option<ClusterStatusAtProviderNodeConfigHostMaintenancePolicy>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// Kubelet configuration, currently supported attributes can be found here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    pub kubelet_config: Option<ClusterStatusAtProviderNodeConfigKubeletConfig>,
    /// The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
    /// reserved by Kubernetes Core components and cannot be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters that can be configured on Linux nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    pub linux_node_config: Option<ClusterStatusAtProviderNodeConfigLinuxNodeConfig>,
    /// Parameters for the local NVMe SSDs. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    pub local_nvme_ssd_block_config: Option<ClusterStatusAtProviderNodeConfigLocalNvmeSsdBlockConfig>,
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
    /// wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
    /// The name of a Google Compute Engine machine type.
    /// Defaults to e2-medium. To create a custom machine type, value should be set as specified
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    /// The metadata key/value pairs assigned to instances in
    /// the cluster. From GKE 1. To avoid this, set the
    /// value in your config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    pub node_group: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// A boolean that represents whether or not the underlying node VMs
    /// are preemptible. See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<ClusterStatusAtProviderNodeConfigReservationAffinity>,
    /// The GCP labels (key/value pairs) to be applied to each node. Refer here
    /// for how these labels are applied to clusters, node pools and nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    pub secondary_boot_disks: Option<Vec<ClusterStatusAtProviderNodeConfigSecondaryBootDisks>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterStatusAtProviderNodeConfigShieldedInstanceConfig>,
    /// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    pub sole_tenant_config: Option<ClusterStatusAtProviderNodeConfigSoleTenantConfig>,
    /// A boolean that represents whether the underlying node VMs are spot.
    /// See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spot: Option<bool>,
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// A list of
    /// Kubernetes taints
    /// to apply to nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taint: Option<Vec<ClusterStatusAtProviderNodeConfigTaint>>,
    /// Metadata configuration to expose to workloads on the node pool.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    pub workload_metadata_config: Option<ClusterStatusAtProviderNodeConfigWorkloadMetadataConfig>,
}

/// Specifies options for controlling
/// advanced machine features. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigConfidentialNodes {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigEffectiveTaints {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigEphemeralStorageLocalSsdConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
/// Node Pool must enable gvnic.
/// GKE version 1.25.2-gke.1700 or later.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigFastSocket {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters for the Google Container Filesystem (GCFS).
/// If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
/// For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
/// A machine_type that has more than 16 GiB of memory is also recommended.
/// GCFS must be enabled in order to use image streaming.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigGcfsConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Configuration for auto installation of GPU driver. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    pub gpu_driver_installation_config: Option<ClusterStatusAtProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    /// Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    pub gpu_partition_size: Option<String>,
    /// Configuration for GPU sharing. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    pub gpu_sharing_config: Option<ClusterStatusAtProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for auto installation of GPU driver. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    pub gpu_driver_version: Option<String>,
}

/// Configuration for GPU sharing. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    pub gpu_sharing_strategy: Option<String>,
    /// The maximum number of containers that can share a GPU.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    pub max_shared_clients_per_gpu: Option<f64>,
}

/// Google Virtual NIC (gVNIC) is a virtual network interface.
/// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
/// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
/// GKE node version 1.15.11-gke.15 or later
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigGvnic {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    pub maintenance_interval: Option<String>,
}

/// Kubelet configuration, currently supported attributes can be found here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigKubeletConfig {
    /// If true, enables CPU CFS quota enforcement for
    /// containers that specify CPU limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    pub cpu_cfs_quota: Option<bool>,
    /// The CPU CFS quota period value. Specified
    /// as a sequence of decimal numbers, each with optional fraction and a unit suffix,
    /// such as "300ms". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m",
    /// "h". The value must be a positive duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    pub cpu_cfs_quota_period: Option<String>,
    /// The CPU management policy on the node. See
    /// K8S CPU Management Policies.
    /// One of "none" or "static". Defaults to none when kubelet_config is unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    pub cpu_manager_policy: Option<String>,
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters that can be configured on Linux nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigLinuxNodeConfig {
    /// Possible cgroup modes that can be used.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    pub cgroup_mode: Option<String>,
    /// The Linux kernel parameters to be applied to the nodes
    /// and all pods running on the nodes. Specified as a map from the key, such as
    /// net.core.wmem_max, to a string value. Currently supported attributes can be found here.
    /// Note that validations happen all server side. All attributes are optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<HashMap<String, String>>,
}

/// Parameters for the local NVMe SSDs. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigLocalNvmeSsdBlockConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    pub consume_reservation_type: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigSecondaryBootDisks {
    /// Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    pub disk_image: Option<String>,
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<Vec<ClusterStatusAtProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigTaint {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Metadata configuration to expose to workloads on the node pool.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodeConfigWorkloadMetadataConfig {
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autoscaling: Option<ClusterStatusAtProviderNodePoolAutoscaling>,
    /// The number of nodes to create in this
    /// cluster's default node pool. In regional or multi-zonal clusters, this is the
    /// number of nodes per zone. Must be set if node_pool is not set. If you're using
    /// google_container_node_pool objects with no default node pool, you'll need to
    /// set this to a value of at least 1, alongside setting
    /// remove_default_node_pool to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    pub initial_node_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupUrls")]
    pub instance_group_urls: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedInstanceGroupUrls")]
    pub managed_instance_group_urls: Option<Vec<String>>,
    /// NodeManagement configuration for this NodePool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub management: Option<ClusterStatusAtProviderNodePoolManagement>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    pub max_pods_per_node: Option<f64>,
    /// The name of the cluster, unique within the project and
    /// location.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    pub name_prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    pub network_config: Option<ClusterStatusAtProviderNodePoolNetworkConfig>,
    /// Parameters used in creating the default node pool. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    pub node_config: Option<ClusterStatusAtProviderNodePoolNodeConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeCount")]
    pub node_count: Option<f64>,
    /// The list of zones in which the cluster's nodes
    /// are located. Nodes must be in the region of their regional cluster or in the
    /// same region as their cluster's zone for zonal clusters. If this is specified for
    /// a zonal cluster, omit the cluster's zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    pub node_locations: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementPolicy")]
    pub placement_policy: Option<ClusterStatusAtProviderNodePoolPlacementPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedProvisioning")]
    pub queued_provisioning: Option<ClusterStatusAtProviderNodePoolQueuedProvisioning>,
    /// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    pub upgrade_settings: Option<ClusterStatusAtProviderNodePoolUpgradeSettings>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolAutoscaling {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationPolicy")]
    pub location_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxNodeCount")]
    pub max_node_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCount")]
    pub min_node_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMaxNodeCount")]
    pub total_max_node_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMinNodeCount")]
    pub total_min_node_count: Option<f64>,
}

/// NodeManagement configuration for this NodePool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolManagement {
    /// Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    pub auto_repair: Option<bool>,
    /// Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    pub auto_upgrade: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNetworkConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalNodeNetworkConfigs")]
    pub additional_node_network_configs: Option<Vec<ClusterStatusAtProviderNodePoolNetworkConfigAdditionalNodeNetworkConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodNetworkConfigs")]
    pub additional_pod_network_configs: Option<Vec<ClusterStatusAtProviderNodePoolNetworkConfigAdditionalPodNetworkConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPodRange")]
    pub create_pod_range: Option<bool>,
    /// Enables the private cluster feature,
    /// creating a private endpoint on the cluster. In a private cluster, nodes only
    /// have RFC 1918 private addresses and communicate with the master's private
    /// endpoint via private networking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    pub enable_private_nodes: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    pub network_performance_config: Option<ClusterStatusAtProviderNodePoolNetworkConfigNetworkPerformanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    pub pod_cidr_overprovision_config: Option<ClusterStatusAtProviderNodePoolNetworkConfigPodCidrOverprovisionConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podIpv4CidrBlock")]
    pub pod_ipv4_cidr_block: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRange")]
    pub pod_range: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNetworkConfigAdditionalNodeNetworkConfigs {
    /// The name or self_link of the Google Compute Engine
    /// network to which the cluster is connected. For Shared VPC, set this to the self link of the
    /// shared network.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// subnetwork in which the cluster's instances are launched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNetworkConfigAdditionalPodNetworkConfigs {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    pub max_pods_per_node: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryPodRange")]
    pub secondary_pod_range: Option<String>,
    /// The name or self_link of the Google Compute Engine
    /// subnetwork in which the cluster's instances are launched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNetworkConfigNetworkPerformanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    pub total_egress_bandwidth_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNetworkConfigPodCidrOverprovisionConfig {
    /// The status of the Istio addon, which makes it easy to set up Istio for services in a
    /// cluster. It is disabled by default. Set disabled = false to enable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// Parameters used in creating the default node pool. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfig {
    /// Specifies options for controlling
    /// advanced machine features. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<ClusterStatusAtProviderNodePoolNodeConfigAdvancedMachineFeatures>,
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    pub boot_disk_kms_key: Option<String>,
    /// Configuration for Confidential Nodes feature. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    pub confidential_nodes: Option<ClusterStatusAtProviderNodePoolNodeConfigConfidentialNodes>,
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterStatusAtProviderNodePoolNodeConfigContainerdConfig>,
    /// Size of the disk attached to each node, specified
    /// in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    pub disk_size_gb: Option<f64>,
    /// Type of the disk attached to each node
    /// (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    pub disk_type: Option<String>,
    /// List of kubernetes taints applied to each node. Structure is documented above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveTaints")]
    pub effective_taints: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigEffectiveTaints>>,
    /// Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    pub enable_confidential_storage: Option<bool>,
    /// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    pub ephemeral_storage_local_ssd_config: Option<ClusterStatusAtProviderNodePoolNodeConfigEphemeralStorageLocalSsdConfig>,
    /// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
    /// Node Pool must enable gvnic.
    /// GKE version 1.25.2-gke.1700 or later.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    pub fast_socket: Option<ClusterStatusAtProviderNodePoolNodeConfigFastSocket>,
    /// The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    pub gcfs_config: Option<ClusterStatusAtProviderNodePoolNodeConfigGcfsConfig>,
    /// List of the type and count of accelerator cards attached to the instance.
    /// Structure documented below.12 this field is an
    /// Attribute as Block
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigGuestAccelerator>>,
    /// Google Virtual NIC (gVNIC) is a virtual network interface.
    /// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
    /// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
    /// GKE node version 1.15.11-gke.15 or later
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gvnic: Option<ClusterStatusAtProviderNodePoolNodeConfigGvnic>,
    /// The maintenance policy to use for the cluster. Structure is
    /// documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    pub host_maintenance_policy: Option<ClusterStatusAtProviderNodePoolNodeConfigHostMaintenancePolicy>,
    /// The image type to use for this node. Note that changing the image type
    /// will delete and recreate all nodes in the node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    pub image_type: Option<String>,
    /// Kubelet configuration, currently supported attributes can be found here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    pub kubelet_config: Option<ClusterStatusAtProviderNodePoolNodeConfigKubeletConfig>,
    /// The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
    /// reserved by Kubernetes Core components and cannot be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters that can be configured on Linux nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    pub linux_node_config: Option<ClusterStatusAtProviderNodePoolNodeConfigLinuxNodeConfig>,
    /// Parameters for the local NVMe SSDs. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    pub local_nvme_ssd_block_config: Option<ClusterStatusAtProviderNodePoolNodeConfigLocalNvmeSsdBlockConfig>,
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
    /// The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
    /// The name of a Google Compute Engine machine type.
    /// Defaults to e2-medium. To create a custom machine type, value should be set as specified
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    /// The metadata key/value pairs assigned to instances in
    /// the cluster. From GKE 1. To avoid this, set the
    /// value in your config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Minimum CPU platform to be used by this instance.
    /// The instance may be scheduled on the specified or newer CPU platform. Applicable
    /// values are the friendly names of CPU platforms, such as Intel Haswell. See the
    /// official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    pub node_group: Option<String>,
    /// The set of Google API scopes to be made available
    /// on all of the node VMs under the "default" service account.
    /// Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    pub oauth_scopes: Option<Vec<String>>,
    /// A boolean that represents whether or not the underlying node VMs
    /// are preemptible. See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<ClusterStatusAtProviderNodePoolNodeConfigReservationAffinity>,
    /// The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<HashMap<String, String>>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    pub secondary_boot_disks: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigSecondaryBootDisks>>,
    /// The service account to be used by the Node VMs.
    /// If not specified, the "default" service account is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Shielded Instance options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<ClusterStatusAtProviderNodePoolNodeConfigShieldedInstanceConfig>,
    /// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    pub sole_tenant_config: Option<ClusterStatusAtProviderNodePoolNodeConfigSoleTenantConfig>,
    /// A boolean that represents whether the underlying node VMs are spot.
    /// See the official documentation
    /// for more information. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spot: Option<bool>,
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// A list of
    /// Kubernetes taints
    /// to apply to nodes. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taint: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigTaint>>,
    /// Metadata configuration to expose to workloads on the node pool.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    pub workload_metadata_config: Option<ClusterStatusAtProviderNodePoolNodeConfigWorkloadMetadataConfig>,
}

/// Specifies options for controlling
/// advanced machine features. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
}

/// Configuration for Confidential Nodes feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigConfidentialNodes {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigEffectiveTaints {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigEphemeralStorageLocalSsdConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
/// Node Pool must enable gvnic.
/// GKE version 1.25.2-gke.1700 or later.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigFastSocket {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigGcfsConfig {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Configuration for auto installation of GPU driver. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    pub gpu_driver_installation_config: Option<ClusterStatusAtProviderNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    /// Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    pub gpu_partition_size: Option<String>,
    /// Configuration for GPU sharing. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    pub gpu_sharing_config: Option<ClusterStatusAtProviderNodePoolNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for auto installation of GPU driver. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    pub gpu_driver_version: Option<String>,
}

/// Configuration for GPU sharing. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigGuestAcceleratorGpuSharingConfig {
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    pub gpu_sharing_strategy: Option<String>,
    /// The maximum number of containers that can share a GPU.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    pub max_shared_clients_per_gpu: Option<f64>,
}

/// Google Virtual NIC (gVNIC) is a virtual network interface.
/// Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
/// gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
/// GKE node version 1.15.11-gke.15 or later
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigGvnic {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The maintenance policy to use for the cluster. Structure is
/// documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    pub maintenance_interval: Option<String>,
}

/// Kubelet configuration, currently supported attributes can be found here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigKubeletConfig {
    /// If true, enables CPU CFS quota enforcement for
    /// containers that specify CPU limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    pub cpu_cfs_quota: Option<bool>,
    /// The CPU CFS quota period value. Specified
    /// as a sequence of decimal numbers, each with optional fraction and a unit suffix,
    /// such as "300ms". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m",
    /// "h". The value must be a positive duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    pub cpu_cfs_quota_period: Option<String>,
    /// The CPU management policy on the node. See
    /// K8S CPU Management Policies.
    /// One of "none" or "static". Defaults to none when kubelet_config is unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    pub cpu_manager_policy: Option<String>,
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters that can be configured on Linux nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigLinuxNodeConfig {
    /// Possible cgroup modes that can be used.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    pub cgroup_mode: Option<String>,
    /// The Linux kernel parameters to be applied to the nodes
    /// and all pods running on the nodes. Specified as a map from the key, such as
    /// net.core.wmem_max, to a string value. Currently supported attributes can be found here.
    /// Note that validations happen all server side. All attributes are optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<HashMap<String, String>>,
}

/// Parameters for the local NVMe SSDs. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigLocalNvmeSsdBlockConfig {
    /// The amount of local SSD disks that will be
    /// attached to each cluster node. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    pub consume_reservation_type: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigSecondaryBootDisks {
    /// Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    pub disk_image: Option<String>,
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Shielded Instance options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigShieldedInstanceConfig {
    /// Defines if the instance has integrity monitoring enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    /// Defines if the instance has Secure Boot enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
}

/// Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<Vec<ClusterStatusAtProviderNodePoolNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigSoleTenantConfigNodeAffinity {
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigTaint {
    /// Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value for taint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Metadata configuration to expose to workloads on the node pool.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolNodeConfigWorkloadMetadataConfig {
    /// How to expose the node metadata to the workload running on the node.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolPlacementPolicy {
    /// The name of the cluster, unique within the project and
    /// location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyName")]
    pub policy_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tpuTopology")]
    pub tpu_topology: Option<String>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolQueuedProvisioning {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Specifies the upgrade settings for NAP created node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolUpgradeSettings {
    /// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    pub blue_green_settings: Option<ClusterStatusAtProviderNodePoolUpgradeSettingsBlueGreenSettings>,
    /// The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<f64>,
    /// The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<f64>,
    /// Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    pub node_pool_soak_duration: Option<String>,
    /// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    pub standard_rollout_policy: Option<ClusterStatusAtProviderNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    pub batch_node_count: Option<f64>,
    /// :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    pub batch_percentage: Option<f64>,
    /// Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    pub batch_soak_duration: Option<String>,
}

/// Node pool configs that apply to auto-provisioned node pools in
/// autopilot clusters and
/// node auto-provisioning-enabled clusters. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolAutoConfig {
    /// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTags")]
    pub network_tags: Option<ClusterStatusAtProviderNodePoolAutoConfigNetworkTags>,
    /// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeKubeletConfig")]
    pub node_kubelet_config: Option<ClusterStatusAtProviderNodePoolAutoConfigNodeKubeletConfig>,
    /// A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolAutoConfigNetworkTags {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolAutoConfigNodeKubeletConfig {
    /// Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
}

/// Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfigDefaults")]
    pub node_config_defaults: Option<ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaults>,
}

/// Subset of NodeConfig message that has defaults.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaults {
    /// Parameters to customize containerd runtime. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    pub containerd_config: Option<ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig>,
    /// only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    /// The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    pub logging_variant: Option<String>,
}

/// Parameters to customize containerd runtime. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
    /// Configuration for private container registries. There are two fields in this config:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    pub private_registry_access_config: Option<ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig>,
}

/// Configuration for private container registries. There are two fields in this config:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
    /// List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    pub certificate_authority_domain_config: Option<Vec<ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    pub gcp_secret_manager_certificate_config: Option<ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    pub secret_uri: Option<String>,
}

/// Configuration for the cluster upgrade notifications feature. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNotificationConfig {
    /// The pubsub config for the cluster's upgrade notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pubsub: Option<ClusterStatusAtProviderNotificationConfigPubsub>,
}

/// The pubsub config for the cluster's upgrade notifications.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNotificationConfigPubsub {
    /// Whether or not the notification config is enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ClusterStatusAtProviderNotificationConfigPubsubFilter>,
    /// The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNotificationConfigPubsubFilter {
    /// Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT and SECURITY_BULLETIN_EVENT. See Filtering notifications for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<Vec<String>>,
}

/// Configuration for private clusters,
/// clusters with private nodes. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderPrivateClusterConfig {
    /// When true, the cluster's private
    /// endpoint is used as the cluster endpoint and access through the public endpoint
    /// is disabled. When false, either endpoint can be used. This field only applies
    /// to private clusters, when enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateEndpoint")]
    pub enable_private_endpoint: Option<bool>,
    /// Enables the private cluster feature,
    /// creating a private endpoint on the cluster. In a private cluster, nodes only
    /// have RFC 1918 private addresses and communicate with the master's private
    /// endpoint via private networking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    pub enable_private_nodes: Option<bool>,
    /// Controls cluster master global
    /// access settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterGlobalAccessConfig")]
    pub master_global_access_config: Option<ClusterStatusAtProviderPrivateClusterConfigMasterGlobalAccessConfig>,
    /// The IP range in CIDR notation to use for
    /// the hosted master network. This range will be used for assigning private IP
    /// addresses to the cluster master(s) and the ILB VIP. This range must not overlap
    /// with any other ranges in use within the cluster's network, and it must be a /28
    /// subnet. See Private Cluster Limitations
    /// for more details. This field only applies to private clusters, when
    /// enable_private_nodes is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterIpv4CidrBlock")]
    pub master_ipv4_cidr_block: Option<String>,
    /// The name of the peering between this cluster and the Google owned VPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "peeringName")]
    pub peering_name: Option<String>,
    /// The internal IP address of this cluster's master endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpoint")]
    pub private_endpoint: Option<String>,
    /// Subnetwork in cluster's network where master's endpoint will be provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateEndpointSubnetwork")]
    pub private_endpoint_subnetwork: Option<String>,
    /// The external IP address of this cluster's master endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicEndpoint")]
    pub public_endpoint: Option<String>,
}

/// Controls cluster master global
/// access settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderPrivateClusterConfigMasterGlobalAccessConfig {
    /// Whether the cluster master is accessible globally or
    /// not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration options for the Release channel
/// feature, which provide more control over automatic upgrades of your GKE clusters.
/// When updating this field, GKE imposes specific version requirements. See
/// Selecting a new release channel
/// for more details; the google_container_engine_versions datasource can provide
/// the default version for a channel. Instead, use the "UNSPECIFIED"
/// channel. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderReleaseChannel {
    /// The selected release channel.
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
}

/// Configuration for the
/// ResourceUsageExportConfig feature.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderResourceUsageExportConfig {
    /// Parameters for using BigQuery as the destination of resource usage export.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryDestination")]
    pub bigquery_destination: Option<ClusterStatusAtProviderResourceUsageExportConfigBigqueryDestination>,
    /// Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
    /// in the cluster to meter network egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNetworkEgressMetering")]
    pub enable_network_egress_metering: Option<bool>,
    /// Whether to enable resource
    /// consumption metering on this cluster. When enabled, a table will be created in
    /// the resource export BigQuery dataset to store resource consumption data. The
    /// resulting table can be joined with the resource usage table or with BigQuery
    /// billing export. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceConsumptionMetering")]
    pub enable_resource_consumption_metering: Option<bool>,
}

/// Parameters for using BigQuery as the destination of resource usage export.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderResourceUsageExportConfigBigqueryDestination {
    /// The ID of a BigQuery Dataset. For Example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
}

/// Enable/Disable Security Posture API features for the cluster. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderSecurityPostureConfig {
    /// Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vulnerabilityMode")]
    pub vulnerability_mode: Option<String>,
}

/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderServiceExternalIpsConfig {
    /// Controls whether external ips specified by a service will be allowed. It is enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderVerticalPodAutoscaling {
    /// Enables vertical pod autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Workload Identity allows Kubernetes service accounts to act as a user-managed
/// Google IAM Service Account.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderWorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadPool")]
    pub workload_pool: Option<String>,
}

