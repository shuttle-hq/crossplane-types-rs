// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "alloydb.gcp.upbound.io", version = "v1beta2", kind = "Cluster", plural = "clusters")]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProvider {
    /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automatedBackupPolicy")]
    pub automated_backup_policy: Option<ClusterForProviderAutomatedBackupPolicy>,
    /// The type of cluster. If not set, defaults to PRIMARY.
    /// Default value is PRIMARY.
    /// Possible values are: PRIMARY, SECONDARY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterType")]
    pub cluster_type: Option<String>,
    /// The continuous backup config for this cluster.
    /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousBackupConfig")]
    pub continuous_backup_config: Option<ClusterForProviderContinuousBackupConfig>,
    /// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseVersion")]
    pub database_version: Option<String>,
    /// Policy to determine if the cluster should be deleted forcefully.
    /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
    /// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// User-settable and human-readable display name for the Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterForProviderEncryptionConfig>,
    /// For Resource freshness validation (https://google.aip.dev/154)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// Initial user to setup during cluster creation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialUser")]
    pub initial_user: Option<ClusterForProviderInitialUser>,
    /// User-defined labels for the alloydb cluster.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the alloydb cluster should reside.
    pub location: String,
    /// MaintenanceUpdatePolicy defines the policy for system updates.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceUpdatePolicy")]
    pub maintenance_update_policy: Option<ClusterForProviderMaintenanceUpdatePolicy>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Metadata related to network configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    pub network_config: Option<ClusterForProviderNetworkConfig>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterForProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterForProviderNetworkSelector>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration for Private Service Connect (PSC) for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConfig")]
    pub psc_config: Option<ClusterForProviderPscConfig>,
    /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreBackupSource")]
    pub restore_backup_source: Option<ClusterForProviderRestoreBackupSource>,
    /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreContinuousBackupSource")]
    pub restore_continuous_backup_source: Option<ClusterForProviderRestoreContinuousBackupSource>,
    /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryConfig")]
    pub secondary_config: Option<ClusterForProviderSecondaryConfig>,
}

/// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicy {
    /// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
    /// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupWindow")]
    pub backup_window: Option<String>,
    /// Whether automated backups are enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterForProviderAutomatedBackupPolicyEncryptionConfig>,
    /// Labels to apply to backups created using this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "quantityBasedRetention")]
    pub quantity_based_retention: Option<ClusterForProviderAutomatedBackupPolicyQuantityBasedRetention>,
    /// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeBasedRetention")]
    pub time_based_retention: Option<ClusterForProviderAutomatedBackupPolicyTimeBasedRetention>,
    /// Weekly schedule for the Backup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklySchedule")]
    pub weekly_schedule: Option<ClusterForProviderAutomatedBackupPolicyWeeklySchedule>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicyEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicyQuantityBasedRetention {
    /// The number of backups to retain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicyTimeBasedRetention {
    /// The retention period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
}

/// Weekly schedule for the Backup.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicyWeeklySchedule {
    /// The days of the week to perform a backup. At least one day of the week must be provided.
    /// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daysOfWeek")]
    pub days_of_week: Option<Vec<String>>,
    /// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTimes")]
    pub start_times: Option<Vec<ClusterForProviderAutomatedBackupPolicyWeeklyScheduleStartTimes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAutomatedBackupPolicyWeeklyScheduleStartTimes {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// The continuous backup config for this cluster.
/// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderContinuousBackupConfig {
    /// Whether continuous backup recovery is enabled. If not set, defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterForProviderContinuousBackupConfigEncryptionConfig>,
    /// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
    /// If not set, defaults to 14 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryWindowDays")]
    pub recovery_window_days: Option<f64>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderContinuousBackupConfigEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// Initial user to setup during cluster creation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderInitialUser {
    /// The initial password for the user.
    /// Note: This property is sensitive and will not be displayed in the plan.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    pub password_secret_ref: Option<ClusterForProviderInitialUserPasswordSecretRef>,
    /// The database username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The initial password for the user.
/// Note: This property is sensitive and will not be displayed in the plan.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderInitialUserPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<ClusterForProviderMaintenanceUpdatePolicyMaintenanceWindows>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenanceUpdatePolicyMaintenanceWindows {
    /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub day: Option<String>,
    /// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<ClusterForProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime>,
}

/// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// Metadata related to network configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkConfig {
    /// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
    /// If set, the instance IPs for this cluster will be created in the allocated range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedIpRange")]
    pub allocated_ip_range: Option<String>,
    /// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
    /// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterForProviderNetworkConfigNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterForProviderNetworkConfigNetworkSelector>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkConfigNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkConfigNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkConfigNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkConfigNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkConfigNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkConfigNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkConfigNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkConfigNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkConfigNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkConfigNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkConfigNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkConfigNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkConfigNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkConfigNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration for Private Service Connect (PSC) for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderPscConfig {
    /// Create an instance that allows connections from Private Service Connect endpoints to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscEnabled")]
    pub psc_enabled: Option<bool>,
}

/// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreBackupSource {
    /// The name of the backup that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
    /// Reference to a Backup in alloydb to populate backupName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupNameRef")]
    pub backup_name_ref: Option<ClusterForProviderRestoreBackupSourceBackupNameRef>,
    /// Selector for a Backup in alloydb to populate backupName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupNameSelector")]
    pub backup_name_selector: Option<ClusterForProviderRestoreBackupSourceBackupNameSelector>,
}

/// Reference to a Backup in alloydb to populate backupName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreBackupSourceBackupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderRestoreBackupSourceBackupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreBackupSourceBackupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderRestoreBackupSourceBackupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderRestoreBackupSourceBackupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreBackupSourceBackupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreBackupSourceBackupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Backup in alloydb to populate backupName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreBackupSourceBackupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreBackupSourceBackupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreContinuousBackupSource {
    /// The name of the source cluster that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// Reference to a Cluster in alloydb to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    pub cluster_ref: Option<ClusterForProviderRestoreContinuousBackupSourceClusterRef>,
    /// Selector for a Cluster in alloydb to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSelector")]
    pub cluster_selector: Option<ClusterForProviderRestoreContinuousBackupSourceClusterSelector>,
    /// The point in time that this cluster is restored to, in RFC 3339 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pointInTime")]
    pub point_in_time: Option<String>,
}

/// Reference to a Cluster in alloydb to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreContinuousBackupSourceClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreContinuousBackupSourceClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in alloydb to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreContinuousBackupSourceClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecondaryConfig {
    /// Name of the primary cluster must be in the format
    /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterName")]
    pub primary_cluster_name: Option<String>,
    /// Reference to a Cluster in alloydb to populate primaryClusterName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterNameRef")]
    pub primary_cluster_name_ref: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameRef>,
    /// Selector for a Cluster in alloydb to populate primaryClusterName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterNameSelector")]
    pub primary_cluster_name_selector: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameSelector>,
}

/// Reference to a Cluster in alloydb to populate primaryClusterName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecondaryConfigPrimaryClusterNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecondaryConfigPrimaryClusterNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in alloydb to populate primaryClusterName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecondaryConfigPrimaryClusterNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProvider {
    /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automatedBackupPolicy")]
    pub automated_backup_policy: Option<ClusterInitProviderAutomatedBackupPolicy>,
    /// The type of cluster. If not set, defaults to PRIMARY.
    /// Default value is PRIMARY.
    /// Possible values are: PRIMARY, SECONDARY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterType")]
    pub cluster_type: Option<String>,
    /// The continuous backup config for this cluster.
    /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousBackupConfig")]
    pub continuous_backup_config: Option<ClusterInitProviderContinuousBackupConfig>,
    /// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseVersion")]
    pub database_version: Option<String>,
    /// Policy to determine if the cluster should be deleted forcefully.
    /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
    /// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// User-settable and human-readable display name for the Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterInitProviderEncryptionConfig>,
    /// For Resource freshness validation (https://google.aip.dev/154)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// Initial user to setup during cluster creation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialUser")]
    pub initial_user: Option<ClusterInitProviderInitialUser>,
    /// User-defined labels for the alloydb cluster.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// MaintenanceUpdatePolicy defines the policy for system updates.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceUpdatePolicy")]
    pub maintenance_update_policy: Option<ClusterInitProviderMaintenanceUpdatePolicy>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Metadata related to network configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    pub network_config: Option<ClusterInitProviderNetworkConfig>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterInitProviderNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterInitProviderNetworkSelector>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration for Private Service Connect (PSC) for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConfig")]
    pub psc_config: Option<ClusterInitProviderPscConfig>,
    /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreBackupSource")]
    pub restore_backup_source: Option<ClusterInitProviderRestoreBackupSource>,
    /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreContinuousBackupSource")]
    pub restore_continuous_backup_source: Option<ClusterInitProviderRestoreContinuousBackupSource>,
    /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryConfig")]
    pub secondary_config: Option<ClusterInitProviderSecondaryConfig>,
}

/// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicy {
    /// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
    /// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupWindow")]
    pub backup_window: Option<String>,
    /// Whether automated backups are enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterInitProviderAutomatedBackupPolicyEncryptionConfig>,
    /// Labels to apply to backups created using this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "quantityBasedRetention")]
    pub quantity_based_retention: Option<ClusterInitProviderAutomatedBackupPolicyQuantityBasedRetention>,
    /// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeBasedRetention")]
    pub time_based_retention: Option<ClusterInitProviderAutomatedBackupPolicyTimeBasedRetention>,
    /// Weekly schedule for the Backup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklySchedule")]
    pub weekly_schedule: Option<ClusterInitProviderAutomatedBackupPolicyWeeklySchedule>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicyEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicyQuantityBasedRetention {
    /// The number of backups to retain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicyTimeBasedRetention {
    /// The retention period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
}

/// Weekly schedule for the Backup.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicyWeeklySchedule {
    /// The days of the week to perform a backup. At least one day of the week must be provided.
    /// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daysOfWeek")]
    pub days_of_week: Option<Vec<String>>,
    /// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTimes")]
    pub start_times: Option<Vec<ClusterInitProviderAutomatedBackupPolicyWeeklyScheduleStartTimes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAutomatedBackupPolicyWeeklyScheduleStartTimes {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// The continuous backup config for this cluster.
/// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderContinuousBackupConfig {
    /// Whether continuous backup recovery is enabled. If not set, defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterInitProviderContinuousBackupConfigEncryptionConfig>,
    /// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
    /// If not set, defaults to 14 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryWindowDays")]
    pub recovery_window_days: Option<f64>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderContinuousBackupConfigEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// Initial user to setup during cluster creation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderInitialUser {
    /// The initial password for the user.
    /// Note: This property is sensitive and will not be displayed in the plan.
    #[serde(rename = "passwordSecretRef")]
    pub password_secret_ref: ClusterInitProviderInitialUserPasswordSecretRef,
    /// The database username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The initial password for the user.
/// Note: This property is sensitive and will not be displayed in the plan.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderInitialUserPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<ClusterInitProviderMaintenanceUpdatePolicyMaintenanceWindows>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenanceUpdatePolicyMaintenanceWindows {
    /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub day: Option<String>,
    /// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<ClusterInitProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime>,
}

/// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// Metadata related to network configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkConfig {
    /// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
    /// If set, the instance IPs for this cluster will be created in the allocated range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedIpRange")]
    pub allocated_ip_range: Option<String>,
    /// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
    /// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<ClusterInitProviderNetworkConfigNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<ClusterInitProviderNetworkConfigNetworkSelector>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkConfigNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkConfigNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkConfigNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkConfigNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkConfigNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkConfigNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkConfigNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkConfigNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkConfigNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkConfigNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkConfigNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkConfigNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkConfigNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkConfigNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration for Private Service Connect (PSC) for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderPscConfig {
    /// Create an instance that allows connections from Private Service Connect endpoints to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscEnabled")]
    pub psc_enabled: Option<bool>,
}

/// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreBackupSource {
    /// The name of the backup that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
    /// Reference to a Backup in alloydb to populate backupName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupNameRef")]
    pub backup_name_ref: Option<ClusterInitProviderRestoreBackupSourceBackupNameRef>,
    /// Selector for a Backup in alloydb to populate backupName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupNameSelector")]
    pub backup_name_selector: Option<ClusterInitProviderRestoreBackupSourceBackupNameSelector>,
}

/// Reference to a Backup in alloydb to populate backupName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreBackupSourceBackupNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderRestoreBackupSourceBackupNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreBackupSourceBackupNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderRestoreBackupSourceBackupNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderRestoreBackupSourceBackupNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreBackupSourceBackupNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreBackupSourceBackupNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Backup in alloydb to populate backupName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreBackupSourceBackupNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreBackupSourceBackupNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreContinuousBackupSource {
    /// The name of the source cluster that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// Reference to a Cluster in alloydb to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    pub cluster_ref: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterRef>,
    /// Selector for a Cluster in alloydb to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSelector")]
    pub cluster_selector: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterSelector>,
    /// The point in time that this cluster is restored to, in RFC 3339 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pointInTime")]
    pub point_in_time: Option<String>,
}

/// Reference to a Cluster in alloydb to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreContinuousBackupSourceClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreContinuousBackupSourceClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in alloydb to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreContinuousBackupSourceClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderRestoreContinuousBackupSourceClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecondaryConfig {
    /// Name of the primary cluster must be in the format
    /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterName")]
    pub primary_cluster_name: Option<String>,
    /// Reference to a Cluster in alloydb to populate primaryClusterName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterNameRef")]
    pub primary_cluster_name_ref: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameRef>,
    /// Selector for a Cluster in alloydb to populate primaryClusterName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterNameSelector")]
    pub primary_cluster_name_selector: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameSelector>,
}

/// Reference to a Cluster in alloydb to populate primaryClusterName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecondaryConfigPrimaryClusterNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecondaryConfigPrimaryClusterNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in alloydb to populate primaryClusterName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecondaryConfigPrimaryClusterNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderSecondaryConfigPrimaryClusterNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProvider {
    /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automatedBackupPolicy")]
    pub automated_backup_policy: Option<ClusterStatusAtProviderAutomatedBackupPolicy>,
    /// Cluster created from backup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupSource")]
    pub backup_source: Option<Vec<ClusterStatusAtProviderBackupSource>>,
    /// The type of cluster. If not set, defaults to PRIMARY.
    /// Default value is PRIMARY.
    /// Possible values are: PRIMARY, SECONDARY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterType")]
    pub cluster_type: Option<String>,
    /// The continuous backup config for this cluster.
    /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousBackupConfig")]
    pub continuous_backup_config: Option<ClusterStatusAtProviderContinuousBackupConfig>,
    /// ContinuousBackupInfo describes the continuous backup properties of a cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousBackupInfo")]
    pub continuous_backup_info: Option<Vec<ClusterStatusAtProviderContinuousBackupInfo>>,
    /// The database engine major version. This is an optional field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseVersion")]
    pub database_version: Option<String>,
    /// Policy to determine if the cluster should be deleted forcefully.
    /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
    /// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// User-settable and human-readable display name for the Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// for all of the annotations present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveAnnotations")]
    pub effective_annotations: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    pub effective_labels: Option<HashMap<String, String>>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterStatusAtProviderEncryptionConfig>,
    /// EncryptionInfo describes the encryption information of a cluster or a backup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionInfo")]
    pub encryption_info: Option<Vec<ClusterStatusAtProviderEncryptionInfo>>,
    /// For Resource freshness validation (https://google.aip.dev/154)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Initial user to setup during cluster creation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialUser")]
    pub initial_user: Option<ClusterStatusAtProviderInitialUser>,
    /// User-defined labels for the alloydb cluster.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the alloydb cluster should reside.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// MaintenanceUpdatePolicy defines the policy for system updates.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceUpdatePolicy")]
    pub maintenance_update_policy: Option<ClusterStatusAtProviderMaintenanceUpdatePolicy>,
    /// Cluster created via DMS migration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migrationSource")]
    pub migration_source: Option<Vec<ClusterStatusAtProviderMigrationSource>>,
    /// The name of the cluster resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Metadata related to network configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    pub network_config: Option<ClusterStatusAtProviderNetworkConfig>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Configuration for Private Service Connect (PSC) for the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscConfig")]
    pub psc_config: Option<ClusterStatusAtProviderPscConfig>,
    /// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
    /// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
    /// This can happen due to user-triggered updates or system actions like failover or maintenance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconciling: Option<bool>,
    /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreBackupSource")]
    pub restore_backup_source: Option<ClusterStatusAtProviderRestoreBackupSource>,
    /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreContinuousBackupSource")]
    pub restore_continuous_backup_source: Option<ClusterStatusAtProviderRestoreContinuousBackupSource>,
    /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryConfig")]
    pub secondary_config: Option<ClusterStatusAtProviderSecondaryConfig>,
    /// Output only. The current serving state of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// The system-generated UID of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicy {
    /// The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
    /// The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupWindow")]
    pub backup_window: Option<String>,
    /// Whether automated backups are enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterStatusAtProviderAutomatedBackupPolicyEncryptionConfig>,
    /// Labels to apply to backups created using this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "quantityBasedRetention")]
    pub quantity_based_retention: Option<ClusterStatusAtProviderAutomatedBackupPolicyQuantityBasedRetention>,
    /// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeBasedRetention")]
    pub time_based_retention: Option<ClusterStatusAtProviderAutomatedBackupPolicyTimeBasedRetention>,
    /// Weekly schedule for the Backup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklySchedule")]
    pub weekly_schedule: Option<ClusterStatusAtProviderAutomatedBackupPolicyWeeklySchedule>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicyEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

/// Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicyQuantityBasedRetention {
    /// The number of backups to retain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicyTimeBasedRetention {
    /// The retention period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
}

/// Weekly schedule for the Backup.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicyWeeklySchedule {
    /// The days of the week to perform a backup. At least one day of the week must be provided.
    /// Each value may be one of: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daysOfWeek")]
    pub days_of_week: Option<Vec<String>>,
    /// The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTimes")]
    pub start_times: Option<Vec<ClusterStatusAtProviderAutomatedBackupPolicyWeeklyScheduleStartTimes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAutomatedBackupPolicyWeeklyScheduleStartTimes {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderBackupSource {
    /// The name of the backup resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
}

/// The continuous backup config for this cluster.
/// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderContinuousBackupConfig {
    /// Whether continuous backup recovery is enabled. If not set, defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    pub encryption_config: Option<ClusterStatusAtProviderContinuousBackupConfigEncryptionConfig>,
    /// The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
    /// If not set, defaults to 14 days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryWindowDays")]
    pub recovery_window_days: Option<f64>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderContinuousBackupConfigEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderContinuousBackupInfo {
    /// (Output)
    /// The earliest restorable time that can be restored to. Output only field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "earliestRestorableTime")]
    pub earliest_restorable_time: Option<String>,
    /// (Output)
    /// When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledTime")]
    pub enabled_time: Option<String>,
    /// (Output)
    /// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionInfo")]
    pub encryption_info: Option<Vec<ClusterStatusAtProviderContinuousBackupInfoEncryptionInfo>>,
    /// (Output)
    /// Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderContinuousBackupInfoEncryptionInfo {
    /// (Output)
    /// Output only. Type of encryption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionType")]
    pub encryption_type: Option<String>,
    /// (Output)
    /// Output only. Cloud KMS key versions that are being used to protect the database or the backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyVersions")]
    pub kms_key_versions: Option<Vec<String>>,
}

/// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderEncryptionConfig {
    /// The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderEncryptionInfo {
    /// (Output)
    /// Output only. Type of encryption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionType")]
    pub encryption_type: Option<String>,
    /// (Output)
    /// Output only. Cloud KMS key versions that are being used to protect the database or the backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyVersions")]
    pub kms_key_versions: Option<Vec<String>>,
}

/// Initial user to setup during cluster creation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderInitialUser {
    /// The database username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<ClusterStatusAtProviderMaintenanceUpdatePolicyMaintenanceWindows>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenanceUpdatePolicyMaintenanceWindows {
    /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub day: Option<String>,
    /// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<ClusterStatusAtProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime>,
}

/// Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMaintenanceUpdatePolicyMaintenanceWindowsStartTime {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Currently, only the value 0 is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMigrationSource {
    /// The host and port of the on-premises instance in host:port format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<String>,
    /// Place holder for the external source identifier(e.g DMS job name) that created the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceId")]
    pub reference_id: Option<String>,
    /// Type of migration source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceType")]
    pub source_type: Option<String>,
}

/// Metadata related to network configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderNetworkConfig {
    /// The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
    /// If set, the instance IPs for this cluster will be created in the allocated range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedIpRange")]
    pub allocated_ip_range: Option<String>,
    /// The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
    /// It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
}

/// Configuration for Private Service Connect (PSC) for the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderPscConfig {
    /// Create an instance that allows connections from Private Service Connect endpoints to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pscEnabled")]
    pub psc_enabled: Option<bool>,
}

/// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderRestoreBackupSource {
    /// The name of the backup that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
}

/// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderRestoreContinuousBackupSource {
    /// The name of the source cluster that this cluster is restored from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// The point in time that this cluster is restored to, in RFC 3339 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pointInTime")]
    pub point_in_time: Option<String>,
}

/// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderSecondaryConfig {
    /// Name of the primary cluster must be in the format
    /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryClusterName")]
    pub primary_cluster_name: Option<String>,
}

