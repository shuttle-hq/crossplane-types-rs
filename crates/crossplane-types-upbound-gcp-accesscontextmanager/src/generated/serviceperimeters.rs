// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ServicePerimeterSpec defines the desired state of ServicePerimeter
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "accesscontextmanager.gcp.upbound.io", version = "v1beta2", kind = "ServicePerimeter", plural = "serviceperimeters")]
#[kube(status = "ServicePerimeterStatus")]
pub struct ServicePerimeterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<ServicePerimeterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ServicePerimeterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<ServicePerimeterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<ServicePerimeterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<ServicePerimeterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<ServicePerimeterWriteConnectionSecretToRef>,
}

/// ServicePerimeterSpec defines the desired state of ServicePerimeter
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProvider {
    /// Description of the ServicePerimeter and its use. Does not affect
    /// behavior.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Resource name for the ServicePerimeter. The short_name component must
    /// begin with a letter and only include alphanumeric and '_'.
    /// Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The AccessPolicy this ServicePerimeter lives in.
    /// Format: accessPolicies/{policy_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Specifies the type of the Perimeter. There are two types: regular and
    /// bridge. Regular Service Perimeter contains resources, access levels,
    /// and restricted services. Every resource can be in at most
    /// ONE regular Service Perimeter.
    /// In addition to being in a regular service perimeter, a resource can also
    /// be in zero or more perimeter bridges. A perimeter bridge only contains
    /// resources. Cross project operations are permitted if all effected
    /// resources share some perimeter (whether bridge or regular). Perimeter
    /// Bridge does not contain access levels or services: those are governed
    /// entirely by the regular perimeter that resource is in.
    /// Perimeter Bridges are typically useful when building more complex
    /// topologies with many independent perimeters that need to share some data
    /// with a common perimeter, but should not be able to share data among
    /// themselves.
    /// Default value is PERIMETER_TYPE_REGULAR.
    /// Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perimeterType")]
    pub perimeter_type: Option<String>,
    /// Proposed (or dry run) ServicePerimeter configuration.
    /// This configuration allows to specify and test ServicePerimeter configuration
    /// without enforcing actual access restrictions. Only allowed to be set when
    /// the useExplicitDryRunSpec flag is set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ServicePerimeterForProviderSpec>,
    /// ServicePerimeter configuration. Specifies sets of resources,
    /// restricted services and access levels that determine
    /// perimeter content and boundaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ServicePerimeterForProviderStatus>,
    /// Human readable title. Must be unique within the Policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
    /// for all Service Perimeters, and that spec is identical to the status for those
    /// Service Perimeters. When this flag is set, it inhibits the generation of the
    /// implicit spec, thereby allowing the user to explicitly provide a
    /// configuration ("spec") to use in a dry-run version of the Service Perimeter.
    /// This allows the user to test changes to the enforced config ("status") without
    /// actually enforcing them. This testing is done through analyzing the differences
    /// between currently enforced and suggested restrictions. useExplicitDryRunSpec must
    /// bet set to True if any of the fields in the spec are set to non-default values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useExplicitDryRunSpec")]
    pub use_explicit_dry_run_spec: Option<bool>,
}

/// Proposed (or dry run) ServicePerimeter configuration.
/// This configuration allows to specify and test ServicePerimeter configuration
/// without enforcing actual access restrictions. Only allowed to be set when
/// the useExplicitDryRunSpec flag is set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpec {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// References to AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsRefs")]
    pub access_levels_refs: Option<Vec<ServicePerimeterForProviderSpecAccessLevelsRefs>>,
    /// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsSelector")]
    pub access_levels_selector: Option<ServicePerimeterForProviderSpecAccessLevelsSelector>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterForProviderSpecEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterForProviderSpecIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterForProviderSpecVpcAccessibleServices>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecAccessLevelsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderSpecAccessLevelsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecAccessLevelsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderSpecAccessLevelsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderSpecAccessLevelsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderSpecAccessLevelsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderSpecAccessLevelsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecAccessLevelsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderSpecAccessLevelsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecAccessLevelsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderSpecAccessLevelsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderSpecAccessLevelsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderSpecAccessLevelsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderSpecAccessLevelsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterForProviderSpecEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterForProviderSpecEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterForProviderSpecEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterForProviderSpecEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterForProviderSpecIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterForProviderSpecIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterForProviderSpecIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterForProviderSpecIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderSpecVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

/// ServicePerimeter configuration. Specifies sets of resources,
/// restricted services and access levels that determine
/// perimeter content and boundaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatus {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// References to AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsRefs")]
    pub access_levels_refs: Option<Vec<ServicePerimeterForProviderStatusAccessLevelsRefs>>,
    /// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsSelector")]
    pub access_levels_selector: Option<ServicePerimeterForProviderStatusAccessLevelsSelector>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterForProviderStatusEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterForProviderStatusIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterForProviderStatusVpcAccessibleServices>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusAccessLevelsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderStatusAccessLevelsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusAccessLevelsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderStatusAccessLevelsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderStatusAccessLevelsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusAccessLevelsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusAccessLevelsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusAccessLevelsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderStatusAccessLevelsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusAccessLevelsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderStatusAccessLevelsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderStatusAccessLevelsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusAccessLevelsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusAccessLevelsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterForProviderStatusEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterForProviderStatusEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterForProviderStatusEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterForProviderStatusEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelRef")]
    pub access_level_ref: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef>,
    /// Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelSelector")]
    pub access_level_selector: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterForProviderStatusIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterForProviderStatusVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProvider {
    /// Description of the ServicePerimeter and its use. Does not affect
    /// behavior.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Resource name for the ServicePerimeter. The short_name component must
    /// begin with a letter and only include alphanumeric and '_'.
    /// Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The AccessPolicy this ServicePerimeter lives in.
    /// Format: accessPolicies/{policy_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Specifies the type of the Perimeter. There are two types: regular and
    /// bridge. Regular Service Perimeter contains resources, access levels,
    /// and restricted services. Every resource can be in at most
    /// ONE regular Service Perimeter.
    /// In addition to being in a regular service perimeter, a resource can also
    /// be in zero or more perimeter bridges. A perimeter bridge only contains
    /// resources. Cross project operations are permitted if all effected
    /// resources share some perimeter (whether bridge or regular). Perimeter
    /// Bridge does not contain access levels or services: those are governed
    /// entirely by the regular perimeter that resource is in.
    /// Perimeter Bridges are typically useful when building more complex
    /// topologies with many independent perimeters that need to share some data
    /// with a common perimeter, but should not be able to share data among
    /// themselves.
    /// Default value is PERIMETER_TYPE_REGULAR.
    /// Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perimeterType")]
    pub perimeter_type: Option<String>,
    /// Proposed (or dry run) ServicePerimeter configuration.
    /// This configuration allows to specify and test ServicePerimeter configuration
    /// without enforcing actual access restrictions. Only allowed to be set when
    /// the useExplicitDryRunSpec flag is set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ServicePerimeterInitProviderSpec>,
    /// ServicePerimeter configuration. Specifies sets of resources,
    /// restricted services and access levels that determine
    /// perimeter content and boundaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ServicePerimeterInitProviderStatus>,
    /// Human readable title. Must be unique within the Policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
    /// for all Service Perimeters, and that spec is identical to the status for those
    /// Service Perimeters. When this flag is set, it inhibits the generation of the
    /// implicit spec, thereby allowing the user to explicitly provide a
    /// configuration ("spec") to use in a dry-run version of the Service Perimeter.
    /// This allows the user to test changes to the enforced config ("status") without
    /// actually enforcing them. This testing is done through analyzing the differences
    /// between currently enforced and suggested restrictions. useExplicitDryRunSpec must
    /// bet set to True if any of the fields in the spec are set to non-default values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useExplicitDryRunSpec")]
    pub use_explicit_dry_run_spec: Option<bool>,
}

/// Proposed (or dry run) ServicePerimeter configuration.
/// This configuration allows to specify and test ServicePerimeter configuration
/// without enforcing actual access restrictions. Only allowed to be set when
/// the useExplicitDryRunSpec flag is set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpec {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// References to AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsRefs")]
    pub access_levels_refs: Option<Vec<ServicePerimeterInitProviderSpecAccessLevelsRefs>>,
    /// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsSelector")]
    pub access_levels_selector: Option<ServicePerimeterInitProviderSpecAccessLevelsSelector>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterInitProviderSpecEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterInitProviderSpecIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterInitProviderSpecVpcAccessibleServices>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecAccessLevelsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderSpecAccessLevelsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecAccessLevelsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderSpecAccessLevelsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderSpecAccessLevelsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderSpecAccessLevelsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderSpecAccessLevelsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecAccessLevelsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderSpecAccessLevelsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterInitProviderSpecEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterInitProviderSpecEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterInitProviderSpecEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterInitProviderSpecEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterInitProviderSpecIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterInitProviderSpecIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterInitProviderSpecIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterInitProviderSpecIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderSpecVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

/// ServicePerimeter configuration. Specifies sets of resources,
/// restricted services and access levels that determine
/// perimeter content and boundaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatus {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// References to AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsRefs")]
    pub access_levels_refs: Option<Vec<ServicePerimeterInitProviderStatusAccessLevelsRefs>>,
    /// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelsSelector")]
    pub access_levels_selector: Option<ServicePerimeterInitProviderStatusAccessLevelsSelector>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterInitProviderStatusEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterInitProviderStatusIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterInitProviderStatusVpcAccessibleServices>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusAccessLevelsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderStatusAccessLevelsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusAccessLevelsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderStatusAccessLevelsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderStatusAccessLevelsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusAccessLevelsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusAccessLevelsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of AccessLevel in accesscontextmanager to populate accessLevels.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusAccessLevelsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusAccessLevelsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterInitProviderStatusEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterInitProviderStatusEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterInitProviderStatusEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterInitProviderStatusEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelRef")]
    pub access_level_ref: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef>,
    /// Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevelSelector")]
    pub access_level_selector: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterInitProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterInitProviderStatusIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterInitProviderStatusVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ServicePerimeterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ServicePerimeterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePerimeterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePerimeterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePerimeterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePerimeterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ServicePerimeterStatus defines the observed state of ServicePerimeter.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<ServicePerimeterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProvider {
    /// Time the AccessPolicy was created in UTC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    pub create_time: Option<String>,
    /// Description of the ServicePerimeter and its use. Does not affect
    /// behavior.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// an identifier for the resource with format {{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Resource name for the ServicePerimeter. The short_name component must
    /// begin with a letter and only include alphanumeric and '_'.
    /// Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The AccessPolicy this ServicePerimeter lives in.
    /// Format: accessPolicies/{policy_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Specifies the type of the Perimeter. There are two types: regular and
    /// bridge. Regular Service Perimeter contains resources, access levels,
    /// and restricted services. Every resource can be in at most
    /// ONE regular Service Perimeter.
    /// In addition to being in a regular service perimeter, a resource can also
    /// be in zero or more perimeter bridges. A perimeter bridge only contains
    /// resources. Cross project operations are permitted if all effected
    /// resources share some perimeter (whether bridge or regular). Perimeter
    /// Bridge does not contain access levels or services: those are governed
    /// entirely by the regular perimeter that resource is in.
    /// Perimeter Bridges are typically useful when building more complex
    /// topologies with many independent perimeters that need to share some data
    /// with a common perimeter, but should not be able to share data among
    /// themselves.
    /// Default value is PERIMETER_TYPE_REGULAR.
    /// Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perimeterType")]
    pub perimeter_type: Option<String>,
    /// Proposed (or dry run) ServicePerimeter configuration.
    /// This configuration allows to specify and test ServicePerimeter configuration
    /// without enforcing actual access restrictions. Only allowed to be set when
    /// the useExplicitDryRunSpec flag is set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ServicePerimeterStatusAtProviderSpec>,
    /// ServicePerimeter configuration. Specifies sets of resources,
    /// restricted services and access levels that determine
    /// perimeter content and boundaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ServicePerimeterStatusAtProviderStatus>,
    /// Human readable title. Must be unique within the Policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Time the AccessPolicy was updated in UTC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    pub update_time: Option<String>,
    /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
    /// for all Service Perimeters, and that spec is identical to the status for those
    /// Service Perimeters. When this flag is set, it inhibits the generation of the
    /// implicit spec, thereby allowing the user to explicitly provide a
    /// configuration ("spec") to use in a dry-run version of the Service Perimeter.
    /// This allows the user to test changes to the enforced config ("status") without
    /// actually enforcing them. This testing is done through analyzing the differences
    /// between currently enforced and suggested restrictions. useExplicitDryRunSpec must
    /// bet set to True if any of the fields in the spec are set to non-default values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useExplicitDryRunSpec")]
    pub use_explicit_dry_run_spec: Option<bool>,
}

/// Proposed (or dry run) ServicePerimeter configuration.
/// This configuration allows to specify and test ServicePerimeter configuration
/// without enforcing actual access restrictions. Only allowed to be set when
/// the useExplicitDryRunSpec flag is set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpec {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterStatusAtProviderSpecEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterStatusAtProviderSpecIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterStatusAtProviderSpecVpcAccessibleServices>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderSpecVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

/// ServicePerimeter configuration. Specifies sets of resources,
/// restricted services and access levels that determine
/// perimeter content and boundaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatus {
    /// A list of AccessLevel resource names that allow resources within
    /// the ServicePerimeter to be accessed from the internet.
    /// AccessLevels listed must be in the same policy as this
    /// ServicePerimeter. Referencing a nonexistent AccessLevel is a
    /// syntax error. If no AccessLevel names are listed, resources within
    /// the perimeter can only be accessed via GCP calls with request
    /// origins within the perimeter. For Service Perimeter Bridge, must
    /// be empty.
    /// Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevels")]
    pub access_levels: Option<Vec<String>>,
    /// List of EgressPolicies to apply to the perimeter. A perimeter may
    /// have multiple EgressPolicies, each of which is evaluated separately.
    /// Access is granted if any EgressPolicy grants it. Must be empty for
    /// a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressPolicies")]
    pub egress_policies: Option<Vec<ServicePerimeterStatusAtProviderStatusEgressPolicies>>,
    /// List of IngressPolicies to apply to the perimeter. A perimeter may
    /// have multiple IngressPolicies, each of which is evaluated
    /// separately. Access is granted if any Ingress Policy grants it.
    /// Must be empty for a perimeter bridge.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPolicies")]
    pub ingress_policies: Option<Vec<ServicePerimeterStatusAtProviderStatusIngressPolicies>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// GCP services that are subject to the Service Perimeter
    /// restrictions. Must contain a list of services. For example, if
    /// storage.googleapis.com is specified, access to the storage
    /// buckets inside the perimeter must meet the perimeter's access
    /// restrictions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictedServices")]
    pub restricted_services: Option<Vec<String>>,
    /// Specifies how APIs are allowed to communicate within the Service
    /// Perimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcAccessibleServices")]
    pub vpc_accessible_services: Option<ServicePerimeterStatusAtProviderStatusVpcAccessibleServices>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPolicies {
    /// Defines conditions on the source of a request causing this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressFrom")]
    pub egress_from: Option<ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressFrom>,
    /// Defines the conditions on the ApiOperation and destination resources that
    /// cause this EgressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressTo")]
    pub egress_to: Option<ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressTo>,
}

/// Defines conditions on the source of a request causing this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Whether to enforce traffic restrictions based on sources field. If the sources field is non-empty, then this field must be set to SOURCE_RESTRICTION_ENABLED.
    /// Possible values are: SOURCE_RESTRICTION_UNSPECIFIED, SOURCE_RESTRICTION_ENABLED, SOURCE_RESTRICTION_DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRestriction")]
    pub source_restriction: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
}

/// Defines the conditions on the ApiOperation and destination resources that
/// cause this EgressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressTo {
    /// A list of external resources that are allowed to be accessed. A request
    /// matches if it contains an external resource in this list (Example:
    /// s3://bucket/path). Currently '*' is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalResources")]
    pub external_resources: Option<Vec<String>>,
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusEgressPoliciesEgressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPolicies {
    /// Defines the conditions on the source of a request causing this IngressPolicy
    /// to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressFrom")]
    pub ingress_from: Option<ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressFrom>,
    /// Defines the conditions on the ApiOperation and request destination that cause
    /// this IngressPolicy to apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTo")]
    pub ingress_to: Option<ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressTo>,
}

/// Defines the conditions on the source of a request causing this IngressPolicy
/// to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressFrom {
    /// A list of identities that are allowed access through this ingress policy.
    /// Should be in the format of email address. The email address should represent
    /// individual user or service account only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identities: Option<Vec<String>>,
    /// Specifies the type of identities that are allowed access from outside the
    /// perimeter. If left unspecified, then members of identities field will be
    /// allowed access.
    /// Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityType")]
    pub identity_type: Option<String>,
    /// Sources that this IngressPolicy authorizes access from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressFromSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressFromSources {
    /// An AccessLevel resource name that allow resources within the
    /// ServicePerimeters to be accessed from the internet. AccessLevels listed
    /// must be in the same policy as this ServicePerimeter. Referencing a nonexistent
    /// AccessLevel will cause an error. If no AccessLevel names are listed,
    /// resources within the perimeter can only be accessed via Google Cloud calls
    /// with request origins within the perimeter.
    /// Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.
    /// If * is specified, then all IngressSources will be allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLevel")]
    pub access_level: Option<String>,
    /// A Google Cloud resource that is allowed to ingress the perimeter.
    /// Requests from these resources will be allowed to access perimeter data.
    /// Currently only projects and VPCs are allowed.
    /// Project format: projects/{projectNumber}
    /// VPC network format:
    /// //compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}.
    /// The project may be in any Google Cloud organization, not just the
    /// organization that the perimeter is defined in. * is not allowed, the case
    /// of allowing all Google Cloud resources only is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Defines the conditions on the ApiOperation and request destination that cause
/// this IngressPolicy to apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressTo {
    /// A list of ApiOperations the sources specified in corresponding IngressFrom
    /// are allowed to perform in this ServicePerimeter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressToOperations>>,
    /// A list of GCP resources that are inside of the service perimeter.
    /// Currently only projects are allowed.
    /// Format: projects/{project_number}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressToOperations {
    /// API methods or permissions to allow. Method or permission must belong to
    /// the service specified by serviceName field. A single MethodSelector entry
    /// with * specified for the method field will allow all methods AND
    /// permissions for the service specified in serviceName.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "methodSelectors")]
    pub method_selectors: Option<Vec<ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressToOperationsMethodSelectors>>,
    /// The name of the API whose methods or permissions the IngressPolicy or
    /// EgressPolicy want to allow. A single ApiOperation with serviceName
    /// field set to * will allow all methods AND permissions for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusIngressPoliciesIngressToOperationsMethodSelectors {
    /// Value for method should be a valid method name for the corresponding
    /// serviceName in ApiOperation. If * used as value for method, then
    /// ALL methods and permissions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Value for permission should be a valid Cloud IAM permission for the
    /// corresponding serviceName in ApiOperation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,
}

/// Specifies how APIs are allowed to communicate within the Service
/// Perimeter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePerimeterStatusAtProviderStatusVpcAccessibleServices {
    /// The list of APIs usable within the Service Perimeter.
    /// Must be empty unless enableRestriction is True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedServices")]
    pub allowed_services: Option<Vec<String>>,
    /// Whether to restrict API calls within the Service Perimeter to the
    /// list of APIs specified in 'allowedServices'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRestriction")]
    pub enable_restriction: Option<bool>,
}

