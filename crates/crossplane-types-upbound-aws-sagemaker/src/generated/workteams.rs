// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// WorkteamSpec defines the desired state of Workteam
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "sagemaker.aws.upbound.io", version = "v1beta2", kind = "Workteam", plural = "workteams")]
#[kube(status = "WorkteamStatus")]
pub struct WorkteamSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<WorkteamDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: WorkteamForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<WorkteamInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<WorkteamProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<WorkteamPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<WorkteamWriteConnectionSecretToRef>,
}

/// WorkteamSpec defines the desired state of Workteam
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProvider {
    /// A description of the work team.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// A list of Member Definitions that contains objects that identify the workers that make up the work team. Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use cognito_member_definition. For workforces created using your own OIDC identity provider (IdP) use oidc_member_definition. Do not provide input for both of these parameters in a single request. see Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memberDefinition")]
    pub member_definition: Option<Vec<WorkteamForProviderMemberDefinition>>,
    /// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfiguration")]
    pub notification_configuration: Option<WorkteamForProviderNotificationConfiguration>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerAccessConfiguration")]
    pub worker_access_configuration: Option<WorkteamForProviderWorkerAccessConfiguration>,
    /// The name of the workforce.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceName")]
    pub workforce_name: Option<String>,
    /// Reference to a Workforce in sagemaker to populate workforceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceNameRef")]
    pub workforce_name_ref: Option<WorkteamForProviderWorkforceNameRef>,
    /// Selector for a Workforce in sagemaker to populate workforceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceNameSelector")]
    pub workforce_name_selector: Option<WorkteamForProviderWorkforceNameSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinition {
    /// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cognitoMemberDefinition")]
    pub cognito_member_definition: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinition>,
    /// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcMemberDefinition")]
    pub oidc_member_definition: Option<WorkteamForProviderMemberDefinitionOidcMemberDefinition>,
}

/// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinition {
    /// An identifier for an application client. You must create the app client ID using Amazon Cognito.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    pub client_id: Option<String>,
    /// Reference to a UserPoolClient in cognitoidp to populate clientId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIdRef")]
    pub client_id_ref: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef>,
    /// Selector for a UserPoolClient in cognitoidp to populate clientId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIdSelector")]
    pub client_id_selector: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector>,
    /// An identifier for a user group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroup")]
    pub user_group: Option<String>,
    /// Reference to a UserGroup in cognitoidp to populate userGroup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroupRef")]
    pub user_group_ref: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef>,
    /// Selector for a UserGroup in cognitoidp to populate userGroup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroupSelector")]
    pub user_group_selector: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector>,
    /// An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPool")]
    pub user_pool: Option<String>,
    /// Reference to a UserPoolDomain in cognitoidp to populate userPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolRef")]
    pub user_pool_ref: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef>,
    /// Selector for a UserPoolDomain in cognitoidp to populate userPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolSelector")]
    pub user_pool_selector: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector>,
}

/// Reference to a UserPoolClient in cognitoidp to populate clientId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolClient in cognitoidp to populate clientId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserGroup in cognitoidp to populate userGroup.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserGroup in cognitoidp to populate userGroup.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolDomain in cognitoidp to populate userPool.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolDomain in cognitoidp to populate userPool.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderMemberDefinitionOidcMemberDefinition {
    /// A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
}

/// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderNotificationConfiguration {
    /// The ARN for the SNS topic to which notifications should be published.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationTopicArn")]
    pub notification_topic_arn: Option<String>,
}

/// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkerAccessConfiguration {
    /// Defines any Amazon S3 resource constraints. see S3 Presign details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Presign")]
    pub s3_presign: Option<WorkteamForProviderWorkerAccessConfigurationS3Presign>,
}

/// Defines any Amazon S3 resource constraints. see S3 Presign details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkerAccessConfigurationS3Presign {
    /// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamPolicyConstraints")]
    pub iam_policy_constraints: Option<WorkteamForProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints>,
}

/// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints {
    /// When SourceIp is Enabled the worker's IP address when a task is rendered in the worker portal is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. This IP address is checked by Amazon S3 and must match in order for the Amazon S3 resource to be rendered in the worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    pub source_ip: Option<String>,
    /// When VpcSourceIp is Enabled the worker's IP address when a task is rendered in private worker portal inside the VPC is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. To render the task successfully Amazon S3 checks that the presigned URL is being accessed over an Amazon S3 VPC Endpoint, and that the worker's IP address matches the IP address in the IAM policy. To learn more about configuring private worker portal, see Use Amazon VPC mode from a private worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSourceIp")]
    pub vpc_source_ip: Option<String>,
}

/// Reference to a Workforce in sagemaker to populate workforceName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkforceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderWorkforceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkforceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderWorkforceNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderWorkforceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderWorkforceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderWorkforceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Workforce in sagemaker to populate workforceName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkforceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamForProviderWorkforceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamForProviderWorkforceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamForProviderWorkforceNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamForProviderWorkforceNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderWorkforceNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamForProviderWorkforceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProvider {
    /// A description of the work team.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// A list of Member Definitions that contains objects that identify the workers that make up the work team. Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use cognito_member_definition. For workforces created using your own OIDC identity provider (IdP) use oidc_member_definition. Do not provide input for both of these parameters in a single request. see Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memberDefinition")]
    pub member_definition: Option<Vec<WorkteamInitProviderMemberDefinition>>,
    /// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfiguration")]
    pub notification_configuration: Option<WorkteamInitProviderNotificationConfiguration>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerAccessConfiguration")]
    pub worker_access_configuration: Option<WorkteamInitProviderWorkerAccessConfiguration>,
    /// The name of the workforce.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceName")]
    pub workforce_name: Option<String>,
    /// Reference to a Workforce in sagemaker to populate workforceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceNameRef")]
    pub workforce_name_ref: Option<WorkteamInitProviderWorkforceNameRef>,
    /// Selector for a Workforce in sagemaker to populate workforceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceNameSelector")]
    pub workforce_name_selector: Option<WorkteamInitProviderWorkforceNameSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinition {
    /// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cognitoMemberDefinition")]
    pub cognito_member_definition: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinition>,
    /// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcMemberDefinition")]
    pub oidc_member_definition: Option<WorkteamInitProviderMemberDefinitionOidcMemberDefinition>,
}

/// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinition {
    /// An identifier for an application client. You must create the app client ID using Amazon Cognito.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    pub client_id: Option<String>,
    /// Reference to a UserPoolClient in cognitoidp to populate clientId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIdRef")]
    pub client_id_ref: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRef>,
    /// Selector for a UserPoolClient in cognitoidp to populate clientId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIdSelector")]
    pub client_id_selector: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector>,
    /// An identifier for a user group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroup")]
    pub user_group: Option<String>,
    /// Reference to a UserGroup in cognitoidp to populate userGroup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroupRef")]
    pub user_group_ref: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef>,
    /// Selector for a UserGroup in cognitoidp to populate userGroup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroupSelector")]
    pub user_group_selector: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector>,
    /// An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPool")]
    pub user_pool: Option<String>,
    /// Reference to a UserPoolDomain in cognitoidp to populate userPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolRef")]
    pub user_pool_ref: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef>,
    /// Selector for a UserPoolDomain in cognitoidp to populate userPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolSelector")]
    pub user_pool_selector: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector>,
}

/// Reference to a UserPoolClient in cognitoidp to populate clientId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolClient in cognitoidp to populate clientId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserGroup in cognitoidp to populate userGroup.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserGroup in cognitoidp to populate userGroup.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a UserPoolDomain in cognitoidp to populate userPool.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPoolDomain in cognitoidp to populate userPool.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderMemberDefinitionOidcMemberDefinition {
    /// A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
}

/// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderNotificationConfiguration {
    /// The ARN for the SNS topic to which notifications should be published.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationTopicArn")]
    pub notification_topic_arn: Option<String>,
}

/// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkerAccessConfiguration {
    /// Defines any Amazon S3 resource constraints. see S3 Presign details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Presign")]
    pub s3_presign: Option<WorkteamInitProviderWorkerAccessConfigurationS3Presign>,
}

/// Defines any Amazon S3 resource constraints. see S3 Presign details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkerAccessConfigurationS3Presign {
    /// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamPolicyConstraints")]
    pub iam_policy_constraints: Option<WorkteamInitProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints>,
}

/// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints {
    /// When SourceIp is Enabled the worker's IP address when a task is rendered in the worker portal is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. This IP address is checked by Amazon S3 and must match in order for the Amazon S3 resource to be rendered in the worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    pub source_ip: Option<String>,
    /// When VpcSourceIp is Enabled the worker's IP address when a task is rendered in private worker portal inside the VPC is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. To render the task successfully Amazon S3 checks that the presigned URL is being accessed over an Amazon S3 VPC Endpoint, and that the worker's IP address matches the IP address in the IAM policy. To learn more about configuring private worker portal, see Use Amazon VPC mode from a private worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSourceIp")]
    pub vpc_source_ip: Option<String>,
}

/// Reference to a Workforce in sagemaker to populate workforceName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkforceNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderWorkforceNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkforceNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderWorkforceNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderWorkforceNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderWorkforceNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderWorkforceNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Workforce in sagemaker to populate workforceName.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkforceNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamInitProviderWorkforceNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamInitProviderWorkforceNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamInitProviderWorkforceNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamInitProviderWorkforceNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderWorkforceNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamInitProviderWorkforceNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<WorkteamPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<WorkteamPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<WorkteamPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<WorkteamPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<WorkteamPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WorkteamPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// WorkteamStatus defines the observed state of Workteam.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<WorkteamStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProvider {
    /// The Amazon Resource Name (ARN) assigned by AWS to this Workteam.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// A description of the work team.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The name of the Workteam.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of Member Definitions that contains objects that identify the workers that make up the work team. Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use cognito_member_definition. For workforces created using your own OIDC identity provider (IdP) use oidc_member_definition. Do not provide input for both of these parameters in a single request. see Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memberDefinition")]
    pub member_definition: Option<Vec<WorkteamStatusAtProviderMemberDefinition>>,
    /// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationConfiguration")]
    pub notification_configuration: Option<WorkteamStatusAtProviderNotificationConfiguration>,
    /// The subdomain for your OIDC Identity Provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subdomain: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
    /// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerAccessConfiguration")]
    pub worker_access_configuration: Option<WorkteamStatusAtProviderWorkerAccessConfiguration>,
    /// The name of the workforce.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workforceName")]
    pub workforce_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderMemberDefinition {
    /// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cognitoMemberDefinition")]
    pub cognito_member_definition: Option<WorkteamStatusAtProviderMemberDefinitionCognitoMemberDefinition>,
    /// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcMemberDefinition")]
    pub oidc_member_definition: Option<WorkteamStatusAtProviderMemberDefinitionOidcMemberDefinition>,
}

/// The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderMemberDefinitionCognitoMemberDefinition {
    /// An identifier for an application client. You must create the app client ID using Amazon Cognito.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    pub client_id: Option<String>,
    /// An identifier for a user group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userGroup")]
    pub user_group: Option<String>,
    /// An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPool")]
    pub user_pool: Option<String>,
}

/// A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderMemberDefinitionOidcMemberDefinition {
    /// A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
}

/// Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderNotificationConfiguration {
    /// The ARN for the SNS topic to which notifications should be published.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationTopicArn")]
    pub notification_topic_arn: Option<String>,
}

/// Use this optional parameter to constrain access to an Amazon S3 resource based on the IP address using supported IAM global condition keys. The Amazon S3 resource is accessed in the worker portal using a Amazon S3 presigned URL. see Worker Access Configuration details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderWorkerAccessConfiguration {
    /// Defines any Amazon S3 resource constraints. see S3 Presign details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Presign")]
    pub s3_presign: Option<WorkteamStatusAtProviderWorkerAccessConfigurationS3Presign>,
}

/// Defines any Amazon S3 resource constraints. see S3 Presign details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderWorkerAccessConfigurationS3Presign {
    /// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamPolicyConstraints")]
    pub iam_policy_constraints: Option<WorkteamStatusAtProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints>,
}

/// Use this parameter to specify the allowed request source. Possible sources are either SourceIp or VpcSourceIp. see IAM Policy Constraints details below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkteamStatusAtProviderWorkerAccessConfigurationS3PresignIamPolicyConstraints {
    /// When SourceIp is Enabled the worker's IP address when a task is rendered in the worker portal is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. This IP address is checked by Amazon S3 and must match in order for the Amazon S3 resource to be rendered in the worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceIp")]
    pub source_ip: Option<String>,
    /// When VpcSourceIp is Enabled the worker's IP address when a task is rendered in private worker portal inside the VPC is added to the IAM policy as a Condition used to generate the Amazon S3 presigned URL. To render the task successfully Amazon S3 checks that the presigned URL is being accessed over an Amazon S3 VPC Endpoint, and that the worker's IP address matches the IP address in the IAM policy. To learn more about configuring private worker portal, see Use Amazon VPC mode from a private worker portal. Valid values are Enabled or Disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSourceIp")]
    pub vpc_source_ip: Option<String>,
}

