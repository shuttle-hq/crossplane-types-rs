// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RoutineSpec defines the desired state of Routine
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "bigquery.gcp.upbound.io", version = "v1beta2", kind = "Routine", plural = "routines")]
#[kube(status = "RoutineStatus")]
pub struct RoutineSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<RoutineDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RoutineForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<RoutineInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<RoutineProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<RoutinePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<RoutineWriteConnectionSecretToRef>,
}

/// RoutineSpec defines the desired state of Routine
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProvider {
    /// Input/output argument of a function or a stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<RoutineForProviderArguments>>,
    /// If set to DATA_MASKING, the function is validated and made available as a masking function. For more information, see https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask
    /// Possible values are: DATA_MASKING.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataGovernanceType")]
    pub data_governance_type: Option<String>,
    /// The ID of the dataset containing this routine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// Reference to a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdRef")]
    pub dataset_id_ref: Option<RoutineForProviderDatasetIdRef>,
    /// Selector for a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdSelector")]
    pub dataset_id_selector: Option<RoutineForProviderDatasetIdSelector>,
    /// The body of the routine. For functions, this is the expression in the AS clause.
    /// If language=SQL, it is the substring inside (but excluding) the parentheses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionBody")]
    pub definition_body: Option<String>,
    /// The description of the routine if defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The determinism level of the JavaScript UDF if defined.
    /// Possible values are: DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, NOT_DETERMINISTIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "determinismLevel")]
    pub determinism_level: Option<String>,
    /// Optional. If language = "JAVASCRIPT", this field stores the path of the
    /// imported JAVASCRIPT libraries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importedLibraries")]
    pub imported_libraries: Option<Vec<String>>,
    /// The language of the routine.
    /// Possible values are: SQL, JAVASCRIPT, PYTHON, JAVA, SCALA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Remote function specific options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteFunctionOptions")]
    pub remote_function_options: Option<RoutineForProviderRemoteFunctionOptions>,
    /// Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION".
    /// If absent, the return table type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the columns in the evaluated table result will
    /// be cast to match the column types specificed in return table type, at query time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnTableType")]
    pub return_table_type: Option<String>,
    /// A JSON schema for the return type. Optional if language = "SQL"; required otherwise.
    /// If absent, the return type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the evaluated result will be cast to
    /// the specified returned type at query time. ~>NOTE: Because this field expects a JSON
    /// string, any changes to the string will create a diff, even if the JSON itself hasn't
    /// changed. If the API returns a different value for the same schema, e.g. it switche
    /// d the order of values or replaced STRUCT field type with RECORD field type, we currently
    /// cannot suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnType")]
    pub return_type: Option<String>,
    /// The type of routine.
    /// Possible values are: SCALAR_FUNCTION, PROCEDURE, TABLE_VALUED_FUNCTION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routineType")]
    pub routine_type: Option<String>,
    /// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkOptions")]
    pub spark_options: Option<RoutineForProviderSparkOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderArguments {
    /// Defaults to FIXED_TYPE.
    /// Default value is FIXED_TYPE.
    /// Possible values are: FIXED_TYPE, ANY_TYPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "argumentKind")]
    pub argument_kind: Option<String>,
    /// A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
    /// ~>NOTE: Because this field expects a JSON string, any changes to the string
    /// will create a diff, even if the JSON itself hasn't changed. If the API returns
    /// a different value for the same schema, e.g. it switched the order of values
    /// or replaced STRUCT field type with RECORD field type, we currently cannot
    /// suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataType")]
    pub data_type: Option<String>,
    /// Specifies whether the argument is input or output. Can be set for procedures only.
    /// Possible values are: IN, OUT, INOUT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The name of this argument. Can be absent for function return argument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Reference to a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderDatasetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderDatasetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderDatasetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderDatasetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderDatasetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderDatasetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderDatasetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderDatasetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderDatasetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderDatasetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderDatasetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderDatasetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderDatasetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderDatasetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Remote function specific options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderRemoteFunctionOptions {
    /// Fully qualified name of the user-provided connection object which holds
    /// the authentication information to send requests to the remote service.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Reference to a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionRef")]
    pub connection_ref: Option<RoutineForProviderRemoteFunctionOptionsConnectionRef>,
    /// Selector for a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionSelector")]
    pub connection_selector: Option<RoutineForProviderRemoteFunctionOptionsConnectionSelector>,
    /// Endpoint of the user-provided remote service, e.g.
    /// https://us-east1-my_gcf_project.cloudfunctions.net/remote_add
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Max number of rows in each batch sent to the remote service. If absent or if 0,
    /// BigQuery dynamically decides the number of rows in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBatchingRows")]
    pub max_batching_rows: Option<String>,
    /// User-defined context as a set of key/value pairs, which will be sent as function
    /// invocation context together with batched arguments in the requests to the remote
    /// service. The total number of bytes of keys and values must be less than 8KB.
    /// An object containing a list of "key": value pairs. Example:
    /// { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDefinedContext")]
    pub user_defined_context: Option<HashMap<String, String>>,
}

/// Reference to a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderRemoteFunctionOptionsConnectionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderRemoteFunctionOptionsConnectionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderRemoteFunctionOptionsConnectionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderRemoteFunctionOptionsConnectionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderRemoteFunctionOptionsConnectionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderRemoteFunctionOptionsConnectionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderRemoteFunctionOptionsConnectionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderRemoteFunctionOptionsConnectionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderRemoteFunctionOptionsConnectionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderSparkOptions {
    /// Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archiveUris")]
    pub archive_uris: Option<Vec<String>>,
    /// Fully qualified name of the user-provided Spark connection object.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Reference to a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionRef")]
    pub connection_ref: Option<RoutineForProviderSparkOptionsConnectionRef>,
    /// Selector for a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionSelector")]
    pub connection_selector: Option<RoutineForProviderSparkOptionsConnectionSelector>,
    /// Custom container image for the runtime environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerImage")]
    pub container_image: Option<String>,
    /// Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileUris")]
    pub file_uris: Option<Vec<String>>,
    /// JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jarUris")]
    pub jar_uris: Option<Vec<String>>,
    /// The fully qualified name of a class in jarUris, for example, com.example.wordcount.
    /// Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainClass")]
    pub main_class: Option<String>,
    /// The main file/jar URI of the Spark application.
    /// Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
    /// Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainFileUri")]
    pub main_file_uri: Option<String>,
    /// Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
    /// For more information, see Apache Spark and the procedure option list.
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<HashMap<String, String>>,
    /// Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pyFileUris")]
    pub py_file_uris: Option<Vec<String>>,
    /// Runtime version. If not specified, the default runtime version is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeVersion")]
    pub runtime_version: Option<String>,
}

/// Reference to a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderSparkOptionsConnectionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderSparkOptionsConnectionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderSparkOptionsConnectionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderSparkOptionsConnectionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderSparkOptionsConnectionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderSparkOptionsConnectionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderSparkOptionsConnectionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderSparkOptionsConnectionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineForProviderSparkOptionsConnectionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineForProviderSparkOptionsConnectionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineForProviderSparkOptionsConnectionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineForProviderSparkOptionsConnectionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderSparkOptionsConnectionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineForProviderSparkOptionsConnectionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProvider {
    /// Input/output argument of a function or a stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<RoutineInitProviderArguments>>,
    /// If set to DATA_MASKING, the function is validated and made available as a masking function. For more information, see https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask
    /// Possible values are: DATA_MASKING.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataGovernanceType")]
    pub data_governance_type: Option<String>,
    /// The body of the routine. For functions, this is the expression in the AS clause.
    /// If language=SQL, it is the substring inside (but excluding) the parentheses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionBody")]
    pub definition_body: Option<String>,
    /// The description of the routine if defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The determinism level of the JavaScript UDF if defined.
    /// Possible values are: DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, NOT_DETERMINISTIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "determinismLevel")]
    pub determinism_level: Option<String>,
    /// Optional. If language = "JAVASCRIPT", this field stores the path of the
    /// imported JAVASCRIPT libraries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importedLibraries")]
    pub imported_libraries: Option<Vec<String>>,
    /// The language of the routine.
    /// Possible values are: SQL, JAVASCRIPT, PYTHON, JAVA, SCALA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Remote function specific options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteFunctionOptions")]
    pub remote_function_options: Option<RoutineInitProviderRemoteFunctionOptions>,
    /// Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION".
    /// If absent, the return table type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the columns in the evaluated table result will
    /// be cast to match the column types specificed in return table type, at query time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnTableType")]
    pub return_table_type: Option<String>,
    /// A JSON schema for the return type. Optional if language = "SQL"; required otherwise.
    /// If absent, the return type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the evaluated result will be cast to
    /// the specified returned type at query time. ~>NOTE: Because this field expects a JSON
    /// string, any changes to the string will create a diff, even if the JSON itself hasn't
    /// changed. If the API returns a different value for the same schema, e.g. it switche
    /// d the order of values or replaced STRUCT field type with RECORD field type, we currently
    /// cannot suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnType")]
    pub return_type: Option<String>,
    /// The type of routine.
    /// Possible values are: SCALAR_FUNCTION, PROCEDURE, TABLE_VALUED_FUNCTION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routineType")]
    pub routine_type: Option<String>,
    /// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkOptions")]
    pub spark_options: Option<RoutineInitProviderSparkOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderArguments {
    /// Defaults to FIXED_TYPE.
    /// Default value is FIXED_TYPE.
    /// Possible values are: FIXED_TYPE, ANY_TYPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "argumentKind")]
    pub argument_kind: Option<String>,
    /// A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
    /// ~>NOTE: Because this field expects a JSON string, any changes to the string
    /// will create a diff, even if the JSON itself hasn't changed. If the API returns
    /// a different value for the same schema, e.g. it switched the order of values
    /// or replaced STRUCT field type with RECORD field type, we currently cannot
    /// suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataType")]
    pub data_type: Option<String>,
    /// Specifies whether the argument is input or output. Can be set for procedures only.
    /// Possible values are: IN, OUT, INOUT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The name of this argument. Can be absent for function return argument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Remote function specific options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderRemoteFunctionOptions {
    /// Fully qualified name of the user-provided connection object which holds
    /// the authentication information to send requests to the remote service.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Reference to a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionRef")]
    pub connection_ref: Option<RoutineInitProviderRemoteFunctionOptionsConnectionRef>,
    /// Selector for a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionSelector")]
    pub connection_selector: Option<RoutineInitProviderRemoteFunctionOptionsConnectionSelector>,
    /// Endpoint of the user-provided remote service, e.g.
    /// https://us-east1-my_gcf_project.cloudfunctions.net/remote_add
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Max number of rows in each batch sent to the remote service. If absent or if 0,
    /// BigQuery dynamically decides the number of rows in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBatchingRows")]
    pub max_batching_rows: Option<String>,
    /// User-defined context as a set of key/value pairs, which will be sent as function
    /// invocation context together with batched arguments in the requests to the remote
    /// service. The total number of bytes of keys and values must be less than 8KB.
    /// An object containing a list of "key": value pairs. Example:
    /// { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDefinedContext")]
    pub user_defined_context: Option<HashMap<String, String>>,
}

/// Reference to a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderRemoteFunctionOptionsConnectionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderRemoteFunctionOptionsConnectionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderRemoteFunctionOptionsConnectionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderRemoteFunctionOptionsConnectionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderSparkOptions {
    /// Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archiveUris")]
    pub archive_uris: Option<Vec<String>>,
    /// Fully qualified name of the user-provided Spark connection object.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Reference to a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionRef")]
    pub connection_ref: Option<RoutineInitProviderSparkOptionsConnectionRef>,
    /// Selector for a Connection in bigquery to populate connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionSelector")]
    pub connection_selector: Option<RoutineInitProviderSparkOptionsConnectionSelector>,
    /// Custom container image for the runtime environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerImage")]
    pub container_image: Option<String>,
    /// Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileUris")]
    pub file_uris: Option<Vec<String>>,
    /// JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jarUris")]
    pub jar_uris: Option<Vec<String>>,
    /// The fully qualified name of a class in jarUris, for example, com.example.wordcount.
    /// Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainClass")]
    pub main_class: Option<String>,
    /// The main file/jar URI of the Spark application.
    /// Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
    /// Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainFileUri")]
    pub main_file_uri: Option<String>,
    /// Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
    /// For more information, see Apache Spark and the procedure option list.
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<HashMap<String, String>>,
    /// Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pyFileUris")]
    pub py_file_uris: Option<Vec<String>>,
    /// Runtime version. If not specified, the default runtime version is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeVersion")]
    pub runtime_version: Option<String>,
}

/// Reference to a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderSparkOptionsConnectionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineInitProviderSparkOptionsConnectionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderSparkOptionsConnectionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineInitProviderSparkOptionsConnectionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineInitProviderSparkOptionsConnectionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderSparkOptionsConnectionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderSparkOptionsConnectionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Connection in bigquery to populate connection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderSparkOptionsConnectionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineInitProviderSparkOptionsConnectionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineInitProviderSparkOptionsConnectionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineInitProviderSparkOptionsConnectionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineInitProviderSparkOptionsConnectionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderSparkOptionsConnectionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineInitProviderSparkOptionsConnectionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutineProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutineProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutineProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutineProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutinePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<RoutinePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<RoutinePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutinePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutinePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutinePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutinePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutinePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutinePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutinePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutinePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RoutineStatus defines the observed state of Routine.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<RoutineStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineStatusAtProvider {
    /// Input/output argument of a function or a stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<RoutineStatusAtProviderArguments>>,
    /// The time when this routine was created, in milliseconds since the
    /// epoch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTime")]
    pub creation_time: Option<f64>,
    /// If set to DATA_MASKING, the function is validated and made available as a masking function. For more information, see https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask
    /// Possible values are: DATA_MASKING.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataGovernanceType")]
    pub data_governance_type: Option<String>,
    /// The ID of the dataset containing this routine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The body of the routine. For functions, this is the expression in the AS clause.
    /// If language=SQL, it is the substring inside (but excluding) the parentheses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionBody")]
    pub definition_body: Option<String>,
    /// The description of the routine if defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The determinism level of the JavaScript UDF if defined.
    /// Possible values are: DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, NOT_DETERMINISTIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "determinismLevel")]
    pub determinism_level: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/datasets/{{dataset_id}}/routines/{{routine_id}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Optional. If language = "JAVASCRIPT", this field stores the path of the
    /// imported JAVASCRIPT libraries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importedLibraries")]
    pub imported_libraries: Option<Vec<String>>,
    /// The language of the routine.
    /// Possible values are: SQL, JAVASCRIPT, PYTHON, JAVA, SCALA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    /// The time when this routine was modified, in milliseconds since the
    /// epoch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastModifiedTime")]
    pub last_modified_time: Option<f64>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Remote function specific options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteFunctionOptions")]
    pub remote_function_options: Option<RoutineStatusAtProviderRemoteFunctionOptions>,
    /// Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION".
    /// If absent, the return table type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the columns in the evaluated table result will
    /// be cast to match the column types specificed in return table type, at query time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnTableType")]
    pub return_table_type: Option<String>,
    /// A JSON schema for the return type. Optional if language = "SQL"; required otherwise.
    /// If absent, the return type is inferred from definitionBody at query time in each query
    /// that references this routine. If present, then the evaluated result will be cast to
    /// the specified returned type at query time. ~>NOTE: Because this field expects a JSON
    /// string, any changes to the string will create a diff, even if the JSON itself hasn't
    /// changed. If the API returns a different value for the same schema, e.g. it switche
    /// d the order of values or replaced STRUCT field type with RECORD field type, we currently
    /// cannot suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnType")]
    pub return_type: Option<String>,
    /// The type of routine.
    /// Possible values are: SCALAR_FUNCTION, PROCEDURE, TABLE_VALUED_FUNCTION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routineType")]
    pub routine_type: Option<String>,
    /// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkOptions")]
    pub spark_options: Option<RoutineStatusAtProviderSparkOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineStatusAtProviderArguments {
    /// Defaults to FIXED_TYPE.
    /// Default value is FIXED_TYPE.
    /// Possible values are: FIXED_TYPE, ANY_TYPE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "argumentKind")]
    pub argument_kind: Option<String>,
    /// A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
    /// ~>NOTE: Because this field expects a JSON string, any changes to the string
    /// will create a diff, even if the JSON itself hasn't changed. If the API returns
    /// a different value for the same schema, e.g. it switched the order of values
    /// or replaced STRUCT field type with RECORD field type, we currently cannot
    /// suppress the recurring diff this causes. As a workaround, we recommend using
    /// the schema as returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataType")]
    pub data_type: Option<String>,
    /// Specifies whether the argument is input or output. Can be set for procedures only.
    /// Possible values are: IN, OUT, INOUT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The name of this argument. Can be absent for function return argument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Remote function specific options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineStatusAtProviderRemoteFunctionOptions {
    /// Fully qualified name of the user-provided connection object which holds
    /// the authentication information to send requests to the remote service.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Endpoint of the user-provided remote service, e.g.
    /// https://us-east1-my_gcf_project.cloudfunctions.net/remote_add
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Max number of rows in each batch sent to the remote service. If absent or if 0,
    /// BigQuery dynamically decides the number of rows in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBatchingRows")]
    pub max_batching_rows: Option<String>,
    /// User-defined context as a set of key/value pairs, which will be sent as function
    /// invocation context together with batched arguments in the requests to the remote
    /// service. The total number of bytes of keys and values must be less than 8KB.
    /// An object containing a list of "key": value pairs. Example:
    /// { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDefinedContext")]
    pub user_defined_context: Option<HashMap<String, String>>,
}

/// Optional. If language is one of "PYTHON", "JAVA", "SCALA", this field stores the options for spark stored procedure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutineStatusAtProviderSparkOptions {
    /// Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archiveUris")]
    pub archive_uris: Option<Vec<String>>,
    /// Fully qualified name of the user-provided Spark connection object.
    /// Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connection: Option<String>,
    /// Custom container image for the runtime environment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerImage")]
    pub container_image: Option<String>,
    /// Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileUris")]
    pub file_uris: Option<Vec<String>>,
    /// JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jarUris")]
    pub jar_uris: Option<Vec<String>>,
    /// The fully qualified name of a class in jarUris, for example, com.example.wordcount.
    /// Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainClass")]
    pub main_class: Option<String>,
    /// The main file/jar URI of the Spark application.
    /// Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
    /// Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainFileUri")]
    pub main_file_uri: Option<String>,
    /// Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
    /// For more information, see Apache Spark and the procedure option list.
    /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<HashMap<String, String>>,
    /// Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pyFileUris")]
    pub py_file_uris: Option<Vec<String>>,
    /// Runtime version. If not specified, the default runtime version is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeVersion")]
    pub runtime_version: Option<String>,
}

