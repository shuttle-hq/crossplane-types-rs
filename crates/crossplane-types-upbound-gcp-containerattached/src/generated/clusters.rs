// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "containerattached.gcp.upbound.io", version = "v1beta2", kind = "Cluster", plural = "clusters")]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProvider {
    /// Optional. Annotations on the cluster. This field has the same
    /// restrictions as Kubernetes annotations. The total size of all keys and
    /// values combined is limited to 256k. Key can have 2 segments: prefix
    /// and name , separated by a slash (/). Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Configuration related to the cluster RBAC settings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ClusterForProviderAuthorization>,
    /// Binary Authorization configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterForProviderBinaryAuthorization>,
    /// Policy to determine what flags to send on delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// A human readable description of this attached cluster. Cannot be longer
    /// than 255 UTF-8 encoded bytes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The Kubernetes distribution of the underlying attached cluster. Supported values:
    /// "eks", "aks", "generic". The generic distribution provides the ability to register
    /// or migrate any CNCF conformant cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<String>,
    /// Fleet configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterForProviderFleet>,
    /// The location for the resource
    pub location: String,
    /// Logging configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterForProviderLoggingConfig>,
    /// Monitoring configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterForProviderMonitoringConfig>,
    /// OIDC discovery information of the target cluster.
    /// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
    /// API server. This fields indicates how GCP services
    /// validate KSA tokens in order to allow system workloads (such as GKE Connect
    /// and telemetry agents) to authenticate back to GCP.
    /// Both clusters with public and private issuer URLs are supported.
    /// Clusters with public issuers only need to specify the issuer_url field
    /// while clusters with private issuers need to provide both
    /// issuer_url and jwks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcConfig")]
    pub oidc_config: Option<ClusterForProviderOidcConfig>,
    /// The platform version for the cluster (e.g. 1.23.0-gke.1).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Support for proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConfig")]
    pub proxy_config: Option<ClusterForProviderProxyConfig>,
}

/// Configuration related to the cluster RBAC settings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderAuthorization {
    /// Groups that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the groups. Up to ten admin groups can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminGroups")]
    pub admin_groups: Option<Vec<String>>,
    /// Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the users. Up to ten admin users can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminUsers")]
    pub admin_users: Option<Vec<String>>,
}

/// Binary Authorization configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderBinaryAuthorization {
    /// Configure Binary Authorization evaluation mode.
    /// Possible values are: DISABLED, PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

/// Fleet configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderFleet {
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Logging configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderLoggingConfig {
    /// The configuration of the logging components
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentConfig")]
    pub component_config: Option<ClusterForProviderLoggingConfigComponentConfig>,
}

/// The configuration of the logging components
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderLoggingConfigComponentConfig {
    /// The components to be enabled.
    /// Each value may be one of: SYSTEM_COMPONENTS, WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// Monitoring configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMonitoringConfig {
    /// Enable Google Cloud Managed Service for Prometheus in the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheusConfig")]
    pub managed_prometheus_config: Option<ClusterForProviderMonitoringConfigManagedPrometheusConfig>,
}

/// Enable Google Cloud Managed Service for Prometheus in the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderMonitoringConfigManagedPrometheusConfig {
    /// Enable Managed Collection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// OIDC discovery information of the target cluster.
/// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
/// API server. This fields indicates how GCP services
/// validate KSA tokens in order to allow system workloads (such as GKE Connect
/// and telemetry agents) to authenticate back to GCP.
/// Both clusters with public and private issuer URLs are supported.
/// Clusters with public issuers only need to specify the issuer_url field
/// while clusters with private issuers need to provide both
/// issuer_url and jwks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderOidcConfig {
    /// A JSON Web Token (JWT) issuer URI. issuer must start with https://
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// OIDC verification keys in JWKS format (RFC 7517).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwks: Option<String>,
}

/// Support for proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderProxyConfig {
    /// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSecret")]
    pub kubernetes_secret: Option<ClusterForProviderProxyConfigKubernetesSecret>,
}

/// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterForProviderProxyConfigKubernetesSecret {
    /// Name of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProvider {
    /// Optional. Annotations on the cluster. This field has the same
    /// restrictions as Kubernetes annotations. The total size of all keys and
    /// values combined is limited to 256k. Key can have 2 segments: prefix
    /// and name , separated by a slash (/). Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Configuration related to the cluster RBAC settings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ClusterInitProviderAuthorization>,
    /// Binary Authorization configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterInitProviderBinaryAuthorization>,
    /// Policy to determine what flags to send on delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// A human readable description of this attached cluster. Cannot be longer
    /// than 255 UTF-8 encoded bytes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The Kubernetes distribution of the underlying attached cluster. Supported values:
    /// "eks", "aks", "generic". The generic distribution provides the ability to register
    /// or migrate any CNCF conformant cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<String>,
    /// Fleet configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterInitProviderFleet>,
    /// Logging configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterInitProviderLoggingConfig>,
    /// Monitoring configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterInitProviderMonitoringConfig>,
    /// OIDC discovery information of the target cluster.
    /// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
    /// API server. This fields indicates how GCP services
    /// validate KSA tokens in order to allow system workloads (such as GKE Connect
    /// and telemetry agents) to authenticate back to GCP.
    /// Both clusters with public and private issuer URLs are supported.
    /// Clusters with public issuers only need to specify the issuer_url field
    /// while clusters with private issuers need to provide both
    /// issuer_url and jwks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcConfig")]
    pub oidc_config: Option<ClusterInitProviderOidcConfig>,
    /// The platform version for the cluster (e.g. 1.23.0-gke.1).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Support for proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConfig")]
    pub proxy_config: Option<ClusterInitProviderProxyConfig>,
}

/// Configuration related to the cluster RBAC settings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderAuthorization {
    /// Groups that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the groups. Up to ten admin groups can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminGroups")]
    pub admin_groups: Option<Vec<String>>,
    /// Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the users. Up to ten admin users can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminUsers")]
    pub admin_users: Option<Vec<String>>,
}

/// Binary Authorization configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderBinaryAuthorization {
    /// Configure Binary Authorization evaluation mode.
    /// Possible values are: DISABLED, PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

/// Fleet configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderFleet {
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Logging configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderLoggingConfig {
    /// The configuration of the logging components
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentConfig")]
    pub component_config: Option<ClusterInitProviderLoggingConfigComponentConfig>,
}

/// The configuration of the logging components
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderLoggingConfigComponentConfig {
    /// The components to be enabled.
    /// Each value may be one of: SYSTEM_COMPONENTS, WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// Monitoring configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMonitoringConfig {
    /// Enable Google Cloud Managed Service for Prometheus in the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheusConfig")]
    pub managed_prometheus_config: Option<ClusterInitProviderMonitoringConfigManagedPrometheusConfig>,
}

/// Enable Google Cloud Managed Service for Prometheus in the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderMonitoringConfigManagedPrometheusConfig {
    /// Enable Managed Collection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// OIDC discovery information of the target cluster.
/// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
/// API server. This fields indicates how GCP services
/// validate KSA tokens in order to allow system workloads (such as GKE Connect
/// and telemetry agents) to authenticate back to GCP.
/// Both clusters with public and private issuer URLs are supported.
/// Clusters with public issuers only need to specify the issuer_url field
/// while clusters with private issuers need to provide both
/// issuer_url and jwks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderOidcConfig {
    /// A JSON Web Token (JWT) issuer URI. issuer must start with https://
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// OIDC verification keys in JWKS format (RFC 7517).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwks: Option<String>,
}

/// Support for proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderProxyConfig {
    /// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSecret")]
    pub kubernetes_secret: Option<ClusterInitProviderProxyConfigKubernetesSecret>,
}

/// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterInitProviderProxyConfigKubernetesSecret {
    /// Name of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProvider {
    /// Optional. Annotations on the cluster. This field has the same
    /// restrictions as Kubernetes annotations. The total size of all keys and
    /// values combined is limited to 256k. Key can have 2 segments: prefix
    /// and name , separated by a slash (/). Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Configuration related to the cluster RBAC settings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ClusterStatusAtProviderAuthorization>,
    /// Binary Authorization configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "binaryAuthorization")]
    pub binary_authorization: Option<ClusterStatusAtProviderBinaryAuthorization>,
    /// Output only. The region where this cluster runs.
    /// For EKS clusters, this is an AWS region. For AKS clusters,
    /// this is an Azure region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRegion")]
    pub cluster_region: Option<String>,
    /// Output only. The time at which this cluster was created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    pub create_time: Option<String>,
    /// Policy to determine what flags to send on delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<String>,
    /// A human readable description of this attached cluster. Cannot be longer
    /// than 255 UTF-8 encoded bytes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The Kubernetes distribution of the underlying attached cluster. Supported values:
    /// "eks", "aks", "generic". The generic distribution provides the ability to register
    /// or migrate any CNCF conformant cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveAnnotations")]
    pub effective_annotations: Option<HashMap<String, String>>,
    /// A set of errors found in the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<ClusterStatusAtProviderErrors>>,
    /// Fleet configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fleet: Option<ClusterStatusAtProviderFleet>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/attachedClusters/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Kubernetes version of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesVersion")]
    pub kubernetes_version: Option<String>,
    /// The location for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Logging configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<ClusterStatusAtProviderLoggingConfig>,
    /// Monitoring configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfig")]
    pub monitoring_config: Option<ClusterStatusAtProviderMonitoringConfig>,
    /// OIDC discovery information of the target cluster.
    /// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
    /// API server. This fields indicates how GCP services
    /// validate KSA tokens in order to allow system workloads (such as GKE Connect
    /// and telemetry agents) to authenticate back to GCP.
    /// Both clusters with public and private issuer URLs are supported.
    /// Clusters with public issuers only need to specify the issuer_url field
    /// while clusters with private issuers need to provide both
    /// issuer_url and jwks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcConfig")]
    pub oidc_config: Option<ClusterStatusAtProviderOidcConfig>,
    /// The platform version for the cluster (e.g. 1.23.0-gke.1).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Support for proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConfig")]
    pub proxy_config: Option<ClusterStatusAtProviderProxyConfig>,
    /// If set, there are currently changes in flight to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconciling: Option<bool>,
    /// The current state of the cluster. Possible values:
    /// STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR,
    /// DEGRADED
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// A globally unique identifier for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
    /// The time at which this cluster was last updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    pub update_time: Option<String>,
    /// Workload Identity settings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentityConfig")]
    pub workload_identity_config: Option<Vec<ClusterStatusAtProviderWorkloadIdentityConfig>>,
}

/// Configuration related to the cluster RBAC settings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderAuthorization {
    /// Groups that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the groups. Up to ten admin groups can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminGroups")]
    pub admin_groups: Option<Vec<String>>,
    /// Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the cluster-admin ClusterRole
    /// to the users. Up to ten admin users can be provided.
    /// For more info on RBAC, see
    /// https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminUsers")]
    pub admin_users: Option<Vec<String>>,
}

/// Binary Authorization configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderBinaryAuthorization {
    /// Configure Binary Authorization evaluation mode.
    /// Possible values are: DISABLED, PROJECT_SINGLETON_POLICY_ENFORCE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluationMode")]
    pub evaluation_mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderErrors {
    /// Human-friendly description of the error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// Fleet configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderFleet {
    /// (Output)
    /// The name of the managed Hub Membership resource associated to this
    /// cluster. Membership names are formatted as
    /// projects//locations/global/membership/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership: Option<String>,
    /// The number of the Fleet host project where this cluster will be registered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// Logging configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderLoggingConfig {
    /// The configuration of the logging components
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentConfig")]
    pub component_config: Option<ClusterStatusAtProviderLoggingConfigComponentConfig>,
}

/// The configuration of the logging components
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderLoggingConfigComponentConfig {
    /// The components to be enabled.
    /// Each value may be one of: SYSTEM_COMPONENTS, WORKLOADS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableComponents")]
    pub enable_components: Option<Vec<String>>,
}

/// Monitoring configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMonitoringConfig {
    /// Enable Google Cloud Managed Service for Prometheus in the cluster.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedPrometheusConfig")]
    pub managed_prometheus_config: Option<ClusterStatusAtProviderMonitoringConfigManagedPrometheusConfig>,
}

/// Enable Google Cloud Managed Service for Prometheus in the cluster.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderMonitoringConfigManagedPrometheusConfig {
    /// Enable Managed Collection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// OIDC discovery information of the target cluster.
/// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
/// API server. This fields indicates how GCP services
/// validate KSA tokens in order to allow system workloads (such as GKE Connect
/// and telemetry agents) to authenticate back to GCP.
/// Both clusters with public and private issuer URLs are supported.
/// Clusters with public issuers only need to specify the issuer_url field
/// while clusters with private issuers need to provide both
/// issuer_url and jwks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderOidcConfig {
    /// A JSON Web Token (JWT) issuer URI. issuer must start with https://
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// OIDC verification keys in JWKS format (RFC 7517).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwks: Option<String>,
}

/// Support for proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderProxyConfig {
    /// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSecret")]
    pub kubernetes_secret: Option<ClusterStatusAtProviderProxyConfigKubernetesSecret>,
}

/// The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderProxyConfigKubernetesSecret {
    /// Name of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the kubernetes secret containing the proxy config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClusterStatusAtProviderWorkloadIdentityConfig {
    /// The ID of the OIDC Identity Provider (IdP) associated to
    /// the Workload Identity Pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityProvider")]
    pub identity_provider: Option<String>,
    /// The OIDC issuer URL for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUri")]
    pub issuer_uri: Option<String>,
    /// The Workload Identity Pool associated to the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadPool")]
    pub workload_pool: Option<String>,
}

