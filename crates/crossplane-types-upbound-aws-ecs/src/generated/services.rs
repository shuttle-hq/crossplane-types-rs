// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ServiceSpec defines the desired state of Service
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "ecs.aws.upbound.io", version = "v1beta2", kind = "Service", plural = "services")]
#[kube(status = "ServiceStatus")]
pub struct ServiceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<ServiceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ServiceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<ServiceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<ServiceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<ServicePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<ServiceWriteConnectionSecretToRef>,
}

/// ServiceSpec defines the desired state of Service
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProvider {
    /// Information about the CloudWatch alarms. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alarms: Option<ServiceForProviderAlarms>,
    /// ECS automatically redistributes tasks within a service across Availability Zones (AZs) to mitigate the risk of impaired application availability due to underlying infrastructure failures and task lifecycle activities. The valid values are ENABLED and DISABLED. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneRebalancing")]
    pub availability_zone_rebalancing: Option<String>,
    /// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProviderStrategy")]
    pub capacity_provider_strategy: Option<Vec<ServiceForProviderCapacityProviderStrategy>>,
    /// Name of an ECS cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// Reference to a Cluster in ecs to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    pub cluster_ref: Option<ServiceForProviderClusterRef>,
    /// Selector for a Cluster in ecs to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSelector")]
    pub cluster_selector: Option<ServiceForProviderClusterSelector>,
    /// Configuration block for deployment circuit breaker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentCircuitBreaker")]
    pub deployment_circuit_breaker: Option<ServiceForProviderDeploymentCircuitBreaker>,
    /// Configuration block for deployment controller configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentController")]
    pub deployment_controller: Option<ServiceForProviderDeploymentController>,
    /// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMaximumPercent")]
    pub deployment_maximum_percent: Option<f64>,
    /// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMinimumHealthyPercent")]
    pub deployment_minimum_healthy_percent: Option<f64>,
    /// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredCount")]
    pub desired_count: Option<f64>,
    /// Whether to enable Amazon ECS managed tags for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableEcsManagedTags")]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Whether to enable Amazon ECS Exec for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExecuteCommand")]
    pub enable_execute_command: Option<bool>,
    /// Enable to delete a service even if it wasn't scaled down to zero tasks. It's only necessary to use this if the service uses the REPLICA scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceDelete")]
    pub force_delete: Option<bool>,
    /// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceNewDeployment")]
    pub force_new_deployment: Option<bool>,
    /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckGracePeriodSeconds")]
    pub health_check_grace_period_seconds: Option<f64>,
    /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRole")]
    pub iam_role: Option<String>,
    /// Reference to a Role in iam to populate iamRole.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleRef")]
    pub iam_role_ref: Option<ServiceForProviderIamRoleRef>,
    /// Selector for a Role in iam to populate iamRole.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleSelector")]
    pub iam_role_selector: Option<ServiceForProviderIamRoleSelector>,
    /// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchType")]
    pub launch_type: Option<String>,
    /// Configuration block for load balancers. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<Vec<ServiceForProviderLoadBalancer>>,
    /// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfiguration")]
    pub network_configuration: Option<ServiceForProviderNetworkConfiguration>,
    /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedPlacementStrategy")]
    pub ordered_placement_strategy: Option<Vec<ServiceForProviderOrderedPlacementStrategy>>,
    /// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementConstraints")]
    pub placement_constraints: Option<Vec<ServiceForProviderPlacementConstraints>>,
    /// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulingStrategy")]
    pub scheduling_strategy: Option<String>,
    /// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConnectConfiguration")]
    pub service_connect_configuration: Option<ServiceForProviderServiceConnectConfiguration>,
    /// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRegistries")]
    pub service_registries: Option<ServiceForProviderServiceRegistries>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinition")]
    pub task_definition: Option<String>,
    /// Reference to a TaskDefinition in ecs to populate taskDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinitionRef")]
    pub task_definition_ref: Option<ServiceForProviderTaskDefinitionRef>,
    /// Selector for a TaskDefinition in ecs to populate taskDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinitionSelector")]
    pub task_definition_selector: Option<ServiceForProviderTaskDefinitionSelector>,
    /// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<HashMap<String, String>>,
    /// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeConfiguration")]
    pub volume_configuration: Option<ServiceForProviderVolumeConfiguration>,
    /// The VPC Lattice configuration for your service that allows Lattice to connect, secure, and monitor your service across multiple accounts and VPCs. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcLatticeConfigurations")]
    pub vpc_lattice_configurations: Option<Vec<ServiceForProviderVpcLatticeConfigurations>>,
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForSteadyState")]
    pub wait_for_steady_state: Option<bool>,
}

/// Information about the CloudWatch alarms. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderAlarms {
    /// One or more CloudWatch alarm names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmNames")]
    pub alarm_names: Option<Vec<String>>,
    /// Whether to use the CloudWatch alarm option in the service deployment process.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderCapacityProviderStrategy {
    /// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProvider")]
    pub capacity_provider: Option<String>,
    /// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<f64>,
}

/// Reference to a Cluster in ecs to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in ecs to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for deployment circuit breaker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderDeploymentCircuitBreaker {
    /// Whether to enable the deployment circuit breaker logic for the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

/// Configuration block for deployment controller configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderDeploymentController {
    /// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to a Role in iam to populate iamRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderIamRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderIamRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderIamRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderIamRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderIamRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderIamRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderIamRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate iamRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderIamRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderIamRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderIamRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderIamRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderIamRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderIamRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderIamRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderLoadBalancer {
    /// Name of the container to associate with the load balancer (as it appears in a container definition).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port on the container to associate with the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Name of the ELB (Classic) to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elbName")]
    pub elb_name: Option<String>,
    /// ARN of the Load Balancer target group to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArnRef")]
    pub target_group_arn_ref: Option<ServiceForProviderLoadBalancerTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArnSelector")]
    pub target_group_arn_selector: Option<ServiceForProviderLoadBalancerTargetGroupArnSelector>,
}

/// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderLoadBalancerTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderLoadBalancerTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderLoadBalancerTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderLoadBalancerTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderLoadBalancerTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderLoadBalancerTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderLoadBalancerTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderLoadBalancerTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderLoadBalancerTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfiguration {
    /// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assignPublicIp")]
    pub assign_public_ip: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupRefs")]
    pub security_group_refs: Option<Vec<ServiceForProviderNetworkConfigurationSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupSelector")]
    pub security_group_selector: Option<ServiceForProviderNetworkConfigurationSecurityGroupSelector>,
    /// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetRefs")]
    pub subnet_refs: Option<Vec<ServiceForProviderNetworkConfigurationSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetSelector")]
    pub subnet_selector: Option<ServiceForProviderNetworkConfigurationSubnetSelector>,
    /// Subnets associated with the task or service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderNetworkConfigurationSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderNetworkConfigurationSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderNetworkConfigurationSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderNetworkConfigurationSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderNetworkConfigurationSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderNetworkConfigurationSubnetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderNetworkConfigurationSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderNetworkConfigurationSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderOrderedPlacementStrategy {
    /// For the spread placement strategy, valid values are instanceId (or host,
    /// which has the same effect), or any platform or custom attribute that is applied to a container instance.
    /// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
    /// needed. For more information, see Placement Strategy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    /// Type of placement strategy. Must be one of: binpack, random, or spread
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderPlacementConstraints {
    /// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfiguration {
    /// Whether to use Service Connect with this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Log configuration for the container. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logConfiguration")]
    pub log_configuration: Option<ServiceForProviderServiceConnectConfigurationLogConfiguration>,
    /// Namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// List of Service Connect service objects. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<Vec<ServiceForProviderServiceConnectConfigurationService>>,
}

/// Log configuration for the container. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationLogConfiguration {
    /// Log driver to use for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logDriver")]
    pub log_driver: Option<String>,
    /// Configuration options to send to the log driver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<HashMap<String, String>>,
    /// Secrets to pass to the log configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretOption")]
    pub secret_option: Option<Vec<ServiceForProviderServiceConnectConfigurationLogConfigurationSecretOption>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationLogConfigurationSecretOption {
    /// Name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationService {
    /// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientAlias")]
    pub client_alias: Option<ServiceForProviderServiceConnectConfigurationServiceClientAlias>,
    /// Name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discoveryName")]
    pub discovery_name: Option<String>,
    /// Port number for the Service Connect proxy to listen on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPortOverride")]
    pub ingress_port_override: Option<f64>,
    /// Name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// Configuration timeouts for Service Connect
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<ServiceForProviderServiceConnectConfigurationServiceTimeout>,
    /// Configuration for enabling Transport Layer Security (TLS)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ServiceForProviderServiceConnectConfigurationServiceTls>,
}

/// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationServiceClientAlias {
    /// Name that you use in the applications of client tasks to connect to this service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

/// Configuration timeouts for Service Connect
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationServiceTimeout {
    /// Amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeoutSeconds")]
    pub idle_timeout_seconds: Option<f64>,
    /// Amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perRequestTimeoutSeconds")]
    pub per_request_timeout_seconds: Option<f64>,
}

/// Configuration for enabling Transport Layer Security (TLS)
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationServiceTls {
    /// Details of the certificate authority which will issue the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerCertAuthority")]
    pub issuer_cert_authority: Option<ServiceForProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority>,
    /// KMS key used to encrypt the private key in Secrets Manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    pub kms_key: Option<String>,
    /// ARN of the IAM Role that's associated with the Service Connect TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Details of the certificate authority which will issue the certificate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority {
    /// ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsPcaAuthorityArn")]
    pub aws_pca_authority_arn: Option<String>,
}

/// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderServiceRegistries {
    /// Container name value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Port value used if your Service Discovery service specified an SRV record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
    /// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "registryArn")]
    pub registry_arn: Option<String>,
}

/// Reference to a TaskDefinition in ecs to populate taskDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderTaskDefinitionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderTaskDefinitionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderTaskDefinitionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderTaskDefinitionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderTaskDefinitionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderTaskDefinitionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderTaskDefinitionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TaskDefinition in ecs to populate taskDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderTaskDefinitionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceForProviderTaskDefinitionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderTaskDefinitionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceForProviderTaskDefinitionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceForProviderTaskDefinitionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderTaskDefinitionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceForProviderTaskDefinitionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderVolumeConfiguration {
    /// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedEbsVolume")]
    pub managed_ebs_volume: Option<ServiceForProviderVolumeConfigurationManagedEbsVolume>,
    /// Name of the volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderVolumeConfigurationManagedEbsVolume {
    /// Whether the volume should be encrypted. Default value is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<bool>,
    /// Linux filesystem type for the volume. For volumes created from a snapshot, same filesystem type must be specified that the volume was using when the snapshot was created. Valid values are ext3, ext4, xfs. Default value is xfs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemType")]
    pub file_system_type: Option<String>,
    /// Number of I/O operations per second (IOPS).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<f64>,
    /// Amazon Resource Name (ARN) identifier of the Amazon Web Services Key Management Service key to use for Amazon EBS encryption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    pub kms_key_id: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Size of the volume in GiB. You must specify either a size_in_gb or a snapshot_id. You can optionally specify a volume size greater than or equal to the snapshot size.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeInGb")]
    pub size_in_gb: Option<f64>,
    /// Snapshot that Amazon ECS uses to create the volume. You must specify either a size_in_gb or a snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    pub snapshot_id: Option<String>,
    /// The tags to apply to the volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSpecifications")]
    pub tag_specifications: Option<Vec<ServiceForProviderVolumeConfigurationManagedEbsVolumeTagSpecifications>>,
    /// Throughput to provision for a volume, in MiB/s, with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<f64>,
    /// Volume type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderVolumeConfigurationManagedEbsVolumeTagSpecifications {
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// The type of volume resource. Valid values, volume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceForProviderVpcLatticeConfigurations {
    /// The name of the port for a target group associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The full ARN of the target group or groups associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProvider {
    /// Information about the CloudWatch alarms. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alarms: Option<ServiceInitProviderAlarms>,
    /// ECS automatically redistributes tasks within a service across Availability Zones (AZs) to mitigate the risk of impaired application availability due to underlying infrastructure failures and task lifecycle activities. The valid values are ENABLED and DISABLED. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneRebalancing")]
    pub availability_zone_rebalancing: Option<String>,
    /// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProviderStrategy")]
    pub capacity_provider_strategy: Option<Vec<ServiceInitProviderCapacityProviderStrategy>>,
    /// Name of an ECS cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// Reference to a Cluster in ecs to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    pub cluster_ref: Option<ServiceInitProviderClusterRef>,
    /// Selector for a Cluster in ecs to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSelector")]
    pub cluster_selector: Option<ServiceInitProviderClusterSelector>,
    /// Configuration block for deployment circuit breaker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentCircuitBreaker")]
    pub deployment_circuit_breaker: Option<ServiceInitProviderDeploymentCircuitBreaker>,
    /// Configuration block for deployment controller configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentController")]
    pub deployment_controller: Option<ServiceInitProviderDeploymentController>,
    /// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMaximumPercent")]
    pub deployment_maximum_percent: Option<f64>,
    /// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMinimumHealthyPercent")]
    pub deployment_minimum_healthy_percent: Option<f64>,
    /// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredCount")]
    pub desired_count: Option<f64>,
    /// Whether to enable Amazon ECS managed tags for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableEcsManagedTags")]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Whether to enable Amazon ECS Exec for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExecuteCommand")]
    pub enable_execute_command: Option<bool>,
    /// Enable to delete a service even if it wasn't scaled down to zero tasks. It's only necessary to use this if the service uses the REPLICA scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceDelete")]
    pub force_delete: Option<bool>,
    /// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceNewDeployment")]
    pub force_new_deployment: Option<bool>,
    /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckGracePeriodSeconds")]
    pub health_check_grace_period_seconds: Option<f64>,
    /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRole")]
    pub iam_role: Option<String>,
    /// Reference to a Role in iam to populate iamRole.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleRef")]
    pub iam_role_ref: Option<ServiceInitProviderIamRoleRef>,
    /// Selector for a Role in iam to populate iamRole.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleSelector")]
    pub iam_role_selector: Option<ServiceInitProviderIamRoleSelector>,
    /// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchType")]
    pub launch_type: Option<String>,
    /// Configuration block for load balancers. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<Vec<ServiceInitProviderLoadBalancer>>,
    /// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfiguration")]
    pub network_configuration: Option<ServiceInitProviderNetworkConfiguration>,
    /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedPlacementStrategy")]
    pub ordered_placement_strategy: Option<Vec<ServiceInitProviderOrderedPlacementStrategy>>,
    /// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementConstraints")]
    pub placement_constraints: Option<Vec<ServiceInitProviderPlacementConstraints>>,
    /// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulingStrategy")]
    pub scheduling_strategy: Option<String>,
    /// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConnectConfiguration")]
    pub service_connect_configuration: Option<ServiceInitProviderServiceConnectConfiguration>,
    /// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRegistries")]
    pub service_registries: Option<ServiceInitProviderServiceRegistries>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinition")]
    pub task_definition: Option<String>,
    /// Reference to a TaskDefinition in ecs to populate taskDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinitionRef")]
    pub task_definition_ref: Option<ServiceInitProviderTaskDefinitionRef>,
    /// Selector for a TaskDefinition in ecs to populate taskDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinitionSelector")]
    pub task_definition_selector: Option<ServiceInitProviderTaskDefinitionSelector>,
    /// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<HashMap<String, String>>,
    /// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeConfiguration")]
    pub volume_configuration: Option<ServiceInitProviderVolumeConfiguration>,
    /// The VPC Lattice configuration for your service that allows Lattice to connect, secure, and monitor your service across multiple accounts and VPCs. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcLatticeConfigurations")]
    pub vpc_lattice_configurations: Option<Vec<ServiceInitProviderVpcLatticeConfigurations>>,
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForSteadyState")]
    pub wait_for_steady_state: Option<bool>,
}

/// Information about the CloudWatch alarms. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderAlarms {
    /// One or more CloudWatch alarm names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmNames")]
    pub alarm_names: Option<Vec<String>>,
    /// Whether to use the CloudWatch alarm option in the service deployment process.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderCapacityProviderStrategy {
    /// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProvider")]
    pub capacity_provider: Option<String>,
    /// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<f64>,
}

/// Reference to a Cluster in ecs to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in ecs to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for deployment circuit breaker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderDeploymentCircuitBreaker {
    /// Whether to enable the deployment circuit breaker logic for the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

/// Configuration block for deployment controller configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderDeploymentController {
    /// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to a Role in iam to populate iamRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderIamRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderIamRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderIamRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderIamRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderIamRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderIamRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderIamRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate iamRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderIamRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderIamRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderIamRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderIamRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderIamRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderIamRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderIamRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderLoadBalancer {
    /// Name of the container to associate with the load balancer (as it appears in a container definition).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port on the container to associate with the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Name of the ELB (Classic) to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elbName")]
    pub elb_name: Option<String>,
    /// ARN of the Load Balancer target group to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
    /// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArnRef")]
    pub target_group_arn_ref: Option<ServiceInitProviderLoadBalancerTargetGroupArnRef>,
    /// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArnSelector")]
    pub target_group_arn_selector: Option<ServiceInitProviderLoadBalancerTargetGroupArnSelector>,
}

/// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderLoadBalancerTargetGroupArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderLoadBalancerTargetGroupArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderLoadBalancerTargetGroupArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderLoadBalancerTargetGroupArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderLoadBalancerTargetGroupArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderLoadBalancerTargetGroupArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderLoadBalancerTargetGroupArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderLoadBalancerTargetGroupArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderLoadBalancerTargetGroupArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfiguration {
    /// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assignPublicIp")]
    pub assign_public_ip: Option<bool>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupRefs")]
    pub security_group_refs: Option<Vec<ServiceInitProviderNetworkConfigurationSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupSelector")]
    pub security_group_selector: Option<ServiceInitProviderNetworkConfigurationSecurityGroupSelector>,
    /// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetRefs")]
    pub subnet_refs: Option<Vec<ServiceInitProviderNetworkConfigurationSubnetRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetSelector")]
    pub subnet_selector: Option<ServiceInitProviderNetworkConfigurationSubnetSelector>,
    /// Subnets associated with the task or service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<Vec<String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSubnetRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderNetworkConfigurationSubnetRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSubnetRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderNetworkConfigurationSubnetRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderNetworkConfigurationSubnetRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSubnetRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSubnetRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSubnetSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderNetworkConfigurationSubnetSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderNetworkConfigurationSubnetSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderNetworkConfigurationSubnetSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderNetworkConfigurationSubnetSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSubnetSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderNetworkConfigurationSubnetSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderOrderedPlacementStrategy {
    /// For the spread placement strategy, valid values are instanceId (or host,
    /// which has the same effect), or any platform or custom attribute that is applied to a container instance.
    /// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
    /// needed. For more information, see Placement Strategy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    /// Type of placement strategy. Must be one of: binpack, random, or spread
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderPlacementConstraints {
    /// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfiguration {
    /// Whether to use Service Connect with this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Log configuration for the container. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logConfiguration")]
    pub log_configuration: Option<ServiceInitProviderServiceConnectConfigurationLogConfiguration>,
    /// Namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// List of Service Connect service objects. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<Vec<ServiceInitProviderServiceConnectConfigurationService>>,
}

/// Log configuration for the container. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationLogConfiguration {
    /// Log driver to use for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logDriver")]
    pub log_driver: Option<String>,
    /// Configuration options to send to the log driver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<HashMap<String, String>>,
    /// Secrets to pass to the log configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretOption")]
    pub secret_option: Option<Vec<ServiceInitProviderServiceConnectConfigurationLogConfigurationSecretOption>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationLogConfigurationSecretOption {
    /// Name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationService {
    /// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientAlias")]
    pub client_alias: Option<ServiceInitProviderServiceConnectConfigurationServiceClientAlias>,
    /// Name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discoveryName")]
    pub discovery_name: Option<String>,
    /// Port number for the Service Connect proxy to listen on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPortOverride")]
    pub ingress_port_override: Option<f64>,
    /// Name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// Configuration timeouts for Service Connect
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<ServiceInitProviderServiceConnectConfigurationServiceTimeout>,
    /// Configuration for enabling Transport Layer Security (TLS)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ServiceInitProviderServiceConnectConfigurationServiceTls>,
}

/// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationServiceClientAlias {
    /// Name that you use in the applications of client tasks to connect to this service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

/// Configuration timeouts for Service Connect
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationServiceTimeout {
    /// Amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeoutSeconds")]
    pub idle_timeout_seconds: Option<f64>,
    /// Amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perRequestTimeoutSeconds")]
    pub per_request_timeout_seconds: Option<f64>,
}

/// Configuration for enabling Transport Layer Security (TLS)
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationServiceTls {
    /// Details of the certificate authority which will issue the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerCertAuthority")]
    pub issuer_cert_authority: Option<ServiceInitProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority>,
    /// KMS key used to encrypt the private key in Secrets Manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    pub kms_key: Option<String>,
    /// ARN of the IAM Role that's associated with the Service Connect TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Details of the certificate authority which will issue the certificate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority {
    /// ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsPcaAuthorityArn")]
    pub aws_pca_authority_arn: Option<String>,
}

/// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderServiceRegistries {
    /// Container name value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Port value used if your Service Discovery service specified an SRV record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
    /// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "registryArn")]
    pub registry_arn: Option<String>,
}

/// Reference to a TaskDefinition in ecs to populate taskDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderTaskDefinitionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderTaskDefinitionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderTaskDefinitionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderTaskDefinitionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderTaskDefinitionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderTaskDefinitionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderTaskDefinitionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TaskDefinition in ecs to populate taskDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderTaskDefinitionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceInitProviderTaskDefinitionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderTaskDefinitionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceInitProviderTaskDefinitionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceInitProviderTaskDefinitionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderTaskDefinitionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceInitProviderTaskDefinitionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderVolumeConfiguration {
    /// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedEbsVolume")]
    pub managed_ebs_volume: Option<ServiceInitProviderVolumeConfigurationManagedEbsVolume>,
    /// Name of the volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderVolumeConfigurationManagedEbsVolume {
    /// Whether the volume should be encrypted. Default value is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<bool>,
    /// Linux filesystem type for the volume. For volumes created from a snapshot, same filesystem type must be specified that the volume was using when the snapshot was created. Valid values are ext3, ext4, xfs. Default value is xfs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemType")]
    pub file_system_type: Option<String>,
    /// Number of I/O operations per second (IOPS).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<f64>,
    /// Amazon Resource Name (ARN) identifier of the Amazon Web Services Key Management Service key to use for Amazon EBS encryption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    pub kms_key_id: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Size of the volume in GiB. You must specify either a size_in_gb or a snapshot_id. You can optionally specify a volume size greater than or equal to the snapshot size.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeInGb")]
    pub size_in_gb: Option<f64>,
    /// Snapshot that Amazon ECS uses to create the volume. You must specify either a size_in_gb or a snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    pub snapshot_id: Option<String>,
    /// The tags to apply to the volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSpecifications")]
    pub tag_specifications: Option<Vec<ServiceInitProviderVolumeConfigurationManagedEbsVolumeTagSpecifications>>,
    /// Throughput to provision for a volume, in MiB/s, with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<f64>,
    /// Volume type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderVolumeConfigurationManagedEbsVolumeTagSpecifications {
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// The type of volume resource. Valid values, volume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceInitProviderVpcLatticeConfigurations {
    /// The name of the port for a target group associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The full ARN of the target group or groups associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServiceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServiceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServiceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ServicePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ServicePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ServicePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ServicePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ServicePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServicePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServicePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ServiceStatus defines the observed state of Service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<ServiceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProvider {
    /// Information about the CloudWatch alarms. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alarms: Option<ServiceStatusAtProviderAlarms>,
    /// ECS automatically redistributes tasks within a service across Availability Zones (AZs) to mitigate the risk of impaired application availability due to underlying infrastructure failures and task lifecycle activities. The valid values are ENABLED and DISABLED. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneRebalancing")]
    pub availability_zone_rebalancing: Option<String>,
    /// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProviderStrategy")]
    pub capacity_provider_strategy: Option<Vec<ServiceStatusAtProviderCapacityProviderStrategy>>,
    /// Name of an ECS cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// Configuration block for deployment circuit breaker. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentCircuitBreaker")]
    pub deployment_circuit_breaker: Option<ServiceStatusAtProviderDeploymentCircuitBreaker>,
    /// Configuration block for deployment controller configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentController")]
    pub deployment_controller: Option<ServiceStatusAtProviderDeploymentController>,
    /// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMaximumPercent")]
    pub deployment_maximum_percent: Option<f64>,
    /// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentMinimumHealthyPercent")]
    pub deployment_minimum_healthy_percent: Option<f64>,
    /// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredCount")]
    pub desired_count: Option<f64>,
    /// Whether to enable Amazon ECS managed tags for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableEcsManagedTags")]
    pub enable_ecs_managed_tags: Option<bool>,
    /// Whether to enable Amazon ECS Exec for the tasks within the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExecuteCommand")]
    pub enable_execute_command: Option<bool>,
    /// Enable to delete a service even if it wasn't scaled down to zero tasks. It's only necessary to use this if the service uses the REPLICA scheduling strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceDelete")]
    pub force_delete: Option<bool>,
    /// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceNewDeployment")]
    pub force_new_deployment: Option<bool>,
    /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckGracePeriodSeconds")]
    pub health_check_grace_period_seconds: Option<f64>,
    /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRole")]
    pub iam_role: Option<String>,
    /// ARN that identifies the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchType")]
    pub launch_type: Option<String>,
    /// Configuration block for load balancers. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<Vec<ServiceStatusAtProviderLoadBalancer>>,
    /// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfiguration")]
    pub network_configuration: Option<ServiceStatusAtProviderNetworkConfiguration>,
    /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedPlacementStrategy")]
    pub ordered_placement_strategy: Option<Vec<ServiceStatusAtProviderOrderedPlacementStrategy>>,
    /// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementConstraints")]
    pub placement_constraints: Option<Vec<ServiceStatusAtProviderPlacementConstraints>>,
    /// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformVersion")]
    pub platform_version: Option<String>,
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulingStrategy")]
    pub scheduling_strategy: Option<String>,
    /// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConnectConfiguration")]
    pub service_connect_configuration: Option<ServiceStatusAtProviderServiceConnectConfiguration>,
    /// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRegistries")]
    pub service_registries: Option<ServiceStatusAtProviderServiceRegistries>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
    /// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskDefinition")]
    pub task_definition: Option<String>,
    /// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<HashMap<String, String>>,
    /// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeConfiguration")]
    pub volume_configuration: Option<ServiceStatusAtProviderVolumeConfiguration>,
    /// The VPC Lattice configuration for your service that allows Lattice to connect, secure, and monitor your service across multiple accounts and VPCs. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcLatticeConfigurations")]
    pub vpc_lattice_configurations: Option<Vec<ServiceStatusAtProviderVpcLatticeConfigurations>>,
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForSteadyState")]
    pub wait_for_steady_state: Option<bool>,
}

/// Information about the CloudWatch alarms. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderAlarms {
    /// One or more CloudWatch alarm names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmNames")]
    pub alarm_names: Option<Vec<String>>,
    /// Whether to use the CloudWatch alarm option in the service deployment process.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderCapacityProviderStrategy {
    /// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base: Option<f64>,
    /// Short name of the capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityProvider")]
    pub capacity_provider: Option<String>,
    /// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<f64>,
}

/// Configuration block for deployment circuit breaker. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderDeploymentCircuitBreaker {
    /// Whether to enable the deployment circuit breaker logic for the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollback: Option<bool>,
}

/// Configuration block for deployment controller configuration. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderDeploymentController {
    /// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderLoadBalancer {
    /// Name of the container to associate with the load balancer (as it appears in a container definition).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port on the container to associate with the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Name of the ELB (Classic) to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elbName")]
    pub elb_name: Option<String>,
    /// ARN of the Load Balancer target group to associate with the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
}

/// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderNetworkConfiguration {
    /// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assignPublicIp")]
    pub assign_public_ip: Option<bool>,
    /// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// Subnets associated with the task or service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderOrderedPlacementStrategy {
    /// For the spread placement strategy, valid values are instanceId (or host,
    /// which has the same effect), or any platform or custom attribute that is applied to a container instance.
    /// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
    /// needed. For more information, see Placement Strategy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    /// Type of placement strategy. Must be one of: binpack, random, or spread
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderPlacementConstraints {
    /// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfiguration {
    /// Whether to use Service Connect with this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Log configuration for the container. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logConfiguration")]
    pub log_configuration: Option<ServiceStatusAtProviderServiceConnectConfigurationLogConfiguration>,
    /// Namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// List of Service Connect service objects. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<Vec<ServiceStatusAtProviderServiceConnectConfigurationService>>,
}

/// Log configuration for the container. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationLogConfiguration {
    /// Log driver to use for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logDriver")]
    pub log_driver: Option<String>,
    /// Configuration options to send to the log driver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<HashMap<String, String>>,
    /// Secrets to pass to the log configuration. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretOption")]
    pub secret_option: Option<Vec<ServiceStatusAtProviderServiceConnectConfigurationLogConfigurationSecretOption>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationLogConfigurationSecretOption {
    /// Name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationService {
    /// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientAlias")]
    pub client_alias: Option<ServiceStatusAtProviderServiceConnectConfigurationServiceClientAlias>,
    /// Name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discoveryName")]
    pub discovery_name: Option<String>,
    /// Port number for the Service Connect proxy to listen on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressPortOverride")]
    pub ingress_port_override: Option<f64>,
    /// Name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// Configuration timeouts for Service Connect
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<ServiceStatusAtProviderServiceConnectConfigurationServiceTimeout>,
    /// Configuration for enabling Transport Layer Security (TLS)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ServiceStatusAtProviderServiceConnectConfigurationServiceTls>,
}

/// List of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationServiceClientAlias {
    /// Name that you use in the applications of client tasks to connect to this service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

/// Configuration timeouts for Service Connect
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationServiceTimeout {
    /// Amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeoutSeconds")]
    pub idle_timeout_seconds: Option<f64>,
    /// Amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perRequestTimeoutSeconds")]
    pub per_request_timeout_seconds: Option<f64>,
}

/// Configuration for enabling Transport Layer Security (TLS)
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationServiceTls {
    /// Details of the certificate authority which will issue the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerCertAuthority")]
    pub issuer_cert_authority: Option<ServiceStatusAtProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority>,
    /// KMS key used to encrypt the private key in Secrets Manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    pub kms_key: Option<String>,
    /// ARN of the IAM Role that's associated with the Service Connect TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Details of the certificate authority which will issue the certificate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceConnectConfigurationServiceTlsIssuerCertAuthority {
    /// ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsPcaAuthorityArn")]
    pub aws_pca_authority_arn: Option<String>,
}

/// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderServiceRegistries {
    /// Container name value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Port value, already specified in the task definition, to be used for your service discovery service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<f64>,
    /// Port value used if your Service Discovery service specified an SRV record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
    /// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "registryArn")]
    pub registry_arn: Option<String>,
}

/// Configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderVolumeConfiguration {
    /// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedEbsVolume")]
    pub managed_ebs_volume: Option<ServiceStatusAtProviderVolumeConfigurationManagedEbsVolume>,
    /// Name of the volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. See below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderVolumeConfigurationManagedEbsVolume {
    /// Whether the volume should be encrypted. Default value is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<bool>,
    /// Linux filesystem type for the volume. For volumes created from a snapshot, same filesystem type must be specified that the volume was using when the snapshot was created. Valid values are ext3, ext4, xfs. Default value is xfs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemType")]
    pub file_system_type: Option<String>,
    /// Number of I/O operations per second (IOPS).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<f64>,
    /// Amazon Resource Name (ARN) identifier of the Amazon Web Services Key Management Service key to use for Amazon EBS encryption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    pub kms_key_id: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Size of the volume in GiB. You must specify either a size_in_gb or a snapshot_id. You can optionally specify a volume size greater than or equal to the snapshot size.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeInGb")]
    pub size_in_gb: Option<f64>,
    /// Snapshot that Amazon ECS uses to create the volume. You must specify either a size_in_gb or a snapshot_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    pub snapshot_id: Option<String>,
    /// The tags to apply to the volume. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSpecifications")]
    pub tag_specifications: Option<Vec<ServiceStatusAtProviderVolumeConfigurationManagedEbsVolumeTagSpecifications>>,
    /// Throughput to provision for a volume, in MiB/s, with a maximum of 1,000 MiB/s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<f64>,
    /// Volume type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderVolumeConfigurationManagedEbsVolumeTagSpecifications {
    /// Whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateTags")]
    pub propagate_tags: Option<String>,
    /// The type of volume resource. Valid values, volume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceType")]
    pub resource_type: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceStatusAtProviderVpcLatticeConfigurations {
    /// The name of the port for a target group associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The full ARN of the target group or groups associated with the VPC Lattice configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArn")]
    pub target_group_arn: Option<String>,
}

