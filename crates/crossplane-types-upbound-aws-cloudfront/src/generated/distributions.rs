// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// DistributionSpec defines the desired state of Distribution
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "cloudfront.aws.upbound.io", version = "v1beta2", kind = "Distribution", plural = "distributions")]
#[kube(status = "DistributionStatus")]
pub struct DistributionSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<DistributionDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: DistributionForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<DistributionInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<DistributionProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<DistributionPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<DistributionWriteConnectionSecretToRef>,
}

/// DistributionSpec defines the desired state of Distribution
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProvider {
    /// Extra CNAMEs (alternate domain names), if any, for this distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    /// Any comments you want to include about the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// Identifier of a continuous deployment policy. This argument should only be set on a production distribution. See the aws_cloudfront_continuous_deployment_policy resource for additional details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousDeploymentPolicyId")]
    pub continuous_deployment_policy_id: Option<String>,
    /// One or more custom error response elements (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customErrorResponse")]
    pub custom_error_response: Option<Vec<DistributionForProviderCustomErrorResponse>>,
    /// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultCacheBehavior")]
    pub default_cache_behavior: Option<DistributionForProviderDefaultCacheBehavior>,
    /// Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRootObject")]
    pub default_root_object: Option<String>,
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpVersion")]
    pub http_version: Option<String>,
    /// Whether the IPv6 is enabled for the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isIpv6Enabled")]
    pub is_ipv6_enabled: Option<bool>,
    /// The logging configuration that controls how logs are written to your distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<DistributionForProviderLoggingConfig>,
    /// Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedCacheBehavior")]
    pub ordered_cache_behavior: Option<Vec<DistributionForProviderOrderedCacheBehavior>>,
    /// One or more origins for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<Vec<DistributionForProviderOrigin>>,
    /// One or more origin_group for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originGroup")]
    pub origin_group: Option<Vec<DistributionForProviderOriginGroup>>,
    /// Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priceClass")]
    pub price_class: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The restriction configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<DistributionForProviderRestrictions>,
    /// If this is set, the distribution needs to be deleted manually afterwards. Default: false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainOnDelete")]
    pub retain_on_delete: Option<bool>,
    /// A Boolean that indicates whether this is a staging distribution. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub staging: Option<bool>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// The SSL configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerCertificate")]
    pub viewer_certificate: Option<DistributionForProviderViewerCertificate>,
    /// If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForDeployment")]
    pub wait_for_deployment: Option<bool>,
    /// Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webAclId")]
    pub web_acl_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderCustomErrorResponse {
    /// Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCachingMinTtl")]
    pub error_caching_min_ttl: Option<f64>,
    /// 4xx or 5xx HTTP status code that you want to customize.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCode")]
    pub error_code: Option<f64>,
    /// HTTP status code that you want CloudFront to return with the custom error page to the viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseCode")]
    pub response_code: Option<f64>,
    /// Path of the custom error page (for example, /custom_404.html).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responsePagePath")]
    pub response_page_path: Option<String>,
}

/// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderDefaultCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionForProviderDefaultCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionForProviderDefaultCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionForProviderDefaultCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderDefaultCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionForProviderDefaultCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderDefaultCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderDefaultCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderDefaultCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
}

/// The logging configuration that controls how logs are written to your distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderLoggingConfig {
    /// Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Whether to include cookies in access logs (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeCookies")]
    pub include_cookies: Option<bool>,
    /// Prefix to the access log filenames for this distribution, for example, myprefix/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionForProviderOrderedCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionForProviderOrderedCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPattern")]
    pub path_pattern: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionForProviderOrderedCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
    /// Reference to a Function in cloudfront to populate functionArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArnRef")]
    pub function_arn_ref: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef>,
    /// Selector for a Function in cloudfront to populate functionArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArnSelector")]
    pub function_arn_selector: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector>,
}

/// Reference to a Function in cloudfront to populate functionArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in cloudfront to populate functionArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArnRef")]
    pub lambda_arn_ref: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArnSelector")]
    pub lambda_arn_selector: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOrigin {
    /// Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionAttempts")]
    pub connection_attempts: Option<f64>,
    /// Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTimeout")]
    pub connection_timeout: Option<f64>,
    /// One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<Vec<DistributionForProviderOriginCustomHeader>>,
    /// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customOriginConfig")]
    pub custom_origin_config: Option<DistributionForProviderOriginCustomOriginConfig>,
    /// DNS domain name of either the S3 bucket, or web site of your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// Unique identifier of a CloudFront origin access control for this origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlId")]
    pub origin_access_control_id: Option<String>,
    /// Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlIdRef")]
    pub origin_access_control_id_ref: Option<DistributionForProviderOriginOriginAccessControlIdRef>,
    /// Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlIdSelector")]
    pub origin_access_control_id_selector: Option<DistributionForProviderOriginOriginAccessControlIdSelector>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
    /// Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originPath")]
    pub origin_path: Option<String>,
    /// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShield")]
    pub origin_shield: Option<DistributionForProviderOriginOriginShield>,
    /// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3OriginConfig")]
    pub s3_origin_config: Option<DistributionForProviderOriginS3OriginConfig>,
    /// The VPC origin configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginConfig")]
    pub vpc_origin_config: Option<DistributionForProviderOriginVpcOriginConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginCustomHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginCustomOriginConfig {
    /// HTTP port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<f64>,
    /// HTTPS port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<f64>,
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originProtocolPolicy")]
    pub origin_protocol_policy: Option<String>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originSslProtocols")]
    pub origin_ssl_protocols: Option<Vec<String>>,
}

/// Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginOriginAccessControlIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOriginOriginAccessControlIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginOriginAccessControlIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOriginOriginAccessControlIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOriginOriginAccessControlIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginOriginAccessControlIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginOriginAccessControlIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginOriginAccessControlIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOriginOriginAccessControlIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginOriginAccessControlIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOriginOriginAccessControlIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOriginOriginAccessControlIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginOriginAccessControlIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginOriginAccessControlIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginOriginShield {
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShieldRegion")]
    pub origin_shield_region: Option<String>,
}

/// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginS3OriginConfig {
    /// The CloudFront origin access identity to associate with the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentity")]
    pub origin_access_identity: Option<String>,
    /// Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentityRef")]
    pub origin_access_identity_ref: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRef>,
    /// Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentitySelector")]
    pub origin_access_identity_selector: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelector>,
}

/// Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The VPC origin configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginVpcOriginConfig {
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// The VPC origin ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginId")]
    pub vpc_origin_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginGroup {
    /// The failover criteria for when to failover to the secondary origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverCriteria")]
    pub failover_criteria: Option<DistributionForProviderOriginGroupFailoverCriteria>,
    /// Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Vec<DistributionForProviderOriginGroupMember>>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The failover criteria for when to failover to the secondary origin.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginGroupFailoverCriteria {
    /// List of HTTP status codes for the origin group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCodes")]
    pub status_codes: Option<Vec<f64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderOriginGroupMember {
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The restriction configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderRestrictions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoRestriction")]
    pub geo_restriction: Option<DistributionForProviderRestrictionsGeoRestriction>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderRestrictionsGeoRestriction {
    /// ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locations: Option<Vec<String>>,
    /// Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictionType")]
    pub restriction_type: Option<String>,
}

/// The SSL configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionForProviderViewerCertificate {
    /// ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acmCertificateArn")]
    pub acm_certificate_arn: Option<String>,
    /// true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudfrontDefaultCertificate")]
    pub cloudfront_default_certificate: Option<bool>,
    /// IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamCertificateId")]
    pub iam_certificate_id: Option<String>,
    /// Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under "Security policy." Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
    /// How you want CloudFront to serve HTTPS requests. One of vip, sni-only, or static-ip. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslSupportMethod")]
    pub ssl_support_method: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProvider {
    /// Extra CNAMEs (alternate domain names), if any, for this distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    /// Any comments you want to include about the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// Identifier of a continuous deployment policy. This argument should only be set on a production distribution. See the aws_cloudfront_continuous_deployment_policy resource for additional details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousDeploymentPolicyId")]
    pub continuous_deployment_policy_id: Option<String>,
    /// One or more custom error response elements (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customErrorResponse")]
    pub custom_error_response: Option<Vec<DistributionInitProviderCustomErrorResponse>>,
    /// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultCacheBehavior")]
    pub default_cache_behavior: Option<DistributionInitProviderDefaultCacheBehavior>,
    /// Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRootObject")]
    pub default_root_object: Option<String>,
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpVersion")]
    pub http_version: Option<String>,
    /// Whether the IPv6 is enabled for the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isIpv6Enabled")]
    pub is_ipv6_enabled: Option<bool>,
    /// The logging configuration that controls how logs are written to your distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<DistributionInitProviderLoggingConfig>,
    /// Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedCacheBehavior")]
    pub ordered_cache_behavior: Option<Vec<DistributionInitProviderOrderedCacheBehavior>>,
    /// One or more origins for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<Vec<DistributionInitProviderOrigin>>,
    /// One or more origin_group for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originGroup")]
    pub origin_group: Option<Vec<DistributionInitProviderOriginGroup>>,
    /// Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priceClass")]
    pub price_class: Option<String>,
    /// The restriction configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<DistributionInitProviderRestrictions>,
    /// If this is set, the distribution needs to be deleted manually afterwards. Default: false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainOnDelete")]
    pub retain_on_delete: Option<bool>,
    /// A Boolean that indicates whether this is a staging distribution. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub staging: Option<bool>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// The SSL configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerCertificate")]
    pub viewer_certificate: Option<DistributionInitProviderViewerCertificate>,
    /// If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForDeployment")]
    pub wait_for_deployment: Option<bool>,
    /// Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webAclId")]
    pub web_acl_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderCustomErrorResponse {
    /// Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCachingMinTtl")]
    pub error_caching_min_ttl: Option<f64>,
    /// 4xx or 5xx HTTP status code that you want to customize.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCode")]
    pub error_code: Option<f64>,
    /// HTTP status code that you want CloudFront to return with the custom error page to the viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseCode")]
    pub response_code: Option<f64>,
    /// Path of the custom error page (for example, /custom_404.html).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responsePagePath")]
    pub response_page_path: Option<String>,
}

/// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderDefaultCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionInitProviderDefaultCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionInitProviderDefaultCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionInitProviderDefaultCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderDefaultCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionInitProviderDefaultCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderDefaultCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderDefaultCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderDefaultCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
}

/// The logging configuration that controls how logs are written to your distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderLoggingConfig {
    /// Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Whether to include cookies in access logs (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeCookies")]
    pub include_cookies: Option<bool>,
    /// Prefix to the access log filenames for this distribution, for example, myprefix/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionInitProviderOrderedCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionInitProviderOrderedCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPattern")]
    pub path_pattern: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionInitProviderOrderedCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
    /// Reference to a Function in cloudfront to populate functionArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArnRef")]
    pub function_arn_ref: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef>,
    /// Selector for a Function in cloudfront to populate functionArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArnSelector")]
    pub function_arn_selector: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector>,
}

/// Reference to a Function in cloudfront to populate functionArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in cloudfront to populate functionArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
    /// Reference to a Function in lambda to populate lambdaArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArnRef")]
    pub lambda_arn_ref: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef>,
    /// Selector for a Function in lambda to populate lambdaArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArnSelector")]
    pub lambda_arn_selector: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector>,
}

/// Reference to a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate lambdaArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOrigin {
    /// Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionAttempts")]
    pub connection_attempts: Option<f64>,
    /// Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTimeout")]
    pub connection_timeout: Option<f64>,
    /// One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<Vec<DistributionInitProviderOriginCustomHeader>>,
    /// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customOriginConfig")]
    pub custom_origin_config: Option<DistributionInitProviderOriginCustomOriginConfig>,
    /// DNS domain name of either the S3 bucket, or web site of your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// Unique identifier of a CloudFront origin access control for this origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlId")]
    pub origin_access_control_id: Option<String>,
    /// Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlIdRef")]
    pub origin_access_control_id_ref: Option<DistributionInitProviderOriginOriginAccessControlIdRef>,
    /// Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlIdSelector")]
    pub origin_access_control_id_selector: Option<DistributionInitProviderOriginOriginAccessControlIdSelector>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
    /// Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originPath")]
    pub origin_path: Option<String>,
    /// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShield")]
    pub origin_shield: Option<DistributionInitProviderOriginOriginShield>,
    /// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3OriginConfig")]
    pub s3_origin_config: Option<DistributionInitProviderOriginS3OriginConfig>,
    /// The VPC origin configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginConfig")]
    pub vpc_origin_config: Option<DistributionInitProviderOriginVpcOriginConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginCustomHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginCustomOriginConfig {
    /// HTTP port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<f64>,
    /// HTTPS port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<f64>,
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originProtocolPolicy")]
    pub origin_protocol_policy: Option<String>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originSslProtocols")]
    pub origin_ssl_protocols: Option<Vec<String>>,
}

/// Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginOriginAccessControlIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOriginOriginAccessControlIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginOriginAccessControlIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOriginOriginAccessControlIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOriginOriginAccessControlIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginOriginAccessControlIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginOriginAccessControlIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginOriginAccessControlIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOriginOriginAccessControlIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginOriginAccessControlIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOriginOriginAccessControlIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOriginOriginAccessControlIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginOriginAccessControlIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginOriginAccessControlIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginOriginShield {
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShieldRegion")]
    pub origin_shield_region: Option<String>,
}

/// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginS3OriginConfig {
    /// The CloudFront origin access identity to associate with the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentity")]
    pub origin_access_identity: Option<String>,
    /// Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentityRef")]
    pub origin_access_identity_ref: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRef>,
    /// Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentitySelector")]
    pub origin_access_identity_selector: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelector>,
}

/// Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionInitProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The VPC origin configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginVpcOriginConfig {
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// The VPC origin ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginId")]
    pub vpc_origin_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginGroup {
    /// The failover criteria for when to failover to the secondary origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverCriteria")]
    pub failover_criteria: Option<DistributionInitProviderOriginGroupFailoverCriteria>,
    /// Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Vec<DistributionInitProviderOriginGroupMember>>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The failover criteria for when to failover to the secondary origin.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginGroupFailoverCriteria {
    /// List of HTTP status codes for the origin group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCodes")]
    pub status_codes: Option<Vec<f64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderOriginGroupMember {
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The restriction configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderRestrictions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoRestriction")]
    pub geo_restriction: Option<DistributionInitProviderRestrictionsGeoRestriction>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderRestrictionsGeoRestriction {
    /// ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locations: Option<Vec<String>>,
    /// Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictionType")]
    pub restriction_type: Option<String>,
}

/// The SSL configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionInitProviderViewerCertificate {
    /// ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acmCertificateArn")]
    pub acm_certificate_arn: Option<String>,
    /// true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudfrontDefaultCertificate")]
    pub cloudfront_default_certificate: Option<bool>,
    /// IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamCertificateId")]
    pub iam_certificate_id: Option<String>,
    /// Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under "Security policy." Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
    /// How you want CloudFront to serve HTTPS requests. One of vip, sni-only, or static-ip. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslSupportMethod")]
    pub ssl_support_method: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<DistributionPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<DistributionPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<DistributionPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<DistributionPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<DistributionPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DistributionPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// DistributionStatus defines the observed state of Distribution.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<DistributionStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProvider {
    /// Extra CNAMEs (alternate domain names), if any, for this distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    /// ARN for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your AWS account ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// Internal value used by CloudFront to allow future updates to the distribution configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "callerReference")]
    pub caller_reference: Option<String>,
    /// Any comments you want to include about the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// Identifier of a continuous deployment policy. This argument should only be set on a production distribution. See the aws_cloudfront_continuous_deployment_policy resource for additional details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continuousDeploymentPolicyId")]
    pub continuous_deployment_policy_id: Option<String>,
    /// One or more custom error response elements (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customErrorResponse")]
    pub custom_error_response: Option<Vec<DistributionStatusAtProviderCustomErrorResponse>>,
    /// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultCacheBehavior")]
    pub default_cache_behavior: Option<DistributionStatusAtProviderDefaultCacheBehavior>,
    /// Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRootObject")]
    pub default_root_object: Option<String>,
    /// DNS domain name of either the S3 bucket, or web site of your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// CloudFront Route 53 zone ID that can be used to route an Alias Resource Record Set to. This attribute is simply an alias for the zone ID Z2FDTNDATAQYW2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostedZoneId")]
    pub hosted_zone_id: Option<String>,
    /// Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpVersion")]
    pub http_version: Option<String>,
    /// Identifier for the distribution. For example: EDFDVBD632BHDS5.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Number of invalidation batches currently in progress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inProgressValidationBatches")]
    pub in_progress_validation_batches: Option<f64>,
    /// Whether the IPv6 is enabled for the distribution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isIpv6Enabled")]
    pub is_ipv6_enabled: Option<bool>,
    /// Date and time the distribution was last modified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastModifiedTime")]
    pub last_modified_time: Option<String>,
    /// The logging configuration that controls how logs are written to your distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingConfig")]
    pub logging_config: Option<DistributionStatusAtProviderLoggingConfig>,
    /// Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderedCacheBehavior")]
    pub ordered_cache_behavior: Option<Vec<DistributionStatusAtProviderOrderedCacheBehavior>>,
    /// One or more origins for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<Vec<DistributionStatusAtProviderOrigin>>,
    /// One or more origin_group for this distribution (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originGroup")]
    pub origin_group: Option<Vec<DistributionStatusAtProviderOriginGroup>>,
    /// Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priceClass")]
    pub price_class: Option<String>,
    /// The restriction configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<DistributionStatusAtProviderRestrictions>,
    /// If this is set, the distribution needs to be deleted manually afterwards. Default: false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainOnDelete")]
    pub retain_on_delete: Option<bool>,
    /// A Boolean that indicates whether this is a staging distribution. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub staging: Option<bool>,
    /// Current status of the distribution. Deployed if the distribution's information is fully propagated throughout the Amazon CloudFront system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<DistributionStatusAtProviderTrustedKeyGroups>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<DistributionStatusAtProviderTrustedSigners>>,
    /// The SSL configuration for this distribution (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerCertificate")]
    pub viewer_certificate: Option<DistributionStatusAtProviderViewerCertificate>,
    /// If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForDeployment")]
    pub wait_for_deployment: Option<bool>,
    /// Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webAclId")]
    pub web_acl_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderCustomErrorResponse {
    /// Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCachingMinTtl")]
    pub error_caching_min_ttl: Option<f64>,
    /// 4xx or 5xx HTTP status code that you want to customize.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorCode")]
    pub error_code: Option<f64>,
    /// HTTP status code that you want CloudFront to return with the custom error page to the viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseCode")]
    pub response_code: Option<f64>,
    /// Path of the custom error page (for example, /custom_404.html).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responsePagePath")]
    pub response_page_path: Option<String>,
}

/// Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderDefaultCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionStatusAtProviderDefaultCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionStatusAtProviderDefaultCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionStatusAtProviderDefaultCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderDefaultCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionStatusAtProviderDefaultCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderDefaultCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderDefaultCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderDefaultCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
}

/// The logging configuration that controls how logs are written to your distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderLoggingConfig {
    /// Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Whether to include cookies in access logs (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeCookies")]
    pub include_cookies: Option<bool>,
    /// Prefix to the access log filenames for this distribution, for example, myprefix/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrderedCacheBehavior {
    /// Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedMethods")]
    pub allowed_methods: Option<Vec<String>>,
    /// Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachePolicyId")]
    pub cache_policy_id: Option<String>,
    /// Controls whether CloudFront caches the response to requests using the specified HTTP methods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachedMethods")]
    pub cached_methods: Option<Vec<String>>,
    /// Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTtl")]
    pub default_ttl: Option<f64>,
    /// Field level encryption configuration ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldLevelEncryptionId")]
    pub field_level_encryption_id: Option<String>,
    /// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardedValues")]
    pub forwarded_values: Option<DistributionStatusAtProviderOrderedCacheBehaviorForwardedValues>,
    /// A config block that triggers a cloudfront function with specific actions (maximum 2).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionAssociation")]
    pub function_association: Option<Vec<DistributionStatusAtProviderOrderedCacheBehaviorFunctionAssociation>>,
    /// A config block that triggers a lambda function with specific actions (maximum 4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFunctionAssociation")]
    pub lambda_function_association: Option<Vec<DistributionStatusAtProviderOrderedCacheBehaviorLambdaFunctionAssociation>>,
    /// Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTtl")]
    pub max_ttl: Option<f64>,
    /// Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minTtl")]
    pub min_ttl: Option<f64>,
    /// Unique identifier of the origin request policy that is attached to the behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originRequestPolicyId")]
    pub origin_request_policy_id: Option<String>,
    /// Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPattern")]
    pub path_pattern: Option<String>,
    /// ARN of the real-time log configuration that is attached to this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "realtimeLogConfigArn")]
    pub realtime_log_config_arn: Option<String>,
    /// Identifier for a response headers policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicyId")]
    pub response_headers_policy_id: Option<String>,
    /// Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "smoothStreaming")]
    pub smooth_streaming: Option<bool>,
    /// Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetOriginId")]
    pub target_origin_id: Option<String>,
    /// List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedKeyGroups")]
    pub trusted_key_groups: Option<Vec<String>>,
    /// List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedSigners")]
    pub trusted_signers: Option<Vec<String>>,
    /// Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "viewerProtocolPolicy")]
    pub viewer_protocol_policy: Option<String>,
}

/// The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrderedCacheBehaviorForwardedValues {
    /// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookies: Option<DistributionStatusAtProviderOrderedCacheBehaviorForwardedValuesCookies>,
    /// Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<bool>,
    /// When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryStringCacheKeys")]
    pub query_string_cache_keys: Option<Vec<String>>,
}

/// The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrderedCacheBehaviorForwardedValuesCookies {
    /// Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<String>,
    /// If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whitelistedNames")]
    pub whitelisted_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrderedCacheBehaviorFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// ARN of the CloudFront function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrderedCacheBehaviorLambdaFunctionAssociation {
    /// Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    /// When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBody")]
    pub include_body: Option<bool>,
    /// ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    pub lambda_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOrigin {
    /// Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionAttempts")]
    pub connection_attempts: Option<f64>,
    /// Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionTimeout")]
    pub connection_timeout: Option<f64>,
    /// One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<Vec<DistributionStatusAtProviderOriginCustomHeader>>,
    /// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customOriginConfig")]
    pub custom_origin_config: Option<DistributionStatusAtProviderOriginCustomOriginConfig>,
    /// DNS domain name of either the S3 bucket, or web site of your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// Unique identifier of a CloudFront origin access control for this origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessControlId")]
    pub origin_access_control_id: Option<String>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
    /// Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originPath")]
    pub origin_path: Option<String>,
    /// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShield")]
    pub origin_shield: Option<DistributionStatusAtProviderOriginOriginShield>,
    /// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3OriginConfig")]
    pub s3_origin_config: Option<DistributionStatusAtProviderOriginS3OriginConfig>,
    /// The VPC origin configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginConfig")]
    pub vpc_origin_config: Option<DistributionStatusAtProviderOriginVpcOriginConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginCustomHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginCustomOriginConfig {
    /// HTTP port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<f64>,
    /// HTTPS port the custom origin listens on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<f64>,
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originProtocolPolicy")]
    pub origin_protocol_policy: Option<String>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originSslProtocols")]
    pub origin_ssl_protocols: Option<Vec<String>>,
}

/// CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginOriginShield {
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originShieldRegion")]
    pub origin_shield_region: Option<String>,
}

/// CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginS3OriginConfig {
    /// The CloudFront origin access identity to associate with the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originAccessIdentity")]
    pub origin_access_identity: Option<String>,
}

/// The VPC origin configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginVpcOriginConfig {
    /// The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originKeepaliveTimeout")]
    pub origin_keepalive_timeout: Option<f64>,
    /// The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originReadTimeout")]
    pub origin_read_timeout: Option<f64>,
    /// The VPC origin ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcOriginId")]
    pub vpc_origin_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginGroup {
    /// The failover criteria for when to failover to the secondary origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverCriteria")]
    pub failover_criteria: Option<DistributionStatusAtProviderOriginGroupFailoverCriteria>,
    /// Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub member: Option<Vec<DistributionStatusAtProviderOriginGroupMember>>,
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The failover criteria for when to failover to the secondary origin.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginGroupFailoverCriteria {
    /// List of HTTP status codes for the origin group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCodes")]
    pub status_codes: Option<Vec<f64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderOriginGroupMember {
    /// Unique identifier for the origin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originId")]
    pub origin_id: Option<String>,
}

/// The restriction configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderRestrictions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoRestriction")]
    pub geo_restriction: Option<DistributionStatusAtProviderRestrictionsGeoRestriction>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderRestrictionsGeoRestriction {
    /// ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locations: Option<Vec<String>>,
    /// Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restrictionType")]
    pub restriction_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderTrustedKeyGroups {
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// List of nested attributes for each key group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<DistributionStatusAtProviderTrustedKeyGroupsItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderTrustedKeyGroupsItems {
    /// ID of the key group that contains the public keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGroupId")]
    pub key_group_id: Option<String>,
    /// Set of CloudFront key pair IDs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPairIds")]
    pub key_pair_ids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderTrustedSigners {
    /// Whether the distribution is enabled to accept end user requests for content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// List of nested attributes for each key group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<DistributionStatusAtProviderTrustedSignersItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderTrustedSignersItems {
    /// AWS account ID or self
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsAccountNumber")]
    pub aws_account_number: Option<String>,
    /// Set of CloudFront key pair IDs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPairIds")]
    pub key_pair_ids: Option<Vec<String>>,
}

/// The SSL configuration for this distribution (maximum one).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DistributionStatusAtProviderViewerCertificate {
    /// ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acmCertificateArn")]
    pub acm_certificate_arn: Option<String>,
    /// true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudfrontDefaultCertificate")]
    pub cloudfront_default_certificate: Option<bool>,
    /// IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamCertificateId")]
    pub iam_certificate_id: Option<String>,
    /// Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under "Security policy." Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
    /// How you want CloudFront to serve HTTPS requests. One of vip, sni-only, or static-ip. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslSupportMethod")]
    pub ssl_support_method: Option<String>,
}

