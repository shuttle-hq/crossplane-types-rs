// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
}
use self::prelude::*;

/// ApplicationSpec defines the desired state of Application
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(
    group = "kinesisanalyticsv2.aws.upbound.io",
    version = "v1beta2",
    kind = "Application",
    plural = "applications"
)]
#[kube(status = "ApplicationStatus")]
pub struct ApplicationSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    pub deletion_policy: Option<ApplicationDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ApplicationForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    pub init_provider: Option<ApplicationInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    pub provider_config_ref: Option<ApplicationProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    pub publish_connection_details_to: Option<ApplicationPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    pub write_connection_secret_to_ref: Option<ApplicationWriteConnectionSecretToRef>,
}

/// ApplicationSpec defines the desired state of Application
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProvider {
    /// The application's configuration
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationConfiguration"
    )]
    pub application_configuration: Option<ApplicationForProviderApplicationConfiguration>,
    /// The application's mode. Valid values are STREAMING, INTERACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationMode"
    )]
    pub application_mode: Option<String>,
    /// A CloudWatch log stream to monitor application configuration errors.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLoggingOptions"
    )]
    pub cloudwatch_logging_options: Option<ApplicationForProviderCloudwatchLoggingOptions>,
    /// A summary description of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether to force stop an unresponsive Flink-based application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceStop")]
    pub force_stop: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The runtime environment for the application. Valid values: SQL-1_0, FLINK-1_6, FLINK-1_8, FLINK-1_11, FLINK-1_13, FLINK-1_15, FLINK-1_18, FLINK-1_19.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runtimeEnvironment"
    )]
    pub runtime_environment: Option<String>,
    /// The ARN of the IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRole"
    )]
    pub service_execution_role: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleRef"
    )]
    pub service_execution_role_ref: Option<ApplicationForProviderServiceExecutionRoleRef>,
    /// Selector for a Role in iam to populate serviceExecutionRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleSelector"
    )]
    pub service_execution_role_selector: Option<ApplicationForProviderServiceExecutionRoleSelector>,
    /// Whether to start or stop the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startApplication"
    )]
    pub start_application: Option<bool>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The application's configuration
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfiguration {
    /// The code location and type parameters for the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationCodeConfiguration"
    )]
    pub application_code_configuration:
        Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfiguration>,
    /// Describes whether snapshots are enabled for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationSnapshotConfiguration"
    )]
    pub application_snapshot_configuration:
        Option<ApplicationForProviderApplicationConfigurationApplicationSnapshotConfiguration>,
    /// Describes execution properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "environmentProperties"
    )]
    pub environment_properties:
        Option<ApplicationForProviderApplicationConfigurationEnvironmentProperties>,
    /// The configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flinkApplicationConfiguration"
    )]
    pub flink_application_configuration:
        Option<ApplicationForProviderApplicationConfigurationFlinkApplicationConfiguration>,
    /// Describes the starting properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runConfiguration"
    )]
    pub run_configuration: Option<ApplicationForProviderApplicationConfigurationRunConfiguration>,
    /// The configuration of a SQL-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqlApplicationConfiguration"
    )]
    pub sql_application_configuration:
        Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfiguration>,
    /// The VPC configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConfiguration"
    )]
    pub vpc_configuration: Option<ApplicationForProviderApplicationConfigurationVpcConfiguration>,
}

/// The code location and type parameters for the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfiguration {
    /// The location and type of the application code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContent"
    )]
    pub code_content: Option<
        ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent,
    >,
    /// Specifies whether the code content is in text or zip format. Valid values: PLAINTEXT, ZIPFILE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContentType"
    )]
    pub code_content_type: Option<String>,
}

/// The location and type of the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent {
    /// Information about the Amazon S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ContentLocation")]
    pub s3_content_location: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation>,
    /// The text-format code for the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "textContent")]
    pub text_content: Option<String>,
}

/// Information about the Amazon S3 bucket containing the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnRef")]
    pub bucket_arn_ref: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef>,
    /// Selector for a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnSelector")]
    pub bucket_arn_selector: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
    /// Reference to a Object in s3 to populate fileKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKeyRef")]
    pub file_key_ref: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef>,
    /// Selector for a Object in s3 to populate fileKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKeySelector")]
    pub file_key_selector: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector>,
    /// The version of the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectVersion")]
    pub object_version: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Reference to a Object in s3 to populate fileKey.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Object in s3 to populate fileKey.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Describes whether snapshots are enabled for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationApplicationSnapshotConfiguration {
    /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotsEnabled"
    )]
    pub snapshots_enabled: Option<bool>,
}

/// Describes execution properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationEnvironmentProperties {
    /// Describes the execution property groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroup"
    )]
    pub property_group: Option<
        Vec<ApplicationForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup {
    /// The key of the application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroupId"
    )]
    pub property_group_id: Option<String>,
    /// Application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyMap"
    )]
    pub property_map: Option<HashMap<String, String>>,
}

/// The configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationFlinkApplicationConfiguration {
    /// Describes an application's checkpointing configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "checkpointConfiguration")]
    pub checkpoint_configuration: Option<ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration>,
    /// Describes configuration parameters for CloudWatch logging for an application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfiguration")]
    pub monitoring_configuration: Option<ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration>,
    /// Describes parameters for how an application executes multiple tasks simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parallelismConfiguration")]
    pub parallelism_configuration: Option<ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration>,
}

/// Describes an application's checkpointing configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
{
    /// Describes the interval in milliseconds between checkpoint operations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointInterval"
    )]
    pub checkpoint_interval: Option<f64>,
    /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointingEnabled"
    )]
    pub checkpointing_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minPauseBetweenCheckpoints"
    )]
    pub min_pause_between_checkpoints: Option<f64>,
}

/// Describes configuration parameters for CloudWatch logging for an application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
{
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the verbosity of the CloudWatch Logs for an application. Valid values: DEBUG, ERROR, INFO, WARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Describes the granularity of the CloudWatch Logs for an application. Valid values: APPLICATION, OPERATOR, PARALLELISM, TASK.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metricsLevel"
    )]
    pub metrics_level: Option<String>,
}

/// Describes parameters for how an application executes multiple tasks simultaneously.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
{
    /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoScalingEnabled"
    )]
    pub auto_scaling_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallelism: Option<f64>,
    /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parallelismPerKpu"
    )]
    pub parallelism_per_kpu: Option<f64>,
}

/// Describes the starting properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationRunConfiguration {
    /// The restore behavior of a restarting application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationRestoreConfiguration")]
    pub application_restore_configuration: Option<ApplicationForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration>,
    /// The starting parameters for a Flink-based Kinesis Data Analytics application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flinkRunConfiguration")]
    pub flink_run_configuration: Option<ApplicationForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration>,
}

/// The restore behavior of a restarting application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
{
    /// Specifies how the application should be restored. Valid values: RESTORE_FROM_CUSTOM_SNAPSHOT, RESTORE_FROM_LATEST_SNAPSHOT, SKIP_RESTORE_FROM_SNAPSHOT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationRestoreType"
    )]
    pub application_restore_type: Option<String>,
    /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for application_restore_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    pub snapshot_name: Option<String>,
}

/// The starting parameters for a Flink-based Kinesis Data Analytics application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration {
    /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowNonRestoredState"
    )]
    pub allow_non_restored_state: Option<bool>,
}

/// The configuration of a SQL-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfiguration {
    /// The input stream used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInput>,
    /// The destination streams used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<Vec<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutput>>,
    /// The reference data source used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceDataSource")]
    pub reference_data_source: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource>,
}

/// The input stream used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInput {
    /// Describes the number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputParallelism")]
    pub input_parallelism: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism>,
    /// The input processing configuration for the input.
    /// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputProcessingConfiguration")]
    pub input_processing_configuration: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration>,
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputSchema")]
    pub input_schema: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema>,
    /// The point at which the application starts processing records from the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputStartingPositionConfiguration")]
    pub input_starting_position_configuration: Option<Vec<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration>>,
    /// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseInput")]
    pub kinesis_firehose_input: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput>,
    /// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsInput")]
    pub kinesis_streams_input: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput>,
    /// The name prefix to use when creating an in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    pub name_prefix: Option<String>,
}

/// Describes the number of in-application streams to create.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
{
    /// The number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// The input processing configuration for the input.
/// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
    /// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputLambdaProcessor")]
    pub input_lambda_processor: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor>,
}

/// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration
{
    /// The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputStartingPosition"
    )]
    pub input_starting_position: Option<String>,
}

/// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a Stream in kinesis to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef>,
    /// Selector for a Stream in kinesis to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector>,
}

/// Reference to a Stream in kinesis to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Stream in kinesis to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutput {
    /// Describes the data format when records are written to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationSchema")]
    pub destination_schema: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema>,
    /// Identifies a Kinesis Data Firehose delivery stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseOutput")]
    pub kinesis_firehose_output: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput>,
    /// Identifies a Kinesis data stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsOutput")]
    pub kinesis_streams_output: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput>,
    /// Identifies a Lambda function as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaOutput")]
    pub lambda_output: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Describes the data format when records are written to the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
{
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordFormatType"
    )]
    pub record_format_type: Option<String>,
}

/// Identifies a Kinesis Data Firehose delivery stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef>,
    /// Selector for a DeliveryStream in firehose to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector>,
}

/// Reference to a DeliveryStream in firehose to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Identifies a Kinesis data stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Identifies a Lambda function as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a Function in lambda to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef>,
    /// Selector for a Function in lambda to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector>,
}

/// Reference to a Function in lambda to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// The reference data source used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceSchema")]
    pub reference_schema: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema>,
    /// Identifies the S3 bucket and object that contains the reference data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ReferenceDataSource")]
    pub s3_reference_data_source: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource>,
    /// The name of the in-application table to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

/// Identifies the S3 bucket and object that contains the reference data.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnRef")]
    pub bucket_arn_ref: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef>,
    /// Selector for a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnSelector")]
    pub bucket_arn_selector: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// The VPC configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfiguration {
    /// The Security Group IDs used by the VPC configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    pub security_group_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdsRefs"
    )]
    pub security_group_ids_refs: Option<
        Vec<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefs>,
    >,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdsSelector"
    )]
    pub security_group_ids_selector: Option<
        ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelector,
    >,
    /// The Subnet IDs used by the VPC configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsRefs"
    )]
    pub subnet_ids_refs:
        Option<Vec<ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsSelector"
    )]
    pub subnet_ids_selector:
        Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<
        ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicy,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy:
        Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<
        ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<
        ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<
        ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A CloudWatch log stream to monitor application configuration errors.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderCloudwatchLoggingOptions {
    /// The ARN of the CloudWatch log stream to receive application messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArn"
    )]
    pub log_stream_arn: Option<String>,
    /// Reference to a Stream in cloudwatchlogs to populate logStreamArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArnRef"
    )]
    pub log_stream_arn_ref: Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRef>,
    /// Selector for a Stream in cloudwatchlogs to populate logStreamArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArnSelector"
    )]
    pub log_stream_arn_selector:
        Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelector>,
}

/// Reference to a Stream in cloudwatchlogs to populate logStreamArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution:
        Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Stream in cloudwatchlogs to populate logStreamArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution:
        Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve:
        Option<ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceExecutionRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderServiceExecutionRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderServiceExecutionRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderServiceExecutionRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderServiceExecutionRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderServiceExecutionRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderServiceExecutionRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderServiceExecutionRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderServiceExecutionRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationForProviderServiceExecutionRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationForProviderServiceExecutionRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationForProviderServiceExecutionRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationForProviderServiceExecutionRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderServiceExecutionRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationForProviderServiceExecutionRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProvider {
    /// The application's configuration
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationConfiguration"
    )]
    pub application_configuration: Option<ApplicationInitProviderApplicationConfiguration>,
    /// The application's mode. Valid values are STREAMING, INTERACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationMode"
    )]
    pub application_mode: Option<String>,
    /// A CloudWatch log stream to monitor application configuration errors.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLoggingOptions"
    )]
    pub cloudwatch_logging_options: Option<ApplicationInitProviderCloudwatchLoggingOptions>,
    /// A summary description of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether to force stop an unresponsive Flink-based application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceStop")]
    pub force_stop: Option<bool>,
    /// The runtime environment for the application. Valid values: SQL-1_0, FLINK-1_6, FLINK-1_8, FLINK-1_11, FLINK-1_13, FLINK-1_15, FLINK-1_18, FLINK-1_19.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runtimeEnvironment"
    )]
    pub runtime_environment: Option<String>,
    /// The ARN of the IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRole"
    )]
    pub service_execution_role: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleRef"
    )]
    pub service_execution_role_ref: Option<ApplicationInitProviderServiceExecutionRoleRef>,
    /// Selector for a Role in iam to populate serviceExecutionRole.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRoleSelector"
    )]
    pub service_execution_role_selector:
        Option<ApplicationInitProviderServiceExecutionRoleSelector>,
    /// Whether to start or stop the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startApplication"
    )]
    pub start_application: Option<bool>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The application's configuration
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfiguration {
    /// The code location and type parameters for the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationCodeConfiguration"
    )]
    pub application_code_configuration:
        Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfiguration>,
    /// Describes whether snapshots are enabled for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationSnapshotConfiguration"
    )]
    pub application_snapshot_configuration:
        Option<ApplicationInitProviderApplicationConfigurationApplicationSnapshotConfiguration>,
    /// Describes execution properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "environmentProperties"
    )]
    pub environment_properties:
        Option<ApplicationInitProviderApplicationConfigurationEnvironmentProperties>,
    /// The configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flinkApplicationConfiguration"
    )]
    pub flink_application_configuration:
        Option<ApplicationInitProviderApplicationConfigurationFlinkApplicationConfiguration>,
    /// Describes the starting properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runConfiguration"
    )]
    pub run_configuration: Option<ApplicationInitProviderApplicationConfigurationRunConfiguration>,
    /// The configuration of a SQL-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqlApplicationConfiguration"
    )]
    pub sql_application_configuration:
        Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfiguration>,
    /// The VPC configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConfiguration"
    )]
    pub vpc_configuration: Option<ApplicationInitProviderApplicationConfigurationVpcConfiguration>,
}

/// The code location and type parameters for the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfiguration {
    /// The location and type of the application code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContent"
    )]
    pub code_content: Option<
        ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent,
    >,
    /// Specifies whether the code content is in text or zip format. Valid values: PLAINTEXT, ZIPFILE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContentType"
    )]
    pub code_content_type: Option<String>,
}

/// The location and type of the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent {
    /// Information about the Amazon S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ContentLocation")]
    pub s3_content_location: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation>,
    /// The text-format code for the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "textContent")]
    pub text_content: Option<String>,
}

/// Information about the Amazon S3 bucket containing the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnRef")]
    pub bucket_arn_ref: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef>,
    /// Selector for a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnSelector")]
    pub bucket_arn_selector: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
    /// Reference to a Object in s3 to populate fileKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKeyRef")]
    pub file_key_ref: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef>,
    /// Selector for a Object in s3 to populate fileKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKeySelector")]
    pub file_key_selector: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector>,
    /// The version of the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectVersion")]
    pub object_version: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Reference to a Object in s3 to populate fileKey.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Object in s3 to populate fileKey.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Describes whether snapshots are enabled for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationApplicationSnapshotConfiguration {
    /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotsEnabled"
    )]
    pub snapshots_enabled: Option<bool>,
}

/// Describes execution properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationEnvironmentProperties {
    /// Describes the execution property groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroup"
    )]
    pub property_group: Option<
        Vec<ApplicationInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup {
    /// The key of the application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroupId"
    )]
    pub property_group_id: Option<String>,
    /// Application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyMap"
    )]
    pub property_map: Option<HashMap<String, String>>,
}

/// The configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationFlinkApplicationConfiguration {
    /// Describes an application's checkpointing configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "checkpointConfiguration")]
    pub checkpoint_configuration: Option<ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration>,
    /// Describes configuration parameters for CloudWatch logging for an application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfiguration")]
    pub monitoring_configuration: Option<ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration>,
    /// Describes parameters for how an application executes multiple tasks simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parallelismConfiguration")]
    pub parallelism_configuration: Option<ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration>,
}

/// Describes an application's checkpointing configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
{
    /// Describes the interval in milliseconds between checkpoint operations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointInterval"
    )]
    pub checkpoint_interval: Option<f64>,
    /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointingEnabled"
    )]
    pub checkpointing_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minPauseBetweenCheckpoints"
    )]
    pub min_pause_between_checkpoints: Option<f64>,
}

/// Describes configuration parameters for CloudWatch logging for an application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
{
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the verbosity of the CloudWatch Logs for an application. Valid values: DEBUG, ERROR, INFO, WARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Describes the granularity of the CloudWatch Logs for an application. Valid values: APPLICATION, OPERATOR, PARALLELISM, TASK.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metricsLevel"
    )]
    pub metrics_level: Option<String>,
}

/// Describes parameters for how an application executes multiple tasks simultaneously.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
{
    /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoScalingEnabled"
    )]
    pub auto_scaling_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallelism: Option<f64>,
    /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parallelismPerKpu"
    )]
    pub parallelism_per_kpu: Option<f64>,
}

/// Describes the starting properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationRunConfiguration {
    /// The restore behavior of a restarting application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationRestoreConfiguration")]
    pub application_restore_configuration: Option<ApplicationInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration>,
    /// The starting parameters for a Flink-based Kinesis Data Analytics application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flinkRunConfiguration")]
    pub flink_run_configuration: Option<ApplicationInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration>,
}

/// The restore behavior of a restarting application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
{
    /// Specifies how the application should be restored. Valid values: RESTORE_FROM_CUSTOM_SNAPSHOT, RESTORE_FROM_LATEST_SNAPSHOT, SKIP_RESTORE_FROM_SNAPSHOT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationRestoreType"
    )]
    pub application_restore_type: Option<String>,
    /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for application_restore_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    pub snapshot_name: Option<String>,
}

/// The starting parameters for a Flink-based Kinesis Data Analytics application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration {
    /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowNonRestoredState"
    )]
    pub allow_non_restored_state: Option<bool>,
}

/// The configuration of a SQL-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfiguration {
    /// The input stream used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInput>,
    /// The destination streams used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<Vec<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutput>>,
    /// The reference data source used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceDataSource")]
    pub reference_data_source: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource>,
}

/// The input stream used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInput {
    /// Describes the number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputParallelism")]
    pub input_parallelism: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism>,
    /// The input processing configuration for the input.
    /// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputProcessingConfiguration")]
    pub input_processing_configuration: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration>,
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputSchema")]
    pub input_schema: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema>,
    /// The point at which the application starts processing records from the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputStartingPositionConfiguration")]
    pub input_starting_position_configuration: Option<Vec<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration>>,
    /// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseInput")]
    pub kinesis_firehose_input: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput>,
    /// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsInput")]
    pub kinesis_streams_input: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput>,
    /// The name prefix to use when creating an in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    pub name_prefix: Option<String>,
}

/// Describes the number of in-application streams to create.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
{
    /// The number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// The input processing configuration for the input.
/// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
    /// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputLambdaProcessor")]
    pub input_lambda_processor: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor>,
}

/// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration
{
    /// The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputStartingPosition"
    )]
    pub input_starting_position: Option<String>,
}

/// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a Stream in kinesis to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef>,
    /// Selector for a Stream in kinesis to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector>,
}

/// Reference to a Stream in kinesis to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Stream in kinesis to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutput {
    /// Describes the data format when records are written to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationSchema")]
    pub destination_schema: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema>,
    /// Identifies a Kinesis Data Firehose delivery stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseOutput")]
    pub kinesis_firehose_output: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput>,
    /// Identifies a Kinesis data stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsOutput")]
    pub kinesis_streams_output: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput>,
    /// Identifies a Lambda function as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaOutput")]
    pub lambda_output: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Describes the data format when records are written to the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
{
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordFormatType"
    )]
    pub record_format_type: Option<String>,
}

/// Identifies a Kinesis Data Firehose delivery stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef>,
    /// Selector for a DeliveryStream in firehose to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector>,
}

/// Reference to a DeliveryStream in firehose to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Identifies a Kinesis data stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Identifies a Lambda function as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput {
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArn")]
    pub resource_arn: Option<String>,
    /// Reference to a Function in lambda to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnRef")]
    pub resource_arn_ref: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef>,
    /// Selector for a Function in lambda to populate resourceArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceArnSelector")]
    pub resource_arn_selector: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector>,
}

/// Reference to a Function in lambda to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Function in lambda to populate resourceArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// The reference data source used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceSchema")]
    pub reference_schema: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema>,
    /// Identifies the S3 bucket and object that contains the reference data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ReferenceDataSource")]
    pub s3_reference_data_source: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource>,
    /// The name of the in-application table to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

/// Identifies the S3 bucket and object that contains the reference data.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnRef")]
    pub bucket_arn_ref: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef>,
    /// Selector for a Bucket in s3 to populate bucketArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArnSelector")]
    pub bucket_arn_selector: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// The VPC configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfiguration {
    /// The Security Group IDs used by the VPC configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    pub security_group_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdsRefs"
    )]
    pub security_group_ids_refs: Option<
        Vec<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefs>,
    >,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIdsSelector"
    )]
    pub security_group_ids_selector: Option<
        ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelector,
    >,
    /// The Subnet IDs used by the VPC configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsRefs"
    )]
    pub subnet_ids_refs:
        Option<Vec<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subnetIdsSelector"
    )]
    pub subnet_ids_selector:
        Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<
        ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicy,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsRefsPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSecurityGroupIdsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy:
        Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<
        ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderApplicationConfigurationVpcConfigurationSubnetIdsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A CloudWatch log stream to monitor application configuration errors.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderCloudwatchLoggingOptions {
    /// The ARN of the CloudWatch log stream to receive application messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArn"
    )]
    pub log_stream_arn: Option<String>,
    /// Reference to a Stream in cloudwatchlogs to populate logStreamArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArnRef"
    )]
    pub log_stream_arn_ref: Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRef>,
    /// Selector for a Stream in cloudwatchlogs to populate logStreamArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArnSelector"
    )]
    pub log_stream_arn_selector:
        Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelector>,
}

/// Reference to a Stream in cloudwatchlogs to populate logStreamArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution:
        Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve:
        Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Stream in cloudwatchlogs to populate logStreamArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution:
        Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve:
        Option<ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceExecutionRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderServiceExecutionRoleRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderServiceExecutionRoleRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderServiceExecutionRoleRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderServiceExecutionRoleRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderServiceExecutionRoleRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderServiceExecutionRoleRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderServiceExecutionRoleRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRole.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderServiceExecutionRoleSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationInitProviderServiceExecutionRoleSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationInitProviderServiceExecutionRoleSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationInitProviderServiceExecutionRoleSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationInitProviderServiceExecutionRoleSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderServiceExecutionRoleSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationInitProviderServiceExecutionRoleSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<ApplicationPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ApplicationPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ApplicationPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<ApplicationPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<ApplicationPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ApplicationPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ApplicationStatus defines the observed state of Application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    pub at_provider: Option<ApplicationStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProvider {
    /// The application's configuration
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationConfiguration"
    )]
    pub application_configuration: Option<ApplicationStatusAtProviderApplicationConfiguration>,
    /// The application's mode. Valid values are STREAMING, INTERACTIVE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationMode"
    )]
    pub application_mode: Option<String>,
    /// The ARN of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// A CloudWatch log stream to monitor application configuration errors.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLoggingOptions"
    )]
    pub cloudwatch_logging_options: Option<ApplicationStatusAtProviderCloudwatchLoggingOptions>,
    /// The current timestamp when the application was created.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createTimestamp"
    )]
    pub create_timestamp: Option<String>,
    /// A summary description of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether to force stop an unresponsive Flink-based application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceStop")]
    pub force_stop: Option<bool>,
    /// The application identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The current timestamp when the application was last updated.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastUpdateTimestamp"
    )]
    pub last_update_timestamp: Option<String>,
    /// The runtime environment for the application. Valid values: SQL-1_0, FLINK-1_6, FLINK-1_8, FLINK-1_11, FLINK-1_13, FLINK-1_15, FLINK-1_18, FLINK-1_19.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runtimeEnvironment"
    )]
    pub runtime_environment: Option<String>,
    /// The ARN of the IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceExecutionRole"
    )]
    pub service_execution_role: Option<String>,
    /// Whether to start or stop the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startApplication"
    )]
    pub start_application: Option<bool>,
    /// The status of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
    /// The current application version. Kinesis Data Analytics updates the version_id each time the application is updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionId")]
    pub version_id: Option<f64>,
}

/// The application's configuration
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfiguration {
    /// The code location and type parameters for the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationCodeConfiguration"
    )]
    pub application_code_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfiguration>,
    /// Describes whether snapshots are enabled for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationSnapshotConfiguration"
    )]
    pub application_snapshot_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationApplicationSnapshotConfiguration>,
    /// Describes execution properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "environmentProperties"
    )]
    pub environment_properties:
        Option<ApplicationStatusAtProviderApplicationConfigurationEnvironmentProperties>,
    /// The configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "flinkApplicationConfiguration"
    )]
    pub flink_application_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfiguration>,
    /// Describes the starting properties for a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runConfiguration"
    )]
    pub run_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationRunConfiguration>,
    /// The configuration of a SQL-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sqlApplicationConfiguration"
    )]
    pub sql_application_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfiguration>,
    /// The VPC configuration of a Flink-based application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConfiguration"
    )]
    pub vpc_configuration:
        Option<ApplicationStatusAtProviderApplicationConfigurationVpcConfiguration>,
}

/// The code location and type parameters for the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfiguration {
    /// The location and type of the application code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContent"
    )]
    pub code_content: Option<
        ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfigurationCodeContent,
    >,
    /// Specifies whether the code content is in text or zip format. Valid values: PLAINTEXT, ZIPFILE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "codeContentType"
    )]
    pub code_content_type: Option<String>,
}

/// The location and type of the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfigurationCodeContent {
    /// Information about the Amazon S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ContentLocation")]
    pub s3_content_location: Option<ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation>,
    /// The text-format code for the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "textContent")]
    pub text_content: Option<String>,
}

/// Information about the Amazon S3 bucket containing the application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation
{
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
    /// The version of the object containing the application code.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "objectVersion"
    )]
    pub object_version: Option<String>,
}

/// Describes whether snapshots are enabled for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationApplicationSnapshotConfiguration {
    /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotsEnabled"
    )]
    pub snapshots_enabled: Option<bool>,
}

/// Describes execution properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationEnvironmentProperties {
    /// Describes the execution property groups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroup"
    )]
    pub property_group: Option<
        Vec<ApplicationStatusAtProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup {
    /// The key of the application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyGroupId"
    )]
    pub property_group_id: Option<String>,
    /// Application execution property key-value map.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "propertyMap"
    )]
    pub property_map: Option<HashMap<String, String>>,
}

/// The configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfiguration {
    /// Describes an application's checkpointing configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "checkpointConfiguration")]
    pub checkpoint_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration>,
    /// Describes configuration parameters for CloudWatch logging for an application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringConfiguration")]
    pub monitoring_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration>,
    /// Describes parameters for how an application executes multiple tasks simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parallelismConfiguration")]
    pub parallelism_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration>,
}

/// Describes an application's checkpointing configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
{
    /// Describes the interval in milliseconds between checkpoint operations.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointInterval"
    )]
    pub checkpoint_interval: Option<f64>,
    /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "checkpointingEnabled"
    )]
    pub checkpointing_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minPauseBetweenCheckpoints"
    )]
    pub min_pause_between_checkpoints: Option<f64>,
}

/// Describes configuration parameters for CloudWatch logging for an application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
{
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the verbosity of the CloudWatch Logs for an application. Valid values: DEBUG, ERROR, INFO, WARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Describes the granularity of the CloudWatch Logs for an application. Valid values: APPLICATION, OPERATOR, PARALLELISM, TASK.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metricsLevel"
    )]
    pub metrics_level: Option<String>,
}

/// Describes parameters for how an application executes multiple tasks simultaneously.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
{
    /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "autoScalingEnabled"
    )]
    pub auto_scaling_enabled: Option<bool>,
    /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationType"
    )]
    pub configuration_type: Option<String>,
    /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallelism: Option<f64>,
    /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "parallelismPerKpu"
    )]
    pub parallelism_per_kpu: Option<f64>,
}

/// Describes the starting properties for a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationRunConfiguration {
    /// The restore behavior of a restarting application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationRestoreConfiguration")]
    pub application_restore_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration>,
    /// The starting parameters for a Flink-based Kinesis Data Analytics application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flinkRunConfiguration")]
    pub flink_run_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration>,
}

/// The restore behavior of a restarting application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
{
    /// Specifies how the application should be restored. Valid values: RESTORE_FROM_CUSTOM_SNAPSHOT, RESTORE_FROM_LATEST_SNAPSHOT, SKIP_RESTORE_FROM_SNAPSHOT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationRestoreType"
    )]
    pub application_restore_type: Option<String>,
    /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for application_restore_type.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "snapshotName"
    )]
    pub snapshot_name: Option<String>,
}

/// The starting parameters for a Flink-based Kinesis Data Analytics application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration
{
    /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowNonRestoredState"
    )]
    pub allow_non_restored_state: Option<bool>,
}

/// The configuration of a SQL-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfiguration {
    /// The input stream used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInput>,
    /// The destination streams used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<Vec<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutput>>,
    /// The reference data source used by the application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceDataSource")]
    pub reference_data_source: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource>,
}

/// The input stream used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInput {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inAppStreamNames")]
    pub in_app_stream_names: Option<Vec<String>>,
    /// The application identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputId")]
    pub input_id: Option<String>,
    /// Describes the number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputParallelism")]
    pub input_parallelism: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism>,
    /// The input processing configuration for the input.
    /// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputProcessingConfiguration")]
    pub input_processing_configuration: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration>,
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputSchema")]
    pub input_schema: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema>,
    /// The point at which the application starts processing records from the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputStartingPositionConfiguration")]
    pub input_starting_position_configuration: Option<Vec<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration>>,
    /// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseInput")]
    pub kinesis_firehose_input: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput>,
    /// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsInput")]
    pub kinesis_streams_input: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput>,
    /// The name prefix to use when creating an in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namePrefix")]
    pub name_prefix: Option<String>,
}

/// Describes the number of in-application streams to create.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
{
    /// The number of in-application streams to create.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
}

/// The input processing configuration for the input.
/// An input processor transforms records as they are received from the stream, before the application's SQL code executes.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
    /// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputLambdaProcessor")]
    pub input_lambda_processor: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor>,
}

/// Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration
{
    /// The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inputStartingPosition"
    )]
    pub input_starting_position: Option<String>,
}

/// If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutput {
    /// Describes the data format when records are written to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationSchema")]
    pub destination_schema: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema>,
    /// Identifies a Kinesis Data Firehose delivery stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisFirehoseOutput")]
    pub kinesis_firehose_output: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput>,
    /// Identifies a Kinesis data stream as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kinesisStreamsOutput")]
    pub kinesis_streams_output: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput>,
    /// Identifies a Lambda function as the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaOutput")]
    pub lambda_output: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The application identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputId")]
    pub output_id: Option<String>,
}

/// Describes the data format when records are written to the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
{
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordFormatType"
    )]
    pub record_format_type: Option<String>,
}

/// Identifies a Kinesis Data Firehose delivery stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Identifies a Kinesis data stream as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// Identifies a Lambda function as the destination.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput
{
    /// The ARN of the Lambda function that operates on records in the stream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceArn"
    )]
    pub resource_arn: Option<String>,
}

/// The reference data source used by the application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
    /// The application identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceId")]
    pub reference_id: Option<String>,
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceSchema")]
    pub reference_schema: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema>,
    /// Identifies the S3 bucket and object that contains the reference data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ReferenceDataSource")]
    pub s3_reference_data_source: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource>,
    /// The name of the in-application table to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

/// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordColumn")]
    pub record_column: Option<Vec<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn>>,
    /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordEncoding")]
    pub record_encoding: Option<String>,
    /// Specifies the format of the records on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormat")]
    pub record_format: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn
{
    /// A reference to the data element in the streaming input or the reference data source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mapping: Option<String>,
    /// The name of the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of column created in the in-application input stream or reference table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
}

/// Specifies the format of the records on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
    /// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingParameters")]
    pub mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters>,
    /// The type of record format. Valid values: CSV, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordFormatType")]
    pub record_format_type: Option<String>,
}

/// Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
    /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvMappingParameters")]
    pub csv_mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters>,
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonMappingParameters")]
    pub json_mapping_parameters: Option<ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters>,
}

/// Provides additional mapping information when the record format uses delimiters (for example, CSV).
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
{
    /// The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordColumnDelimiter"
    )]
    pub record_column_delimiter: Option<String>,
    /// The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowDelimiter"
    )]
    pub record_row_delimiter: Option<String>,
}

/// Provides additional mapping information when JSON is the record format on the streaming source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
{
    /// The path to the top-level parent that contains the records.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordRowPath"
    )]
    pub record_row_path: Option<String>,
}

/// Identifies the S3 bucket and object that contains the reference data.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource
{
    /// The ARN for the S3 bucket containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketArn")]
    pub bucket_arn: Option<String>,
    /// The file key for the object containing the application code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileKey")]
    pub file_key: Option<String>,
}

/// The VPC configuration of a Flink-based application.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderApplicationConfigurationVpcConfiguration {
    /// The Security Group IDs used by the VPC configuration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupIds"
    )]
    pub security_group_ids: Option<Vec<String>>,
    /// The Subnet IDs used by the VPC configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    pub subnet_ids: Option<Vec<String>>,
    /// The application identifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConfigurationId"
    )]
    pub vpc_configuration_id: Option<String>,
    /// The application identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    pub vpc_id: Option<String>,
}

/// A CloudWatch log stream to monitor application configuration errors.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ApplicationStatusAtProviderCloudwatchLoggingOptions {
    /// The application identifier.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLoggingOptionId"
    )]
    pub cloudwatch_logging_option_id: Option<String>,
    /// The ARN of the CloudWatch log stream to receive application messages.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logStreamArn"
    )]
    pub log_stream_arn: Option<String>,
}
