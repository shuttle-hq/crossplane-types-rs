// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// PatchDeploymentSpec defines the desired state of PatchDeployment
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "osconfig.gcp.upbound.io", version = "v1beta2", kind = "PatchDeployment", plural = "patchdeployments")]
#[kube(status = "PatchDeploymentStatus")]
pub struct PatchDeploymentSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<PatchDeploymentDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: PatchDeploymentForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<PatchDeploymentInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<PatchDeploymentProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<PatchDeploymentPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<PatchDeploymentWriteConnectionSecretToRef>,
}

/// PatchDeploymentSpec defines the desired state of PatchDeployment
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProvider {
    /// Description of the patch deployment. Length of the description is limited to 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Duration of the patch. After the duration ends, the patch times out.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// VM instances to patch.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceFilter")]
    pub instance_filter: Option<PatchDeploymentForProviderInstanceFilter>,
    /// Schedule a one-time execution.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneTimeSchedule")]
    pub one_time_schedule: Option<PatchDeploymentForProviderOneTimeSchedule>,
    /// Patch configuration that is applied.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchConfig")]
    pub patch_config: Option<PatchDeploymentForProviderPatchConfig>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Schedule recurring executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringSchedule")]
    pub recurring_schedule: Option<PatchDeploymentForProviderRecurringSchedule>,
    /// Rollout strategy of the patch job.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollout: Option<PatchDeploymentForProviderRollout>,
}

/// VM instances to patch.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilter {
    /// Target all VM instances in the project. If true, no other criteria is permitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<bool>,
    /// Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupLabels")]
    pub group_labels: Option<Vec<PatchDeploymentForProviderInstanceFilterGroupLabels>>,
    /// Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group
    /// VMs when targeting configs, for example prefix="prod-".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceNamePrefixes")]
    pub instance_name_prefixes: Option<Vec<String>>,
    /// Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}},
    /// projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or
    /// https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// References to Instance in compute to populate instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancesRefs")]
    pub instances_refs: Option<Vec<PatchDeploymentForProviderInstanceFilterInstancesRefs>>,
    /// Selector for a list of Instance in compute to populate instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancesSelector")]
    pub instances_selector: Option<PatchDeploymentForProviderInstanceFilterInstancesSelector>,
    /// Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zones: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilterGroupLabels {
    /// Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilterInstancesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentForProviderInstanceFilterInstancesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilterInstancesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentForProviderInstanceFilterInstancesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentForProviderInstanceFilterInstancesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentForProviderInstanceFilterInstancesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentForProviderInstanceFilterInstancesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Instance in compute to populate instances.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilterInstancesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentForProviderInstanceFilterInstancesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Schedule a one-time execution.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderOneTimeSchedule {
    /// The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format,
    /// accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executeTime")]
    pub execute_time: Option<String>,
}

/// Patch configuration that is applied.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfig {
    /// Apt update settings. Use this setting to override the default apt patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub apt: Option<PatchDeploymentForProviderPatchConfigApt>,
    /// goo update settings. Use this setting to override the default goo patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub goo: Option<PatchDeploymentForProviderPatchConfigGoo>,
    /// Allows the patch job to run on Managed instance groups (MIGs).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migInstancesAllowed")]
    pub mig_instances_allowed: Option<bool>,
    /// The ExecStep to run after the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStep")]
    pub post_step: Option<PatchDeploymentForProviderPatchConfigPostStep>,
    /// The ExecStep to run before the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStep")]
    pub pre_step: Option<PatchDeploymentForProviderPatchConfigPreStep>,
    /// Post-patch reboot settings.
    /// Possible values are: DEFAULT, ALWAYS, NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rebootConfig")]
    pub reboot_config: Option<String>,
    /// Windows update settings. Use this setting to override the default Windows patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsUpdate")]
    pub windows_update: Option<PatchDeploymentForProviderPatchConfigWindowsUpdate>,
    /// Yum update settings. Use this setting to override the default yum patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yum: Option<PatchDeploymentForProviderPatchConfigYum>,
    /// zypper update settings. Use this setting to override the default zypper patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zypper: Option<PatchDeploymentForProviderPatchConfigZypper>,
}

/// Apt update settings. Use this setting to override the default apt patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigApt {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead.
    /// Possible values are: DIST, UPGRADE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// goo update settings. Use this setting to override the default goo patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigGoo {
    /// goo update settings. Use this setting to override the default goo patch rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The ExecStep to run after the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPostStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentForProviderPatchConfigPostStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentForProviderPatchConfigPostStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPostStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPostStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStep to run before the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPreStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentForProviderPatchConfigPreStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentForProviderPatchConfigPreStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPreStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPreStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// Windows update settings. Use this setting to override the default Windows patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigWindowsUpdate {
    /// Only apply updates of these windows update classifications. If empty, all updates are applied.
    /// Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
}

/// Yum update settings. Use this setting to override the default yum patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigYum {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// Will cause patch to run yum update-minimal instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimal: Option<bool>,
    /// Adds the --security flag to yum update. Not supported on all platforms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<bool>,
}

/// zypper update settings. Use this setting to override the default zypper patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderPatchConfigZypper {
    /// Install only patches with these categories. Common categories include security, recommended, and feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub categories: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
    /// Install only patches with these severities. Common severities include critical, important, moderate, and low.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severities: Option<Vec<String>>,
    /// Adds the --with-optional flag to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withOptional")]
    pub with_optional: Option<bool>,
    /// Adds the --with-update flag, to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withUpdate")]
    pub with_update: Option<bool>,
}

/// Schedule recurring executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringSchedule {
    /// The end time at which a recurring patch deployment schedule is no longer active.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Schedule with monthly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly: Option<PatchDeploymentForProviderRecurringScheduleMonthly>,
    /// The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Time of the day to run a recurring deployment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    pub time_of_day: Option<PatchDeploymentForProviderRecurringScheduleTimeOfDay>,
    /// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
    /// determined by the chosen time zone.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<PatchDeploymentForProviderRecurringScheduleTimeZone>,
    /// Schedule with weekly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekly: Option<PatchDeploymentForProviderRecurringScheduleWeekly>,
}

/// Schedule with monthly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringScheduleMonthly {
    /// One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month.
    /// Months without the target day will be skipped. For example, a schedule to run "every month on the 31st"
    /// will not run in February, April, June, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monthDay")]
    pub month_day: Option<f64>,
    /// Week day in a month.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekDayOfMonth")]
    pub week_day_of_month: Option<PatchDeploymentForProviderRecurringScheduleMonthlyWeekDayOfMonth>,
}

/// Week day in a month.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringScheduleMonthlyWeekDayOfMonth {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
    /// Represents the number of days before or after the given week day of month that the patch deployment is scheduled for.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOffset")]
    pub day_offset: Option<f64>,
    /// Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekOrdinal")]
    pub week_ordinal: Option<f64>,
}

/// Time of the day to run a recurring deployment.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringScheduleTimeOfDay {
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    /// An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
/// determined by the chosen time zone.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringScheduleTimeZone {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// IANA Time Zone Database version number, e.g. "2019a".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Schedule with weekly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRecurringScheduleWeekly {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
}

/// Rollout strategy of the patch job.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRollout {
    /// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
    /// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
    /// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
    /// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
    /// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disruptionBudget")]
    pub disruption_budget: Option<PatchDeploymentForProviderRolloutDisruptionBudget>,
    /// Mode of the patch rollout.
    /// Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
/// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
/// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
/// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
/// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentForProviderRolloutDisruptionBudget {
    /// Specifies a fixed value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percentage: Option<f64>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProvider {
    /// Description of the patch deployment. Length of the description is limited to 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Duration of the patch. After the duration ends, the patch times out.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// VM instances to patch.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceFilter")]
    pub instance_filter: Option<PatchDeploymentInitProviderInstanceFilter>,
    /// Schedule a one-time execution.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneTimeSchedule")]
    pub one_time_schedule: Option<PatchDeploymentInitProviderOneTimeSchedule>,
    /// Patch configuration that is applied.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchConfig")]
    pub patch_config: Option<PatchDeploymentInitProviderPatchConfig>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Schedule recurring executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringSchedule")]
    pub recurring_schedule: Option<PatchDeploymentInitProviderRecurringSchedule>,
    /// Rollout strategy of the patch job.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollout: Option<PatchDeploymentInitProviderRollout>,
}

/// VM instances to patch.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilter {
    /// Target all VM instances in the project. If true, no other criteria is permitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<bool>,
    /// Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupLabels")]
    pub group_labels: Option<Vec<PatchDeploymentInitProviderInstanceFilterGroupLabels>>,
    /// Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group
    /// VMs when targeting configs, for example prefix="prod-".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceNamePrefixes")]
    pub instance_name_prefixes: Option<Vec<String>>,
    /// Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}},
    /// projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or
    /// https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// References to Instance in compute to populate instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancesRefs")]
    pub instances_refs: Option<Vec<PatchDeploymentInitProviderInstanceFilterInstancesRefs>>,
    /// Selector for a list of Instance in compute to populate instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancesSelector")]
    pub instances_selector: Option<PatchDeploymentInitProviderInstanceFilterInstancesSelector>,
    /// Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zones: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilterGroupLabels {
    /// Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilterInstancesRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentInitProviderInstanceFilterInstancesRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Instance in compute to populate instances.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilterInstancesSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentInitProviderInstanceFilterInstancesSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Schedule a one-time execution.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderOneTimeSchedule {
    /// The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format,
    /// accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executeTime")]
    pub execute_time: Option<String>,
}

/// Patch configuration that is applied.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfig {
    /// Apt update settings. Use this setting to override the default apt patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub apt: Option<PatchDeploymentInitProviderPatchConfigApt>,
    /// goo update settings. Use this setting to override the default goo patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub goo: Option<PatchDeploymentInitProviderPatchConfigGoo>,
    /// Allows the patch job to run on Managed instance groups (MIGs).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migInstancesAllowed")]
    pub mig_instances_allowed: Option<bool>,
    /// The ExecStep to run after the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStep")]
    pub post_step: Option<PatchDeploymentInitProviderPatchConfigPostStep>,
    /// The ExecStep to run before the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStep")]
    pub pre_step: Option<PatchDeploymentInitProviderPatchConfigPreStep>,
    /// Post-patch reboot settings.
    /// Possible values are: DEFAULT, ALWAYS, NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rebootConfig")]
    pub reboot_config: Option<String>,
    /// Windows update settings. Use this setting to override the default Windows patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsUpdate")]
    pub windows_update: Option<PatchDeploymentInitProviderPatchConfigWindowsUpdate>,
    /// Yum update settings. Use this setting to override the default yum patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yum: Option<PatchDeploymentInitProviderPatchConfigYum>,
    /// zypper update settings. Use this setting to override the default zypper patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zypper: Option<PatchDeploymentInitProviderPatchConfigZypper>,
}

/// Apt update settings. Use this setting to override the default apt patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigApt {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead.
    /// Possible values are: DIST, UPGRADE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// goo update settings. Use this setting to override the default goo patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigGoo {
    /// goo update settings. Use this setting to override the default goo patch rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The ExecStep to run after the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPostStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentInitProviderPatchConfigPostStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentInitProviderPatchConfigPostStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPostStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPostStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStep to run before the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPreStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentInitProviderPatchConfigPreStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentInitProviderPatchConfigPreStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPreStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPreStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// Windows update settings. Use this setting to override the default Windows patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigWindowsUpdate {
    /// Only apply updates of these windows update classifications. If empty, all updates are applied.
    /// Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
}

/// Yum update settings. Use this setting to override the default yum patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigYum {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// Will cause patch to run yum update-minimal instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimal: Option<bool>,
    /// Adds the --security flag to yum update. Not supported on all platforms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<bool>,
}

/// zypper update settings. Use this setting to override the default zypper patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderPatchConfigZypper {
    /// Install only patches with these categories. Common categories include security, recommended, and feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub categories: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
    /// Install only patches with these severities. Common severities include critical, important, moderate, and low.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severities: Option<Vec<String>>,
    /// Adds the --with-optional flag to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withOptional")]
    pub with_optional: Option<bool>,
    /// Adds the --with-update flag, to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withUpdate")]
    pub with_update: Option<bool>,
}

/// Schedule recurring executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringSchedule {
    /// The end time at which a recurring patch deployment schedule is no longer active.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Schedule with monthly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly: Option<PatchDeploymentInitProviderRecurringScheduleMonthly>,
    /// The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Time of the day to run a recurring deployment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    pub time_of_day: Option<PatchDeploymentInitProviderRecurringScheduleTimeOfDay>,
    /// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
    /// determined by the chosen time zone.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<PatchDeploymentInitProviderRecurringScheduleTimeZone>,
    /// Schedule with weekly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekly: Option<PatchDeploymentInitProviderRecurringScheduleWeekly>,
}

/// Schedule with monthly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringScheduleMonthly {
    /// One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month.
    /// Months without the target day will be skipped. For example, a schedule to run "every month on the 31st"
    /// will not run in February, April, June, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monthDay")]
    pub month_day: Option<f64>,
    /// Week day in a month.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekDayOfMonth")]
    pub week_day_of_month: Option<PatchDeploymentInitProviderRecurringScheduleMonthlyWeekDayOfMonth>,
}

/// Week day in a month.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringScheduleMonthlyWeekDayOfMonth {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
    /// Represents the number of days before or after the given week day of month that the patch deployment is scheduled for.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOffset")]
    pub day_offset: Option<f64>,
    /// Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekOrdinal")]
    pub week_ordinal: Option<f64>,
}

/// Time of the day to run a recurring deployment.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringScheduleTimeOfDay {
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    /// An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
/// determined by the chosen time zone.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringScheduleTimeZone {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// IANA Time Zone Database version number, e.g. "2019a".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Schedule with weekly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRecurringScheduleWeekly {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
}

/// Rollout strategy of the patch job.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRollout {
    /// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
    /// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
    /// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
    /// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
    /// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disruptionBudget")]
    pub disruption_budget: Option<PatchDeploymentInitProviderRolloutDisruptionBudget>,
    /// Mode of the patch rollout.
    /// Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
/// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
/// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
/// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
/// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentInitProviderRolloutDisruptionBudget {
    /// Specifies a fixed value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percentage: Option<f64>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<PatchDeploymentPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PatchDeploymentPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<PatchDeploymentPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<PatchDeploymentPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<PatchDeploymentPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PatchDeploymentPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// PatchDeploymentStatus defines the observed state of PatchDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<PatchDeploymentStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProvider {
    /// Time the patch deployment was created. Timestamp is in RFC3339 text format.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    pub create_time: Option<String>,
    /// Description of the patch deployment. Length of the description is limited to 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Duration of the patch. After the duration ends, the patch times out.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// an identifier for the resource with format {{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// VM instances to patch.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceFilter")]
    pub instance_filter: Option<PatchDeploymentStatusAtProviderInstanceFilter>,
    /// The last time a patch job was started by this deployment. Timestamp is in RFC3339 text format.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastExecuteTime")]
    pub last_execute_time: Option<String>,
    /// Unique name for the patch deployment resource in a project.
    /// The patch deployment name is in the form: projects/{project_id}/patchDeployments/{patchDeploymentId}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Schedule a one-time execution.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneTimeSchedule")]
    pub one_time_schedule: Option<PatchDeploymentStatusAtProviderOneTimeSchedule>,
    /// Patch configuration that is applied.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchConfig")]
    pub patch_config: Option<PatchDeploymentStatusAtProviderPatchConfig>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Schedule recurring executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurringSchedule")]
    pub recurring_schedule: Option<PatchDeploymentStatusAtProviderRecurringSchedule>,
    /// Rollout strategy of the patch job.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollout: Option<PatchDeploymentStatusAtProviderRollout>,
    /// Time the patch deployment was last updated. Timestamp is in RFC3339 text format.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    pub update_time: Option<String>,
}

/// VM instances to patch.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderInstanceFilter {
    /// Target all VM instances in the project. If true, no other criteria is permitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<bool>,
    /// Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupLabels")]
    pub group_labels: Option<Vec<PatchDeploymentStatusAtProviderInstanceFilterGroupLabels>>,
    /// Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group
    /// VMs when targeting configs, for example prefix="prod-".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceNamePrefixes")]
    pub instance_name_prefixes: Option<Vec<String>>,
    /// Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}},
    /// projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or
    /// https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zones: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderInstanceFilterGroupLabels {
    /// Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
}

/// Schedule a one-time execution.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderOneTimeSchedule {
    /// The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format,
    /// accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executeTime")]
    pub execute_time: Option<String>,
}

/// Patch configuration that is applied.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfig {
    /// Apt update settings. Use this setting to override the default apt patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub apt: Option<PatchDeploymentStatusAtProviderPatchConfigApt>,
    /// goo update settings. Use this setting to override the default goo patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub goo: Option<PatchDeploymentStatusAtProviderPatchConfigGoo>,
    /// Allows the patch job to run on Managed instance groups (MIGs).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migInstancesAllowed")]
    pub mig_instances_allowed: Option<bool>,
    /// The ExecStep to run after the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStep")]
    pub post_step: Option<PatchDeploymentStatusAtProviderPatchConfigPostStep>,
    /// The ExecStep to run before the patch update.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStep")]
    pub pre_step: Option<PatchDeploymentStatusAtProviderPatchConfigPreStep>,
    /// Post-patch reboot settings.
    /// Possible values are: DEFAULT, ALWAYS, NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rebootConfig")]
    pub reboot_config: Option<String>,
    /// Windows update settings. Use this setting to override the default Windows patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsUpdate")]
    pub windows_update: Option<PatchDeploymentStatusAtProviderPatchConfigWindowsUpdate>,
    /// Yum update settings. Use this setting to override the default yum patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yum: Option<PatchDeploymentStatusAtProviderPatchConfigYum>,
    /// zypper update settings. Use this setting to override the default zypper patch rules.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zypper: Option<PatchDeploymentStatusAtProviderPatchConfigZypper>,
}

/// Apt update settings. Use this setting to override the default apt patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigApt {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead.
    /// Possible values are: DIST, UPGRADE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// goo update settings. Use this setting to override the default goo patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigGoo {
    /// goo update settings. Use this setting to override the default goo patch rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The ExecStep to run after the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPostStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentStatusAtProviderPatchConfigPostStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentStatusAtProviderPatchConfigPostStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPostStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentStatusAtProviderPatchConfigPostStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPostStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentStatusAtProviderPatchConfigPostStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStep to run before the patch update.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPreStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxExecStepConfig")]
    pub linux_exec_step_config: Option<PatchDeploymentStatusAtProviderPatchConfigPreStepLinuxExecStepConfig>,
    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsExecStepConfig")]
    pub windows_exec_step_config: Option<PatchDeploymentStatusAtProviderPatchConfigPreStepWindowsExecStepConfig>,
}

/// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPreStepLinuxExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentStatusAtProviderPatchConfigPreStepLinuxExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPreStepWindowsExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSuccessCodes")]
    pub allowed_success_codes: Option<Vec<f64>>,
    /// A Cloud Storage object containing the executable.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcsObject")]
    pub gcs_object: Option<PatchDeploymentStatusAtProviderPatchConfigPreStepWindowsExecStepConfigGcsObject>,
    /// The script interpreter to use to run the script. If no interpreter is specified the script will
    /// be executed directly, which will likely only succeed for scripts with shebang lines.
    /// Possible values are: SHELL, POWERSHELL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpreter: Option<String>,
    /// An absolute path to the executable on the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPath")]
    pub local_path: Option<String>,
}

/// A Cloud Storage object containing the executable.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
    /// Bucket of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generationNumber")]
    pub generation_number: Option<String>,
    /// Name of the Cloud Storage object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
}

/// Windows update settings. Use this setting to override the default Windows patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigWindowsUpdate {
    /// Only apply updates of these windows update classifications. If empty, all updates are applied.
    /// Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
}

/// Yum update settings. Use this setting to override the default yum patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigYum {
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of packages to be updated. These are the only packages that will be updated.
    /// If these packages are not installed, they will be ignored. This field cannot be specified with
    /// any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePackages")]
    pub exclusive_packages: Option<Vec<String>>,
    /// Will cause patch to run yum update-minimal instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimal: Option<bool>,
    /// Adds the --security flag to yum update. Not supported on all platforms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<bool>,
}

/// zypper update settings. Use this setting to override the default zypper patch rules.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderPatchConfigZypper {
    /// Install only patches with these categories. Common categories include security, recommended, and feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub categories: Option<Vec<String>>,
    /// List of packages to exclude from update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludes: Option<Vec<String>>,
    /// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusivePatches")]
    pub exclusive_patches: Option<Vec<String>>,
    /// Install only patches with these severities. Common severities include critical, important, moderate, and low.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severities: Option<Vec<String>>,
    /// Adds the --with-optional flag to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withOptional")]
    pub with_optional: Option<bool>,
    /// Adds the --with-update flag, to zypper patch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withUpdate")]
    pub with_update: Option<bool>,
}

/// Schedule recurring executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringSchedule {
    /// The end time at which a recurring patch deployment schedule is no longer active.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// (Output)
    /// The time the last patch job ran successfully.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastExecuteTime")]
    pub last_execute_time: Option<String>,
    /// Schedule with monthly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monthly: Option<PatchDeploymentStatusAtProviderRecurringScheduleMonthly>,
    /// (Output)
    /// The time the next patch job is scheduled to run.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nextExecuteTime")]
    pub next_execute_time: Option<String>,
    /// The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Time of the day to run a recurring deployment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    pub time_of_day: Option<PatchDeploymentStatusAtProviderRecurringScheduleTimeOfDay>,
    /// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
    /// determined by the chosen time zone.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<PatchDeploymentStatusAtProviderRecurringScheduleTimeZone>,
    /// Schedule with weekly executions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekly: Option<PatchDeploymentStatusAtProviderRecurringScheduleWeekly>,
}

/// Schedule with monthly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringScheduleMonthly {
    /// One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month.
    /// Months without the target day will be skipped. For example, a schedule to run "every month on the 31st"
    /// will not run in February, April, June, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monthDay")]
    pub month_day: Option<f64>,
    /// Week day in a month.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekDayOfMonth")]
    pub week_day_of_month: Option<PatchDeploymentStatusAtProviderRecurringScheduleMonthlyWeekDayOfMonth>,
}

/// Week day in a month.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringScheduleMonthlyWeekDayOfMonth {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
    /// Represents the number of days before or after the given week day of month that the patch deployment is scheduled for.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOffset")]
    pub day_offset: Option<f64>,
    /// Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weekOrdinal")]
    pub week_ordinal: Option<f64>,
}

/// Time of the day to run a recurring deployment.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringScheduleTimeOfDay {
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    /// An API may choose to allow the value "24:00:00" for scenarios like business closing time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

/// Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
/// determined by the chosen time zone.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringScheduleTimeZone {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// IANA Time Zone Database version number, e.g. "2019a".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Schedule with weekly executions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRecurringScheduleWeekly {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
}

/// Rollout strategy of the patch job.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRollout {
    /// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
    /// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
    /// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
    /// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
    /// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disruptionBudget")]
    pub disruption_budget: Option<PatchDeploymentStatusAtProviderRolloutDisruptionBudget>,
    /// Mode of the patch rollout.
    /// Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
/// During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
/// A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
/// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
/// For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PatchDeploymentStatusAtProviderRolloutDisruptionBudget {
    /// Specifies a fixed value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percentage: Option<f64>,
}

