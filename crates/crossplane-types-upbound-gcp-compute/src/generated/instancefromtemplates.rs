// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InstanceFromTemplateSpec defines the desired state of InstanceFromTemplate
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "InstanceFromTemplate", plural = "instancefromtemplates")]
#[kube(status = "InstanceFromTemplateStatus")]
pub struct InstanceFromTemplateSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<InstanceFromTemplateDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InstanceFromTemplateForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<InstanceFromTemplateInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<InstanceFromTemplateProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<InstanceFromTemplatePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<InstanceFromTemplateWriteConnectionSecretToRef>,
}

/// InstanceFromTemplateSpec defines the desired state of InstanceFromTemplate
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProvider {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<InstanceFromTemplateForProviderAdvancedMachineFeatures>,
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    pub allow_stopping_for_update: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    pub attached_disk: Option<Vec<InstanceFromTemplateForProviderAttachedDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    pub boot_disk: Option<InstanceFromTemplateForProviderBootDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    pub can_ip_forward: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    pub confidential_instance_config: Option<InstanceFromTemplateForProviderConfidentialInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    pub desired_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    pub enable_display: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<InstanceFromTemplateForProviderGuestAccelerator>>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    pub metadata_startup_script: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    pub network_interface: Option<Vec<InstanceFromTemplateForProviderNetworkInterface>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    pub network_performance_config: Option<InstanceFromTemplateForProviderNetworkPerformanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<InstanceFromTemplateForProviderParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<InstanceFromTemplateForProviderReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    pub resource_policies: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheduling: Option<InstanceFromTemplateForProviderScheduling>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    pub scratch_disk: Option<Vec<InstanceFromTemplateForProviderScratchDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<InstanceFromTemplateForProviderServiceAccount>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<InstanceFromTemplateForProviderShieldedInstanceConfig>,
    /// Name or self link of an instance
    /// template to create the instance based on. It is recommended to reference
    /// instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplate")]
    pub source_instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplateRef")]
    pub source_instance_template_ref: Option<InstanceFromTemplateForProviderSourceInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplateSelector")]
    pub source_instance_template_selector: Option<InstanceFromTemplateForProviderSourceInstanceTemplateSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// The zone that the machine should be created in. If not
    /// set, the provider zone is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderAttachedDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRaw")]
    pub disk_encryption_key_raw: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    pub disk_encryption_key_sha256: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderBootDisk {
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<bool>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceFromTemplateForProviderBootDiskDiskEncryptionKeyRawSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    pub initialize_params: Option<InstanceFromTemplateForProviderBootDiskInitializeParams>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderBootDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderBootDiskInitializeParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    pub provisioned_iops: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    pub provisioned_throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderConfidentialInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    pub confidential_instance_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterface {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    pub access_config: Option<Vec<InstanceFromTemplateForProviderNetworkInterfaceAccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    pub alias_ip_range: Option<Vec<InstanceFromTemplateForProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    pub internal_ipv6_prefix_length: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    pub ipv6_access_config: Option<Vec<InstanceFromTemplateForProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    pub ipv6_address: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    pub nic_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    pub queue_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    pub subnetwork_ref: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    pub subnetwork_selector: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    pub nat_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceAliasIpRange {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    pub ip_cidr_range: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceIpv6AccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    pub external_ipv6: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderNetworkPerformanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    pub total_egress_bandwidth_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderReservationAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    pub specific_reservation: Option<InstanceFromTemplateForProviderReservationAffinitySpecificReservation>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderReservationAffinitySpecificReservation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderScheduling {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    pub automatic_restart: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    pub instance_termination_action: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    pub local_ssd_recovery_timeout: Option<InstanceFromTemplateForProviderSchedulingLocalSsdRecoveryTimeout>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    pub max_run_duration: Option<InstanceFromTemplateForProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    pub min_node_cpus: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    pub node_affinities: Option<Vec<InstanceFromTemplateForProviderSchedulingNodeAffinities>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    pub on_host_maintenance: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    pub on_instance_stop_action: Option<InstanceFromTemplateForProviderSchedulingOnInstanceStopAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSchedulingLocalSsdRecoveryTimeout {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSchedulingMaxRunDuration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSchedulingNodeAffinities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSchedulingOnInstanceStopAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderScratchDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interface: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderServiceAccount {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    pub enable_vtpm: Option<bool>,
}

/// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSourceInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderSourceInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSourceInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateForProviderSourceInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProvider {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<InstanceFromTemplateInitProviderAdvancedMachineFeatures>,
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    pub allow_stopping_for_update: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    pub attached_disk: Option<Vec<InstanceFromTemplateInitProviderAttachedDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    pub boot_disk: Option<InstanceFromTemplateInitProviderBootDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    pub can_ip_forward: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    pub confidential_instance_config: Option<InstanceFromTemplateInitProviderConfidentialInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    pub desired_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    pub enable_display: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<InstanceFromTemplateInitProviderGuestAccelerator>>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    pub metadata_startup_script: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    pub network_interface: Option<Vec<InstanceFromTemplateInitProviderNetworkInterface>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    pub network_performance_config: Option<InstanceFromTemplateInitProviderNetworkPerformanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<InstanceFromTemplateInitProviderParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<InstanceFromTemplateInitProviderReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    pub resource_policies: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheduling: Option<InstanceFromTemplateInitProviderScheduling>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    pub scratch_disk: Option<Vec<InstanceFromTemplateInitProviderScratchDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<InstanceFromTemplateInitProviderServiceAccount>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<InstanceFromTemplateInitProviderShieldedInstanceConfig>,
    /// Name or self link of an instance
    /// template to create the instance based on. It is recommended to reference
    /// instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplate")]
    pub source_instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplateRef")]
    pub source_instance_template_ref: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplateSelector")]
    pub source_instance_template_selector: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// The zone that the machine should be created in. If not
    /// set, the provider zone is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderAttachedDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRaw")]
    pub disk_encryption_key_raw: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    pub disk_encryption_key_sha256: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderBootDisk {
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<bool>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceFromTemplateInitProviderBootDiskDiskEncryptionKeyRawSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    pub initialize_params: Option<InstanceFromTemplateInitProviderBootDiskInitializeParams>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderBootDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderBootDiskInitializeParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    pub provisioned_iops: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    pub provisioned_throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderConfidentialInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    pub confidential_instance_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterface {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    pub access_config: Option<Vec<InstanceFromTemplateInitProviderNetworkInterfaceAccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    pub alias_ip_range: Option<Vec<InstanceFromTemplateInitProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    pub internal_ipv6_prefix_length: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    pub ipv6_access_config: Option<Vec<InstanceFromTemplateInitProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    pub ipv6_address: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    pub network_ref: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    pub network_selector: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    pub nic_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    pub queue_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    pub subnetwork_ref: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    pub subnetwork_selector: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    pub nat_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceAliasIpRange {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    pub ip_cidr_range: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceIpv6AccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    pub external_ipv6: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderNetworkPerformanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    pub total_egress_bandwidth_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderReservationAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    pub specific_reservation: Option<InstanceFromTemplateInitProviderReservationAffinitySpecificReservation>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderReservationAffinitySpecificReservation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderScheduling {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    pub automatic_restart: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    pub instance_termination_action: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    pub local_ssd_recovery_timeout: Option<InstanceFromTemplateInitProviderSchedulingLocalSsdRecoveryTimeout>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    pub max_run_duration: Option<InstanceFromTemplateInitProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    pub min_node_cpus: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    pub node_affinities: Option<Vec<InstanceFromTemplateInitProviderSchedulingNodeAffinities>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    pub on_host_maintenance: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    pub on_instance_stop_action: Option<InstanceFromTemplateInitProviderSchedulingOnInstanceStopAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSchedulingLocalSsdRecoveryTimeout {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSchedulingMaxRunDuration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSchedulingNodeAffinities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSchedulingOnInstanceStopAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderScratchDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interface: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderServiceAccount {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    pub enable_vtpm: Option<bool>,
}

/// Reference to a InstanceTemplate in compute to populate sourceInstanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSourceInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderSourceInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate sourceInstanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSourceInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateInitProviderSourceInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplateProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplateProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplateProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplateProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplatePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<InstanceFromTemplatePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstanceFromTemplatePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplatePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceFromTemplatePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplatePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InstanceFromTemplateStatus defines the observed state of InstanceFromTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<InstanceFromTemplateStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProvider {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    pub advanced_machine_features: Option<InstanceFromTemplateStatusAtProviderAdvancedMachineFeatures>,
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    pub allow_stopping_for_update: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    pub attached_disk: Option<Vec<InstanceFromTemplateStatusAtProviderAttachedDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    pub boot_disk: Option<InstanceFromTemplateStatusAtProviderBootDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    pub can_ip_forward: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    pub confidential_instance_config: Option<InstanceFromTemplateStatusAtProviderConfidentialInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuPlatform")]
    pub cpu_platform: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentStatus")]
    pub current_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    pub deletion_protection: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    pub desired_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    pub effective_labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    pub enable_display: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    pub guest_accelerator: Option<Vec<InstanceFromTemplateStatusAtProviderGuestAccelerator>>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceId")]
    pub instance_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelFingerprint")]
    pub label_fingerprint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFingerprint")]
    pub metadata_fingerprint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    pub metadata_startup_script: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    pub min_cpu_platform: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    pub network_interface: Option<Vec<InstanceFromTemplateStatusAtProviderNetworkInterface>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    pub network_performance_config: Option<InstanceFromTemplateStatusAtProviderNetworkPerformanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<InstanceFromTemplateStatusAtProviderParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    pub reservation_affinity: Option<InstanceFromTemplateStatusAtProviderReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    pub resource_policies: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheduling: Option<InstanceFromTemplateStatusAtProviderScheduling>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    pub scratch_disk: Option<Vec<InstanceFromTemplateStatusAtProviderScratchDisk>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    pub self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<InstanceFromTemplateStatusAtProviderServiceAccount>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    pub shielded_instance_config: Option<InstanceFromTemplateStatusAtProviderShieldedInstanceConfig>,
    /// Name or self link of an instance
    /// template to create the instance based on. It is recommended to reference
    /// instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceInstanceTemplate")]
    pub source_instance_template: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsFingerprint")]
    pub tags_fingerprint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// The zone that the machine should be created in. If not
    /// set, the provider zone is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    pub threads_per_core: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderAttachedDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRaw")]
    pub disk_encryption_key_raw: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    pub disk_encryption_key_sha256: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderBootDisk {
    /// Default is 6 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<bool>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    pub disk_encryption_key_sha256: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    pub initialize_params: Option<InstanceFromTemplateStatusAtProviderBootDiskInitializeParams>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    pub kms_key_self_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderBootDiskInitializeParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    pub provisioned_iops: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    pub provisioned_throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderConfidentialInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    pub confidential_instance_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderNetworkInterface {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    pub access_config: Option<Vec<InstanceFromTemplateStatusAtProviderNetworkInterfaceAccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    pub alias_ip_range: Option<Vec<InstanceFromTemplateStatusAtProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    pub internal_ipv6_prefix_length: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    pub ipv6_access_config: Option<Vec<InstanceFromTemplateStatusAtProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessType")]
    pub ipv6_access_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    pub ipv6_address: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    pub network_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    pub nic_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    pub queue_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    pub stack_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnetwork: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    pub subnetwork_project: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderNetworkInterfaceAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    pub nat_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderNetworkInterfaceAliasIpRange {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    pub ip_cidr_range: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderNetworkInterfaceIpv6AccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    pub external_ipv6: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    pub network_tier: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderNetworkPerformanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    pub total_egress_bandwidth_tier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderParams {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderReservationAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    pub specific_reservation: Option<InstanceFromTemplateStatusAtProviderReservationAffinitySpecificReservation>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderReservationAffinitySpecificReservation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderScheduling {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    pub automatic_restart: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    pub instance_termination_action: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    pub local_ssd_recovery_timeout: Option<InstanceFromTemplateStatusAtProviderSchedulingLocalSsdRecoveryTimeout>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    pub max_run_duration: Option<InstanceFromTemplateStatusAtProviderSchedulingMaxRunDuration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    pub min_node_cpus: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    pub node_affinities: Option<Vec<InstanceFromTemplateStatusAtProviderSchedulingNodeAffinities>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    pub on_host_maintenance: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    pub on_instance_stop_action: Option<InstanceFromTemplateStatusAtProviderSchedulingOnInstanceStopAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preemptible: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    pub provisioning_model: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderSchedulingLocalSsdRecoveryTimeout {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderSchedulingMaxRunDuration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nanos: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderSchedulingNodeAffinities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderSchedulingOnInstanceStopAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderScratchDisk {
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interface: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderServiceAccount {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceFromTemplateStatusAtProviderShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    pub enable_secure_boot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    pub enable_vtpm: Option<bool>,
}

