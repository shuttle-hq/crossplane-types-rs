// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// SecurityPolicySpec defines the desired state of SecurityPolicy
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "SecurityPolicy", plural = "securitypolicies")]
#[kube(status = "SecurityPolicyStatus")]
pub struct SecurityPolicySpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<SecurityPolicyDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: SecurityPolicyForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<SecurityPolicyInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<SecurityPolicyProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<SecurityPolicyPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<SecurityPolicyWriteConnectionSecretToRef>,
}

/// SecurityPolicySpec defines the desired state of SecurityPolicy
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SecurityPolicyDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProvider {
    /// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adaptiveProtectionConfig")]
    pub adaptive_protection_config: Option<SecurityPolicyForProviderAdaptiveProtectionConfig>,
    /// Advanced Configuration Options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedOptionsConfig")]
    pub advanced_options_config: Option<SecurityPolicyForProviderAdvancedOptionsConfig>,
    /// An optional description of this security policy. Max size is 2048.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// reCAPTCHA Configuration Options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptionsConfig")]
    pub recaptcha_options_config: Option<SecurityPolicyForProviderRecaptchaOptionsConfig>,
    /// The set of rules that belong to this policy. There must always be a default
    /// rule (rule with priority 2147483647 and match "*"). If no rules are provided when creating a
    /// security policy, a default rule with action "allow" will be added. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rule: Option<Vec<SecurityPolicyForProviderRule>>,
    /// The type indicates the intended use of the security policy. This field can be set only at resource creation time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderAdaptiveProtectionConfig {
    /// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "layer7DdosDefenseConfig")]
    pub layer7_ddos_defense_config: Option<SecurityPolicyForProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig>,
}

/// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig {
    /// If set to true, enables CAAP for L7 DDoS detection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Rule visibility can be one of the following:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleVisibility")]
    pub rule_visibility: Option<String>,
}

/// Advanced Configuration Options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderAdvancedOptionsConfig {
    /// Custom configuration to apply the JSON parsing. Only applicable when
    /// json_parsing is set to STANDARD. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonCustomConfig")]
    pub json_custom_config: Option<SecurityPolicyForProviderAdvancedOptionsConfigJsonCustomConfig>,
    /// Whether or not to JSON parse the payload body. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonParsing")]
    pub json_parsing: Option<String>,
    /// Log level to use. Defaults to NORMAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// An optional list of case-insensitive request header names to use for resolving the callers client IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userIpRequestHeaders")]
    pub user_ip_request_headers: Option<Vec<String>>,
}

/// Custom configuration to apply the JSON parsing. Only applicable when
/// json_parsing is set to STANDARD. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderAdvancedOptionsConfigJsonCustomConfig {
    /// A list of custom Content-Type header values to apply the JSON parsing. The
    /// format of the Content-Type header values is defined in
    /// RFC 1341. When configuring a custom Content-Type header
    /// value, only the type/subtype needs to be specified, and the parameters should be excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentTypes")]
    pub content_types: Option<Vec<String>>,
}

/// reCAPTCHA Configuration Options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRecaptchaOptionsConfig {
    /// A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectSiteKey")]
    pub redirect_site_key: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRule {
    /// Action to take when match matches the request. Valid values:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// An optional description of this rule. Max size is 64.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Additional actions that are performed on headers. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    pub header_action: Option<SecurityPolicyForProviderRuleHeaderAction>,
    /// A match condition that incoming traffic is evaluated against.
    /// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<SecurityPolicyForProviderRuleMatch>,
    /// When set to true, the action specified above is not enforced.
    /// Stackdriver logs for requests that trigger a preview action are annotated as such.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preview: Option<bool>,
    /// An unique positive integer indicating the priority of evaluation for a rule.
    /// Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<f64>,
    /// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitOptions")]
    pub rate_limit_options: Option<SecurityPolicyForProviderRuleRateLimitOptions>,
    /// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectOptions")]
    pub redirect_options: Option<SecurityPolicyForProviderRuleRedirectOptions>,
}

/// Additional actions that are performed on headers. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleHeaderAction {
    /// The list of request headers to add or overwrite if they're already present. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdds")]
    pub request_headers_to_adds: Option<Vec<SecurityPolicyForProviderRuleHeaderActionRequestHeadersToAdds>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleHeaderActionRequestHeadersToAdds {
    /// The name of the header to set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
    /// The value to set the named header to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    pub header_value: Option<String>,
}

/// A match condition that incoming traffic is evaluated against.
/// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleMatch {
    /// The configuration options available when specifying versioned_expr.
    /// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<SecurityPolicyForProviderRuleMatchConfig>,
    /// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
    /// such as origin.ip, source.region_code and contents in the request header.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expr: Option<SecurityPolicyForProviderRuleMatchExpr>,
    /// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exprOptions")]
    pub expr_options: Option<SecurityPolicyForProviderRuleMatchExprOptions>,
    /// Predefined rule expression. If this field is specified, config must also be specified.
    /// Available options:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionedExpr")]
    pub versioned_expr: Option<String>,
}

/// The configuration options available when specifying versioned_expr.
/// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleMatchConfig {
    /// Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
    /// to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of * matches all IPs
    /// (can be used to override the default behavior).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "srcIpRanges")]
    pub src_ip_ranges: Option<Vec<String>>,
}

/// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
/// such as origin.ip, source.region_code and contents in the request header.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleMatchExpr {
    /// Textual representation of an expression in Common Expression Language syntax.
    /// The application context of the containing message determines which well-known feature set of CEL is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleMatchExprOptions {
    /// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptions")]
    pub recaptcha_options: Option<SecurityPolicyForProviderRuleMatchExprOptionsRecaptchaOptions>,
}

/// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleMatchExprOptionsRecaptchaOptions {
    /// A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "actionTokenSiteKeys")]
    pub action_token_site_keys: Option<Vec<String>>,
    /// A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSiteKeys")]
    pub session_token_site_keys: Option<Vec<String>>,
}

/// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleRateLimitOptions {
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banDurationSec")]
    pub ban_duration_sec: Option<f64>,
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
    /// exceed this ban_threshold. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banThreshold")]
    pub ban_threshold: Option<SecurityPolicyForProviderRuleRateLimitOptionsBanThreshold>,
    /// Action to take for requests that are under the configured rate limit threshold. Valid option is allow only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conformAction")]
    pub conform_action: Option<String>,
    /// Determines the key to enforce the rate_limit_threshold on. If not specified, defaults to ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKey")]
    pub enforce_on_key: Option<String>,
    /// Rate limit key name applicable only for the following key types:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKeyName")]
    pub enforce_on_key_name: Option<String>,
    /// When a request is denied, returns the HTTP response code specified.
    /// Valid options are deny() where valid values for status are 403, 404, 429, and 502.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedAction")]
    pub exceed_action: Option<String>,
    /// block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedRedirectOptions")]
    pub exceed_redirect_options: Option<SecurityPolicyForProviderRuleRateLimitOptionsExceedRedirectOptions>,
    /// Threshold at which to begin ratelimiting. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitThreshold")]
    pub rate_limit_threshold: Option<SecurityPolicyForProviderRuleRateLimitOptionsRateLimitThreshold>,
}

/// Can only be specified if the action for the rule is rate_based_ban.
/// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
/// exceed this ban_threshold. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleRateLimitOptionsBanThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// block supports:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleRateLimitOptionsExceedRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Threshold at which to begin ratelimiting. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleRateLimitOptionsRateLimitThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyForProviderRuleRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProvider {
    /// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adaptiveProtectionConfig")]
    pub adaptive_protection_config: Option<SecurityPolicyInitProviderAdaptiveProtectionConfig>,
    /// Advanced Configuration Options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedOptionsConfig")]
    pub advanced_options_config: Option<SecurityPolicyInitProviderAdvancedOptionsConfig>,
    /// An optional description of this security policy. Max size is 2048.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// reCAPTCHA Configuration Options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptionsConfig")]
    pub recaptcha_options_config: Option<SecurityPolicyInitProviderRecaptchaOptionsConfig>,
    /// The set of rules that belong to this policy. There must always be a default
    /// rule (rule with priority 2147483647 and match "*"). If no rules are provided when creating a
    /// security policy, a default rule with action "allow" will be added. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rule: Option<Vec<SecurityPolicyInitProviderRule>>,
    /// The type indicates the intended use of the security policy. This field can be set only at resource creation time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderAdaptiveProtectionConfig {
    /// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "layer7DdosDefenseConfig")]
    pub layer7_ddos_defense_config: Option<SecurityPolicyInitProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig>,
}

/// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig {
    /// If set to true, enables CAAP for L7 DDoS detection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Rule visibility can be one of the following:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleVisibility")]
    pub rule_visibility: Option<String>,
}

/// Advanced Configuration Options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderAdvancedOptionsConfig {
    /// Custom configuration to apply the JSON parsing. Only applicable when
    /// json_parsing is set to STANDARD. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonCustomConfig")]
    pub json_custom_config: Option<SecurityPolicyInitProviderAdvancedOptionsConfigJsonCustomConfig>,
    /// Whether or not to JSON parse the payload body. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonParsing")]
    pub json_parsing: Option<String>,
    /// Log level to use. Defaults to NORMAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// An optional list of case-insensitive request header names to use for resolving the callers client IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userIpRequestHeaders")]
    pub user_ip_request_headers: Option<Vec<String>>,
}

/// Custom configuration to apply the JSON parsing. Only applicable when
/// json_parsing is set to STANDARD. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderAdvancedOptionsConfigJsonCustomConfig {
    /// A list of custom Content-Type header values to apply the JSON parsing. The
    /// format of the Content-Type header values is defined in
    /// RFC 1341. When configuring a custom Content-Type header
    /// value, only the type/subtype needs to be specified, and the parameters should be excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentTypes")]
    pub content_types: Option<Vec<String>>,
}

/// reCAPTCHA Configuration Options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRecaptchaOptionsConfig {
    /// A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectSiteKey")]
    pub redirect_site_key: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRule {
    /// Action to take when match matches the request. Valid values:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// An optional description of this rule. Max size is 64.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Additional actions that are performed on headers. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    pub header_action: Option<SecurityPolicyInitProviderRuleHeaderAction>,
    /// A match condition that incoming traffic is evaluated against.
    /// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<SecurityPolicyInitProviderRuleMatch>,
    /// When set to true, the action specified above is not enforced.
    /// Stackdriver logs for requests that trigger a preview action are annotated as such.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preview: Option<bool>,
    /// An unique positive integer indicating the priority of evaluation for a rule.
    /// Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<f64>,
    /// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitOptions")]
    pub rate_limit_options: Option<SecurityPolicyInitProviderRuleRateLimitOptions>,
    /// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectOptions")]
    pub redirect_options: Option<SecurityPolicyInitProviderRuleRedirectOptions>,
}

/// Additional actions that are performed on headers. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleHeaderAction {
    /// The list of request headers to add or overwrite if they're already present. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdds")]
    pub request_headers_to_adds: Option<Vec<SecurityPolicyInitProviderRuleHeaderActionRequestHeadersToAdds>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleHeaderActionRequestHeadersToAdds {
    /// The name of the header to set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
    /// The value to set the named header to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    pub header_value: Option<String>,
}

/// A match condition that incoming traffic is evaluated against.
/// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleMatch {
    /// The configuration options available when specifying versioned_expr.
    /// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<SecurityPolicyInitProviderRuleMatchConfig>,
    /// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
    /// such as origin.ip, source.region_code and contents in the request header.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expr: Option<SecurityPolicyInitProviderRuleMatchExpr>,
    /// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exprOptions")]
    pub expr_options: Option<SecurityPolicyInitProviderRuleMatchExprOptions>,
    /// Predefined rule expression. If this field is specified, config must also be specified.
    /// Available options:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionedExpr")]
    pub versioned_expr: Option<String>,
}

/// The configuration options available when specifying versioned_expr.
/// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleMatchConfig {
    /// Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
    /// to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of * matches all IPs
    /// (can be used to override the default behavior).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "srcIpRanges")]
    pub src_ip_ranges: Option<Vec<String>>,
}

/// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
/// such as origin.ip, source.region_code and contents in the request header.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleMatchExpr {
    /// Textual representation of an expression in Common Expression Language syntax.
    /// The application context of the containing message determines which well-known feature set of CEL is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleMatchExprOptions {
    /// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptions")]
    pub recaptcha_options: Option<SecurityPolicyInitProviderRuleMatchExprOptionsRecaptchaOptions>,
}

/// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleMatchExprOptionsRecaptchaOptions {
    /// A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "actionTokenSiteKeys")]
    pub action_token_site_keys: Option<Vec<String>>,
    /// A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSiteKeys")]
    pub session_token_site_keys: Option<Vec<String>>,
}

/// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleRateLimitOptions {
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banDurationSec")]
    pub ban_duration_sec: Option<f64>,
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
    /// exceed this ban_threshold. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banThreshold")]
    pub ban_threshold: Option<SecurityPolicyInitProviderRuleRateLimitOptionsBanThreshold>,
    /// Action to take for requests that are under the configured rate limit threshold. Valid option is allow only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conformAction")]
    pub conform_action: Option<String>,
    /// Determines the key to enforce the rate_limit_threshold on. If not specified, defaults to ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKey")]
    pub enforce_on_key: Option<String>,
    /// Rate limit key name applicable only for the following key types:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKeyName")]
    pub enforce_on_key_name: Option<String>,
    /// When a request is denied, returns the HTTP response code specified.
    /// Valid options are deny() where valid values for status are 403, 404, 429, and 502.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedAction")]
    pub exceed_action: Option<String>,
    /// block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedRedirectOptions")]
    pub exceed_redirect_options: Option<SecurityPolicyInitProviderRuleRateLimitOptionsExceedRedirectOptions>,
    /// Threshold at which to begin ratelimiting. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitThreshold")]
    pub rate_limit_threshold: Option<SecurityPolicyInitProviderRuleRateLimitOptionsRateLimitThreshold>,
}

/// Can only be specified if the action for the rule is rate_based_ban.
/// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
/// exceed this ban_threshold. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleRateLimitOptionsBanThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// block supports:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleRateLimitOptionsExceedRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Threshold at which to begin ratelimiting. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleRateLimitOptionsRateLimitThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyInitProviderRuleRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SecurityPolicyProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SecurityPolicyProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SecurityPolicyProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SecurityPolicyProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SecurityPolicyProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<SecurityPolicyPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<SecurityPolicyPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SecurityPolicyPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SecurityPolicyPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SecurityPolicyPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SecurityPolicyPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SecurityPolicyPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// SecurityPolicyStatus defines the observed state of SecurityPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<SecurityPolicyStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProvider {
    /// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adaptiveProtectionConfig")]
    pub adaptive_protection_config: Option<SecurityPolicyStatusAtProviderAdaptiveProtectionConfig>,
    /// Advanced Configuration Options.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedOptionsConfig")]
    pub advanced_options_config: Option<SecurityPolicyStatusAtProviderAdvancedOptionsConfig>,
    /// An optional description of this security policy. Max size is 2048.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Fingerprint of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/global/securityPolicies/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// reCAPTCHA Configuration Options. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptionsConfig")]
    pub recaptcha_options_config: Option<SecurityPolicyStatusAtProviderRecaptchaOptionsConfig>,
    /// The set of rules that belong to this policy. There must always be a default
    /// rule (rule with priority 2147483647 and match "*"). If no rules are provided when creating a
    /// security policy, a default rule with action "allow" will be added. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rule: Option<Vec<SecurityPolicyStatusAtProviderRule>>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    pub self_link: Option<String>,
    /// The type indicates the intended use of the security policy. This field can be set only at resource creation time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration for Google Cloud Armor Adaptive Protection. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderAdaptiveProtectionConfig {
    /// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "layer7DdosDefenseConfig")]
    pub layer7_ddos_defense_config: Option<SecurityPolicyStatusAtProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig>,
}

/// Configuration for Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderAdaptiveProtectionConfigLayer7DdosDefenseConfig {
    /// If set to true, enables CAAP for L7 DDoS detection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Rule visibility can be one of the following:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleVisibility")]
    pub rule_visibility: Option<String>,
}

/// Advanced Configuration Options.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderAdvancedOptionsConfig {
    /// Custom configuration to apply the JSON parsing. Only applicable when
    /// json_parsing is set to STANDARD. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonCustomConfig")]
    pub json_custom_config: Option<SecurityPolicyStatusAtProviderAdvancedOptionsConfigJsonCustomConfig>,
    /// Whether or not to JSON parse the payload body. Defaults to DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonParsing")]
    pub json_parsing: Option<String>,
    /// Log level to use. Defaults to NORMAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// An optional list of case-insensitive request header names to use for resolving the callers client IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userIpRequestHeaders")]
    pub user_ip_request_headers: Option<Vec<String>>,
}

/// Custom configuration to apply the JSON parsing. Only applicable when
/// json_parsing is set to STANDARD. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderAdvancedOptionsConfigJsonCustomConfig {
    /// A list of custom Content-Type header values to apply the JSON parsing. The
    /// format of the Content-Type header values is defined in
    /// RFC 1341. When configuring a custom Content-Type header
    /// value, only the type/subtype needs to be specified, and the parameters should be excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentTypes")]
    pub content_types: Option<Vec<String>>,
}

/// reCAPTCHA Configuration Options. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRecaptchaOptionsConfig {
    /// A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectSiteKey")]
    pub redirect_site_key: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRule {
    /// Action to take when match matches the request. Valid values:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// An optional description of this rule. Max size is 64.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Additional actions that are performed on headers. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    pub header_action: Option<SecurityPolicyStatusAtProviderRuleHeaderAction>,
    /// A match condition that incoming traffic is evaluated against.
    /// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<SecurityPolicyStatusAtProviderRuleMatch>,
    /// When set to true, the action specified above is not enforced.
    /// Stackdriver logs for requests that trigger a preview action are annotated as such.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preview: Option<bool>,
    /// An unique positive integer indicating the priority of evaluation for a rule.
    /// Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<f64>,
    /// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitOptions")]
    pub rate_limit_options: Option<SecurityPolicyStatusAtProviderRuleRateLimitOptions>,
    /// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectOptions")]
    pub redirect_options: Option<SecurityPolicyStatusAtProviderRuleRedirectOptions>,
}

/// Additional actions that are performed on headers. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleHeaderAction {
    /// The list of request headers to add or overwrite if they're already present. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdds")]
    pub request_headers_to_adds: Option<Vec<SecurityPolicyStatusAtProviderRuleHeaderActionRequestHeadersToAdds>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleHeaderActionRequestHeadersToAdds {
    /// The name of the header to set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
    /// The value to set the named header to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    pub header_value: Option<String>,
}

/// A match condition that incoming traffic is evaluated against.
/// If it evaluates to true, the corresponding action is enforced. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleMatch {
    /// The configuration options available when specifying versioned_expr.
    /// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<SecurityPolicyStatusAtProviderRuleMatchConfig>,
    /// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
    /// such as origin.ip, source.region_code and contents in the request header.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expr: Option<SecurityPolicyStatusAtProviderRuleMatchExpr>,
    /// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exprOptions")]
    pub expr_options: Option<SecurityPolicyStatusAtProviderRuleMatchExprOptions>,
    /// Predefined rule expression. If this field is specified, config must also be specified.
    /// Available options:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionedExpr")]
    pub versioned_expr: Option<String>,
}

/// The configuration options available when specifying versioned_expr.
/// This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleMatchConfig {
    /// Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
    /// to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of * matches all IPs
    /// (can be used to override the default behavior).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "srcIpRanges")]
    pub src_ip_ranges: Option<Vec<String>>,
}

/// User defined CEVAL expression. A CEVAL expression is used to specify match criteria
/// such as origin.ip, source.region_code and contents in the request header.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleMatchExpr {
    /// Textual representation of an expression in Common Expression Language syntax.
    /// The application context of the containing message determines which well-known feature set of CEL is supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleMatchExprOptions {
    /// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recaptchaOptions")]
    pub recaptcha_options: Option<SecurityPolicyStatusAtProviderRuleMatchExprOptionsRecaptchaOptions>,
}

/// reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleMatchExprOptionsRecaptchaOptions {
    /// A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "actionTokenSiteKeys")]
    pub action_token_site_keys: Option<Vec<String>>,
    /// A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSiteKeys")]
    pub session_token_site_keys: Option<Vec<String>>,
}

/// Must be specified if the action is rate_based_ban or throttle. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleRateLimitOptions {
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banDurationSec")]
    pub ban_duration_sec: Option<f64>,
    /// Can only be specified if the action for the rule is rate_based_ban.
    /// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
    /// exceed this ban_threshold. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "banThreshold")]
    pub ban_threshold: Option<SecurityPolicyStatusAtProviderRuleRateLimitOptionsBanThreshold>,
    /// Action to take for requests that are under the configured rate limit threshold. Valid option is allow only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conformAction")]
    pub conform_action: Option<String>,
    /// Determines the key to enforce the rate_limit_threshold on. If not specified, defaults to ALL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKey")]
    pub enforce_on_key: Option<String>,
    /// Rate limit key name applicable only for the following key types:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforceOnKeyName")]
    pub enforce_on_key_name: Option<String>,
    /// When a request is denied, returns the HTTP response code specified.
    /// Valid options are deny() where valid values for status are 403, 404, 429, and 502.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedAction")]
    pub exceed_action: Option<String>,
    /// block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exceedRedirectOptions")]
    pub exceed_redirect_options: Option<SecurityPolicyStatusAtProviderRuleRateLimitOptionsExceedRedirectOptions>,
    /// Threshold at which to begin ratelimiting. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitThreshold")]
    pub rate_limit_threshold: Option<SecurityPolicyStatusAtProviderRuleRateLimitOptionsRateLimitThreshold>,
}

/// Can only be specified if the action for the rule is rate_based_ban.
/// If specified, the key will be banned for the configured ban_duration_sec when the number of requests that exceed the rate_limit_threshold also
/// exceed this ban_threshold. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleRateLimitOptionsBanThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// block supports:
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleRateLimitOptionsExceedRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Threshold at which to begin ratelimiting. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleRateLimitOptionsRateLimitThreshold {
    /// Number of HTTP(S) requests for calculating the threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// Interval over which the threshold is computed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSec")]
    pub interval_sec: Option<f64>,
}

/// Can be specified if the action is redirect. Cannot be specified for other actions. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SecurityPolicyStatusAtProviderRuleRedirectOptions {
    /// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// Type of the redirect action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

