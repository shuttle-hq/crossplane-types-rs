// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RegionPerInstanceConfigSpec defines the desired state of RegionPerInstanceConfig
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "RegionPerInstanceConfig", plural = "regionperinstanceconfigs")]
#[kube(status = "RegionPerInstanceConfigStatus")]
pub struct RegionPerInstanceConfigSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<RegionPerInstanceConfigDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RegionPerInstanceConfigForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<RegionPerInstanceConfigInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<RegionPerInstanceConfigProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<RegionPerInstanceConfigPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<RegionPerInstanceConfigWriteConnectionSecretToRef>,
}

/// RegionPerInstanceConfigSpec defines the desired state of RegionPerInstanceConfig
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProvider {
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    pub preserved_state: Option<RegionPerInstanceConfigForProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Region where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// The region instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManager")]
    pub region_instance_group_manager: Option<String>,
    /// Reference to a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManagerRef")]
    pub region_instance_group_manager_ref: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRef>,
    /// Selector for a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManagerSelector")]
    pub region_instance_group_manager_selector: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelector>,
    /// Reference to a RegionInstanceGroupManager in compute to populate region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionRef")]
    pub region_ref: Option<RegionPerInstanceConfigForProviderRegionRef>,
    /// Selector for a RegionInstanceGroupManager in compute to populate region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionSelector")]
    pub region_selector: Option<RegionPerInstanceConfigForProviderRegionSelector>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    pub remove_instance_state_on_destroy: Option<bool>,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disk: Option<Vec<RegionPerInstanceConfigForProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    pub external_ip: Option<Vec<RegionPerInstanceConfigForProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    pub internal_ip: Option<Vec<RegionPerInstanceConfigForProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    pub source_ref: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    pub source_selector: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelector>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderPreservedStateDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderPreservedStateDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigForProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigForProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

/// Reference to a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionInstanceGroupManagerRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionInstanceGroupManagerSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RegionInstanceGroupManager in compute to populate region.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderRegionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderRegionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderRegionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionInstanceGroupManager in compute to populate region.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigForProviderRegionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigForProviderRegionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigForProviderRegionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigForProviderRegionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigForProviderRegionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProvider {
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    pub preserved_state: Option<RegionPerInstanceConfigInitProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Region where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// The region instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManager")]
    pub region_instance_group_manager: Option<String>,
    /// Reference to a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManagerRef")]
    pub region_instance_group_manager_ref: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRef>,
    /// Selector for a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManagerSelector")]
    pub region_instance_group_manager_selector: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelector>,
    /// Reference to a RegionInstanceGroupManager in compute to populate region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionRef")]
    pub region_ref: Option<RegionPerInstanceConfigInitProviderRegionRef>,
    /// Selector for a RegionInstanceGroupManager in compute to populate region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionSelector")]
    pub region_selector: Option<RegionPerInstanceConfigInitProviderRegionSelector>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    pub remove_instance_state_on_destroy: Option<bool>,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disk: Option<Vec<RegionPerInstanceConfigInitProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    pub external_ip: Option<Vec<RegionPerInstanceConfigInitProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    pub internal_ip: Option<Vec<RegionPerInstanceConfigInitProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Reference to a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    pub source_ref: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRef>,
    /// Selector for a Disk in compute to populate source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSelector")]
    pub source_selector: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelector>,
}

/// Reference to a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderPreservedStateDiskSourceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Disk in compute to populate source.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderPreservedStateDiskSourceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigInitProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigInitProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

/// Reference to a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionInstanceGroupManager in compute to populate regionInstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionInstanceGroupManagerSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RegionInstanceGroupManager in compute to populate region.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderRegionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderRegionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderRegionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegionInstanceGroupManager in compute to populate region.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigInitProviderRegionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigInitProviderRegionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigInitProviderRegionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigInitProviderRegionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigInitProviderRegionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<RegionPerInstanceConfigPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<RegionPerInstanceConfigPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RegionPerInstanceConfigPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RegionPerInstanceConfigStatus defines the observed state of RegionPerInstanceConfig.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<RegionPerInstanceConfigStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProvider {
    /// an identifier for the resource with format {{project}}/{{region}}/{{region_instance_group_manager}}/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The minimal action to perform on the instance during an update.
    /// Default is NONE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// The most disruptive action to perform on the instance during an update.
    /// Default is REPLACE. Possible values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// The name for this per-instance config and its corresponding instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The preserved state for this instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservedState")]
    pub preserved_state: Option<RegionPerInstanceConfigStatusAtProviderPreservedState>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Region where the containing instance group manager is located
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// The region instance group manager this instance config is part of.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regionInstanceGroupManager")]
    pub region_instance_group_manager: Option<String>,
    /// When true, deleting this config will immediately remove the underlying instance.
    /// When false, deleting this config will use the behavior as determined by remove_instance_on_destroy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceOnDestroy")]
    pub remove_instance_on_destroy: Option<bool>,
    /// When true, deleting this config will immediately remove any specified state from the underlying instance.
    /// When false, deleting this config will not immediately remove any state from the underlying instance.
    /// State will be removed on the next instance recreation or update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeInstanceStateOnDestroy")]
    pub remove_instance_state_on_destroy: Option<bool>,
}

/// The preserved state for this instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedState {
    /// Stateful disks for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disk: Option<Vec<RegionPerInstanceConfigStatusAtProviderPreservedStateDisk>>,
    /// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIp")]
    pub external_ip: Option<Vec<RegionPerInstanceConfigStatusAtProviderPreservedStateExternalIp>>,
    /// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIp")]
    pub internal_ip: Option<Vec<RegionPerInstanceConfigStatusAtProviderPreservedStateInternalIp>>,
    /// Preserved metadata defined for this instance. This is a list of key->value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedStateDisk {
    /// A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
    /// The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION.
    /// NEVER - detach the disk when the VM is deleted, but do not delete the disk.
    /// ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently
    /// deleted from the instance group.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// The mode of the disk.
    /// Default value is READ_WRITE.
    /// Possible values are: READ_ONLY, READ_WRITE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The URI of an existing persistent disk to attach under the specified device-name in the format
    /// projects/project-id/zones/zone/disks/disk-name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedStateExternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigStatusAtProviderPreservedStateExternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedStateExternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedStateInternalIp {
    /// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
    /// Default value is NEVER.
    /// Possible values are: NEVER, ON_PERMANENT_INSTANCE_DELETION.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    pub auto_delete: Option<String>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
    /// Ip address representation
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<RegionPerInstanceConfigStatusAtProviderPreservedStateInternalIpIpAddress>,
}

/// Ip address representation
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RegionPerInstanceConfigStatusAtProviderPreservedStateInternalIpIpAddress {
    /// The URL of the reservation for this IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

