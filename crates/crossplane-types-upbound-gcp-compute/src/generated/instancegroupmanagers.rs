// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InstanceGroupManagerSpec defines the desired state of InstanceGroupManager
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "InstanceGroupManager", plural = "instancegroupmanagers")]
#[kube(status = "InstanceGroupManagerStatus")]
pub struct InstanceGroupManagerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<InstanceGroupManagerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InstanceGroupManagerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<InstanceGroupManagerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<InstanceGroupManagerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<InstanceGroupManagerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<InstanceGroupManagerWriteConnectionSecretToRef>,
}

/// InstanceGroupManagerSpec defines the desired state of InstanceGroupManager
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    pub all_instances_config: Option<InstanceGroupManagerForProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    pub auto_healing_policies: Option<InstanceGroupManagerForProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    pub base_instance_name: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    pub instance_lifecycle_policy: Option<InstanceGroupManagerForProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    pub list_managed_instances_results: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    pub named_port: Option<Vec<InstanceGroupManagerForProviderNamedPort>>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    pub stateful_disk: Option<Vec<InstanceGroupManagerForProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    pub stateful_external_ip: Option<Vec<InstanceGroupManagerForProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    pub stateful_internal_ip: Option<Vec<InstanceGroupManagerForProviderStatefulInternalIp>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    pub target_pools: Option<Vec<String>>,
    /// References to TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsRefs")]
    pub target_pools_refs: Option<Vec<InstanceGroupManagerForProviderTargetPoolsRefs>>,
    /// Selector for a list of TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsSelector")]
    pub target_pools_selector: Option<InstanceGroupManagerForProviderTargetPoolsSelector>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<InstanceGroupManagerForProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<Vec<InstanceGroupManagerForProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    pub wait_for_instances_status: Option<String>,
    /// The zone that instances in this group should be created
    /// in.
    pub zone: String,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<String>,
    /// Reference to a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckRef")]
    pub health_check_ref: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRef>,
    /// Selector for a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckSelector")]
    pub health_check_selector: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelector>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    pub initial_delay_sec: Option<f64>,
}

/// Reference to a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderTargetPoolsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderTargetPoolsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderTargetPoolsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderTargetPoolsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderTargetPoolsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderTargetPoolsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderTargetPoolsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of TargetPool in compute to populate targetPools.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderTargetPoolsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderTargetPoolsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderTargetPoolsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderTargetPoolsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderUpdatePolicy {
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    pub instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateRef")]
    pub instance_template_ref: Option<InstanceGroupManagerForProviderVersionInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateSelector")]
    pub instance_template_selector: Option<InstanceGroupManagerForProviderVersionInstanceTemplateSelector>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<InstanceGroupManagerForProviderVersionTargetSize>,
}

/// Reference to a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersionInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderVersionInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersionInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerForProviderVersionInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerForProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<f64>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    pub all_instances_config: Option<InstanceGroupManagerInitProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    pub auto_healing_policies: Option<InstanceGroupManagerInitProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    pub base_instance_name: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    pub instance_lifecycle_policy: Option<InstanceGroupManagerInitProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    pub list_managed_instances_results: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    pub named_port: Option<Vec<InstanceGroupManagerInitProviderNamedPort>>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    pub stateful_disk: Option<Vec<InstanceGroupManagerInitProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    pub stateful_external_ip: Option<Vec<InstanceGroupManagerInitProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    pub stateful_internal_ip: Option<Vec<InstanceGroupManagerInitProviderStatefulInternalIp>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    pub target_pools: Option<Vec<String>>,
    /// References to TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsRefs")]
    pub target_pools_refs: Option<Vec<InstanceGroupManagerInitProviderTargetPoolsRefs>>,
    /// Selector for a list of TargetPool in compute to populate targetPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPoolsSelector")]
    pub target_pools_selector: Option<InstanceGroupManagerInitProviderTargetPoolsSelector>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<InstanceGroupManagerInitProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<Vec<InstanceGroupManagerInitProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    pub wait_for_instances_status: Option<String>,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<String>,
    /// Reference to a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckRef")]
    pub health_check_ref: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRef>,
    /// Selector for a HealthCheck in compute to populate healthCheck.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckSelector")]
    pub health_check_selector: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelector>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    pub initial_delay_sec: Option<f64>,
}

/// Reference to a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in compute to populate healthCheck.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderAutoHealingPoliciesHealthCheckSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderTargetPoolsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderTargetPoolsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderTargetPoolsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderTargetPoolsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of TargetPool in compute to populate targetPools.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderTargetPoolsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderTargetPoolsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderTargetPoolsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderTargetPoolsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderUpdatePolicy {
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    pub instance_template: Option<String>,
    /// Reference to a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateRef")]
    pub instance_template_ref: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateRef>,
    /// Selector for a InstanceTemplate in compute to populate instanceTemplate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplateSelector")]
    pub instance_template_selector: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateSelector>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<InstanceGroupManagerInitProviderVersionTargetSize>,
}

/// Reference to a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersionInstanceTemplateRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderVersionInstanceTemplateRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceTemplate in compute to populate instanceTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersionInstanceTemplateSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerInitProviderVersionInstanceTemplateSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerInitProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<f64>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<InstanceGroupManagerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstanceGroupManagerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceGroupManagerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InstanceGroupManagerStatus defines the observed state of InstanceGroupManager.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<InstanceGroupManagerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProvider {
    /// Properties to set on all instances in the group. After setting
    /// allInstancesConfig on the group, you must update the group's instances to
    /// apply the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    pub all_instances_config: Option<InstanceGroupManagerStatusAtProviderAllInstancesConfig>,
    /// The autohealing policies for this managed instance
    /// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoHealingPolicies")]
    pub auto_healing_policies: Option<InstanceGroupManagerStatusAtProviderAutoHealingPolicies>,
    /// The base instance name to use for
    /// instances in this group. The value must be a valid
    /// RFC1035 name. Supported characters
    /// are lowercase letters, numbers, and hyphens (-). Instances are named by
    /// appending a hyphen and a random four-character string to the base instance
    /// name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseInstanceName")]
    pub base_instance_name: Option<String>,
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    pub creation_timestamp: Option<String>,
    /// An optional textual description of the instance
    /// group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The fingerprint of the instance group manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fingerprint: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The full URL of the instance group created by the manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroup")]
    pub instance_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceLifecyclePolicy")]
    pub instance_lifecycle_policy: Option<InstanceGroupManagerStatusAtProviderInstanceLifecyclePolicy>,
    /// Pagination behavior of the listManagedInstances API
    /// method for this managed instance group. Valid values are: PAGELESS, PAGINATED.
    /// If PAGELESS (default), Pagination is disabled for the group's listManagedInstances API method.
    /// maxResults and pageToken query parameters are ignored and all instances are returned in a single
    /// response. If PAGINATED, pagination is enabled, maxResults and pageToken query parameters are
    /// respected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listManagedInstancesResults")]
    pub list_managed_instances_results: Option<String>,
    /// The named port configuration. See the section below
    /// for details on configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namedPort")]
    pub named_port: Option<Vec<InstanceGroupManagerStatusAtProviderNamedPort>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// The URL of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    pub self_link: Option<String>,
    /// Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the official documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulDisk")]
    pub stateful_disk: Option<Vec<InstanceGroupManagerStatusAtProviderStatefulDisk>>,
    /// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulExternalIp")]
    pub stateful_external_ip: Option<Vec<InstanceGroupManagerStatusAtProviderStatefulExternalIp>>,
    /// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulInternalIp")]
    pub stateful_internal_ip: Option<Vec<InstanceGroupManagerStatusAtProviderStatefulInternalIp>>,
    /// The status of this managed instance group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Vec<InstanceGroupManagerStatusAtProviderStatus>>,
    /// The full URL of all target pools to which new
    /// instances in the group are added. Updating the target pools attribute does
    /// not affect existing instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPools")]
    pub target_pools: Option<Vec<String>>,
    /// The target number of running instances for this managed
    /// instance group. This value will fight with autoscaler settings when set, and generally shouldn't be set
    /// when using one. If a value is required, such as to specify a creation-time target size for the MIG,
    /// lifecycle. Defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<f64>,
    /// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<InstanceGroupManagerStatusAtProviderUpdatePolicy>,
    /// Application versions managed by this instance group. Each
    /// version deals with a specific instance template, allowing canary release scenarios.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<Vec<InstanceGroupManagerStatusAtProviderVersion>>,
    /// Whether to wait for all instances to be created/updated before
    /// returning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstances")]
    pub wait_for_instances: Option<bool>,
    /// When used with wait_for_instances it specifies the status to wait for.
    /// When STABLE is specified this resource will wait until the instances are stable before returning. When UPDATED is
    /// set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
    /// instances to be stable before returning. The possible values are STABLE and UPDATED
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForInstancesStatus")]
    pub wait_for_instances_status: Option<String>,
    /// The zone that instances in this group should be created
    /// in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

/// Properties to set on all instances in the group. After setting
/// allInstancesConfig on the group, you must update the group's instances to
/// apply the configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderAllInstancesConfig {
    /// , The label key-value pairs that you want to patch onto the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// , The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

/// The autohealing policies for this managed instance
/// group. You can specify only one value. Structure is documented below. For more information, see the official documentation.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderAutoHealingPolicies {
    /// The health check resource that signals autohealing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<String>,
    /// The number of seconds that the managed instance group waits before
    /// it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySec")]
    pub initial_delay_sec: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderInstanceLifecyclePolicy {
    /// , Default behavior for all instance or health check failures. Valid options are: REPAIR, DO_NOTHING. If DO_NOTHING then instances will not be repaired. If REPAIR (default), then failed instances will be repaired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultActionOnFailure")]
    pub default_action_on_failure: Option<String>,
    /// , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUpdateOnRepair")]
    pub force_update_on_repair: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderNamedPort {
    /// The name of the port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatefulDisk {
    /// , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The device name of the disk to be attached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatefulExternalIp {
    /// , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the external ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the external Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatefulInternalIp {
    /// , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the ip when the VM is deleted, but do not delete the ip. ON_PERMANENT_INSTANCE_DELETION will delete the internal ip when the VM is permanently deleted from the instance group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteRule")]
    pub delete_rule: Option<String>,
    /// , The network interface name of the internal Ip. Possible value: nic0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceName")]
    pub interface_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatus {
    /// Status of all-instances configuration on the group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInstancesConfig")]
    pub all_instances_config: Option<Vec<InstanceGroupManagerStatusAtProviderStatusAllInstancesConfig>>,
    /// A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isStable")]
    pub is_stable: Option<bool>,
    /// Stateful status of the given Instance Group Manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stateful: Option<Vec<InstanceGroupManagerStatusAtProviderStatusStateful>>,
    /// A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionTarget")]
    pub version_target: Option<Vec<InstanceGroupManagerStatusAtProviderStatusVersionTarget>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatusAllInstancesConfig {
    /// Current all-instances configuration revision. This value is in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentRevision")]
    pub current_revision: Option<String>,
    /// A bit indicating whether this configuration has been applied to all managed instances in the group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatusStateful {
    /// A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hasStatefulConfig")]
    pub has_stateful_config: Option<bool>,
    /// Status of per-instance configs on the instances.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perInstanceConfigs")]
    pub per_instance_configs: Option<Vec<InstanceGroupManagerStatusAtProviderStatusStatefulPerInstanceConfigs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatusStatefulPerInstanceConfigs {
    /// A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allEffective")]
    pub all_effective: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderStatusVersionTarget {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isReached")]
    pub is_reached: Option<bool>,
}

/// The update policy for this managed instance group. Structure is documented below. For more information, see the official documentation and API.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderUpdatePolicy {
    /// , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgeFixed")]
    pub max_surge_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurgePercent")]
    pub max_surge_percent: Option<f64>,
    /// , Specifies a fixed number of VM instances. This must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableFixed")]
    pub max_unavailable_fixed: Option<f64>,
    /// , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercent")]
    pub max_unavailable_percent: Option<f64>,
    /// - Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimalAction")]
    pub minimal_action: Option<String>,
    /// - Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mostDisruptiveAllowedAction")]
    pub most_disruptive_allowed_action: Option<String>,
    /// , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementMethod")]
    pub replacement_method: Option<String>,
    /// - The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderVersion {
    /// - The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (self_link_unique attribute).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTemplate")]
    pub instance_template: Option<String>,
    /// - Version name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSize")]
    pub target_size: Option<InstanceGroupManagerStatusAtProviderVersionTargetSize>,
}

/// - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InstanceGroupManagerStatusAtProviderVersionTargetSize {
    /// , The number of instances which are managed for this version. Conflicts with percent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fixed: Option<f64>,
    /// , The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed.
    /// Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions,
    /// one of which has a target_size.percent of 60 will create 2 instances of that version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<f64>,
}

