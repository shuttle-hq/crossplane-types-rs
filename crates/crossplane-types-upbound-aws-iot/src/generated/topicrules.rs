// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TopicRuleSpec defines the desired state of TopicRule
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "iot.aws.upbound.io", version = "v1beta2", kind = "TopicRule", plural = "topicrules")]
#[kube(status = "TopicRuleStatus")]
pub struct TopicRuleSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<TopicRuleDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TopicRuleForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<TopicRuleInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<TopicRuleProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<TopicRulePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<TopicRuleWriteConnectionSecretToRef>,
}

/// TopicRuleSpec defines the desired state of TopicRule
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProvider {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<Vec<TopicRuleForProviderCloudwatchAlarm>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<Vec<TopicRuleForProviderCloudwatchLogs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<Vec<TopicRuleForProviderCloudwatchMetric>>,
    /// The description of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<Vec<TopicRuleForProviderDynamodb>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<Vec<TopicRuleForProviderDynamodbv2>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<Vec<TopicRuleForProviderElasticsearch>>,
    /// Specifies whether the rule is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAction")]
    pub error_action: Option<TopicRuleForProviderErrorAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<Vec<TopicRuleForProviderFirehose>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<TopicRuleForProviderHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<Vec<TopicRuleForProviderIotAnalytics>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<Vec<TopicRuleForProviderIotEvents>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<TopicRuleForProviderKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<Vec<TopicRuleForProviderKinesis>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<Vec<TopicRuleForProviderLambda>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<Vec<TopicRuleForProviderRepublish>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<Vec<TopicRuleForProviderS3>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<Vec<TopicRuleForProviderSns>>,
    /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<String>,
    /// The version of the SQL rules engine to use when evaluating the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlVersion")]
    pub sql_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<Vec<TopicRuleForProviderSqs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<Vec<TopicRuleForProviderStepFunctions>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<Vec<TopicRuleForProviderTimestream>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleForProviderDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<TopicRuleForProviderErrorActionCloudwatchAlarm>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<TopicRuleForProviderErrorActionCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<TopicRuleForProviderErrorActionCloudwatchMetric>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<TopicRuleForProviderErrorActionDynamodb>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<TopicRuleForProviderErrorActionDynamodbv2>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TopicRuleForProviderErrorActionElasticsearch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<TopicRuleForProviderErrorActionFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<TopicRuleForProviderErrorActionHttp>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<TopicRuleForProviderErrorActionIotAnalytics>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<TopicRuleForProviderErrorActionIotEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<TopicRuleForProviderErrorActionKafka>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<TopicRuleForProviderErrorActionKinesis>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<TopicRuleForProviderErrorActionLambda>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<TopicRuleForProviderErrorActionRepublish>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<TopicRuleForProviderErrorActionS3>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<TopicRuleForProviderErrorActionSns>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<TopicRuleForProviderErrorActionSqs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<TopicRuleForProviderErrorActionStepFunctions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<TopicRuleForProviderErrorActionTimestream>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleForProviderErrorActionDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleForProviderErrorActionHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleForProviderErrorActionKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    pub role_arn_ref: Option<TopicRuleForProviderErrorActionSnsRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    pub role_arn_selector: Option<TopicRuleForProviderErrorActionSnsRoleArnSelector>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
    /// Reference to a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnRef")]
    pub target_arn_ref: Option<TopicRuleForProviderErrorActionSnsTargetArnRef>,
    /// Selector for a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnSelector")]
    pub target_arn_selector: Option<TopicRuleForProviderErrorActionSnsTargetArnSelector>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderErrorActionSnsRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderErrorActionSnsRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderErrorActionSnsRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderErrorActionSnsTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderErrorActionSnsTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderErrorActionSnsTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderErrorActionSnsTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleForProviderErrorActionTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleForProviderErrorActionTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderErrorActionTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleForProviderHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleForProviderKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    pub role_arn_ref: Option<TopicRuleForProviderSnsRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    pub role_arn_selector: Option<TopicRuleForProviderSnsRoleArnSelector>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
    /// Reference to a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnRef")]
    pub target_arn_ref: Option<TopicRuleForProviderSnsTargetArnRef>,
    /// Selector for a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnSelector")]
    pub target_arn_selector: Option<TopicRuleForProviderSnsTargetArnSelector>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderSnsRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderSnsRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderSnsRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderSnsRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderSnsRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderSnsRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderSnsTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderSnsTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderSnsTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleForProviderSnsTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSnsTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleForProviderSnsTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleForProviderSnsTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleForProviderSnsTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleForProviderTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleForProviderTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleForProviderTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProvider {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<Vec<TopicRuleInitProviderCloudwatchAlarm>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<Vec<TopicRuleInitProviderCloudwatchLogs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<Vec<TopicRuleInitProviderCloudwatchMetric>>,
    /// The description of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<Vec<TopicRuleInitProviderDynamodb>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<Vec<TopicRuleInitProviderDynamodbv2>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<Vec<TopicRuleInitProviderElasticsearch>>,
    /// Specifies whether the rule is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAction")]
    pub error_action: Option<TopicRuleInitProviderErrorAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<Vec<TopicRuleInitProviderFirehose>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<TopicRuleInitProviderHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<Vec<TopicRuleInitProviderIotAnalytics>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<Vec<TopicRuleInitProviderIotEvents>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<TopicRuleInitProviderKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<Vec<TopicRuleInitProviderKinesis>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<Vec<TopicRuleInitProviderLambda>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<Vec<TopicRuleInitProviderRepublish>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<Vec<TopicRuleInitProviderS3>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<Vec<TopicRuleInitProviderSns>>,
    /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<String>,
    /// The version of the SQL rules engine to use when evaluating the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlVersion")]
    pub sql_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<Vec<TopicRuleInitProviderSqs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<Vec<TopicRuleInitProviderStepFunctions>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<Vec<TopicRuleInitProviderTimestream>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleInitProviderDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<TopicRuleInitProviderErrorActionCloudwatchAlarm>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<TopicRuleInitProviderErrorActionCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<TopicRuleInitProviderErrorActionCloudwatchMetric>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<TopicRuleInitProviderErrorActionDynamodb>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<TopicRuleInitProviderErrorActionDynamodbv2>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TopicRuleInitProviderErrorActionElasticsearch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<TopicRuleInitProviderErrorActionFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<TopicRuleInitProviderErrorActionHttp>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<TopicRuleInitProviderErrorActionIotAnalytics>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<TopicRuleInitProviderErrorActionIotEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<TopicRuleInitProviderErrorActionKafka>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<TopicRuleInitProviderErrorActionKinesis>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<TopicRuleInitProviderErrorActionLambda>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<TopicRuleInitProviderErrorActionRepublish>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<TopicRuleInitProviderErrorActionS3>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<TopicRuleInitProviderErrorActionSns>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<TopicRuleInitProviderErrorActionSqs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<TopicRuleInitProviderErrorActionStepFunctions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<TopicRuleInitProviderErrorActionTimestream>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleInitProviderErrorActionDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleInitProviderErrorActionHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleInitProviderErrorActionKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    pub role_arn_ref: Option<TopicRuleInitProviderErrorActionSnsRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    pub role_arn_selector: Option<TopicRuleInitProviderErrorActionSnsRoleArnSelector>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
    /// Reference to a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnRef")]
    pub target_arn_ref: Option<TopicRuleInitProviderErrorActionSnsTargetArnRef>,
    /// Selector for a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnSelector")]
    pub target_arn_selector: Option<TopicRuleInitProviderErrorActionSnsTargetArnSelector>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderErrorActionSnsRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderErrorActionSnsRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderErrorActionSnsRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderErrorActionSnsTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderErrorActionSnsTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderErrorActionSnsTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderErrorActionSnsTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleInitProviderErrorActionTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleInitProviderErrorActionTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderErrorActionTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleInitProviderHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleInitProviderKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    pub role_arn_ref: Option<TopicRuleInitProviderSnsRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    pub role_arn_selector: Option<TopicRuleInitProviderSnsRoleArnSelector>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
    /// Reference to a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnRef")]
    pub target_arn_ref: Option<TopicRuleInitProviderSnsTargetArnRef>,
    /// Selector for a Topic in sns to populate targetArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArnSelector")]
    pub target_arn_selector: Option<TopicRuleInitProviderSnsTargetArnSelector>,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderSnsRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderSnsRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderSnsRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderSnsRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderSnsRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderSnsRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsTargetArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderSnsTargetArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsTargetArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderSnsTargetArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderSnsTargetArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsTargetArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsTargetArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in sns to populate targetArn.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsTargetArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleInitProviderSnsTargetArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSnsTargetArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleInitProviderSnsTargetArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleInitProviderSnsTargetArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsTargetArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleInitProviderSnsTargetArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleInitProviderTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleInitProviderTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleInitProviderTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRuleProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRuleProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRuleProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRuleProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRulePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<TopicRulePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TopicRulePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRulePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<TopicRulePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRulePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<TopicRulePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<TopicRulePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRulePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicRulePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRulePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TopicRuleStatus defines the observed state of TopicRule.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<TopicRuleStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProvider {
    /// The ARN of the topic rule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<Vec<TopicRuleStatusAtProviderCloudwatchAlarm>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<Vec<TopicRuleStatusAtProviderCloudwatchLogs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<Vec<TopicRuleStatusAtProviderCloudwatchMetric>>,
    /// The description of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<Vec<TopicRuleStatusAtProviderDynamodb>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<Vec<TopicRuleStatusAtProviderDynamodbv2>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<Vec<TopicRuleStatusAtProviderElasticsearch>>,
    /// Specifies whether the rule is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAction")]
    pub error_action: Option<TopicRuleStatusAtProviderErrorAction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<Vec<TopicRuleStatusAtProviderFirehose>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<TopicRuleStatusAtProviderHttp>>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<Vec<TopicRuleStatusAtProviderIotAnalytics>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<Vec<TopicRuleStatusAtProviderIotEvents>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<TopicRuleStatusAtProviderKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<Vec<TopicRuleStatusAtProviderKinesis>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<Vec<TopicRuleStatusAtProviderLambda>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<Vec<TopicRuleStatusAtProviderRepublish>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<Vec<TopicRuleStatusAtProviderS3>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<Vec<TopicRuleStatusAtProviderSns>>,
    /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<String>,
    /// The version of the SQL rules engine to use when evaluating the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlVersion")]
    pub sql_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<Vec<TopicRuleStatusAtProviderSqs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<Vec<TopicRuleStatusAtProviderStepFunctions>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<Vec<TopicRuleStatusAtProviderTimestream>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleStatusAtProviderDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorAction {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchAlarm")]
    pub cloudwatch_alarm: Option<TopicRuleStatusAtProviderErrorActionCloudwatchAlarm>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchLogs")]
    pub cloudwatch_logs: Option<TopicRuleStatusAtProviderErrorActionCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudwatchMetric")]
    pub cloudwatch_metric: Option<TopicRuleStatusAtProviderErrorActionCloudwatchMetric>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodb: Option<TopicRuleStatusAtProviderErrorActionDynamodb>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dynamodbv2: Option<TopicRuleStatusAtProviderErrorActionDynamodbv2>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TopicRuleStatusAtProviderErrorActionElasticsearch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<TopicRuleStatusAtProviderErrorActionFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<TopicRuleStatusAtProviderErrorActionHttp>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotAnalytics")]
    pub iot_analytics: Option<TopicRuleStatusAtProviderErrorActionIotAnalytics>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iotEvents")]
    pub iot_events: Option<TopicRuleStatusAtProviderErrorActionIotEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<TopicRuleStatusAtProviderErrorActionKafka>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<TopicRuleStatusAtProviderErrorActionKinesis>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lambda: Option<TopicRuleStatusAtProviderErrorActionLambda>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<TopicRuleStatusAtProviderErrorActionRepublish>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<TopicRuleStatusAtProviderErrorActionS3>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns: Option<TopicRuleStatusAtProviderErrorActionSns>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sqs: Option<TopicRuleStatusAtProviderErrorActionSqs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepFunctions")]
    pub step_functions: Option<TopicRuleStatusAtProviderErrorActionStepFunctions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestream: Option<TopicRuleStatusAtProviderErrorActionTimestream>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionCloudwatchAlarm {
    /// The CloudWatch alarm name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alarmName")]
    pub alarm_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The reason for the alarm change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateReason")]
    pub state_reason: Option<String>,
    /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateValue")]
    pub state_value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionCloudwatchLogs {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The CloudWatch log group name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionCloudwatchMetric {
    /// The CloudWatch metric name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricName")]
    pub metric_name: Option<String>,
    /// The CloudWatch metric namespace name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricTimestamp")]
    pub metric_timestamp: Option<String>,
    /// The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricUnit")]
    pub metric_unit: Option<String>,
    /// The CloudWatch metric value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricValue")]
    pub metric_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionDynamodb {
    /// The hash key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyField")]
    pub hash_key_field: Option<String>,
    /// The hash key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyType")]
    pub hash_key_type: Option<String>,
    /// The hash key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashKeyValue")]
    pub hash_key_value: Option<String>,
    /// The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// The action payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadField")]
    pub payload_field: Option<String>,
    /// The range key name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyField")]
    pub range_key_field: Option<String>,
    /// The range key type. Valid values are "STRING" or "NUMBER".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyType")]
    pub range_key_type: Option<String>,
    /// The range key value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeKeyValue")]
    pub range_key_value: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionDynamodbv2 {
    /// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putItem")]
    pub put_item: Option<TopicRuleStatusAtProviderErrorActionDynamodbv2PutItem>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

/// Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionDynamodbv2PutItem {
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionElasticsearch {
    /// The endpoint of your Elasticsearch domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The unique identifier for the document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Elasticsearch index where you want to store your data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The type of document you are storing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleStatusAtProviderErrorActionHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleStatusAtProviderErrorActionKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleStatusAtProviderErrorActionTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleStatusAtProviderErrorActionTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderErrorActionTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderFirehose {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The delivery stream name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryStreamName")]
    pub delivery_stream_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderHttp {
    /// The HTTPS URL used to verify ownership of url.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confirmationUrl")]
    pub confirmation_url: Option<String>,
    /// Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeader")]
    pub http_header: Option<Vec<TopicRuleStatusAtProviderHttpHttpHeader>>,
    /// The HTTPS URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderHttpHttpHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderIotAnalytics {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// Name of AWS IOT Analytics channel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "channelName")]
    pub channel_name: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderIotEvents {
    /// The payload that contains a JSON array of records will be sent to CloudWatch via a batch call.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchMode")]
    pub batch_mode: Option<bool>,
    /// The name of the AWS IoT Events input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inputName")]
    pub input_name: Option<String>,
    /// Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageId")]
    pub message_id: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderKafka {
    /// Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientProperties")]
    pub client_properties: Option<HashMap<String, String>>,
    /// The ARN of Kafka action's VPC aws_iot_topic_rule_destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationArn")]
    pub destination_arn: Option<String>,
    /// The list of Kafka headers that you specify. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<Vec<TopicRuleStatusAtProviderKafkaHeader>>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The Kafka message partition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderKafkaHeader {
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderKinesis {
    /// The partition key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionKey")]
    pub partition_key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Amazon Kinesis stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderLambda {
    /// The ARN of the Lambda function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "functionArn")]
    pub function_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderRepublish {
    /// The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<f64>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The Kafka topic for messages to be sent to the Kafka broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderS3 {
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAcl")]
    pub canned_acl: Option<String>,
    /// The name of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderSns {
    /// The message format of the message to publish. Accepted values are "JSON" and "RAW".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageFormat")]
    pub message_format: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The ARN of the SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetArn")]
    pub target_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderSqs {
    /// The URL of the Amazon SQS queue.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueUrl")]
    pub queue_url: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specifies whether to use Base64 encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useBase64")]
    pub use_base64: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderStepFunctions {
    /// The prefix used to generate, along with a UUID, the unique state machine execution name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamePrefix")]
    pub execution_name_prefix: Option<String>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the Step Functions state machine whose execution will be started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMachineName")]
    pub state_machine_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderTimestream {
    /// The name of an Amazon Timestream database.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseName")]
    pub database_name: Option<String>,
    /// Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dimension: Option<Vec<TopicRuleStatusAtProviderTimestreamDimension>>,
    /// The IAM role ARN that allows access to the CloudWatch alarm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// The name of the DynamoDB table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableName")]
    pub table_name: Option<String>,
    /// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<TopicRuleStatusAtProviderTimestreamTimestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderTimestreamDimension {
    /// The name of the rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TopicRuleStatusAtProviderTimestreamTimestamp {
    /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// The value of the HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

