// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RouteSpec defines the desired state of Route
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "ec2.aws.upbound.io", version = "v1beta2", kind = "Route", plural = "routes")]
#[kube(status = "RouteStatus")]
pub struct RouteSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<RouteDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RouteForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<RouteInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<RouteProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<RoutePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<RouteWriteConnectionSecretToRef>,
}

/// RouteSpec defines the desired state of Route
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProvider {
    /// Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "carrierGatewayId")]
    pub carrier_gateway_id: Option<String>,
    /// The Amazon Resource Name (ARN) of a core network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreNetworkArn")]
    pub core_network_arn: Option<String>,
    /// The destination CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCidrBlock")]
    pub destination_cidr_block: Option<String>,
    /// The destination IPv6 CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationIpv6CidrBlock")]
    pub destination_ipv6_cidr_block: Option<String>,
    /// The ID of a managed prefix list destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListId")]
    pub destination_prefix_list_id: Option<String>,
    /// Reference to a ManagedPrefixList in ec2 to populate destinationPrefixListId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListIdRef")]
    pub destination_prefix_list_id_ref: Option<RouteForProviderDestinationPrefixListIdRef>,
    /// Selector for a ManagedPrefixList in ec2 to populate destinationPrefixListId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListIdSelector")]
    pub destination_prefix_list_id_selector: Option<RouteForProviderDestinationPrefixListIdSelector>,
    /// Identifier of a VPC Egress Only Internet Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayId")]
    pub egress_only_gateway_id: Option<String>,
    /// Reference to a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayIdRef")]
    pub egress_only_gateway_id_ref: Option<RouteForProviderEgressOnlyGatewayIdRef>,
    /// Selector for a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayIdSelector")]
    pub egress_only_gateway_id_selector: Option<RouteForProviderEgressOnlyGatewayIdSelector>,
    /// Identifier of a VPC internet gateway or a virtual private gateway. Specify local when updating a previously imported local route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayId")]
    pub gateway_id: Option<String>,
    /// Reference to a InternetGateway in ec2 to populate gatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayIdRef")]
    pub gateway_id_ref: Option<RouteForProviderGatewayIdRef>,
    /// Selector for a InternetGateway in ec2 to populate gatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayIdSelector")]
    pub gateway_id_selector: Option<RouteForProviderGatewayIdSelector>,
    /// Identifier of a Outpost local gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localGatewayId")]
    pub local_gateway_id: Option<String>,
    /// Identifier of a VPC NAT gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayId")]
    pub nat_gateway_id: Option<String>,
    /// Reference to a NATGateway in ec2 to populate natGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayIdRef")]
    pub nat_gateway_id_ref: Option<RouteForProviderNatGatewayIdRef>,
    /// Selector for a NATGateway in ec2 to populate natGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayIdSelector")]
    pub nat_gateway_id_selector: Option<RouteForProviderNatGatewayIdSelector>,
    /// Identifier of an EC2 network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceId")]
    pub network_interface_id: Option<String>,
    /// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceIdRef")]
    pub network_interface_id_ref: Option<RouteForProviderNetworkInterfaceIdRef>,
    /// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceIdSelector")]
    pub network_interface_id_selector: Option<RouteForProviderNetworkInterfaceIdSelector>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The ID of the routing table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableId")]
    pub route_table_id: Option<String>,
    /// Reference to a RouteTable in ec2 to populate routeTableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableIdRef")]
    pub route_table_id_ref: Option<RouteForProviderRouteTableIdRef>,
    /// Selector for a RouteTable in ec2 to populate routeTableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableIdSelector")]
    pub route_table_id_selector: Option<RouteForProviderRouteTableIdSelector>,
    /// Identifier of an EC2 Transit Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayId")]
    pub transit_gateway_id: Option<String>,
    /// Reference to a TransitGateway in ec2 to populate transitGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayIdRef")]
    pub transit_gateway_id_ref: Option<RouteForProviderTransitGatewayIdRef>,
    /// Selector for a TransitGateway in ec2 to populate transitGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayIdSelector")]
    pub transit_gateway_id_selector: Option<RouteForProviderTransitGatewayIdSelector>,
    /// Identifier of a VPC Endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointId")]
    pub vpc_endpoint_id: Option<String>,
    /// Reference to a VPCEndpoint in ec2 to populate vpcEndpointId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointIdRef")]
    pub vpc_endpoint_id_ref: Option<RouteForProviderVpcEndpointIdRef>,
    /// Selector for a VPCEndpoint in ec2 to populate vpcEndpointId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointIdSelector")]
    pub vpc_endpoint_id_selector: Option<RouteForProviderVpcEndpointIdSelector>,
    /// Identifier of a VPC peering connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionId")]
    pub vpc_peering_connection_id: Option<String>,
    /// Reference to a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionIdRef")]
    pub vpc_peering_connection_id_ref: Option<RouteForProviderVpcPeeringConnectionIdRef>,
    /// Selector for a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionIdSelector")]
    pub vpc_peering_connection_id_selector: Option<RouteForProviderVpcPeeringConnectionIdSelector>,
}

/// Reference to a ManagedPrefixList in ec2 to populate destinationPrefixListId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderDestinationPrefixListIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderDestinationPrefixListIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderDestinationPrefixListIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderDestinationPrefixListIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderDestinationPrefixListIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderDestinationPrefixListIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderDestinationPrefixListIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ManagedPrefixList in ec2 to populate destinationPrefixListId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderDestinationPrefixListIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderDestinationPrefixListIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderDestinationPrefixListIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderDestinationPrefixListIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderDestinationPrefixListIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderDestinationPrefixListIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderDestinationPrefixListIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderEgressOnlyGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderEgressOnlyGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderEgressOnlyGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderEgressOnlyGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderEgressOnlyGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderEgressOnlyGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderEgressOnlyGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderEgressOnlyGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderEgressOnlyGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderEgressOnlyGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderEgressOnlyGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderEgressOnlyGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderEgressOnlyGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderEgressOnlyGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a InternetGateway in ec2 to populate gatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InternetGateway in ec2 to populate gatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a NATGateway in ec2 to populate natGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNatGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderNatGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNatGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderNatGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderNatGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNatGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNatGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NATGateway in ec2 to populate natGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNatGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderNatGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNatGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderNatGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderNatGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNatGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNatGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNetworkInterfaceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderNetworkInterfaceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNetworkInterfaceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderNetworkInterfaceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderNetworkInterfaceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNetworkInterfaceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNetworkInterfaceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNetworkInterfaceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderNetworkInterfaceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderNetworkInterfaceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderNetworkInterfaceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderNetworkInterfaceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNetworkInterfaceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderNetworkInterfaceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RouteTable in ec2 to populate routeTableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderRouteTableIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderRouteTableIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderRouteTableIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderRouteTableIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderRouteTableIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderRouteTableIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderRouteTableIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RouteTable in ec2 to populate routeTableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderRouteTableIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderRouteTableIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderRouteTableIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderRouteTableIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderRouteTableIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderRouteTableIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderRouteTableIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a TransitGateway in ec2 to populate transitGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderTransitGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderTransitGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderTransitGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderTransitGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderTransitGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderTransitGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderTransitGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TransitGateway in ec2 to populate transitGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderTransitGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderTransitGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderTransitGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderTransitGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderTransitGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderTransitGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderTransitGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCEndpoint in ec2 to populate vpcEndpointId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcEndpointIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderVpcEndpointIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcEndpointIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderVpcEndpointIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderVpcEndpointIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcEndpointIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcEndpointIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCEndpoint in ec2 to populate vpcEndpointId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcEndpointIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderVpcEndpointIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcEndpointIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderVpcEndpointIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderVpcEndpointIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcEndpointIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcEndpointIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcPeeringConnectionIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderVpcPeeringConnectionIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcPeeringConnectionIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderVpcPeeringConnectionIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderVpcPeeringConnectionIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcPeeringConnectionIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcPeeringConnectionIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcPeeringConnectionIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteForProviderVpcPeeringConnectionIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteForProviderVpcPeeringConnectionIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteForProviderVpcPeeringConnectionIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteForProviderVpcPeeringConnectionIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcPeeringConnectionIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteForProviderVpcPeeringConnectionIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProvider {
    /// Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "carrierGatewayId")]
    pub carrier_gateway_id: Option<String>,
    /// The Amazon Resource Name (ARN) of a core network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreNetworkArn")]
    pub core_network_arn: Option<String>,
    /// The destination CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCidrBlock")]
    pub destination_cidr_block: Option<String>,
    /// The destination IPv6 CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationIpv6CidrBlock")]
    pub destination_ipv6_cidr_block: Option<String>,
    /// The ID of a managed prefix list destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListId")]
    pub destination_prefix_list_id: Option<String>,
    /// Reference to a ManagedPrefixList in ec2 to populate destinationPrefixListId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListIdRef")]
    pub destination_prefix_list_id_ref: Option<RouteInitProviderDestinationPrefixListIdRef>,
    /// Selector for a ManagedPrefixList in ec2 to populate destinationPrefixListId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListIdSelector")]
    pub destination_prefix_list_id_selector: Option<RouteInitProviderDestinationPrefixListIdSelector>,
    /// Identifier of a VPC Egress Only Internet Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayId")]
    pub egress_only_gateway_id: Option<String>,
    /// Reference to a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayIdRef")]
    pub egress_only_gateway_id_ref: Option<RouteInitProviderEgressOnlyGatewayIdRef>,
    /// Selector for a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayIdSelector")]
    pub egress_only_gateway_id_selector: Option<RouteInitProviderEgressOnlyGatewayIdSelector>,
    /// Identifier of a VPC internet gateway or a virtual private gateway. Specify local when updating a previously imported local route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayId")]
    pub gateway_id: Option<String>,
    /// Reference to a InternetGateway in ec2 to populate gatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayIdRef")]
    pub gateway_id_ref: Option<RouteInitProviderGatewayIdRef>,
    /// Selector for a InternetGateway in ec2 to populate gatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayIdSelector")]
    pub gateway_id_selector: Option<RouteInitProviderGatewayIdSelector>,
    /// Identifier of a Outpost local gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localGatewayId")]
    pub local_gateway_id: Option<String>,
    /// Identifier of a VPC NAT gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayId")]
    pub nat_gateway_id: Option<String>,
    /// Reference to a NATGateway in ec2 to populate natGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayIdRef")]
    pub nat_gateway_id_ref: Option<RouteInitProviderNatGatewayIdRef>,
    /// Selector for a NATGateway in ec2 to populate natGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayIdSelector")]
    pub nat_gateway_id_selector: Option<RouteInitProviderNatGatewayIdSelector>,
    /// Identifier of an EC2 network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceId")]
    pub network_interface_id: Option<String>,
    /// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceIdRef")]
    pub network_interface_id_ref: Option<RouteInitProviderNetworkInterfaceIdRef>,
    /// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceIdSelector")]
    pub network_interface_id_selector: Option<RouteInitProviderNetworkInterfaceIdSelector>,
    /// The ID of the routing table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableId")]
    pub route_table_id: Option<String>,
    /// Reference to a RouteTable in ec2 to populate routeTableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableIdRef")]
    pub route_table_id_ref: Option<RouteInitProviderRouteTableIdRef>,
    /// Selector for a RouteTable in ec2 to populate routeTableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableIdSelector")]
    pub route_table_id_selector: Option<RouteInitProviderRouteTableIdSelector>,
    /// Identifier of an EC2 Transit Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayId")]
    pub transit_gateway_id: Option<String>,
    /// Reference to a TransitGateway in ec2 to populate transitGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayIdRef")]
    pub transit_gateway_id_ref: Option<RouteInitProviderTransitGatewayIdRef>,
    /// Selector for a TransitGateway in ec2 to populate transitGatewayId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayIdSelector")]
    pub transit_gateway_id_selector: Option<RouteInitProviderTransitGatewayIdSelector>,
    /// Identifier of a VPC Endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointId")]
    pub vpc_endpoint_id: Option<String>,
    /// Reference to a VPCEndpoint in ec2 to populate vpcEndpointId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointIdRef")]
    pub vpc_endpoint_id_ref: Option<RouteInitProviderVpcEndpointIdRef>,
    /// Selector for a VPCEndpoint in ec2 to populate vpcEndpointId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointIdSelector")]
    pub vpc_endpoint_id_selector: Option<RouteInitProviderVpcEndpointIdSelector>,
    /// Identifier of a VPC peering connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionId")]
    pub vpc_peering_connection_id: Option<String>,
    /// Reference to a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionIdRef")]
    pub vpc_peering_connection_id_ref: Option<RouteInitProviderVpcPeeringConnectionIdRef>,
    /// Selector for a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionIdSelector")]
    pub vpc_peering_connection_id_selector: Option<RouteInitProviderVpcPeeringConnectionIdSelector>,
}

/// Reference to a ManagedPrefixList in ec2 to populate destinationPrefixListId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderDestinationPrefixListIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderDestinationPrefixListIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderDestinationPrefixListIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderDestinationPrefixListIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderDestinationPrefixListIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderDestinationPrefixListIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderDestinationPrefixListIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ManagedPrefixList in ec2 to populate destinationPrefixListId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderDestinationPrefixListIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderDestinationPrefixListIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderDestinationPrefixListIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderDestinationPrefixListIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderDestinationPrefixListIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderDestinationPrefixListIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderDestinationPrefixListIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderEgressOnlyGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderEgressOnlyGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderEgressOnlyGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderEgressOnlyGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderEgressOnlyGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderEgressOnlyGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderEgressOnlyGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a EgressOnlyInternetGateway in ec2 to populate egressOnlyGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderEgressOnlyGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderEgressOnlyGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderEgressOnlyGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderEgressOnlyGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderEgressOnlyGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderEgressOnlyGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderEgressOnlyGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a InternetGateway in ec2 to populate gatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InternetGateway in ec2 to populate gatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a NATGateway in ec2 to populate natGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNatGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderNatGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNatGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderNatGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderNatGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNatGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNatGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NATGateway in ec2 to populate natGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNatGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderNatGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNatGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderNatGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderNatGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNatGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNatGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNetworkInterfaceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderNetworkInterfaceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNetworkInterfaceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderNetworkInterfaceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderNetworkInterfaceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNetworkInterfaceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNetworkInterfaceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNetworkInterfaceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderNetworkInterfaceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderNetworkInterfaceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderNetworkInterfaceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderNetworkInterfaceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNetworkInterfaceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderNetworkInterfaceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a RouteTable in ec2 to populate routeTableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderRouteTableIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderRouteTableIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderRouteTableIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderRouteTableIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderRouteTableIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderRouteTableIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderRouteTableIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RouteTable in ec2 to populate routeTableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderRouteTableIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderRouteTableIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderRouteTableIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderRouteTableIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderRouteTableIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderRouteTableIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderRouteTableIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a TransitGateway in ec2 to populate transitGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderTransitGatewayIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderTransitGatewayIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderTransitGatewayIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderTransitGatewayIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderTransitGatewayIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderTransitGatewayIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderTransitGatewayIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a TransitGateway in ec2 to populate transitGatewayId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderTransitGatewayIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderTransitGatewayIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderTransitGatewayIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderTransitGatewayIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderTransitGatewayIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderTransitGatewayIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderTransitGatewayIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCEndpoint in ec2 to populate vpcEndpointId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcEndpointIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderVpcEndpointIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcEndpointIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderVpcEndpointIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderVpcEndpointIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcEndpointIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcEndpointIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCEndpoint in ec2 to populate vpcEndpointId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcEndpointIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderVpcEndpointIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcEndpointIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderVpcEndpointIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderVpcEndpointIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcEndpointIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcEndpointIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcPeeringConnectionIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderVpcPeeringConnectionIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcPeeringConnectionIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderVpcPeeringConnectionIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderVpcPeeringConnectionIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcPeeringConnectionIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcPeeringConnectionIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a VPCPeeringConnection in ec2 to populate vpcPeeringConnectionId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcPeeringConnectionIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteInitProviderVpcPeeringConnectionIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteInitProviderVpcPeeringConnectionIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteInitProviderVpcPeeringConnectionIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteInitProviderVpcPeeringConnectionIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcPeeringConnectionIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteInitProviderVpcPeeringConnectionIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RouteProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RouteProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RouteProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RouteProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<RoutePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<RoutePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<RoutePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<RoutePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<RoutePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RoutePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RoutePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RouteStatus defines the observed state of Route.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<RouteStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RouteStatusAtProvider {
    /// Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "carrierGatewayId")]
    pub carrier_gateway_id: Option<String>,
    /// The Amazon Resource Name (ARN) of a core network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreNetworkArn")]
    pub core_network_arn: Option<String>,
    /// The destination CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCidrBlock")]
    pub destination_cidr_block: Option<String>,
    /// The destination IPv6 CIDR block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationIpv6CidrBlock")]
    pub destination_ipv6_cidr_block: Option<String>,
    /// The ID of a managed prefix list destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationPrefixListId")]
    pub destination_prefix_list_id: Option<String>,
    /// Identifier of a VPC Egress Only Internet Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressOnlyGatewayId")]
    pub egress_only_gateway_id: Option<String>,
    /// Identifier of a VPC internet gateway or a virtual private gateway. Specify local when updating a previously imported local route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayId")]
    pub gateway_id: Option<String>,
    /// Route identifier computed from the routing table identifier and route destination.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Identifier of an EC2 instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceId")]
    pub instance_id: Option<String>,
    /// The AWS account ID of the owner of the EC2 instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceOwnerId")]
    pub instance_owner_id: Option<String>,
    /// Identifier of a Outpost local gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localGatewayId")]
    pub local_gateway_id: Option<String>,
    /// Identifier of a VPC NAT gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natGatewayId")]
    pub nat_gateway_id: Option<String>,
    /// Identifier of an EC2 network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceId")]
    pub network_interface_id: Option<String>,
    /// How the route was created - CreateRouteTable, CreateRoute or EnableVgwRoutePropagation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    /// The ID of the routing table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableId")]
    pub route_table_id: Option<String>,
    /// The state of the route - active or blackhole.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// Identifier of an EC2 Transit Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGatewayId")]
    pub transit_gateway_id: Option<String>,
    /// Identifier of a VPC Endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointId")]
    pub vpc_endpoint_id: Option<String>,
    /// Identifier of a VPC peering connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcPeeringConnectionId")]
    pub vpc_peering_connection_id: Option<String>,
}

