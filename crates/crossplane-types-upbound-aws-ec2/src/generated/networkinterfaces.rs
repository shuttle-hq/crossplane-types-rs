// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// NetworkInterfaceSpec defines the desired state of NetworkInterface
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "ec2.aws.upbound.io", version = "v1beta1", kind = "NetworkInterface", plural = "networkinterfaces")]
#[kube(status = "NetworkInterfaceStatus")]
pub struct NetworkInterfaceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<NetworkInterfaceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: NetworkInterfaceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<NetworkInterfaceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<NetworkInterfaceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<NetworkInterfacePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<NetworkInterfaceWriteConnectionSecretToRef>,
}

/// NetworkInterfaceSpec defines the desired state of NetworkInterface
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProvider {
    /// Description for the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Enables assigning a primary IPv6 Global Unicast Address (GUA) to the network interface (ENI) in dual-stack or IPv6-only subnets. This ensures the instance attached to the ENI retains a consistent IPv6 address. Once enabled, the first IPv6 GUA becomes the primary IPv6 address and cannot be disabled. The primary IPv6 address remains assigned until the instance is terminated or the ENI is detached. Enabling and subsequent disabling forces recreation of the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrimaryIpv6")]
    pub enable_primary_ipv6: Option<bool>,
    /// Type of network interface to create. Set to efa for Elastic Fabric Adapter. Changing interface_type will cause the resource to be destroyed and re-created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceType")]
    pub interface_type: Option<String>,
    /// Number of IPv4 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4PrefixCount")]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4Prefixes")]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// Number of IPv6 addresses to assign to a network interface. You can't use this option if specifying specific ipv6_addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressCount")]
    pub ipv6_address_count: Option<f64>,
    /// List of private IPs to assign to the ENI in sequential order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressList")]
    pub ipv6_address_list: Option<Vec<String>>,
    /// Whether ipv6_address_list is allowed and controls the IPs to assign to the ENI and ipv6_addresses and ipv6_address_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressListEnabled")]
    pub ipv6_address_list_enabled: Option<bool>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Addresses are assigned without regard to order. You can't use this option if you're specifying ipv6_address_count.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Addresses")]
    pub ipv6_addresses: Option<Vec<String>>,
    /// Number of IPv6 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6PrefixCount")]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Prefixes")]
    pub ipv6_prefixes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIp")]
    pub private_ip: Option<String>,
    /// List of private IPs to assign to the ENI in sequential order. Requires setting private_ip_list_enabled to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpList")]
    pub private_ip_list: Option<Vec<String>>,
    /// Whether private_ip_list is allowed and controls the IPs to assign to the ENI and private_ips and private_ips_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpListEnabled")]
    pub private_ip_list_enabled: Option<bool>,
    /// List of private IPs to assign to the ENI without regard to order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIps")]
    pub private_ips: Option<Vec<String>>,
    /// Number of secondary private IPs to assign to the ENI. The total number of private IPs will be 1 + private_ips_count, as a primary private IP will be assiged to an ENI by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpsCount")]
    pub private_ips_count: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupRefs")]
    pub security_group_refs: Option<Vec<NetworkInterfaceForProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupSelector")]
    pub security_group_selector: Option<NetworkInterfaceForProviderSecurityGroupSelector>,
    /// List of security group IDs to assign to the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// Whether to enable source destination checking for the ENI. Default true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceDestCheck")]
    pub source_dest_check: Option<bool>,
    /// Subnet ID to create the ENI in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdRef")]
    pub subnet_id_ref: Option<NetworkInterfaceForProviderSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdSelector")]
    pub subnet_id_selector: Option<NetworkInterfaceForProviderSubnetIdSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceForProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceForProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceForProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceForProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceForProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceForProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceForProviderSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceForProviderSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceForProviderSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceForProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceForProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceForProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceForProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceForProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProvider {
    /// Description for the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Enables assigning a primary IPv6 Global Unicast Address (GUA) to the network interface (ENI) in dual-stack or IPv6-only subnets. This ensures the instance attached to the ENI retains a consistent IPv6 address. Once enabled, the first IPv6 GUA becomes the primary IPv6 address and cannot be disabled. The primary IPv6 address remains assigned until the instance is terminated or the ENI is detached. Enabling and subsequent disabling forces recreation of the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrimaryIpv6")]
    pub enable_primary_ipv6: Option<bool>,
    /// Type of network interface to create. Set to efa for Elastic Fabric Adapter. Changing interface_type will cause the resource to be destroyed and re-created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceType")]
    pub interface_type: Option<String>,
    /// Number of IPv4 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4PrefixCount")]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4Prefixes")]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// Number of IPv6 addresses to assign to a network interface. You can't use this option if specifying specific ipv6_addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressCount")]
    pub ipv6_address_count: Option<f64>,
    /// List of private IPs to assign to the ENI in sequential order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressList")]
    pub ipv6_address_list: Option<Vec<String>>,
    /// Whether ipv6_address_list is allowed and controls the IPs to assign to the ENI and ipv6_addresses and ipv6_address_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressListEnabled")]
    pub ipv6_address_list_enabled: Option<bool>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Addresses are assigned without regard to order. You can't use this option if you're specifying ipv6_address_count.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Addresses")]
    pub ipv6_addresses: Option<Vec<String>>,
    /// Number of IPv6 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6PrefixCount")]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Prefixes")]
    pub ipv6_prefixes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIp")]
    pub private_ip: Option<String>,
    /// List of private IPs to assign to the ENI in sequential order. Requires setting private_ip_list_enabled to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpList")]
    pub private_ip_list: Option<Vec<String>>,
    /// Whether private_ip_list is allowed and controls the IPs to assign to the ENI and private_ips and private_ips_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpListEnabled")]
    pub private_ip_list_enabled: Option<bool>,
    /// List of private IPs to assign to the ENI without regard to order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIps")]
    pub private_ips: Option<Vec<String>>,
    /// Number of secondary private IPs to assign to the ENI. The total number of private IPs will be 1 + private_ips_count, as a primary private IP will be assiged to an ENI by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpsCount")]
    pub private_ips_count: Option<f64>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupRefs")]
    pub security_group_refs: Option<Vec<NetworkInterfaceInitProviderSecurityGroupRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupSelector")]
    pub security_group_selector: Option<NetworkInterfaceInitProviderSecurityGroupSelector>,
    /// List of security group IDs to assign to the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// Whether to enable source destination checking for the ENI. Default true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceDestCheck")]
    pub source_dest_check: Option<bool>,
    /// Subnet ID to create the ENI in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    pub subnet_id: Option<String>,
    /// Reference to a Subnet in ec2 to populate subnetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdRef")]
    pub subnet_id_ref: Option<NetworkInterfaceInitProviderSubnetIdRef>,
    /// Selector for a Subnet in ec2 to populate subnetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdSelector")]
    pub subnet_id_selector: Option<NetworkInterfaceInitProviderSubnetIdSelector>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSecurityGroupRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceInitProviderSecurityGroupRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSecurityGroupRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceInitProviderSecurityGroupRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceInitProviderSecurityGroupRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSecurityGroupRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSecurityGroupRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSecurityGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceInitProviderSecurityGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSecurityGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceInitProviderSecurityGroupSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceInitProviderSecurityGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSecurityGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSecurityGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSubnetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceInitProviderSubnetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSubnetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceInitProviderSubnetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceInitProviderSubnetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSubnetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSubnetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnet in ec2 to populate subnetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceInitProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceInitProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceInitProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceInitProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceInitProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfaceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfaceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfaceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfaceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfacePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<NetworkInterfacePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<NetworkInterfacePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfacePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<NetworkInterfacePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfacePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<NetworkInterfacePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<NetworkInterfacePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfacePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NetworkInterfacePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfacePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// NetworkInterfaceStatus defines the observed state of NetworkInterface.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<NetworkInterfaceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceStatusAtProvider {
    /// ARN of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// Configuration block to define the attachment of the ENI. See Attachment below for more details!
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attachment: Option<Vec<NetworkInterfaceStatusAtProviderAttachment>>,
    /// Description for the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Enables assigning a primary IPv6 Global Unicast Address (GUA) to the network interface (ENI) in dual-stack or IPv6-only subnets. This ensures the instance attached to the ENI retains a consistent IPv6 address. Once enabled, the first IPv6 GUA becomes the primary IPv6 address and cannot be disabled. The primary IPv6 address remains assigned until the instance is terminated or the ENI is detached. Enabling and subsequent disabling forces recreation of the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrimaryIpv6")]
    pub enable_primary_ipv6: Option<bool>,
    /// ID of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Type of network interface to create. Set to efa for Elastic Fabric Adapter. Changing interface_type will cause the resource to be destroyed and re-created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceType")]
    pub interface_type: Option<String>,
    /// Number of IPv4 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4PrefixCount")]
    pub ipv4_prefix_count: Option<f64>,
    /// One or more IPv4 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4Prefixes")]
    pub ipv4_prefixes: Option<Vec<String>>,
    /// Number of IPv6 addresses to assign to a network interface. You can't use this option if specifying specific ipv6_addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressCount")]
    pub ipv6_address_count: Option<f64>,
    /// List of private IPs to assign to the ENI in sequential order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressList")]
    pub ipv6_address_list: Option<Vec<String>>,
    /// Whether ipv6_address_list is allowed and controls the IPs to assign to the ENI and ipv6_addresses and ipv6_address_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AddressListEnabled")]
    pub ipv6_address_list_enabled: Option<bool>,
    /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Addresses are assigned without regard to order. You can't use this option if you're specifying ipv6_address_count.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Addresses")]
    pub ipv6_addresses: Option<Vec<String>>,
    /// Number of IPv6 prefixes that AWS automatically assigns to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6PrefixCount")]
    pub ipv6_prefix_count: Option<f64>,
    /// One or more IPv6 prefixes assigned to the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Prefixes")]
    pub ipv6_prefixes: Option<Vec<String>>,
    /// MAC address of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "macAddress")]
    pub mac_address: Option<String>,
    /// ARN of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outpostArn")]
    pub outpost_arn: Option<String>,
    /// AWS account ID of the owner of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerId")]
    pub owner_id: Option<String>,
    /// Private DNS name of the network interface (IPv4).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateDnsName")]
    pub private_dns_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIp")]
    pub private_ip: Option<String>,
    /// List of private IPs to assign to the ENI in sequential order. Requires setting private_ip_list_enabled to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpList")]
    pub private_ip_list: Option<Vec<String>>,
    /// Whether private_ip_list is allowed and controls the IPs to assign to the ENI and private_ips and private_ips_count become read-only. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpListEnabled")]
    pub private_ip_list_enabled: Option<bool>,
    /// List of private IPs to assign to the ENI without regard to order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIps")]
    pub private_ips: Option<Vec<String>>,
    /// Number of secondary private IPs to assign to the ENI. The total number of private IPs will be 1 + private_ips_count, as a primary private IP will be assiged to an ENI by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIpsCount")]
    pub private_ips_count: Option<f64>,
    /// List of security group IDs to assign to the ENI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    /// Whether to enable source destination checking for the ENI. Default true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceDestCheck")]
    pub source_dest_check: Option<bool>,
    /// Subnet ID to create the ENI in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    pub subnet_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    pub tags_all: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct NetworkInterfaceStatusAtProviderAttachment {
    /// ID of the network interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachmentId")]
    pub attachment_id: Option<String>,
    /// Integer to define the devices index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceIndex")]
    pub device_index: Option<f64>,
    /// ID of the instance to attach to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,
}

