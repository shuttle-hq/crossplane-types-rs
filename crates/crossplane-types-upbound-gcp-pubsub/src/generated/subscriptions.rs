// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// SubscriptionSpec defines the desired state of Subscription
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "pubsub.gcp.upbound.io", version = "v1beta2", kind = "Subscription", plural = "subscriptions")]
#[kube(status = "SubscriptionStatus")]
pub struct SubscriptionSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<SubscriptionDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: SubscriptionForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<SubscriptionInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<SubscriptionProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<SubscriptionPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<SubscriptionWriteConnectionSecretToRef>,
}

/// SubscriptionSpec defines the desired state of Subscription
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProvider {
    /// This value is the maximum time after a subscriber receives a message
    /// before the subscriber should acknowledge the message. After message
    /// delivery but before the ack deadline expires and before the message is
    /// acknowledged, it is an outstanding message and will not be delivered
    /// again during that time (on a best-effort basis).
    /// For pull subscriptions, this value is used as the initial value for
    /// the ack deadline. To override this value for a given message, call
    /// subscriptions.modifyAckDeadline with the corresponding ackId if using
    /// pull. The minimum custom deadline you can specify is 10 seconds. The
    /// maximum custom deadline you can specify is 600 seconds (10 minutes).
    /// If this parameter is 0, a default value of 10 seconds is used.
    /// For push delivery, this value is also used to set the request timeout
    /// for the call to the push endpoint.
    /// If the subscriber never acknowledges the message, the Pub/Sub system
    /// will eventually redeliver the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackDeadlineSeconds")]
    pub ack_deadline_seconds: Option<f64>,
    /// If delivery to BigQuery is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryConfig")]
    pub bigquery_config: Option<SubscriptionForProviderBigqueryConfig>,
    /// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageConfig")]
    pub cloud_storage_config: Option<SubscriptionForProviderCloudStorageConfig>,
    /// A policy that specifies the conditions for dead lettering messages in
    /// this subscription. If dead_letter_policy is not set, dead lettering
    /// is disabled.
    /// The Cloud Pub/Sub service account associated with this subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Acknowledge() messages on this subscription.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterPolicy")]
    pub dead_letter_policy: Option<SubscriptionForProviderDeadLetterPolicy>,
    /// If true, Pub/Sub provides the following guarantees for the delivery
    /// of a message with a given value of messageId on this Subscriptions':
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExactlyOnceDelivery")]
    pub enable_exactly_once_delivery: Option<bool>,
    /// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
    /// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
    /// may be delivered in any order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMessageOrdering")]
    pub enable_message_ordering: Option<bool>,
    /// A policy that specifies the conditions for this subscription's expiration.
    /// A subscription is considered active as long as any connected subscriber
    /// is successfully consuming messages from the subscription or is issuing
    /// operations on the subscription. If expirationPolicy is not set, a default
    /// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
    /// resource never expires.  The minimum allowed value for expirationPolicy.ttl
    /// is 1 day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationPolicy")]
    pub expiration_policy: Option<SubscriptionForProviderExpirationPolicy>,
    /// The subscription only delivers the messages that match the filter.
    /// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
    /// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
    /// you can't modify the filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// A set of key/value label pairs to assign to this Subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// How long to retain unacknowledged messages in the subscription's
    /// backlog, from the moment a message is published. If
    /// retain_acked_messages is true, then this also configures the retention
    /// of acknowledged messages, and thus configures how far back in time a
    /// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
    /// than 7 days ("604800s") or less than 10 minutes ("600s").
    /// A duration in seconds with up to nine fractional digits, terminated
    /// by 's'. Example: "600.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageRetentionDuration")]
    pub message_retention_duration: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// If push delivery is used with this subscription, this field is used to
    /// configure it. An empty pushConfig signifies that the subscriber will
    /// pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushConfig")]
    pub push_config: Option<SubscriptionForProviderPushConfig>,
    /// Indicates whether to retain acknowledged messages. If true, then
    /// messages are not expunged from the subscription's backlog, even if
    /// they are acknowledged, until they fall out of the
    /// messageRetentionDuration window.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainAckedMessages")]
    pub retain_acked_messages: Option<bool>,
    /// A policy that specifies how Pub/Sub retries message delivery for this subscription.
    /// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
    /// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<SubscriptionForProviderRetryPolicy>,
    /// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
    /// (as in the id property of a google_pubsub_topic), or just a topic name if
    /// the topic is in the same project as the subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// Reference to a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicRef")]
    pub topic_ref: Option<SubscriptionForProviderTopicRef>,
    /// Selector for a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicSelector")]
    pub topic_selector: Option<SubscriptionForProviderTopicSelector>,
}

/// If delivery to BigQuery is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderBigqueryConfig {
    /// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
    /// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
    /// and any messages with extra fields are not written and remain in the subscription's backlog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropUnknownFields")]
    pub drop_unknown_fields: Option<bool>,
    /// The service account to use to write to BigQuery. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    pub service_account_email_ref: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    pub service_account_email_selector: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailSelector>,
    /// The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<String>,
    /// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
    /// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTableSchema")]
    pub use_table_schema: Option<bool>,
    /// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
    /// Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTopicSchema")]
    pub use_topic_schema: Option<bool>,
    /// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
    /// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderBigqueryConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderBigqueryConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderBigqueryConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfig {
    /// If set, message data will be written to Cloud Storage in Avro format.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "avroConfig")]
    pub avro_config: Option<SubscriptionForProviderCloudStorageConfigAvroConfig>,
    /// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameDatetimeFormat")]
    pub filename_datetime_format: Option<String>,
    /// User-provided prefix for Cloud Storage filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenamePrefix")]
    pub filename_prefix: Option<String>,
    /// User-provided suffix for Cloud Storage filename. Must not end in "/".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameSuffix")]
    pub filename_suffix: Option<String>,
    /// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
    /// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<f64>,
    /// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
    /// May not exceed the subscription's acknowledgement deadline.
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDuration")]
    pub max_duration: Option<String>,
    /// The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    pub service_account_email_ref: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    pub service_account_email_selector: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelector>,
}

/// If set, message data will be written to Cloud Storage in Avro format.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfigAvroConfig {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderCloudStorageConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies the conditions for dead lettering messages in
/// this subscription. If dead_letter_policy is not set, dead lettering
/// is disabled.
/// The Cloud Pub/Sub service account associated with this subscription's
/// parent project (i.e.,
/// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
/// permission to Acknowledge() messages on this subscription.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderDeadLetterPolicy {
    /// The name of the topic to which dead letter messages should be published.
    /// Format is projects/{project}/topics/{topic}.
    /// The Cloud Pub/Sub service account associated with the enclosing subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Publish() to this topic.
    /// The operation will fail if the topic does not exist.
    /// Users should ensure that there is a subscription attached to this topic
    /// since messages published to a topic with no subscriptions are lost.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopic")]
    pub dead_letter_topic: Option<String>,
    /// Reference to a Topic in pubsub to populate deadLetterTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopicRef")]
    pub dead_letter_topic_ref: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRef>,
    /// Selector for a Topic in pubsub to populate deadLetterTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopicSelector")]
    pub dead_letter_topic_selector: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelector>,
    /// The maximum number of delivery attempts for any message. The value must be
    /// between 5 and 100.
    /// The number of delivery attempts is defined as 1 + (the sum of number of
    /// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
    /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    /// client libraries may automatically extend ack_deadlines.
    /// This field will be honored on a best effort basis.
    /// If this parameter is 0, a default value of 5 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDeliveryAttempts")]
    pub max_delivery_attempts: Option<f64>,
}

/// Reference to a Topic in pubsub to populate deadLetterTopic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate deadLetterTopic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies the conditions for this subscription's expiration.
/// A subscription is considered active as long as any connected subscriber
/// is successfully consuming messages from the subscription or is issuing
/// operations on the subscription. If expirationPolicy is not set, a default
/// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
/// resource never expires.  The minimum allowed value for expirationPolicy.ttl
/// is 1 day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderExpirationPolicy {
    /// Specifies the "time-to-live" duration for an associated resource. The
    /// resource expires if it is not active for a period of ttl.
    /// If ttl is set to "", the associated resource never expires.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'.
    /// Example - "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// If push delivery is used with this subscription, this field is used to
/// configure it. An empty pushConfig signifies that the subscriber will
/// pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderPushConfig {
    /// Endpoint configuration attributes.
    /// Every endpoint has a set of API supported attributes that can
    /// be used to control different aspects of the message delivery.
    /// The currently supported attribute is x-goog-version, which you
    /// can use to change the format of the pushed message. This
    /// attribute indicates the version of the data expected by
    /// the endpoint. This controls the shape of the pushed message
    /// (i.e., its fields and metadata). The endpoint version is
    /// based on the version of the Pub/Sub API.
    /// If not present during the subscriptions.create call,
    /// it will default to the version of the API used to make
    /// such call. If not present during a subscriptions.modifyPushConfig
    /// call, its value will not be changed. subscriptions.get
    /// calls will always return a valid version, even if the
    /// subscription was created without this attribute.
    /// The possible values for this attribute are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<HashMap<String, String>>,
    /// When set, the payload to the push endpoint is not wrapped.Sets the
    /// data field as the HTTP body for delivery.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noWrapper")]
    pub no_wrapper: Option<SubscriptionForProviderPushConfigNoWrapper>,
    /// If specified, Pub/Sub will generate and attach an OIDC JWT token as
    /// an Authorization header in the HTTP request for every pushed message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcToken")]
    pub oidc_token: Option<SubscriptionForProviderPushConfigOidcToken>,
    /// A URL locating the endpoint to which messages should be pushed.
    /// For example, a Webhook endpoint might use
    /// "https://example.com/push".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushEndpoint")]
    pub push_endpoint: Option<String>,
}

/// When set, the payload to the push endpoint is not wrapped.Sets the
/// data field as the HTTP body for delivery.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderPushConfigNoWrapper {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// If specified, Pub/Sub will generate and attach an OIDC JWT token as
/// an Authorization header in the HTTP request for every pushed message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderPushConfigOidcToken {
    /// Audience to be used when generating OIDC token. The audience claim
    /// identifies the recipients that the JWT is intended for. The audience
    /// value is a single case-sensitive string. Having multiple values (array)
    /// for the audience field is not supported. More info about the OIDC JWT
    /// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
    /// Note: if not specified, the Push endpoint URL will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// Service account email to be used for generating the OIDC token.
    /// The caller (for subscriptions.create, subscriptions.patch, and
    /// subscriptions.modifyPushConfig RPCs) must have the
    /// iam.serviceAccounts.actAs permission for the service account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
}

/// A policy that specifies how Pub/Sub retries message delivery for this subscription.
/// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
/// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderRetryPolicy {
    /// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumBackoff")]
    pub maximum_backoff: Option<String>,
    /// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumBackoff")]
    pub minimum_backoff: Option<String>,
}

/// Reference to a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionForProviderTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionForProviderTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionForProviderTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionForProviderTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionForProviderTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProvider {
    /// This value is the maximum time after a subscriber receives a message
    /// before the subscriber should acknowledge the message. After message
    /// delivery but before the ack deadline expires and before the message is
    /// acknowledged, it is an outstanding message and will not be delivered
    /// again during that time (on a best-effort basis).
    /// For pull subscriptions, this value is used as the initial value for
    /// the ack deadline. To override this value for a given message, call
    /// subscriptions.modifyAckDeadline with the corresponding ackId if using
    /// pull. The minimum custom deadline you can specify is 10 seconds. The
    /// maximum custom deadline you can specify is 600 seconds (10 minutes).
    /// If this parameter is 0, a default value of 10 seconds is used.
    /// For push delivery, this value is also used to set the request timeout
    /// for the call to the push endpoint.
    /// If the subscriber never acknowledges the message, the Pub/Sub system
    /// will eventually redeliver the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackDeadlineSeconds")]
    pub ack_deadline_seconds: Option<f64>,
    /// If delivery to BigQuery is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryConfig")]
    pub bigquery_config: Option<SubscriptionInitProviderBigqueryConfig>,
    /// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageConfig")]
    pub cloud_storage_config: Option<SubscriptionInitProviderCloudStorageConfig>,
    /// A policy that specifies the conditions for dead lettering messages in
    /// this subscription. If dead_letter_policy is not set, dead lettering
    /// is disabled.
    /// The Cloud Pub/Sub service account associated with this subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Acknowledge() messages on this subscription.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterPolicy")]
    pub dead_letter_policy: Option<SubscriptionInitProviderDeadLetterPolicy>,
    /// If true, Pub/Sub provides the following guarantees for the delivery
    /// of a message with a given value of messageId on this Subscriptions':
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExactlyOnceDelivery")]
    pub enable_exactly_once_delivery: Option<bool>,
    /// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
    /// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
    /// may be delivered in any order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMessageOrdering")]
    pub enable_message_ordering: Option<bool>,
    /// A policy that specifies the conditions for this subscription's expiration.
    /// A subscription is considered active as long as any connected subscriber
    /// is successfully consuming messages from the subscription or is issuing
    /// operations on the subscription. If expirationPolicy is not set, a default
    /// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
    /// resource never expires.  The minimum allowed value for expirationPolicy.ttl
    /// is 1 day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationPolicy")]
    pub expiration_policy: Option<SubscriptionInitProviderExpirationPolicy>,
    /// The subscription only delivers the messages that match the filter.
    /// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
    /// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
    /// you can't modify the filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// A set of key/value label pairs to assign to this Subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// How long to retain unacknowledged messages in the subscription's
    /// backlog, from the moment a message is published. If
    /// retain_acked_messages is true, then this also configures the retention
    /// of acknowledged messages, and thus configures how far back in time a
    /// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
    /// than 7 days ("604800s") or less than 10 minutes ("600s").
    /// A duration in seconds with up to nine fractional digits, terminated
    /// by 's'. Example: "600.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageRetentionDuration")]
    pub message_retention_duration: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// If push delivery is used with this subscription, this field is used to
    /// configure it. An empty pushConfig signifies that the subscriber will
    /// pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushConfig")]
    pub push_config: Option<SubscriptionInitProviderPushConfig>,
    /// Indicates whether to retain acknowledged messages. If true, then
    /// messages are not expunged from the subscription's backlog, even if
    /// they are acknowledged, until they fall out of the
    /// messageRetentionDuration window.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainAckedMessages")]
    pub retain_acked_messages: Option<bool>,
    /// A policy that specifies how Pub/Sub retries message delivery for this subscription.
    /// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
    /// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<SubscriptionInitProviderRetryPolicy>,
    /// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
    /// (as in the id property of a google_pubsub_topic), or just a topic name if
    /// the topic is in the same project as the subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// Reference to a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicRef")]
    pub topic_ref: Option<SubscriptionInitProviderTopicRef>,
    /// Selector for a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicSelector")]
    pub topic_selector: Option<SubscriptionInitProviderTopicSelector>,
}

/// If delivery to BigQuery is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderBigqueryConfig {
    /// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
    /// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
    /// and any messages with extra fields are not written and remain in the subscription's backlog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropUnknownFields")]
    pub drop_unknown_fields: Option<bool>,
    /// The service account to use to write to BigQuery. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    pub service_account_email_ref: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    pub service_account_email_selector: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelector>,
    /// The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<String>,
    /// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
    /// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTableSchema")]
    pub use_table_schema: Option<bool>,
    /// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
    /// Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTopicSchema")]
    pub use_topic_schema: Option<bool>,
    /// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
    /// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderBigqueryConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderBigqueryConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderBigqueryConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfig {
    /// If set, message data will be written to Cloud Storage in Avro format.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "avroConfig")]
    pub avro_config: Option<SubscriptionInitProviderCloudStorageConfigAvroConfig>,
    /// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameDatetimeFormat")]
    pub filename_datetime_format: Option<String>,
    /// User-provided prefix for Cloud Storage filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenamePrefix")]
    pub filename_prefix: Option<String>,
    /// User-provided suffix for Cloud Storage filename. Must not end in "/".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameSuffix")]
    pub filename_suffix: Option<String>,
    /// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
    /// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<f64>,
    /// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
    /// May not exceed the subscription's acknowledgement deadline.
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDuration")]
    pub max_duration: Option<String>,
    /// The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    pub service_account_email_ref: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    pub service_account_email_selector: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelector>,
}

/// If set, message data will be written to Cloud Storage in Avro format.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfigAvroConfig {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderCloudStorageConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderCloudStorageConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies the conditions for dead lettering messages in
/// this subscription. If dead_letter_policy is not set, dead lettering
/// is disabled.
/// The Cloud Pub/Sub service account associated with this subscription's
/// parent project (i.e.,
/// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
/// permission to Acknowledge() messages on this subscription.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderDeadLetterPolicy {
    /// The name of the topic to which dead letter messages should be published.
    /// Format is projects/{project}/topics/{topic}.
    /// The Cloud Pub/Sub service account associated with the enclosing subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Publish() to this topic.
    /// The operation will fail if the topic does not exist.
    /// Users should ensure that there is a subscription attached to this topic
    /// since messages published to a topic with no subscriptions are lost.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopic")]
    pub dead_letter_topic: Option<String>,
    /// Reference to a Topic in pubsub to populate deadLetterTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopicRef")]
    pub dead_letter_topic_ref: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRef>,
    /// Selector for a Topic in pubsub to populate deadLetterTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopicSelector")]
    pub dead_letter_topic_selector: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelector>,
    /// The maximum number of delivery attempts for any message. The value must be
    /// between 5 and 100.
    /// The number of delivery attempts is defined as 1 + (the sum of number of
    /// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
    /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    /// client libraries may automatically extend ack_deadlines.
    /// This field will be honored on a best effort basis.
    /// If this parameter is 0, a default value of 5 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDeliveryAttempts")]
    pub max_delivery_attempts: Option<f64>,
}

/// Reference to a Topic in pubsub to populate deadLetterTopic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate deadLetterTopic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A policy that specifies the conditions for this subscription's expiration.
/// A subscription is considered active as long as any connected subscriber
/// is successfully consuming messages from the subscription or is issuing
/// operations on the subscription. If expirationPolicy is not set, a default
/// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
/// resource never expires.  The minimum allowed value for expirationPolicy.ttl
/// is 1 day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderExpirationPolicy {
    /// Specifies the "time-to-live" duration for an associated resource. The
    /// resource expires if it is not active for a period of ttl.
    /// If ttl is set to "", the associated resource never expires.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'.
    /// Example - "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// If push delivery is used with this subscription, this field is used to
/// configure it. An empty pushConfig signifies that the subscriber will
/// pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderPushConfig {
    /// Endpoint configuration attributes.
    /// Every endpoint has a set of API supported attributes that can
    /// be used to control different aspects of the message delivery.
    /// The currently supported attribute is x-goog-version, which you
    /// can use to change the format of the pushed message. This
    /// attribute indicates the version of the data expected by
    /// the endpoint. This controls the shape of the pushed message
    /// (i.e., its fields and metadata). The endpoint version is
    /// based on the version of the Pub/Sub API.
    /// If not present during the subscriptions.create call,
    /// it will default to the version of the API used to make
    /// such call. If not present during a subscriptions.modifyPushConfig
    /// call, its value will not be changed. subscriptions.get
    /// calls will always return a valid version, even if the
    /// subscription was created without this attribute.
    /// The possible values for this attribute are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<HashMap<String, String>>,
    /// When set, the payload to the push endpoint is not wrapped.Sets the
    /// data field as the HTTP body for delivery.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noWrapper")]
    pub no_wrapper: Option<SubscriptionInitProviderPushConfigNoWrapper>,
    /// If specified, Pub/Sub will generate and attach an OIDC JWT token as
    /// an Authorization header in the HTTP request for every pushed message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcToken")]
    pub oidc_token: Option<SubscriptionInitProviderPushConfigOidcToken>,
    /// A URL locating the endpoint to which messages should be pushed.
    /// For example, a Webhook endpoint might use
    /// "https://example.com/push".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushEndpoint")]
    pub push_endpoint: Option<String>,
}

/// When set, the payload to the push endpoint is not wrapped.Sets the
/// data field as the HTTP body for delivery.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderPushConfigNoWrapper {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// If specified, Pub/Sub will generate and attach an OIDC JWT token as
/// an Authorization header in the HTTP request for every pushed message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderPushConfigOidcToken {
    /// Audience to be used when generating OIDC token. The audience claim
    /// identifies the recipients that the JWT is intended for. The audience
    /// value is a single case-sensitive string. Having multiple values (array)
    /// for the audience field is not supported. More info about the OIDC JWT
    /// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
    /// Note: if not specified, the Push endpoint URL will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// Service account email to be used for generating the OIDC token.
    /// The caller (for subscriptions.create, subscriptions.patch, and
    /// subscriptions.modifyPushConfig RPCs) must have the
    /// iam.serviceAccounts.actAs permission for the service account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
}

/// A policy that specifies how Pub/Sub retries message delivery for this subscription.
/// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
/// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderRetryPolicy {
    /// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumBackoff")]
    pub maximum_backoff: Option<String>,
    /// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumBackoff")]
    pub minimum_backoff: Option<String>,
}

/// Reference to a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionInitProviderTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionInitProviderTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionInitProviderTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionInitProviderTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionInitProviderTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<SubscriptionPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<SubscriptionPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<SubscriptionPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<SubscriptionPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<SubscriptionPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SubscriptionPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// SubscriptionStatus defines the observed state of Subscription.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<SubscriptionStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProvider {
    /// This value is the maximum time after a subscriber receives a message
    /// before the subscriber should acknowledge the message. After message
    /// delivery but before the ack deadline expires and before the message is
    /// acknowledged, it is an outstanding message and will not be delivered
    /// again during that time (on a best-effort basis).
    /// For pull subscriptions, this value is used as the initial value for
    /// the ack deadline. To override this value for a given message, call
    /// subscriptions.modifyAckDeadline with the corresponding ackId if using
    /// pull. The minimum custom deadline you can specify is 10 seconds. The
    /// maximum custom deadline you can specify is 600 seconds (10 minutes).
    /// If this parameter is 0, a default value of 10 seconds is used.
    /// For push delivery, this value is also used to set the request timeout
    /// for the call to the push endpoint.
    /// If the subscriber never acknowledges the message, the Pub/Sub system
    /// will eventually redeliver the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackDeadlineSeconds")]
    pub ack_deadline_seconds: Option<f64>,
    /// If delivery to BigQuery is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigqueryConfig")]
    pub bigquery_config: Option<SubscriptionStatusAtProviderBigqueryConfig>,
    /// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
    /// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
    /// If all three are empty, then the subscriber will pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageConfig")]
    pub cloud_storage_config: Option<SubscriptionStatusAtProviderCloudStorageConfig>,
    /// A policy that specifies the conditions for dead lettering messages in
    /// this subscription. If dead_letter_policy is not set, dead lettering
    /// is disabled.
    /// The Cloud Pub/Sub service account associated with this subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Acknowledge() messages on this subscription.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterPolicy")]
    pub dead_letter_policy: Option<SubscriptionStatusAtProviderDeadLetterPolicy>,
    /// for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    pub effective_labels: Option<HashMap<String, String>>,
    /// If true, Pub/Sub provides the following guarantees for the delivery
    /// of a message with a given value of messageId on this Subscriptions':
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExactlyOnceDelivery")]
    pub enable_exactly_once_delivery: Option<bool>,
    /// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
    /// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
    /// may be delivered in any order.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMessageOrdering")]
    pub enable_message_ordering: Option<bool>,
    /// A policy that specifies the conditions for this subscription's expiration.
    /// A subscription is considered active as long as any connected subscriber
    /// is successfully consuming messages from the subscription or is issuing
    /// operations on the subscription. If expirationPolicy is not set, a default
    /// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
    /// resource never expires.  The minimum allowed value for expirationPolicy.ttl
    /// is 1 day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationPolicy")]
    pub expiration_policy: Option<SubscriptionStatusAtProviderExpirationPolicy>,
    /// The subscription only delivers the messages that match the filter.
    /// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
    /// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
    /// you can't modify the filter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/subscriptions/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A set of key/value label pairs to assign to this Subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// How long to retain unacknowledged messages in the subscription's
    /// backlog, from the moment a message is published. If
    /// retain_acked_messages is true, then this also configures the retention
    /// of acknowledged messages, and thus configures how far back in time a
    /// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
    /// than 7 days ("604800s") or less than 10 minutes ("600s").
    /// A duration in seconds with up to nine fractional digits, terminated
    /// by 's'. Example: "600.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageRetentionDuration")]
    pub message_retention_duration: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// If push delivery is used with this subscription, this field is used to
    /// configure it. An empty pushConfig signifies that the subscriber will
    /// pull and ack messages using API methods.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushConfig")]
    pub push_config: Option<SubscriptionStatusAtProviderPushConfig>,
    /// Indicates whether to retain acknowledged messages. If true, then
    /// messages are not expunged from the subscription's backlog, even if
    /// they are acknowledged, until they fall out of the
    /// messageRetentionDuration window.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retainAckedMessages")]
    pub retain_acked_messages: Option<bool>,
    /// A policy that specifies how Pub/Sub retries message delivery for this subscription.
    /// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
    /// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<SubscriptionStatusAtProviderRetryPolicy>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
    /// (as in the id property of a google_pubsub_topic), or just a topic name if
    /// the topic is in the same project as the subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// If delivery to BigQuery is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderBigqueryConfig {
    /// When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
    /// are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
    /// and any messages with extra fields are not written and remain in the subscription's backlog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropUnknownFields")]
    pub drop_unknown_fields: Option<bool>,
    /// The service account to use to write to BigQuery. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<String>,
    /// When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
    /// must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTableSchema")]
    pub use_table_schema: Option<bool>,
    /// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
    /// Only one of use_topic_schema and use_table_schema can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTopicSchema")]
    pub use_topic_schema: Option<bool>,
    /// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
    /// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
/// Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
/// If all three are empty, then the subscriber will pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderCloudStorageConfig {
    /// If set, message data will be written to Cloud Storage in Avro format.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "avroConfig")]
    pub avro_config: Option<SubscriptionStatusAtProviderCloudStorageConfigAvroConfig>,
    /// User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameDatetimeFormat")]
    pub filename_datetime_format: Option<String>,
    /// User-provided prefix for Cloud Storage filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenamePrefix")]
    pub filename_prefix: Option<String>,
    /// User-provided suffix for Cloud Storage filename. Must not end in "/".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filenameSuffix")]
    pub filename_suffix: Option<String>,
    /// The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
    /// The maxBytes limit may be exceeded in cases where messages are larger than the limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<f64>,
    /// The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
    /// May not exceed the subscription's acknowledgement deadline.
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDuration")]
    pub max_duration: Option<String>,
    /// The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
    /// service agent,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// (Output)
    /// An output-only field that indicates whether or not the subscription can receive messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// If set, message data will be written to Cloud Storage in Avro format.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderCloudStorageConfigAvroConfig {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// A policy that specifies the conditions for dead lettering messages in
/// this subscription. If dead_letter_policy is not set, dead lettering
/// is disabled.
/// The Cloud Pub/Sub service account associated with this subscription's
/// parent project (i.e.,
/// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
/// permission to Acknowledge() messages on this subscription.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderDeadLetterPolicy {
    /// The name of the topic to which dead letter messages should be published.
    /// Format is projects/{project}/topics/{topic}.
    /// The Cloud Pub/Sub service account associated with the enclosing subscription's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Publish() to this topic.
    /// The operation will fail if the topic does not exist.
    /// Users should ensure that there is a subscription attached to this topic
    /// since messages published to a topic with no subscriptions are lost.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deadLetterTopic")]
    pub dead_letter_topic: Option<String>,
    /// The maximum number of delivery attempts for any message. The value must be
    /// between 5 and 100.
    /// The number of delivery attempts is defined as 1 + (the sum of number of
    /// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
    /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    /// client libraries may automatically extend ack_deadlines.
    /// This field will be honored on a best effort basis.
    /// If this parameter is 0, a default value of 5 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDeliveryAttempts")]
    pub max_delivery_attempts: Option<f64>,
}

/// A policy that specifies the conditions for this subscription's expiration.
/// A subscription is considered active as long as any connected subscriber
/// is successfully consuming messages from the subscription or is issuing
/// operations on the subscription. If expirationPolicy is not set, a default
/// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
/// resource never expires.  The minimum allowed value for expirationPolicy.ttl
/// is 1 day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderExpirationPolicy {
    /// Specifies the "time-to-live" duration for an associated resource. The
    /// resource expires if it is not active for a period of ttl.
    /// If ttl is set to "", the associated resource never expires.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'.
    /// Example - "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// If push delivery is used with this subscription, this field is used to
/// configure it. An empty pushConfig signifies that the subscriber will
/// pull and ack messages using API methods.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderPushConfig {
    /// Endpoint configuration attributes.
    /// Every endpoint has a set of API supported attributes that can
    /// be used to control different aspects of the message delivery.
    /// The currently supported attribute is x-goog-version, which you
    /// can use to change the format of the pushed message. This
    /// attribute indicates the version of the data expected by
    /// the endpoint. This controls the shape of the pushed message
    /// (i.e., its fields and metadata). The endpoint version is
    /// based on the version of the Pub/Sub API.
    /// If not present during the subscriptions.create call,
    /// it will default to the version of the API used to make
    /// such call. If not present during a subscriptions.modifyPushConfig
    /// call, its value will not be changed. subscriptions.get
    /// calls will always return a valid version, even if the
    /// subscription was created without this attribute.
    /// The possible values for this attribute are:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<HashMap<String, String>>,
    /// When set, the payload to the push endpoint is not wrapped.Sets the
    /// data field as the HTTP body for delivery.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noWrapper")]
    pub no_wrapper: Option<SubscriptionStatusAtProviderPushConfigNoWrapper>,
    /// If specified, Pub/Sub will generate and attach an OIDC JWT token as
    /// an Authorization header in the HTTP request for every pushed message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcToken")]
    pub oidc_token: Option<SubscriptionStatusAtProviderPushConfigOidcToken>,
    /// A URL locating the endpoint to which messages should be pushed.
    /// For example, a Webhook endpoint might use
    /// "https://example.com/push".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushEndpoint")]
    pub push_endpoint: Option<String>,
}

/// When set, the payload to the push endpoint is not wrapped.Sets the
/// data field as the HTTP body for delivery.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderPushConfigNoWrapper {
    /// When true, writes the Pub/Sub message metadata to
    /// x-goog-pubsub-<KEY>:<VAL> headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to <KEY>:<VAL> headers of the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeMetadata")]
    pub write_metadata: Option<bool>,
}

/// If specified, Pub/Sub will generate and attach an OIDC JWT token as
/// an Authorization header in the HTTP request for every pushed message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderPushConfigOidcToken {
    /// Audience to be used when generating OIDC token. The audience claim
    /// identifies the recipients that the JWT is intended for. The audience
    /// value is a single case-sensitive string. Having multiple values (array)
    /// for the audience field is not supported. More info about the OIDC JWT
    /// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
    /// Note: if not specified, the Push endpoint URL will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// Service account email to be used for generating the OIDC token.
    /// The caller (for subscriptions.create, subscriptions.patch, and
    /// subscriptions.modifyPushConfig RPCs) must have the
    /// iam.serviceAccounts.actAs permission for the service account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
}

/// A policy that specifies how Pub/Sub retries message delivery for this subscription.
/// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
/// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct SubscriptionStatusAtProviderRetryPolicy {
    /// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumBackoff")]
    pub maximum_backoff: Option<String>,
    /// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumBackoff")]
    pub minimum_backoff: Option<String>,
}

