// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InspectTemplateSpec defines the desired state of InspectTemplate
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "datalossprevention.gcp.upbound.io", version = "v1beta2", kind = "InspectTemplate", plural = "inspecttemplates")]
#[kube(status = "InspectTemplateStatus")]
pub struct InspectTemplateSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<InspectTemplateDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InspectTemplateForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<InspectTemplateInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<InspectTemplateProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<InspectTemplatePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<InspectTemplateWriteConnectionSecretToRef>,
}

/// InspectTemplateSpec defines the desired state of InspectTemplate
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InspectTemplateDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProvider {
    /// A description of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<InspectTemplateForProviderInspectConfig>,
    /// The parent of the inspect template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateId")]
    pub template_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfig {
    /// List of options defining data content to scan. If empty, text, images, and other content will be included.
    /// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentOptions")]
    pub content_options: Option<Vec<String>>,
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<InspectTemplateForProviderInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
    /// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
    /// By default this may be all types, but may change over time as detectors are updated.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateForProviderInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<InspectTemplateForProviderInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<InspectTemplateForProviderInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesStoredType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateForProviderInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<InspectTemplateForProviderInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// For tabular data, the context includes the column name.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// For tabular data, the context includes the column name.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateForProviderInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProvider {
    /// A description of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<InspectTemplateInitProviderInspectConfig>,
    /// The parent of the inspect template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateId")]
    pub template_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfig {
    /// List of options defining data content to scan. If empty, text, images, and other content will be included.
    /// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentOptions")]
    pub content_options: Option<Vec<String>>,
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<InspectTemplateInitProviderInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
    /// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
    /// By default this may be all types, but may change over time as detectors are updated.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateInitProviderInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<InspectTemplateInitProviderInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<InspectTemplateInitProviderInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesStoredType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateInitProviderInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<InspectTemplateInitProviderInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// For tabular data, the context includes the column name.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// For tabular data, the context includes the column name.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateInitProviderInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InspectTemplateProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InspectTemplateProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InspectTemplateProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InspectTemplateProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InspectTemplateProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplatePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<InspectTemplatePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InspectTemplatePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplatePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<InspectTemplatePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplatePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<InspectTemplatePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<InspectTemplatePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InspectTemplatePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InspectTemplatePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplatePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InspectTemplateStatus defines the observed state of InspectTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<InspectTemplateStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProvider {
    /// A description of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the inspect template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// an identifier for the resource with format {{parent}}/inspectTemplates/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<InspectTemplateStatusAtProviderInspectConfig>,
    /// The resource name of the inspect template. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The parent of the inspect template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateId")]
    pub template_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfig {
    /// List of options defining data content to scan. If empty, text, images, and other content will be included.
    /// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentOptions")]
    pub content_options: Option<Vec<String>>,
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
    /// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
    /// By default this may be all types, but may change over time as detectors are updated.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateStatusAtProviderInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<InspectTemplateStatusAtProviderInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<InspectTemplateStatusAtProviderInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesStoredType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateStatusAtProviderInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<InspectTemplateStatusAtProviderInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// For tabular data, the context includes the column name.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// For tabular data, the context includes the column name.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
    /// or projects/project-id/storedInfoTypes/432452342.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct InspectTemplateStatusAtProviderInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

