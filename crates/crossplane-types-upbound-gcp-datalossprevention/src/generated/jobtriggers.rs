// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// JobTriggerSpec defines the desired state of JobTrigger
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "datalossprevention.gcp.upbound.io", version = "v1beta2", kind = "JobTrigger", plural = "jobtriggers")]
#[kube(status = "JobTriggerStatus")]
pub struct JobTriggerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<JobTriggerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: JobTriggerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    pub init_provider: Option<JobTriggerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    pub provider_config_ref: Option<JobTriggerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    pub publish_connection_details_to: Option<JobTriggerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    pub write_connection_secret_to_ref: Option<JobTriggerWriteConnectionSecretToRef>,
}

/// JobTriggerSpec defines the desired state of JobTrigger
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProvider {
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// Controls what and how to inspect for findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectJob")]
    pub inspect_job: Option<JobTriggerForProviderInspectJob>,
    /// The parent of the trigger, either in the format projects/{{project}}
    /// or projects/{{project}}/locations/{{location}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Whether the trigger is currently active.
    /// Default value is HEALTHY.
    /// Possible values are: PAUSED, HEALTHY, CANCELLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// The trigger id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+.
    /// The maximum length is 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerId")]
    pub trigger_id: Option<String>,
    /// What event needs to occur for a new job to be started.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<Vec<JobTriggerForProviderTriggers>>,
}

/// Controls what and how to inspect for findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJob {
    /// Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<JobTriggerForProviderInspectJobActions>>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<JobTriggerForProviderInspectJobInspectConfig>,
    /// The name of the template to run when this job is triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectTemplateName")]
    pub inspect_template_name: Option<String>,
    /// Information on where to inspect
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageConfig")]
    pub storage_config: Option<JobTriggerForProviderInspectJobStorageConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActions {
    /// Create a de-identified copy of the requested table or files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deidentify: Option<JobTriggerForProviderInspectJobActionsDeidentify>,
    /// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobNotificationEmails")]
    pub job_notification_emails: Option<JobTriggerForProviderInspectJobActionsJobNotificationEmails>,
    /// Publish a message into a given Pub/Sub topic when the job completes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubSub")]
    pub pub_sub: Option<JobTriggerForProviderInspectJobActionsPubSub>,
    /// Publish findings of a DlpJob to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishFindingsToCloudDataCatalog")]
    pub publish_findings_to_cloud_data_catalog: Option<JobTriggerForProviderInspectJobActionsPublishFindingsToCloudDataCatalog>,
    /// Publish the result summary of a DlpJob to the Cloud Security Command Center.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishSummaryToCscc")]
    pub publish_summary_to_cscc: Option<JobTriggerForProviderInspectJobActionsPublishSummaryToCscc>,
    /// Enable Stackdriver metric dlp.googleapis.com/findingCount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishToStackdriver")]
    pub publish_to_stackdriver: Option<JobTriggerForProviderInspectJobActionsPublishToStackdriver>,
    /// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "saveFindings")]
    pub save_findings: Option<JobTriggerForProviderInspectJobActionsSaveFindings>,
}

/// Create a de-identified copy of the requested table or files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentify {
    /// User settable Cloud Storage bucket and folders to store de-identified files.
    /// This field must be set for cloud storage deidentification.
    /// The output Cloud Storage bucket must be different from the input bucket.
    /// De-identified files will overwrite files in the output path.
    /// Form of: gs://bucket/folder/ or gs://bucket
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOutput")]
    pub cloud_storage_output: Option<String>,
    /// List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
    /// If empty, all supported files will be transformed. Supported types may be automatically added over time.
    /// If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
    /// Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypesToTransform")]
    pub file_types_to_transform: Option<Vec<String>>,
    /// User specified deidentify templates and configs for structured, unstructured, and image files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationConfig")]
    pub transformation_config: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationConfig>,
    /// Config for storing transformation details.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationDetailsStorageConfig")]
    pub transformation_details_storage_config: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig>,
}

/// User specified deidentify templates and configs for structured, unstructured, and image files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationConfig {
    /// If this template is specified, it will serve as the default de-identify template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deidentifyTemplate")]
    pub deidentify_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRedactTemplate")]
    pub image_redact_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "structuredDeidentifyTemplate")]
    pub structured_deidentify_template: Option<String>,
}

/// Config for storing transformation details.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig {
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// Reference to a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdRef")]
    pub dataset_id_ref: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef>,
    /// Selector for a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdSelector")]
    pub dataset_id_selector: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
    /// Reference to a Table in bigquery to populate tableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableIdRef")]
    pub table_id_ref: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef>,
    /// Selector for a Table in bigquery to populate tableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableIdSelector")]
    pub table_id_selector: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector>,
}

/// Reference to a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Table in bigquery to populate tableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Table in bigquery to populate tableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsJobNotificationEmails {
}

/// Publish a message into a given Pub/Sub topic when the job completes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsPubSub {
    /// Cloud Pub/Sub topic to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Publish findings of a DlpJob to Data Catalog.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsPublishFindingsToCloudDataCatalog {
}

/// Publish the result summary of a DlpJob to the Cloud Security Command Center.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsPublishSummaryToCscc {
}

/// Enable Stackdriver metric dlp.googleapis.com/findingCount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsPublishToStackdriver {
}

/// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsSaveFindings {
    /// Information on where to store output
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputConfig")]
    pub output_config: Option<JobTriggerForProviderInspectJobActionsSaveFindingsOutputConfig>,
}

/// Information on where to store output
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsSaveFindingsOutputConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only used for
    /// Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
    /// object. If appending to an existing table, any columns from the predefined schema
    /// that are missing will be added. No columns in the existing table will be deleted.
    /// If unspecified, then all available columns will be used for a new table or an (existing)
    /// table with no schema, and no changes will be made to an existing table that has a schema.
    /// Only for use with external storage.
    /// Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputSchema")]
    pub output_schema: Option<String>,
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerForProviderInspectJobActionsSaveFindingsOutputConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobActionsSaveFindingsOutputConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfig {
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerForProviderInspectJobInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<JobTriggerForProviderInspectJobInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<JobTriggerForProviderInspectJobInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesStoredType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerForProviderInspectJobInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<JobTriggerForProviderInspectJobInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// Information on where to inspect
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfig {
    /// Options defining BigQuery table and row identifiers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigQueryOptions")]
    pub big_query_options: Option<JobTriggerForProviderInspectJobStorageConfigBigQueryOptions>,
    /// Options defining a file or a set of files within a Google Cloud Storage bucket.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOptions")]
    pub cloud_storage_options: Option<JobTriggerForProviderInspectJobStorageConfigCloudStorageOptions>,
    /// Options defining a data set within Google Cloud Datastore.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datastoreOptions")]
    pub datastore_options: Option<JobTriggerForProviderInspectJobStorageConfigDatastoreOptions>,
    /// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridOptions")]
    pub hybrid_options: Option<JobTriggerForProviderInspectJobStorageConfigHybridOptions>,
    /// Configuration of the timespan of the items to include in scanning
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timespanConfig")]
    pub timespan_config: Option<JobTriggerForProviderInspectJobStorageConfigTimespanConfig>,
}

/// Options defining BigQuery table and row identifiers.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigBigQueryOptions {
    /// References to fields excluded from scanning.
    /// This allows you to skip inspection of entire columns which you know have no findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedFields")]
    pub excluded_fields: Option<Vec<JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields>>,
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields>>,
    /// Limit scanning only to these fields.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFields")]
    pub included_fields: Option<Vec<JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields>>,
    /// Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
    /// If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
    /// specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimit")]
    pub rows_limit: Option<f64>,
    /// Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimitPercent")]
    pub rows_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableReference")]
    pub table_reference: Option<JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsTableReference>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigBigQueryOptionsTableReference {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// Options defining a file or a set of files within a Google Cloud Storage bucket.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigCloudStorageOptions {
    /// Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
    /// then the rest of the bytes are omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFile")]
    pub bytes_limit_per_file: Option<f64>,
    /// Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFilePercent")]
    pub bytes_limit_per_file_percent: Option<f64>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSet")]
    pub file_set: Option<JobTriggerForProviderInspectJobStorageConfigCloudStorageOptionsFileSet>,
    /// List of file type groups to include in the scan. If empty, all files are scanned and available data
    /// format processors are applied. In addition, the binary content of the selected files is always scanned as well.
    /// Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
    /// Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV, POWERPOINT, EXCEL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypes")]
    pub file_types: Option<Vec<String>>,
    /// Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filesLimitPercent")]
    pub files_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
    /// The regex-filtered set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexFileSet")]
    pub regex_file_set: Option<JobTriggerForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet>,
    /// The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard
    /// in the path is allowed.
    /// If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
    /// non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is
    /// equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// The regex-filtered set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
    /// The name of a Cloud Storage bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// A list of regular expressions matching file paths to exclude. All files in the bucket that match at
    /// least one of these regular expressions will be excluded from the scan.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeRegex")]
    pub exclude_regex: Option<Vec<String>>,
    /// A list of regular expressions matching file paths to include. All files in the bucket
    /// that match at least one of these regular expressions will be included in the set of files,
    /// except for those that also match an item in excludeRegex. Leaving this field empty will
    /// match all files by default (this is equivalent to including .* in the list)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeRegex")]
    pub include_regex: Option<Vec<String>>,
}

/// Options defining a data set within Google Cloud Datastore.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigDatastoreOptions {
    /// A representation of a Datastore kind.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<JobTriggerForProviderInspectJobStorageConfigDatastoreOptionsKind>,
    /// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
    /// is always by project and namespace, however the namespace ID may be empty.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionId")]
    pub partition_id: Option<JobTriggerForProviderInspectJobStorageConfigDatastoreOptionsPartitionId>,
}

/// A representation of a Datastore kind.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigDatastoreOptionsKind {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
/// is always by project and namespace, however the namespace ID may be empty.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
    /// If not empty, the ID of the namespace to which the entities belong.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceId")]
    pub namespace_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
}

/// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigHybridOptions {
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// To organize findings, these labels will be added to each finding.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?.
    /// No more than 10 labels can be associated with a given finding.
    /// Examples:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// These are labels that each inspection request must include within their 'finding_labels' map. Request
    /// may contain others, but any missing one of these will be rejected.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// No more than 10 keys can be required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredFindingLabelKeys")]
    pub required_finding_label_keys: Option<Vec<String>>,
    /// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableOptions")]
    pub table_options: Option<JobTriggerForProviderInspectJobStorageConfigHybridOptionsTableOptions>,
}

/// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigHybridOptionsTableOptions {
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration of the timespan of the items to include in scanning
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigTimespanConfig {
    /// When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
    /// scanning files that have not been modified since the last time the JobTrigger executed. This will
    /// be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
    /// used in the last run of the JobTrigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutoPopulationOfTimespanConfig")]
    pub enable_auto_population_of_timespan_config: Option<bool>,
    /// Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Specification of the field containing the timestamp of scanned items.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampField")]
    pub timestamp_field: Option<JobTriggerForProviderInspectJobStorageConfigTimespanConfigTimestampField>,
}

/// Specification of the field containing the timestamp of scanned items.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderInspectJobStorageConfigTimespanConfigTimestampField {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderTriggers {
    /// For use with hybrid jobs. Jobs must be manually created and finished.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manual: Option<JobTriggerForProviderTriggersManual>,
    /// Schedule for triggered jobs
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<JobTriggerForProviderTriggersSchedule>,
}

/// For use with hybrid jobs. Jobs must be manually created and finished.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderTriggersManual {
}

/// Schedule for triggered jobs
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerForProviderTriggersSchedule {
    /// With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
    /// A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
    /// This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurrencePeriodDuration")]
    pub recurrence_period_duration: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProvider {
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// Controls what and how to inspect for findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectJob")]
    pub inspect_job: Option<JobTriggerInitProviderInspectJob>,
    /// The parent of the trigger, either in the format projects/{{project}}
    /// or projects/{{project}}/locations/{{location}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Whether the trigger is currently active.
    /// Default value is HEALTHY.
    /// Possible values are: PAUSED, HEALTHY, CANCELLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// The trigger id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+.
    /// The maximum length is 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerId")]
    pub trigger_id: Option<String>,
    /// What event needs to occur for a new job to be started.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<Vec<JobTriggerInitProviderTriggers>>,
}

/// Controls what and how to inspect for findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJob {
    /// Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<JobTriggerInitProviderInspectJobActions>>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<JobTriggerInitProviderInspectJobInspectConfig>,
    /// The name of the template to run when this job is triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectTemplateName")]
    pub inspect_template_name: Option<String>,
    /// Information on where to inspect
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageConfig")]
    pub storage_config: Option<JobTriggerInitProviderInspectJobStorageConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActions {
    /// Create a de-identified copy of the requested table or files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deidentify: Option<JobTriggerInitProviderInspectJobActionsDeidentify>,
    /// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobNotificationEmails")]
    pub job_notification_emails: Option<JobTriggerInitProviderInspectJobActionsJobNotificationEmails>,
    /// Publish a message into a given Pub/Sub topic when the job completes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubSub")]
    pub pub_sub: Option<JobTriggerInitProviderInspectJobActionsPubSub>,
    /// Publish findings of a DlpJob to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishFindingsToCloudDataCatalog")]
    pub publish_findings_to_cloud_data_catalog: Option<JobTriggerInitProviderInspectJobActionsPublishFindingsToCloudDataCatalog>,
    /// Publish the result summary of a DlpJob to the Cloud Security Command Center.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishSummaryToCscc")]
    pub publish_summary_to_cscc: Option<JobTriggerInitProviderInspectJobActionsPublishSummaryToCscc>,
    /// Enable Stackdriver metric dlp.googleapis.com/findingCount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishToStackdriver")]
    pub publish_to_stackdriver: Option<JobTriggerInitProviderInspectJobActionsPublishToStackdriver>,
    /// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "saveFindings")]
    pub save_findings: Option<JobTriggerInitProviderInspectJobActionsSaveFindings>,
}

/// Create a de-identified copy of the requested table or files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentify {
    /// User settable Cloud Storage bucket and folders to store de-identified files.
    /// This field must be set for cloud storage deidentification.
    /// The output Cloud Storage bucket must be different from the input bucket.
    /// De-identified files will overwrite files in the output path.
    /// Form of: gs://bucket/folder/ or gs://bucket
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOutput")]
    pub cloud_storage_output: Option<String>,
    /// List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
    /// If empty, all supported files will be transformed. Supported types may be automatically added over time.
    /// If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
    /// Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypesToTransform")]
    pub file_types_to_transform: Option<Vec<String>>,
    /// User specified deidentify templates and configs for structured, unstructured, and image files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationConfig")]
    pub transformation_config: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationConfig>,
    /// Config for storing transformation details.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationDetailsStorageConfig")]
    pub transformation_details_storage_config: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig>,
}

/// User specified deidentify templates and configs for structured, unstructured, and image files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationConfig {
    /// If this template is specified, it will serve as the default de-identify template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deidentifyTemplate")]
    pub deidentify_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRedactTemplate")]
    pub image_redact_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "structuredDeidentifyTemplate")]
    pub structured_deidentify_template: Option<String>,
}

/// Config for storing transformation details.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig {
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// Reference to a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdRef")]
    pub dataset_id_ref: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef>,
    /// Selector for a Dataset in bigquery to populate datasetId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetIdSelector")]
    pub dataset_id_selector: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
    /// Reference to a Table in bigquery to populate tableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableIdRef")]
    pub table_id_ref: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef>,
    /// Selector for a Table in bigquery to populate tableId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableIdSelector")]
    pub table_id_selector: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector>,
}

/// Reference to a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Dataset in bigquery to populate datasetId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Table in bigquery to populate tableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Table in bigquery to populate tableId.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsJobNotificationEmails {
}

/// Publish a message into a given Pub/Sub topic when the job completes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsPubSub {
    /// Cloud Pub/Sub topic to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Publish findings of a DlpJob to Data Catalog.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsPublishFindingsToCloudDataCatalog {
}

/// Publish the result summary of a DlpJob to the Cloud Security Command Center.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsPublishSummaryToCscc {
}

/// Enable Stackdriver metric dlp.googleapis.com/findingCount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsPublishToStackdriver {
}

/// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsSaveFindings {
    /// Information on where to store output
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputConfig")]
    pub output_config: Option<JobTriggerInitProviderInspectJobActionsSaveFindingsOutputConfig>,
}

/// Information on where to store output
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsSaveFindingsOutputConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only used for
    /// Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
    /// object. If appending to an existing table, any columns from the predefined schema
    /// that are missing will be added. No columns in the existing table will be deleted.
    /// If unspecified, then all available columns will be used for a new table or an (existing)
    /// table with no schema, and no changes will be made to an existing table that has a schema.
    /// Only for use with external storage.
    /// Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputSchema")]
    pub output_schema: Option<String>,
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerInitProviderInspectJobActionsSaveFindingsOutputConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobActionsSaveFindingsOutputConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfig {
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<JobTriggerInitProviderInspectJobInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesStoredType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// Information on where to inspect
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfig {
    /// Options defining BigQuery table and row identifiers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigQueryOptions")]
    pub big_query_options: Option<JobTriggerInitProviderInspectJobStorageConfigBigQueryOptions>,
    /// Options defining a file or a set of files within a Google Cloud Storage bucket.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOptions")]
    pub cloud_storage_options: Option<JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptions>,
    /// Options defining a data set within Google Cloud Datastore.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datastoreOptions")]
    pub datastore_options: Option<JobTriggerInitProviderInspectJobStorageConfigDatastoreOptions>,
    /// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridOptions")]
    pub hybrid_options: Option<JobTriggerInitProviderInspectJobStorageConfigHybridOptions>,
    /// Configuration of the timespan of the items to include in scanning
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timespanConfig")]
    pub timespan_config: Option<JobTriggerInitProviderInspectJobStorageConfigTimespanConfig>,
}

/// Options defining BigQuery table and row identifiers.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigBigQueryOptions {
    /// References to fields excluded from scanning.
    /// This allows you to skip inspection of entire columns which you know have no findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedFields")]
    pub excluded_fields: Option<Vec<JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields>>,
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields>>,
    /// Limit scanning only to these fields.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFields")]
    pub included_fields: Option<Vec<JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields>>,
    /// Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
    /// If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
    /// specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimit")]
    pub rows_limit: Option<f64>,
    /// Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimitPercent")]
    pub rows_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableReference")]
    pub table_reference: Option<JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsTableReference>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigBigQueryOptionsTableReference {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// Options defining a file or a set of files within a Google Cloud Storage bucket.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptions {
    /// Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
    /// then the rest of the bytes are omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFile")]
    pub bytes_limit_per_file: Option<f64>,
    /// Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFilePercent")]
    pub bytes_limit_per_file_percent: Option<f64>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSet")]
    pub file_set: Option<JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet>,
    /// List of file type groups to include in the scan. If empty, all files are scanned and available data
    /// format processors are applied. In addition, the binary content of the selected files is always scanned as well.
    /// Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
    /// Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV, POWERPOINT, EXCEL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypes")]
    pub file_types: Option<Vec<String>>,
    /// Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filesLimitPercent")]
    pub files_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
    /// The regex-filtered set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexFileSet")]
    pub regex_file_set: Option<JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet>,
    /// The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard
    /// in the path is allowed.
    /// If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
    /// non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is
    /// equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// The regex-filtered set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
    /// The name of a Cloud Storage bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// A list of regular expressions matching file paths to exclude. All files in the bucket that match at
    /// least one of these regular expressions will be excluded from the scan.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeRegex")]
    pub exclude_regex: Option<Vec<String>>,
    /// A list of regular expressions matching file paths to include. All files in the bucket
    /// that match at least one of these regular expressions will be included in the set of files,
    /// except for those that also match an item in excludeRegex. Leaving this field empty will
    /// match all files by default (this is equivalent to including .* in the list)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeRegex")]
    pub include_regex: Option<Vec<String>>,
}

/// Options defining a data set within Google Cloud Datastore.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigDatastoreOptions {
    /// A representation of a Datastore kind.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<JobTriggerInitProviderInspectJobStorageConfigDatastoreOptionsKind>,
    /// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
    /// is always by project and namespace, however the namespace ID may be empty.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionId")]
    pub partition_id: Option<JobTriggerInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId>,
}

/// A representation of a Datastore kind.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigDatastoreOptionsKind {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
/// is always by project and namespace, however the namespace ID may be empty.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
    /// If not empty, the ID of the namespace to which the entities belong.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceId")]
    pub namespace_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
}

/// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigHybridOptions {
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// To organize findings, these labels will be added to each finding.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?.
    /// No more than 10 labels can be associated with a given finding.
    /// Examples:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// These are labels that each inspection request must include within their 'finding_labels' map. Request
    /// may contain others, but any missing one of these will be rejected.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// No more than 10 keys can be required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredFindingLabelKeys")]
    pub required_finding_label_keys: Option<Vec<String>>,
    /// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableOptions")]
    pub table_options: Option<JobTriggerInitProviderInspectJobStorageConfigHybridOptionsTableOptions>,
}

/// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigHybridOptionsTableOptions {
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration of the timespan of the items to include in scanning
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigTimespanConfig {
    /// When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
    /// scanning files that have not been modified since the last time the JobTrigger executed. This will
    /// be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
    /// used in the last run of the JobTrigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutoPopulationOfTimespanConfig")]
    pub enable_auto_population_of_timespan_config: Option<bool>,
    /// Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Specification of the field containing the timestamp of scanned items.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampField")]
    pub timestamp_field: Option<JobTriggerInitProviderInspectJobStorageConfigTimespanConfigTimestampField>,
}

/// Specification of the field containing the timestamp of scanned items.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderInspectJobStorageConfigTimespanConfigTimestampField {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderTriggers {
    /// For use with hybrid jobs. Jobs must be manually created and finished.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manual: Option<JobTriggerInitProviderTriggersManual>,
    /// Schedule for triggered jobs
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<JobTriggerInitProviderTriggersSchedule>,
}

/// For use with hybrid jobs. Jobs must be manually created and finished.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderTriggersManual {
}

/// Schedule for triggered jobs
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerInitProviderTriggersSchedule {
    /// With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
    /// A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
    /// This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurrencePeriodDuration")]
    pub recurrence_period_duration: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<JobTriggerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<JobTriggerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<JobTriggerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<JobTriggerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolve: Option<JobTriggerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum JobTriggerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// JobTriggerStatus defines the observed state of JobTrigger.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    pub at_provider: Option<JobTriggerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProvider {
    /// The creation timestamp of an inspectTemplate. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    pub create_time: Option<String>,
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// User set display name of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    pub display_name: Option<String>,
    /// an identifier for the resource with format {{parent}}/jobTriggers/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Controls what and how to inspect for findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectJob")]
    pub inspect_job: Option<JobTriggerStatusAtProviderInspectJob>,
    /// The timestamp of the last time this trigger executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastRunTime")]
    pub last_run_time: Option<String>,
    /// The resource name of the job trigger. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The parent of the trigger, either in the format projects/{{project}}
    /// or projects/{{project}}/locations/{{location}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Whether the trigger is currently active.
    /// Default value is HEALTHY.
    /// Possible values are: PAUSED, HEALTHY, CANCELLED.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// The trigger id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+.
    /// The maximum length is 100 characters. Can be empty to allow the system to generate one.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerId")]
    pub trigger_id: Option<String>,
    /// What event needs to occur for a new job to be started.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triggers: Option<Vec<JobTriggerStatusAtProviderTriggers>>,
    /// The last update timestamp of an inspectTemplate. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    pub update_time: Option<String>,
}

/// Controls what and how to inspect for findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJob {
    /// Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<JobTriggerStatusAtProviderInspectJobActions>>,
    /// The core content of the template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectConfig")]
    pub inspect_config: Option<JobTriggerStatusAtProviderInspectJobInspectConfig>,
    /// The name of the template to run when this job is triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inspectTemplateName")]
    pub inspect_template_name: Option<String>,
    /// Information on where to inspect
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageConfig")]
    pub storage_config: Option<JobTriggerStatusAtProviderInspectJobStorageConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActions {
    /// Create a de-identified copy of the requested table or files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deidentify: Option<JobTriggerStatusAtProviderInspectJobActionsDeidentify>,
    /// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobNotificationEmails")]
    pub job_notification_emails: Option<JobTriggerStatusAtProviderInspectJobActionsJobNotificationEmails>,
    /// Publish a message into a given Pub/Sub topic when the job completes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubSub")]
    pub pub_sub: Option<JobTriggerStatusAtProviderInspectJobActionsPubSub>,
    /// Publish findings of a DlpJob to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishFindingsToCloudDataCatalog")]
    pub publish_findings_to_cloud_data_catalog: Option<JobTriggerStatusAtProviderInspectJobActionsPublishFindingsToCloudDataCatalog>,
    /// Publish the result summary of a DlpJob to the Cloud Security Command Center.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishSummaryToCscc")]
    pub publish_summary_to_cscc: Option<JobTriggerStatusAtProviderInspectJobActionsPublishSummaryToCscc>,
    /// Enable Stackdriver metric dlp.googleapis.com/findingCount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishToStackdriver")]
    pub publish_to_stackdriver: Option<JobTriggerStatusAtProviderInspectJobActionsPublishToStackdriver>,
    /// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "saveFindings")]
    pub save_findings: Option<JobTriggerStatusAtProviderInspectJobActionsSaveFindings>,
}

/// Create a de-identified copy of the requested table or files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsDeidentify {
    /// User settable Cloud Storage bucket and folders to store de-identified files.
    /// This field must be set for cloud storage deidentification.
    /// The output Cloud Storage bucket must be different from the input bucket.
    /// De-identified files will overwrite files in the output path.
    /// Form of: gs://bucket/folder/ or gs://bucket
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOutput")]
    pub cloud_storage_output: Option<String>,
    /// List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
    /// If empty, all supported files will be transformed. Supported types may be automatically added over time.
    /// If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
    /// Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypesToTransform")]
    pub file_types_to_transform: Option<Vec<String>>,
    /// User specified deidentify templates and configs for structured, unstructured, and image files.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationConfig")]
    pub transformation_config: Option<JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationConfig>,
    /// Config for storing transformation details.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transformationDetailsStorageConfig")]
    pub transformation_details_storage_config: Option<JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig>,
}

/// User specified deidentify templates and configs for structured, unstructured, and image files.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationConfig {
    /// If this template is specified, it will serve as the default de-identify template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deidentifyTemplate")]
    pub deidentify_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRedactTemplate")]
    pub image_redact_template: Option<String>,
    /// If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "structuredDeidentifyTemplate")]
    pub structured_deidentify_template: Option<String>,
}

/// Config for storing transformation details.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig {
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsJobNotificationEmails {
}

/// Publish a message into a given Pub/Sub topic when the job completes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsPubSub {
    /// Cloud Pub/Sub topic to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Publish findings of a DlpJob to Data Catalog.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsPublishFindingsToCloudDataCatalog {
}

/// Publish the result summary of a DlpJob to the Cloud Security Command Center.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsPublishSummaryToCscc {
}

/// Enable Stackdriver metric dlp.googleapis.com/findingCount.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsPublishToStackdriver {
}

/// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsSaveFindings {
    /// Information on where to store output
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputConfig")]
    pub output_config: Option<JobTriggerStatusAtProviderInspectJobActionsSaveFindingsOutputConfig>,
}

/// Information on where to store output
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsSaveFindingsOutputConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only used for
    /// Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
    /// object. If appending to an existing table, any columns from the predefined schema
    /// that are missing will be added. No columns in the existing table will be deleted.
    /// If unspecified, then all available columns will be used for a new table or an (existing)
    /// table with no schema, and no changes will be made to an existing table that has a schema.
    /// Only for use with external storage.
    /// Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputSchema")]
    pub output_schema: Option<String>,
    /// The BigQuery table in which to store the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<JobTriggerStatusAtProviderInspectJobActionsSaveFindingsOutputConfigTable>,
}

/// The BigQuery table in which to store the output.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobActionsSaveFindingsOutputConfigTable {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// The core content of the template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfig {
    /// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customInfoTypes")]
    pub custom_info_types: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypes>>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<bool>,
    /// When true, a contextual quote from the data that triggered a finding is included in the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeQuote")]
    pub include_quote: Option<bool>,
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigInfoTypes>>,
    /// Configuration to control the number of findings returned.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<JobTriggerStatusAtProviderInspectJobInspectConfigLimits>,
    /// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
    /// Default value is POSSIBLE.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLikelihood")]
    pub min_likelihood: Option<String>,
    /// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
    /// other rules are executed in the order they are specified for each info type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleSet")]
    pub rule_set: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSet>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypes {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionary>,
    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
    /// Possible values are: EXCLUSION_TYPE_EXCLUDE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionType")]
    pub exclusion_type: Option<String>,
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesInfoType>,
    /// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
    /// specified by the rule.
    /// Default value is VERY_LIKELY.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub likelihood: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesRegex>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore>,
    /// A reference to a StoredInfoType to use with scanning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storedType")]
    pub stored_type: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesStoredType>,
    /// Message for detecting output from deidentification transformations that support reversing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateType")]
    pub surrogate_type: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesSurrogateType>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// A reference to a StoredInfoType to use with scanning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesStoredType {
    /// (Output)
    /// The creation timestamp of an inspectTemplate. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    pub create_time: Option<String>,
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Message for detecting output from deidentification transformations that support reversing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigCustomInfoTypesSurrogateType {
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Configuration to control the number of findings returned.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigLimits {
    /// Configuration of findings limit given for specified infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerInfoType")]
    pub max_findings_per_info_type: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType>>,
    /// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerItem")]
    pub max_findings_per_item: Option<f64>,
    /// Max number of findings that will be returned per request/job. The maximum returned is 2000.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindingsPerRequest")]
    pub max_findings_per_request: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
    /// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
    /// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
    /// specified in another InfoTypeLimit.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoType")]
    pub info_type: Option<JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>,
    /// Max findings limit for the given infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFindings")]
    pub max_findings: Option<f64>,
}

/// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
/// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
/// specified in another InfoTypeLimit.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSet {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetInfoTypes>>,
    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRules {
    /// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusionRule")]
    pub exclusion_rule: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRule>,
    /// Hotword-based detection rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRule")]
    pub hotword_rule: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRule>,
}

/// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRule {
    /// Dictionary which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dictionary: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary>,
    /// Drop if the hotword rule is contained in the proximate context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeByHotword")]
    pub exclude_by_hotword: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword>,
    /// When true, excludes type information of the findings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInfoTypes")]
    pub exclude_info_types: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes>,
    /// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
    /// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingType")]
    pub matching_type: Option<String>,
    /// Regular expression which defines the rule.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex>,
}

/// Dictionary which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
    /// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStoragePath")]
    pub cloud_storage_path: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath>,
    /// List of words or phrases to search for.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    pub word_list: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList>,
}

/// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
    /// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// List of words or phrases to search for.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
    /// Words or phrases defining the dictionary. The dictionary must contain at least one
    /// phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub words: Option<Vec<String>>,
}

/// Drop if the hotword rule is contained in the proximate context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// When true, excludes type information of the findings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
    /// List of infoTypes this rule set is applied to.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    pub info_types: Option<Vec<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    pub sensitivity_score: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore>,
    /// Version of the information type to use. By default, the version is set to stable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<String>,
}

/// Regular expression which defines the rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Hotword-based detection rule.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRule {
    /// Regular expression pattern defining what qualifies as a hotword.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hotwordRegex")]
    pub hotword_regex: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex>,
    /// Likelihood adjustment to apply to all matching findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "likelihoodAdjustment")]
    pub likelihood_adjustment: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment>,
    /// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
    /// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
    /// used to match substrings of the finding itself. For example, the certainty of a phone number regex
    /// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
    /// office using the hotword regex (xxx), where xxx is the area code in question.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proximity: Option<JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity>,
}

/// Regular expression pattern defining what qualifies as a hotword.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
    /// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIndexes")]
    pub group_indexes: Option<Vec<f64>>,
    /// Pattern defining the regular expression.
    /// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

/// Likelihood adjustment to apply to all matching findings.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
    /// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
    /// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedLikelihood")]
    pub fixed_likelihood: Option<String>,
    /// Increase or decrease the likelihood by the specified number of levels. For example,
    /// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
    /// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
    /// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
    /// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
    /// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativeLikelihood")]
    pub relative_likelihood: Option<f64>,
}

/// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
/// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
/// used to match substrings of the finding itself. For example, the certainty of a phone number regex
/// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
/// office using the hotword regex (xxx), where xxx is the area code in question.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
    /// Number of characters after the finding to consider. Either this or window_before must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowAfter")]
    pub window_after: Option<f64>,
    /// Number of characters before the finding to consider. Either this or window_after must be specified
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowBefore")]
    pub window_before: Option<f64>,
}

/// Information on where to inspect
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfig {
    /// Options defining BigQuery table and row identifiers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bigQueryOptions")]
    pub big_query_options: Option<JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptions>,
    /// Options defining a file or a set of files within a Google Cloud Storage bucket.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudStorageOptions")]
    pub cloud_storage_options: Option<JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptions>,
    /// Options defining a data set within Google Cloud Datastore.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datastoreOptions")]
    pub datastore_options: Option<JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptions>,
    /// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridOptions")]
    pub hybrid_options: Option<JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptions>,
    /// Configuration of the timespan of the items to include in scanning
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timespanConfig")]
    pub timespan_config: Option<JobTriggerStatusAtProviderInspectJobStorageConfigTimespanConfig>,
}

/// Options defining BigQuery table and row identifiers.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptions {
    /// References to fields excluded from scanning.
    /// This allows you to skip inspection of entire columns which you know have no findings.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedFields")]
    pub excluded_fields: Option<Vec<JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsExcludedFields>>,
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields>>,
    /// Limit scanning only to these fields.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFields")]
    pub included_fields: Option<Vec<JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsIncludedFields>>,
    /// Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
    /// If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
    /// specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimit")]
    pub rows_limit: Option<f64>,
    /// Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowsLimitPercent")]
    pub rows_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableReference")]
    pub table_reference: Option<JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsTableReference>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsExcludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsIncludedFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigBigQueryOptionsTableReference {
    /// The ID of the dataset containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetId")]
    pub dataset_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// The ID of the table. The ID must contain only letters (a-z,
    /// A-Z), numbers (0-9), or underscores (_). The maximum length
    /// is 1,024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableId")]
    pub table_id: Option<String>,
}

/// Options defining a file or a set of files within a Google Cloud Storage bucket.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptions {
    /// Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
    /// then the rest of the bytes are omitted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFile")]
    pub bytes_limit_per_file: Option<f64>,
    /// Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesLimitPerFilePercent")]
    pub bytes_limit_per_file_percent: Option<f64>,
    /// Set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSet")]
    pub file_set: Option<JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptionsFileSet>,
    /// List of file type groups to include in the scan. If empty, all files are scanned and available data
    /// format processors are applied. In addition, the binary content of the selected files is always scanned as well.
    /// Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
    /// Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV, POWERPOINT, EXCEL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileTypes")]
    pub file_types: Option<Vec<String>>,
    /// Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
    /// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filesLimitPercent")]
    pub files_limit_percent: Option<f64>,
    /// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
    /// If not specified, scanning would start from the top.
    /// Possible values are: TOP, RANDOM_START.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleMethod")]
    pub sample_method: Option<String>,
}

/// Set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
    /// The regex-filtered set of files to scan.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexFileSet")]
    pub regex_file_set: Option<JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet>,
    /// The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard
    /// in the path is allowed.
    /// If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
    /// non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is
    /// equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// The regex-filtered set of files to scan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
    /// The name of a Cloud Storage bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// A list of regular expressions matching file paths to exclude. All files in the bucket that match at
    /// least one of these regular expressions will be excluded from the scan.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeRegex")]
    pub exclude_regex: Option<Vec<String>>,
    /// A list of regular expressions matching file paths to include. All files in the bucket
    /// that match at least one of these regular expressions will be included in the set of files,
    /// except for those that also match an item in excludeRegex. Leaving this field empty will
    /// match all files by default (this is equivalent to including .* in the list)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeRegex")]
    pub include_regex: Option<Vec<String>>,
}

/// Options defining a data set within Google Cloud Datastore.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptions {
    /// A representation of a Datastore kind.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptionsKind>,
    /// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
    /// is always by project and namespace, however the namespace ID may be empty.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "partitionId")]
    pub partition_id: Option<JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptionsPartitionId>,
}

/// A representation of a Datastore kind.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptionsKind {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
/// is always by project and namespace, however the namespace ID may be empty.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
    /// If not empty, the ID of the namespace to which the entities belong.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceId")]
    pub namespace_id: Option<String>,
    /// The ID of the project containing this table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
}

/// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptions {
    /// A description of the job trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// To organize findings, these labels will be added to each finding.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?.
    /// No more than 10 labels can be associated with a given finding.
    /// Examples:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// These are labels that each inspection request must include within their 'finding_labels' map. Request
    /// may contain others, but any missing one of these will be rejected.
    /// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
    /// No more than 10 keys can be required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredFindingLabelKeys")]
    pub required_finding_label_keys: Option<Vec<String>>,
    /// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableOptions")]
    pub table_options: Option<JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptionsTableOptions>,
}

/// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptionsTableOptions {
    /// The columns that are the primary keys for table objects included in ContentItem. A copy of this
    /// cell's value will stored alongside alongside each finding so that the finding can be traced to
    /// the specific row it came from. No more than 3 may be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identifyingFields")]
    pub identifying_fields: Option<Vec<JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration of the timespan of the items to include in scanning
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigTimespanConfig {
    /// When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
    /// scanning files that have not been modified since the last time the JobTrigger executed. This will
    /// be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
    /// used in the last run of the JobTrigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAutoPopulationOfTimespanConfig")]
    pub enable_auto_population_of_timespan_config: Option<bool>,
    /// Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Specification of the field containing the timestamp of scanned items.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampField")]
    pub timestamp_field: Option<JobTriggerStatusAtProviderInspectJobStorageConfigTimespanConfigTimestampField>,
}

/// Specification of the field containing the timestamp of scanned items.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderInspectJobStorageConfigTimespanConfigTimestampField {
    /// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
    /// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
    /// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
    /// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
    /// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
    /// timestamp property does not exist or its value is empty or invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderTriggers {
    /// For use with hybrid jobs. Jobs must be manually created and finished.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manual: Option<JobTriggerStatusAtProviderTriggersManual>,
    /// Schedule for triggered jobs
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<JobTriggerStatusAtProviderTriggersSchedule>,
}

/// For use with hybrid jobs. Jobs must be manually created and finished.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderTriggersManual {
}

/// Schedule for triggered jobs
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct JobTriggerStatusAtProviderTriggersSchedule {
    /// With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
    /// A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
    /// This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recurrencePeriodDuration")]
    pub recurrence_period_duration: Option<String>,
}

