// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TriggerSpec defines the desired state of Trigger
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "eventarc.gcp.upbound.io", version = "v1beta2", kind = "Trigger", plural = "triggers")]
#[kube(status = "TriggerStatus")]
pub struct TriggerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<TriggerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TriggerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<TriggerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<TriggerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<TriggerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<TriggerWriteConnectionSecretToRef>,
}

/// TriggerSpec defines the desired state of Trigger
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProvider {
    /// Optional. The name of the channel associated with the trigger in projects/{project}/locations/{location}/channels/{channel} format. You must provide a channel to receive events from Eventarc SaaS partners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Required. Destination specifies where the events should be sent to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub destination: Option<TriggerForProviderDestination>,
    /// Optional. EventDataContentType specifies the type of payload in MIME format that is expected from the CloudEvent data field. This is set to application/json if the value is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventDataContentType")]
    #[builder(default)]
    pub event_data_content_type: Option<String>,
    /// Optional. User labels attached to the triggers that can be used to group resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location for the resource
    pub location: String,
    /// Required. null The list of filters that applies to event attributes. Only events that match all the provided filters will be sent to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingCriteria")]
    #[builder(default)]
    pub matching_criteria: Option<Vec<TriggerForProviderMatchingCriteria>>,
    /// The project for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Optional. The IAM service account email associated with the trigger. The service account represents the identity of the trigger. The principal who calls this API must have iam.serviceAccounts.actAs permission in the service account. See https://cloud.google.com/iam/docs/understanding-service-accounts#sa_common for more information. For Cloud Run destinations, this service account is used to generate identity tokens when invoking the service. See https://cloud.google.com/run/docs/triggering/pubsub-push#create-service-account for information on how to invoke authenticated Cloud Run services. In order to create Audit Log triggers, the service account should also have roles/eventarc.eventReceiver IAM role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transport: Option<TriggerForProviderTransport>,
}

/// Required. Destination specifies where the events should be sent to.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestination {
    /// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudRunService")]
    #[builder(default)]
    pub cloud_run_service: Option<TriggerForProviderDestinationCloudRunService>,
    /// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gke: Option<TriggerForProviderDestinationGke>,
    /// An HTTP endpoint destination described by an URI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpEndpoint")]
    #[builder(default)]
    pub http_endpoint: Option<TriggerForProviderDestinationHttpEndpoint>,
    /// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<TriggerForProviderDestinationNetworkConfig>,
    /// The resource name of the Workflow whose Executions are triggered by the events. The Workflow resource should be deployed in the same project as the trigger. Format: projects/{project}/locations/{location}/workflows/{workflow}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub workflow: Option<String>,
}

/// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationCloudRunService {
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. The region the Cloud Run service is deployed in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a Service in cloudrun to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<TriggerForProviderDestinationCloudRunServiceServiceRef>,
    /// Selector for a Service in cloudrun to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<TriggerForProviderDestinationCloudRunServiceServiceSelector>,
}

/// Reference to a Service in cloudrun to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationCloudRunServiceServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderDestinationCloudRunServiceServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationCloudRunServiceServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderDestinationCloudRunServiceServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderDestinationCloudRunServiceServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderDestinationCloudRunServiceServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderDestinationCloudRunServiceServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Service in cloudrun to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationCloudRunServiceServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderDestinationCloudRunServiceServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationGke {
    /// Required. The name of the cluster the GKE service is running in. The cluster must be running in the same project as the trigger being created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// The location for the resource
    pub location: String,
    /// Required. The namespace the GKE service is running in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// An HTTP endpoint destination described by an URI.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationHttpEndpoint {
    /// Required. The URI of the HTTP enpdoint. The value must be a RFC2396 URI string. Examples: http://10.10.10.8:80/route, http://svc.us-central1.p.local:8080/. Only HTTP and HTTPS protocols are supported. The host can be either a static IP addressable from the VPC specified by the network config, or an internal DNS hostname of the service resolvable via Cloud DNS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderDestinationNetworkConfig {
    /// Required. Name of the NetworkAttachment that allows access to the destination VPC. Format: projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkAttachment")]
    #[builder(default)]
    pub network_attachment: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderMatchingCriteria {
    /// Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. All triggers MUST provide a filter for the 'type' attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is match-path-pattern.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute. See https://cloud.google.com/eventarc/docs/creating-triggers#trigger-gcloud for available values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderTransport {
    /// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub pubsub: Option<TriggerForProviderTransportPubsub>,
}

/// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderTransportPubsub {
    /// Optional. The name of the Pub/Sub topic created and managed by Eventarc system as a transport for the event delivery. Format: projects/{PROJECT_ID}/topics/{TOPIC_NAME}. You may set an existing topic for triggers of the type google.cloud.pubsub.topic.v1.messagePublished only. The topic you provide here will not be deleted by Eventarc at trigger deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProvider {
    /// Optional. The name of the channel associated with the trigger in projects/{project}/locations/{location}/channels/{channel} format. You must provide a channel to receive events from Eventarc SaaS partners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Required. Destination specifies where the events should be sent to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub destination: Option<TriggerInitProviderDestination>,
    /// Optional. EventDataContentType specifies the type of payload in MIME format that is expected from the CloudEvent data field. This is set to application/json if the value is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventDataContentType")]
    #[builder(default)]
    pub event_data_content_type: Option<String>,
    /// Optional. User labels attached to the triggers that can be used to group resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Required. null The list of filters that applies to event attributes. Only events that match all the provided filters will be sent to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingCriteria")]
    #[builder(default)]
    pub matching_criteria: Option<Vec<TriggerInitProviderMatchingCriteria>>,
    /// The project for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Optional. The IAM service account email associated with the trigger. The service account represents the identity of the trigger. The principal who calls this API must have iam.serviceAccounts.actAs permission in the service account. See https://cloud.google.com/iam/docs/understanding-service-accounts#sa_common for more information. For Cloud Run destinations, this service account is used to generate identity tokens when invoking the service. See https://cloud.google.com/run/docs/triggering/pubsub-push#create-service-account for information on how to invoke authenticated Cloud Run services. In order to create Audit Log triggers, the service account should also have roles/eventarc.eventReceiver IAM role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transport: Option<TriggerInitProviderTransport>,
}

/// Required. Destination specifies where the events should be sent to.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestination {
    /// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudRunService")]
    #[builder(default)]
    pub cloud_run_service: Option<TriggerInitProviderDestinationCloudRunService>,
    /// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gke: Option<TriggerInitProviderDestinationGke>,
    /// An HTTP endpoint destination described by an URI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpEndpoint")]
    #[builder(default)]
    pub http_endpoint: Option<TriggerInitProviderDestinationHttpEndpoint>,
    /// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<TriggerInitProviderDestinationNetworkConfig>,
    /// The resource name of the Workflow whose Executions are triggered by the events. The Workflow resource should be deployed in the same project as the trigger. Format: projects/{project}/locations/{location}/workflows/{workflow}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub workflow: Option<String>,
}

/// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationCloudRunService {
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. The region the Cloud Run service is deployed in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a Service in cloudrun to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<TriggerInitProviderDestinationCloudRunServiceServiceRef>,
    /// Selector for a Service in cloudrun to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<TriggerInitProviderDestinationCloudRunServiceServiceSelector>,
}

/// Reference to a Service in cloudrun to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationCloudRunServiceServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderDestinationCloudRunServiceServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationCloudRunServiceServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderDestinationCloudRunServiceServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderDestinationCloudRunServiceServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderDestinationCloudRunServiceServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderDestinationCloudRunServiceServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Service in cloudrun to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationCloudRunServiceServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderDestinationCloudRunServiceServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationGke {
    /// Required. The name of the cluster the GKE service is running in. The cluster must be running in the same project as the trigger being created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// Required. The namespace the GKE service is running in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// An HTTP endpoint destination described by an URI.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationHttpEndpoint {
    /// Required. The URI of the HTTP enpdoint. The value must be a RFC2396 URI string. Examples: http://10.10.10.8:80/route, http://svc.us-central1.p.local:8080/. Only HTTP and HTTPS protocols are supported. The host can be either a static IP addressable from the VPC specified by the network config, or an internal DNS hostname of the service resolvable via Cloud DNS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderDestinationNetworkConfig {
    /// Required. Name of the NetworkAttachment that allows access to the destination VPC. Format: projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkAttachment")]
    #[builder(default)]
    pub network_attachment: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderMatchingCriteria {
    /// Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. All triggers MUST provide a filter for the 'type' attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is match-path-pattern.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute. See https://cloud.google.com/eventarc/docs/creating-triggers#trigger-gcloud for available values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderTransport {
    /// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub pubsub: Option<TriggerInitProviderTransportPubsub>,
}

/// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderTransportPubsub {
    /// Optional. The name of the Pub/Sub topic created and managed by Eventarc system as a transport for the event delivery. Format: projects/{PROJECT_ID}/topics/{TOPIC_NAME}. You may set an existing topic for triggers of the type google.cloud.pubsub.topic.v1.messagePublished only. The topic you provide here will not be deleted by Eventarc at trigger deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<TriggerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<TriggerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TriggerStatus defines the observed state of Trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<TriggerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProvider {
    /// Optional. The name of the channel associated with the trigger in projects/{project}/locations/{location}/channels/{channel} format. You must provide a channel to receive events from Eventarc SaaS partners.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Output only. The reason(s) why a trigger is in FAILED state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<HashMap<String, String>>,
    /// Output only. The creation time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    #[builder(default)]
    pub create_time: Option<String>,
    /// Required. Destination specifies where the events should be sent to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub destination: Option<TriggerStatusAtProviderDestination>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// Output only. This checksum is computed by the server based on the value of other fields, and may be sent only on create requests to ensure the client has an up-to-date value before proceeding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub etag: Option<String>,
    /// Optional. EventDataContentType specifies the type of payload in MIME format that is expected from the CloudEvent data field. This is set to application/json if the value is not defined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventDataContentType")]
    #[builder(default)]
    pub event_data_content_type: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/triggers/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Optional. User labels attached to the triggers that can be used to group resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Required. null The list of filters that applies to event attributes. Only events that match all the provided filters will be sent to the destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingCriteria")]
    #[builder(default)]
    pub matching_criteria: Option<Vec<TriggerStatusAtProviderMatchingCriteria>>,
    /// The project for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Optional. The IAM service account email associated with the trigger. The service account represents the identity of the trigger. The principal who calls this API must have iam.serviceAccounts.actAs permission in the service account. See https://cloud.google.com/iam/docs/understanding-service-accounts#sa_common for more information. For Cloud Run destinations, this service account is used to generate identity tokens when invoking the service. See https://cloud.google.com/run/docs/triggering/pubsub-push#create-service-account for information on how to invoke authenticated Cloud Run services. In order to create Audit Log triggers, the service account should also have roles/eventarc.eventReceiver IAM role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// The combination of labels configured directly on the resource and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transport: Option<TriggerStatusAtProviderTransport>,
    /// Output only. Server assigned unique identifier for the trigger. The value is a UUID4 string and guaranteed to remain unchanged until the resource is deleted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uid: Option<String>,
    /// Output only. The last-modified time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    #[builder(default)]
    pub update_time: Option<String>,
}

/// Required. Destination specifies where the events should be sent to.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderDestination {
    /// The Cloud Function resource name. Only Cloud Functions V2 is supported. Format projects/{project}/locations/{location}/functions/{function} This is a read-only field. [WARNING] Creating Cloud Functions V2 triggers is only supported via the Cloud Functions product. An error will be returned if the user sets this value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudFunction")]
    #[builder(default)]
    pub cloud_function: Option<String>,
    /// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudRunService")]
    #[builder(default)]
    pub cloud_run_service: Option<TriggerStatusAtProviderDestinationCloudRunService>,
    /// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gke: Option<TriggerStatusAtProviderDestinationGke>,
    /// An HTTP endpoint destination described by an URI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpEndpoint")]
    #[builder(default)]
    pub http_endpoint: Option<TriggerStatusAtProviderDestinationHttpEndpoint>,
    /// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<TriggerStatusAtProviderDestinationNetworkConfig>,
    /// The resource name of the Workflow whose Executions are triggered by the events. The Workflow resource should be deployed in the same project as the trigger. Format: projects/{project}/locations/{location}/workflows/{workflow}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub workflow: Option<String>,
}

/// Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderDestinationCloudRunService {
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. The region the Cloud Run service is deployed in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// A GKE service capable of receiving events. The service should be running in the same project as the trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderDestinationGke {
    /// Required. The name of the cluster the GKE service is running in. The cluster must be running in the same project as the trigger being created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// The location for the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Required. The namespace the GKE service is running in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
    /// Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Required. Name of the GKE service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

/// An HTTP endpoint destination described by an URI.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderDestinationHttpEndpoint {
    /// Required. The URI of the HTTP enpdoint. The value must be a RFC2396 URI string. Examples: http://10.10.10.8:80/route, http://svc.us-central1.p.local:8080/. Only HTTP and HTTPS protocols are supported. The host can be either a static IP addressable from the VPC specified by the network config, or an internal DNS hostname of the service resolvable via Cloud DNS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderDestinationNetworkConfig {
    /// Required. Name of the NetworkAttachment that allows access to the destination VPC. Format: projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkAttachment")]
    #[builder(default)]
    pub network_attachment: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderMatchingCriteria {
    /// Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. All triggers MUST provide a filter for the 'type' attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is match-path-pattern.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute. See https://cloud.google.com/eventarc/docs/creating-triggers#trigger-gcloud for available values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Optional. In order to deliver messages, Eventarc may use other GCP products as transport intermediary. This field contains a reference to that transport intermediary. This information can be used for debugging purposes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderTransport {
    /// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub pubsub: Option<TriggerStatusAtProviderTransportPubsub>,
}

/// The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderTransportPubsub {
    /// Output only. The name of the Pub/Sub subscription created and managed by Eventarc system as a transport for the event delivery. Format: projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subscription: Option<String>,
    /// Optional. The name of the Pub/Sub topic created and managed by Eventarc system as a transport for the event delivery. Format: projects/{PROJECT_ID}/topics/{TOPIC_NAME}. You may set an existing topic for triggers of the type google.cloud.pubsub.topic.v1.messagePublished only. The topic you provide here will not be deleted by Eventarc at trigger deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
}

