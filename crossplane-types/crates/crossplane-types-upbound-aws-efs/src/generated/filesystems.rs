// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// FileSystemSpec defines the desired state of FileSystem
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "efs.aws.upbound.io", version = "v1beta2", kind = "FileSystem", plural = "filesystems")]
#[kube(status = "FileSystemStatus")]
pub struct FileSystemSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<FileSystemDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: FileSystemForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<FileSystemInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<FileSystemProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<FileSystemPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<FileSystemWriteConnectionSecretToRef>,
}

/// FileSystemSpec defines the desired state of FileSystem
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProvider {
    /// the AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes. See user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneName")]
    #[builder(default)]
    pub availability_zone_name: Option<String>,
    /// A unique name (a maximum of 64 characters are allowed)
    /// used as reference when creating the Elastic File System to ensure idempotent file
    /// system creation. See Elastic File System
    /// user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationToken")]
    #[builder(default)]
    pub creation_token: Option<String>,
    /// If true, the disk will be encrypted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    /// The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdRef")]
    #[builder(default)]
    pub kms_key_id_ref: Option<FileSystemForProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdSelector")]
    #[builder(default)]
    pub kms_key_id_selector: Option<FileSystemForProviderKmsKeyIdSelector>,
    /// A file system lifecycle policy object. See lifecycle_policy block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lifecyclePolicy")]
    #[builder(default)]
    pub lifecycle_policy: Option<Vec<FileSystemForProviderLifecyclePolicy>>,
    /// The file system performance mode. Can be either "generalPurpose" or "maxIO" (Default: "generalPurpose").
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "performanceMode")]
    #[builder(default)]
    pub performance_mode: Option<String>,
    /// A file system protection object. See protection block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protection: Option<FileSystemForProviderProtection>,
    /// The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with throughput_mode set to provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughputInMibps")]
    #[builder(default)]
    pub provisioned_throughput_in_mibps: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Throughput mode for the file system. Defaults to bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputMode")]
    #[builder(default)]
    pub throughput_mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemForProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemForProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemForProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemForProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemForProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemForProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemForProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemForProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemForProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemForProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderLifecyclePolicy {
    /// Indicates how long it takes to transition files to the archive storage class. Requires transition_to_ia, Elastic Throughput and General Purpose performance mode. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToArchive")]
    #[builder(default)]
    pub transition_to_archive: Option<String>,
    /// Indicates how long it takes to transition files to the IA storage class. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToIa")]
    #[builder(default)]
    pub transition_to_ia: Option<String>,
    /// Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: AFTER_1_ACCESS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToPrimaryStorageClass")]
    #[builder(default)]
    pub transition_to_primary_storage_class: Option<String>,
}

/// A file system protection object. See protection block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemForProviderProtection {
    /// Indicates whether replication overwrite protection is enabled. Valid values: ENABLED or DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationOverwrite")]
    #[builder(default)]
    pub replication_overwrite: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProvider {
    /// the AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes. See user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneName")]
    #[builder(default)]
    pub availability_zone_name: Option<String>,
    /// A unique name (a maximum of 64 characters are allowed)
    /// used as reference when creating the Elastic File System to ensure idempotent file
    /// system creation. See Elastic File System
    /// user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationToken")]
    #[builder(default)]
    pub creation_token: Option<String>,
    /// If true, the disk will be encrypted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    /// The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdRef")]
    #[builder(default)]
    pub kms_key_id_ref: Option<FileSystemInitProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdSelector")]
    #[builder(default)]
    pub kms_key_id_selector: Option<FileSystemInitProviderKmsKeyIdSelector>,
    /// A file system lifecycle policy object. See lifecycle_policy block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lifecyclePolicy")]
    #[builder(default)]
    pub lifecycle_policy: Option<Vec<FileSystemInitProviderLifecyclePolicy>>,
    /// The file system performance mode. Can be either "generalPurpose" or "maxIO" (Default: "generalPurpose").
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "performanceMode")]
    #[builder(default)]
    pub performance_mode: Option<String>,
    /// A file system protection object. See protection block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protection: Option<FileSystemInitProviderProtection>,
    /// The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with throughput_mode set to provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughputInMibps")]
    #[builder(default)]
    pub provisioned_throughput_in_mibps: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Throughput mode for the file system. Defaults to bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputMode")]
    #[builder(default)]
    pub throughput_mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemInitProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemInitProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemInitProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemInitProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemInitProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemInitProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemInitProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemInitProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemInitProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemInitProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderLifecyclePolicy {
    /// Indicates how long it takes to transition files to the archive storage class. Requires transition_to_ia, Elastic Throughput and General Purpose performance mode. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToArchive")]
    #[builder(default)]
    pub transition_to_archive: Option<String>,
    /// Indicates how long it takes to transition files to the IA storage class. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToIa")]
    #[builder(default)]
    pub transition_to_ia: Option<String>,
    /// Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: AFTER_1_ACCESS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToPrimaryStorageClass")]
    #[builder(default)]
    pub transition_to_primary_storage_class: Option<String>,
}

/// A file system protection object. See protection block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemInitProviderProtection {
    /// Indicates whether replication overwrite protection is enabled. Valid values: ENABLED or DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationOverwrite")]
    #[builder(default)]
    pub replication_overwrite: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<FileSystemPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<FileSystemPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FileSystemPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FileSystemPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FileSystemPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FileSystemPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// FileSystemStatus defines the observed state of FileSystem.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<FileSystemStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemStatusAtProvider {
    /// Amazon Resource Name of the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// The identifier of the Availability Zone in which the file system's One Zone storage classes exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneId")]
    #[builder(default)]
    pub availability_zone_id: Option<String>,
    /// the AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes. See user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZoneName")]
    #[builder(default)]
    pub availability_zone_name: Option<String>,
    /// A unique name (a maximum of 64 characters are allowed)
    /// used as reference when creating the Elastic File System to ensure idempotent file
    /// system creation. See Elastic File System
    /// user guide for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationToken")]
    #[builder(default)]
    pub creation_token: Option<String>,
    /// The DNS name for the filesystem per documented convention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default)]
    pub dns_name: Option<String>,
    /// If true, the disk will be encrypted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    /// The ID that identifies the file system (e.g., fs-ccfc0d65).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// A file system lifecycle policy object. See lifecycle_policy block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lifecyclePolicy")]
    #[builder(default)]
    pub lifecycle_policy: Option<Vec<FileSystemStatusAtProviderLifecyclePolicy>>,
    /// The value of the file system's Name tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The current number of mount targets that the file system has.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfMountTargets")]
    #[builder(default)]
    pub number_of_mount_targets: Option<f64>,
    /// The AWS account that created the file system. If the file system was createdby an IAM user, the parent account to which the user belongs is the owner.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerId")]
    #[builder(default)]
    pub owner_id: Option<String>,
    /// The file system performance mode. Can be either "generalPurpose" or "maxIO" (Default: "generalPurpose").
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "performanceMode")]
    #[builder(default)]
    pub performance_mode: Option<String>,
    /// A file system protection object. See protection block below for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub protection: Option<FileSystemStatusAtProviderProtection>,
    /// The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with throughput_mode set to provisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughputInMibps")]
    #[builder(default)]
    pub provisioned_throughput_in_mibps: Option<f64>,
    /// The latest known metered size (in bytes) of data stored in the file system, the value is not the exact size that the file system was at any point in time. See Size In Bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeInBytes")]
    #[builder(default)]
    pub size_in_bytes: Option<Vec<FileSystemStatusAtProviderSizeInBytes>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// Throughput mode for the file system. Defaults to bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputMode")]
    #[builder(default)]
    pub throughput_mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemStatusAtProviderLifecyclePolicy {
    /// Indicates how long it takes to transition files to the archive storage class. Requires transition_to_ia, Elastic Throughput and General Purpose performance mode. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToArchive")]
    #[builder(default)]
    pub transition_to_archive: Option<String>,
    /// Indicates how long it takes to transition files to the IA storage class. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_270_DAYS, or AFTER_365_DAYS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToIa")]
    #[builder(default)]
    pub transition_to_ia: Option<String>,
    /// Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: AFTER_1_ACCESS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionToPrimaryStorageClass")]
    #[builder(default)]
    pub transition_to_primary_storage_class: Option<String>,
}

/// A file system protection object. See protection block below for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemStatusAtProviderProtection {
    /// Indicates whether replication overwrite protection is enabled. Valid values: ENABLED or DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationOverwrite")]
    #[builder(default)]
    pub replication_overwrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FileSystemStatusAtProviderSizeInBytes {
    /// The latest known metered size (in bytes) of data stored in the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<f64>,
    /// The latest known metered size (in bytes) of data stored in the Infrequent Access storage class.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueInIa")]
    #[builder(default)]
    pub value_in_ia: Option<f64>,
    /// The latest known metered size (in bytes) of data stored in the Standard storage class.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueInStandard")]
    #[builder(default)]
    pub value_in_standard: Option<f64>,
}

