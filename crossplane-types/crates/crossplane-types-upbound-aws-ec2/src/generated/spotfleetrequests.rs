// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// SpotFleetRequestSpec defines the desired state of SpotFleetRequest
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "ec2.aws.upbound.io", version = "v1beta2", kind = "SpotFleetRequest", plural = "spotfleetrequests")]
#[kube(status = "SpotFleetRequestStatus")]
pub struct SpotFleetRequestSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<SpotFleetRequestDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: SpotFleetRequestForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<SpotFleetRequestInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<SpotFleetRequestProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<SpotFleetRequestPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<SpotFleetRequestWriteConnectionSecretToRef>,
}

/// SpotFleetRequestSpec defines the desired state of SpotFleetRequest
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProvider {
    /// Indicates how to allocate the target capacity across
    /// the Spot pools specified by the Spot fleet request. Valid values: lowestPrice, diversified, capacityOptimized, capacityOptimizedPrioritized, and priceCapacityOptimized. The default is
    /// lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocationStrategy")]
    #[builder(default)]
    pub allocation_strategy: Option<String>,
    /// Reserved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated if the target capacity of the Spot fleet
    /// request is decreased below the current size of the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excessCapacityTerminationPolicy")]
    #[builder(default)]
    pub excess_capacity_termination_policy: Option<String>,
    /// The type of fleet request. Indicates whether the Spot Fleet only requests the target
    /// capacity or also attempts to maintain it. Default is maintain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fleetType")]
    #[builder(default)]
    pub fleet_type: Option<String>,
    /// Grants the Spot fleet permission to terminate
    /// Spot instances on your behalf when you cancel its Spot fleet request using
    /// CancelSpotFleetRequests or when the Spot fleet request expires, if you set
    /// terminateInstancesWithExpiration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamFleetRole")]
    #[builder(default)]
    pub iam_fleet_role: Option<String>,
    /// Indicates whether a Spot
    /// instance stops or terminates when it is interrupted. Default is
    /// terminate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceInterruptionBehaviour")]
    #[builder(default)]
    pub instance_interruption_behaviour: Option<String>,
    /// The number of Spot pools across which to allocate your target Spot capacity.
    /// Valid only when allocation_strategy is set to lowestPrice. Spot Fleet selects
    /// the cheapest Spot pools and evenly allocates your target Spot capacity across
    /// the number of Spot pools that you specify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancePoolsToUseCount")]
    #[builder(default)]
    pub instance_pools_to_use_count: Option<f64>,
    /// Used to define the launch configuration of the
    /// spot-fleet request. Can be specified multiple times to define different bids
    /// across different markets and instance types. Conflicts with launch_template_config. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchSpecification")]
    #[builder(default)]
    pub launch_specification: Option<Vec<SpotFleetRequestForProviderLaunchSpecification>>,
    /// Launch template configuration block. See Launch Template Configs below for more details. Conflicts with launch_specification. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateConfig")]
    #[builder(default)]
    pub launch_template_config: Option<Vec<SpotFleetRequestForProviderLaunchTemplateConfig>>,
    /// A list of elastic load balancer names to add to the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancers")]
    #[builder(default)]
    pub load_balancers: Option<Vec<String>>,
    /// The order of the launch template overrides to use in fulfilling On-Demand capacity. the possible values are: lowestPrice and prioritized. the default is lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandAllocationStrategy")]
    #[builder(default)]
    pub on_demand_allocation_strategy: Option<String>,
    /// The maximum amount per hour for On-Demand Instances that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn’t met the target capacity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxTotalPrice")]
    #[builder(default)]
    pub on_demand_max_total_price: Option<String>,
    /// The number of On-Demand units to request. If the request type is maintain, you can specify a target capacity of 0 and add capacity later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandTargetCapacity")]
    #[builder(default)]
    pub on_demand_target_capacity: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Indicates whether Spot fleet should replace unhealthy instances. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceUnhealthyInstances")]
    #[builder(default)]
    pub replace_unhealthy_instances: Option<bool>,
    /// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaintenanceStrategies")]
    #[builder(default)]
    pub spot_maintenance_strategies: Option<SpotFleetRequestForProviderSpotMaintenanceStrategies>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// The number of units to request. You can choose to set the
    /// target capacity in terms of instances or a performance characteristic that is
    /// important to your application workload, such as vCPUs, memory, or I/O.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacity")]
    #[builder(default)]
    pub target_capacity: Option<f64>,
    /// The unit for the target capacity. This can only be done with instance_requirements defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacityUnitType")]
    #[builder(default)]
    pub target_capacity_unit_type: Option<String>,
    /// A list of aws_alb_target_group ARNs, for use with Application Load Balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArns")]
    #[builder(default)]
    pub target_group_arns: Option<Vec<String>>,
    /// Indicates whether running Spot
    /// instances should be terminated when the resource is deleted (and the Spot fleet request cancelled).
    /// If no value is specified, the value of the terminate_instances_with_expiration argument is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesOnDelete")]
    #[builder(default)]
    pub terminate_instances_on_delete: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated when the Spot fleet request expires.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesWithExpiration")]
    #[builder(default)]
    pub terminate_instances_with_expiration: Option<bool>,
    /// The start date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validFrom")]
    #[builder(default)]
    pub valid_from: Option<String>,
    /// The end date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validUntil")]
    #[builder(default)]
    pub valid_until: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForFulfillment")]
    #[builder(default)]
    pub wait_for_fulfillment: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ami: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "associatePublicIpAddress")]
    #[builder(default)]
    pub associate_public_ip_address: Option<bool>,
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsBlockDevice")]
    #[builder(default)]
    pub ebs_block_device: Option<Vec<SpotFleetRequestForProviderLaunchSpecificationEbsBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsOptimized")]
    #[builder(default)]
    pub ebs_optimized: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralBlockDevice")]
    #[builder(default)]
    pub ephemeral_block_device: Option<Vec<SpotFleetRequestForProviderLaunchSpecificationEphemeralBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfile")]
    #[builder(default)]
    pub iam_instance_profile: Option<String>,
    /// takes aws_iam_instance_profile attribute arn as input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArn")]
    #[builder(default)]
    pub iam_instance_profile_arn: Option<String>,
    /// Reference to a InstanceProfile in iam to populate iamInstanceProfileArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArnRef")]
    #[builder(default)]
    pub iam_instance_profile_arn_ref: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRef>,
    /// Selector for a InstanceProfile in iam to populate iamInstanceProfileArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArnSelector")]
    #[builder(default)]
    pub iam_instance_profile_arn_selector: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelector>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default)]
    pub key_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementGroup")]
    #[builder(default)]
    pub placement_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementTenancy")]
    #[builder(default)]
    pub placement_tenancy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootBlockDevice")]
    #[builder(default)]
    pub root_block_device: Option<Vec<SpotFleetRequestForProviderLaunchSpecificationRootBlockDevice>>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default)]
    pub user_data: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSecurityGroupIds")]
    #[builder(default)]
    pub vpc_security_group_ids: Option<Vec<String>>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationEbsBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    #[builder(default)]
    pub snapshot_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationEphemeralBlockDevice {
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "virtualName")]
    #[builder(default)]
    pub virtual_name: Option<String>,
}

/// Reference to a InstanceProfile in iam to populate iamInstanceProfileArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate iamInstanceProfileArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchSpecificationRootBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfig {
    /// Launch template specification. See Launch Template Specification below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateSpecification")]
    #[builder(default)]
    pub launch_template_specification: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecification>,
    /// One or more override configurations. See Overrides below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub overrides: Option<Vec<SpotFleetRequestForProviderLaunchTemplateConfigOverrides>>,
}

/// Launch template specification. See Launch Template Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecification {
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Reference to a LaunchTemplate in ec2 to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idRef")]
    #[builder(default)]
    pub id_ref: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRef>,
    /// Selector for a LaunchTemplate in ec2 to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idSelector")]
    #[builder(default)]
    pub id_selector: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelector>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Template version. Unlike the autoscaling equivalent, does not support $Latest or $Default, so use the launch_template resource's attribute, e.g., "${aws_launch_template.foo.latest_version}". It will use the default version if omitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
    /// Reference to a LaunchTemplate in ec2 to populate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionRef")]
    #[builder(default)]
    pub version_ref: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRef>,
    /// Selector for a LaunchTemplate in ec2 to populate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionSelector")]
    #[builder(default)]
    pub version_selector: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelector>,
}

/// Reference to a LaunchTemplate in ec2 to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LaunchTemplate in ec2 to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a LaunchTemplate in ec2 to populate version.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LaunchTemplate in ec2 to populate version.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestForProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverrides {
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    /// The instance requirements. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRequirements")]
    #[builder(default)]
    pub instance_requirements: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirements>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<f64>,
}

/// The instance requirements. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorCount")]
    #[builder(default)]
    pub accelerator_count: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorManufacturers")]
    #[builder(default)]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorNames")]
    #[builder(default)]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTotalMemoryMib")]
    #[builder(default)]
    pub accelerator_total_memory_mib: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTypes")]
    #[builder(default)]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInstanceTypes")]
    #[builder(default)]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default)]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baselineEbsBandwidthMbps")]
    #[builder(default)]
    pub baseline_ebs_bandwidth_mbps: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "burstablePerformance")]
    #[builder(default)]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManufacturers")]
    #[builder(default)]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedInstanceTypes")]
    #[builder(default)]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGenerations")]
    #[builder(default)]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorage")]
    #[builder(default)]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorageTypes")]
    #[builder(default)]
    pub local_storage_types: Option<Vec<String>>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryGibPerVcpu")]
    #[builder(default)]
    pub memory_gib_per_vcpu: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default)]
    pub memory_mib: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkBandwidthGbps")]
    #[builder(default)]
    pub network_bandwidth_gbps: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceCount")]
    #[builder(default)]
    pub network_interface_count: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireHibernateSupport")]
    #[builder(default)]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLocalStorageGb")]
    #[builder(default)]
    pub total_local_storage_gb: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default)]
    pub vcpu_count: Option<SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderSpotMaintenanceStrategies {
    /// Nested argument containing the capacity rebalance for your fleet request. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityRebalance")]
    #[builder(default)]
    pub capacity_rebalance: Option<SpotFleetRequestForProviderSpotMaintenanceStrategiesCapacityRebalance>,
}

/// Nested argument containing the capacity rebalance for your fleet request. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestForProviderSpotMaintenanceStrategiesCapacityRebalance {
    /// The replacement strategy to use. Only available for spot fleets with fleet_type set to maintain. Valid values: launch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementStrategy")]
    #[builder(default)]
    pub replacement_strategy: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProvider {
    /// Indicates how to allocate the target capacity across
    /// the Spot pools specified by the Spot fleet request. Valid values: lowestPrice, diversified, capacityOptimized, capacityOptimizedPrioritized, and priceCapacityOptimized. The default is
    /// lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocationStrategy")]
    #[builder(default)]
    pub allocation_strategy: Option<String>,
    /// Reserved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated if the target capacity of the Spot fleet
    /// request is decreased below the current size of the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excessCapacityTerminationPolicy")]
    #[builder(default)]
    pub excess_capacity_termination_policy: Option<String>,
    /// The type of fleet request. Indicates whether the Spot Fleet only requests the target
    /// capacity or also attempts to maintain it. Default is maintain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fleetType")]
    #[builder(default)]
    pub fleet_type: Option<String>,
    /// Grants the Spot fleet permission to terminate
    /// Spot instances on your behalf when you cancel its Spot fleet request using
    /// CancelSpotFleetRequests or when the Spot fleet request expires, if you set
    /// terminateInstancesWithExpiration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamFleetRole")]
    #[builder(default)]
    pub iam_fleet_role: Option<String>,
    /// Indicates whether a Spot
    /// instance stops or terminates when it is interrupted. Default is
    /// terminate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceInterruptionBehaviour")]
    #[builder(default)]
    pub instance_interruption_behaviour: Option<String>,
    /// The number of Spot pools across which to allocate your target Spot capacity.
    /// Valid only when allocation_strategy is set to lowestPrice. Spot Fleet selects
    /// the cheapest Spot pools and evenly allocates your target Spot capacity across
    /// the number of Spot pools that you specify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancePoolsToUseCount")]
    #[builder(default)]
    pub instance_pools_to_use_count: Option<f64>,
    /// Used to define the launch configuration of the
    /// spot-fleet request. Can be specified multiple times to define different bids
    /// across different markets and instance types. Conflicts with launch_template_config. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchSpecification")]
    #[builder(default)]
    pub launch_specification: Option<Vec<SpotFleetRequestInitProviderLaunchSpecification>>,
    /// Launch template configuration block. See Launch Template Configs below for more details. Conflicts with launch_specification. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateConfig")]
    #[builder(default)]
    pub launch_template_config: Option<Vec<SpotFleetRequestInitProviderLaunchTemplateConfig>>,
    /// A list of elastic load balancer names to add to the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancers")]
    #[builder(default)]
    pub load_balancers: Option<Vec<String>>,
    /// The order of the launch template overrides to use in fulfilling On-Demand capacity. the possible values are: lowestPrice and prioritized. the default is lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandAllocationStrategy")]
    #[builder(default)]
    pub on_demand_allocation_strategy: Option<String>,
    /// The maximum amount per hour for On-Demand Instances that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn’t met the target capacity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxTotalPrice")]
    #[builder(default)]
    pub on_demand_max_total_price: Option<String>,
    /// The number of On-Demand units to request. If the request type is maintain, you can specify a target capacity of 0 and add capacity later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandTargetCapacity")]
    #[builder(default)]
    pub on_demand_target_capacity: Option<f64>,
    /// Indicates whether Spot fleet should replace unhealthy instances. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceUnhealthyInstances")]
    #[builder(default)]
    pub replace_unhealthy_instances: Option<bool>,
    /// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaintenanceStrategies")]
    #[builder(default)]
    pub spot_maintenance_strategies: Option<SpotFleetRequestInitProviderSpotMaintenanceStrategies>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// The number of units to request. You can choose to set the
    /// target capacity in terms of instances or a performance characteristic that is
    /// important to your application workload, such as vCPUs, memory, or I/O.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacity")]
    #[builder(default)]
    pub target_capacity: Option<f64>,
    /// The unit for the target capacity. This can only be done with instance_requirements defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacityUnitType")]
    #[builder(default)]
    pub target_capacity_unit_type: Option<String>,
    /// A list of aws_alb_target_group ARNs, for use with Application Load Balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArns")]
    #[builder(default)]
    pub target_group_arns: Option<Vec<String>>,
    /// Indicates whether running Spot
    /// instances should be terminated when the resource is deleted (and the Spot fleet request cancelled).
    /// If no value is specified, the value of the terminate_instances_with_expiration argument is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesOnDelete")]
    #[builder(default)]
    pub terminate_instances_on_delete: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated when the Spot fleet request expires.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesWithExpiration")]
    #[builder(default)]
    pub terminate_instances_with_expiration: Option<bool>,
    /// The start date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validFrom")]
    #[builder(default)]
    pub valid_from: Option<String>,
    /// The end date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validUntil")]
    #[builder(default)]
    pub valid_until: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForFulfillment")]
    #[builder(default)]
    pub wait_for_fulfillment: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ami: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "associatePublicIpAddress")]
    #[builder(default)]
    pub associate_public_ip_address: Option<bool>,
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsBlockDevice")]
    #[builder(default)]
    pub ebs_block_device: Option<Vec<SpotFleetRequestInitProviderLaunchSpecificationEbsBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsOptimized")]
    #[builder(default)]
    pub ebs_optimized: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralBlockDevice")]
    #[builder(default)]
    pub ephemeral_block_device: Option<Vec<SpotFleetRequestInitProviderLaunchSpecificationEphemeralBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfile")]
    #[builder(default)]
    pub iam_instance_profile: Option<String>,
    /// takes aws_iam_instance_profile attribute arn as input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArn")]
    #[builder(default)]
    pub iam_instance_profile_arn: Option<String>,
    /// Reference to a InstanceProfile in iam to populate iamInstanceProfileArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArnRef")]
    #[builder(default)]
    pub iam_instance_profile_arn_ref: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRef>,
    /// Selector for a InstanceProfile in iam to populate iamInstanceProfileArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArnSelector")]
    #[builder(default)]
    pub iam_instance_profile_arn_selector: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelector>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default)]
    pub key_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementGroup")]
    #[builder(default)]
    pub placement_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementTenancy")]
    #[builder(default)]
    pub placement_tenancy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootBlockDevice")]
    #[builder(default)]
    pub root_block_device: Option<Vec<SpotFleetRequestInitProviderLaunchSpecificationRootBlockDevice>>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default)]
    pub user_data: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSecurityGroupIds")]
    #[builder(default)]
    pub vpc_security_group_ids: Option<Vec<String>>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationEbsBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    #[builder(default)]
    pub snapshot_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationEphemeralBlockDevice {
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "virtualName")]
    #[builder(default)]
    pub virtual_name: Option<String>,
}

/// Reference to a InstanceProfile in iam to populate iamInstanceProfileArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a InstanceProfile in iam to populate iamInstanceProfileArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchSpecificationIamInstanceProfileArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchSpecificationRootBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfig {
    /// Launch template specification. See Launch Template Specification below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateSpecification")]
    #[builder(default)]
    pub launch_template_specification: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecification>,
    /// One or more override configurations. See Overrides below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub overrides: Option<Vec<SpotFleetRequestInitProviderLaunchTemplateConfigOverrides>>,
}

/// Launch template specification. See Launch Template Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecification {
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Reference to a LaunchTemplate in ec2 to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idRef")]
    #[builder(default)]
    pub id_ref: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRef>,
    /// Selector for a LaunchTemplate in ec2 to populate id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idSelector")]
    #[builder(default)]
    pub id_selector: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelector>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Template version. Unlike the autoscaling equivalent, does not support $Latest or $Default, so use the launch_template resource's attribute, e.g., "${aws_launch_template.foo.latest_version}". It will use the default version if omitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
    /// Reference to a LaunchTemplate in ec2 to populate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionRef")]
    #[builder(default)]
    pub version_ref: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRef>,
    /// Selector for a LaunchTemplate in ec2 to populate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionSelector")]
    #[builder(default)]
    pub version_selector: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelector>,
}

/// Reference to a LaunchTemplate in ec2 to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LaunchTemplate in ec2 to populate id.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a LaunchTemplate in ec2 to populate version.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a LaunchTemplate in ec2 to populate version.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestInitProviderLaunchTemplateConfigLaunchTemplateSpecificationVersionSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverrides {
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    /// The instance requirements. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRequirements")]
    #[builder(default)]
    pub instance_requirements: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirements>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<f64>,
}

/// The instance requirements. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorCount")]
    #[builder(default)]
    pub accelerator_count: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorManufacturers")]
    #[builder(default)]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorNames")]
    #[builder(default)]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTotalMemoryMib")]
    #[builder(default)]
    pub accelerator_total_memory_mib: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTypes")]
    #[builder(default)]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInstanceTypes")]
    #[builder(default)]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default)]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baselineEbsBandwidthMbps")]
    #[builder(default)]
    pub baseline_ebs_bandwidth_mbps: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "burstablePerformance")]
    #[builder(default)]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManufacturers")]
    #[builder(default)]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedInstanceTypes")]
    #[builder(default)]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGenerations")]
    #[builder(default)]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorage")]
    #[builder(default)]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorageTypes")]
    #[builder(default)]
    pub local_storage_types: Option<Vec<String>>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryGibPerVcpu")]
    #[builder(default)]
    pub memory_gib_per_vcpu: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default)]
    pub memory_mib: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkBandwidthGbps")]
    #[builder(default)]
    pub network_bandwidth_gbps: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceCount")]
    #[builder(default)]
    pub network_interface_count: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireHibernateSupport")]
    #[builder(default)]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLocalStorageGb")]
    #[builder(default)]
    pub total_local_storage_gb: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default)]
    pub vcpu_count: Option<SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderSpotMaintenanceStrategies {
    /// Nested argument containing the capacity rebalance for your fleet request. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityRebalance")]
    #[builder(default)]
    pub capacity_rebalance: Option<SpotFleetRequestInitProviderSpotMaintenanceStrategiesCapacityRebalance>,
}

/// Nested argument containing the capacity rebalance for your fleet request. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestInitProviderSpotMaintenanceStrategiesCapacityRebalance {
    /// The replacement strategy to use. Only available for spot fleets with fleet_type set to maintain. Valid values: launch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementStrategy")]
    #[builder(default)]
    pub replacement_strategy: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<SpotFleetRequestPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<SpotFleetRequestPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<SpotFleetRequestPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<SpotFleetRequestPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<SpotFleetRequestPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SpotFleetRequestPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// SpotFleetRequestStatus defines the observed state of SpotFleetRequest.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<SpotFleetRequestStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProvider {
    /// Indicates how to allocate the target capacity across
    /// the Spot pools specified by the Spot fleet request. Valid values: lowestPrice, diversified, capacityOptimized, capacityOptimizedPrioritized, and priceCapacityOptimized. The default is
    /// lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocationStrategy")]
    #[builder(default)]
    pub allocation_strategy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientToken")]
    #[builder(default)]
    pub client_token: Option<String>,
    /// Reserved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated if the target capacity of the Spot fleet
    /// request is decreased below the current size of the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excessCapacityTerminationPolicy")]
    #[builder(default)]
    pub excess_capacity_termination_policy: Option<String>,
    /// The type of fleet request. Indicates whether the Spot Fleet only requests the target
    /// capacity or also attempts to maintain it. Default is maintain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fleetType")]
    #[builder(default)]
    pub fleet_type: Option<String>,
    /// Grants the Spot fleet permission to terminate
    /// Spot instances on your behalf when you cancel its Spot fleet request using
    /// CancelSpotFleetRequests or when the Spot fleet request expires, if you set
    /// terminateInstancesWithExpiration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamFleetRole")]
    #[builder(default)]
    pub iam_fleet_role: Option<String>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Indicates whether a Spot
    /// instance stops or terminates when it is interrupted. Default is
    /// terminate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceInterruptionBehaviour")]
    #[builder(default)]
    pub instance_interruption_behaviour: Option<String>,
    /// The number of Spot pools across which to allocate your target Spot capacity.
    /// Valid only when allocation_strategy is set to lowestPrice. Spot Fleet selects
    /// the cheapest Spot pools and evenly allocates your target Spot capacity across
    /// the number of Spot pools that you specify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instancePoolsToUseCount")]
    #[builder(default)]
    pub instance_pools_to_use_count: Option<f64>,
    /// Used to define the launch configuration of the
    /// spot-fleet request. Can be specified multiple times to define different bids
    /// across different markets and instance types. Conflicts with launch_template_config. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchSpecification")]
    #[builder(default)]
    pub launch_specification: Option<Vec<SpotFleetRequestStatusAtProviderLaunchSpecification>>,
    /// Launch template configuration block. See Launch Template Configs below for more details. Conflicts with launch_specification. At least one of launch_specification or launch_template_config is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateConfig")]
    #[builder(default)]
    pub launch_template_config: Option<Vec<SpotFleetRequestStatusAtProviderLaunchTemplateConfig>>,
    /// A list of elastic load balancer names to add to the Spot fleet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancers")]
    #[builder(default)]
    pub load_balancers: Option<Vec<String>>,
    /// The order of the launch template overrides to use in fulfilling On-Demand capacity. the possible values are: lowestPrice and prioritized. the default is lowestPrice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandAllocationStrategy")]
    #[builder(default)]
    pub on_demand_allocation_strategy: Option<String>,
    /// The maximum amount per hour for On-Demand Instances that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn’t met the target capacity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxTotalPrice")]
    #[builder(default)]
    pub on_demand_max_total_price: Option<String>,
    /// The number of On-Demand units to request. If the request type is maintain, you can specify a target capacity of 0 and add capacity later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandTargetCapacity")]
    #[builder(default)]
    pub on_demand_target_capacity: Option<f64>,
    /// Indicates whether Spot fleet should replace unhealthy instances. Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceUnhealthyInstances")]
    #[builder(default)]
    pub replace_unhealthy_instances: Option<bool>,
    /// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaintenanceStrategies")]
    #[builder(default)]
    pub spot_maintenance_strategies: Option<SpotFleetRequestStatusAtProviderSpotMaintenanceStrategies>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The state of the Spot fleet request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotRequestState")]
    #[builder(default)]
    pub spot_request_state: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// The number of units to request. You can choose to set the
    /// target capacity in terms of instances or a performance characteristic that is
    /// important to your application workload, such as vCPUs, memory, or I/O.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacity")]
    #[builder(default)]
    pub target_capacity: Option<f64>,
    /// The unit for the target capacity. This can only be done with instance_requirements defined
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCapacityUnitType")]
    #[builder(default)]
    pub target_capacity_unit_type: Option<String>,
    /// A list of aws_alb_target_group ARNs, for use with Application Load Balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetGroupArns")]
    #[builder(default)]
    pub target_group_arns: Option<Vec<String>>,
    /// Indicates whether running Spot
    /// instances should be terminated when the resource is deleted (and the Spot fleet request cancelled).
    /// If no value is specified, the value of the terminate_instances_with_expiration argument is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesOnDelete")]
    #[builder(default)]
    pub terminate_instances_on_delete: Option<String>,
    /// Indicates whether running Spot
    /// instances should be terminated when the Spot fleet request expires.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminateInstancesWithExpiration")]
    #[builder(default)]
    pub terminate_instances_with_expiration: Option<bool>,
    /// The start date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validFrom")]
    #[builder(default)]
    pub valid_from: Option<String>,
    /// The end date and time of the request, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validUntil")]
    #[builder(default)]
    pub valid_until: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitForFulfillment")]
    #[builder(default)]
    pub wait_for_fulfillment: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchSpecification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ami: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "associatePublicIpAddress")]
    #[builder(default)]
    pub associate_public_ip_address: Option<bool>,
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsBlockDevice")]
    #[builder(default)]
    pub ebs_block_device: Option<Vec<SpotFleetRequestStatusAtProviderLaunchSpecificationEbsBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ebsOptimized")]
    #[builder(default)]
    pub ebs_optimized: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralBlockDevice")]
    #[builder(default)]
    pub ephemeral_block_device: Option<Vec<SpotFleetRequestStatusAtProviderLaunchSpecificationEphemeralBlockDevice>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfile")]
    #[builder(default)]
    pub iam_instance_profile: Option<String>,
    /// takes aws_iam_instance_profile attribute arn as input.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamInstanceProfileArn")]
    #[builder(default)]
    pub iam_instance_profile_arn: Option<String>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyName")]
    #[builder(default)]
    pub key_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementGroup")]
    #[builder(default)]
    pub placement_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementTenancy")]
    #[builder(default)]
    pub placement_tenancy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootBlockDevice")]
    #[builder(default)]
    pub root_block_device: Option<Vec<SpotFleetRequestStatusAtProviderLaunchSpecificationRootBlockDevice>>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userData")]
    #[builder(default)]
    pub user_data: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSecurityGroupIds")]
    #[builder(default)]
    pub vpc_security_group_ids: Option<Vec<String>>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchSpecificationEbsBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotId")]
    #[builder(default)]
    pub snapshot_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchSpecificationEphemeralBlockDevice {
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "virtualName")]
    #[builder(default)]
    pub virtual_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchSpecificationRootBlockDevice {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    #[builder(default)]
    pub delete_on_termination: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encrypted: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub throughput: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSize")]
    #[builder(default)]
    pub volume_size: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeType")]
    #[builder(default)]
    pub volume_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfig {
    /// Launch template specification. See Launch Template Specification below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplateSpecification")]
    #[builder(default)]
    pub launch_template_specification: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigLaunchTemplateSpecification>,
    /// One or more override configurations. See Overrides below for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub overrides: Option<Vec<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverrides>>,
}

/// Launch template specification. See Launch Template Specification below for more details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigLaunchTemplateSpecification {
    /// The ID of the launch template. Conflicts with name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The name of the launch template. Conflicts with id.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Template version. Unlike the autoscaling equivalent, does not support $Latest or $Default, so use the launch_template resource's attribute, e.g., "${aws_launch_template.foo.latest_version}". It will use the default version if omitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverrides {
    /// The availability zone in which to place the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    #[builder(default)]
    pub availability_zone: Option<String>,
    /// The instance requirements. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceRequirements")]
    #[builder(default)]
    pub instance_requirements: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirements>,
    /// The type of instance to request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceType")]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// The maximum bid price per unit hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotPrice")]
    #[builder(default)]
    pub spot_price: Option<String>,
    /// The subnet in which to launch the requested instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetId")]
    #[builder(default)]
    pub subnet_id: Option<String>,
    /// The capacity added to the fleet by a fulfilled request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedCapacity")]
    #[builder(default)]
    pub weighted_capacity: Option<f64>,
}

/// The instance requirements. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirements {
    /// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorCount")]
    #[builder(default)]
    pub accelerator_count: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount>,
    /// List of accelerator manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorManufacturers")]
    #[builder(default)]
    pub accelerator_manufacturers: Option<Vec<String>>,
    /// List of accelerator names. Default is any acclerator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorNames")]
    #[builder(default)]
    pub accelerator_names: Option<Vec<String>>,
    /// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTotalMemoryMib")]
    #[builder(default)]
    pub accelerator_total_memory_mib: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib>,
    /// List of accelerator types. Default is any accelerator type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceleratorTypes")]
    #[builder(default)]
    pub accelerator_types: Option<Vec<String>>,
    /// List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInstanceTypes")]
    #[builder(default)]
    pub allowed_instance_types: Option<Vec<String>>,
    /// Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bareMetal")]
    #[builder(default)]
    pub bare_metal: Option<String>,
    /// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baselineEbsBandwidthMbps")]
    #[builder(default)]
    pub baseline_ebs_bandwidth_mbps: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps>,
    /// Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "burstablePerformance")]
    #[builder(default)]
    pub burstable_performance: Option<String>,
    /// List of CPU manufacturer names. Default is any manufacturer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManufacturers")]
    #[builder(default)]
    pub cpu_manufacturers: Option<Vec<String>>,
    /// List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedInstanceTypes")]
    #[builder(default)]
    pub excluded_instance_types: Option<Vec<String>>,
    /// List of instance generation names. Default is any generation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGenerations")]
    #[builder(default)]
    pub instance_generations: Option<Vec<String>>,
    /// Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorage")]
    #[builder(default)]
    pub local_storage: Option<String>,
    /// List of local storage type names. Default any storage type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localStorageTypes")]
    #[builder(default)]
    pub local_storage_types: Option<Vec<String>>,
    /// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryGibPerVcpu")]
    #[builder(default)]
    pub memory_gib_per_vcpu: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu>,
    /// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMib")]
    #[builder(default)]
    pub memory_mib: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib>,
    /// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkBandwidthGbps")]
    #[builder(default)]
    pub network_bandwidth_gbps: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps>,
    /// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceCount")]
    #[builder(default)]
    pub network_interface_count: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount>,
    /// The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDemandMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub on_demand_max_price_percentage_over_lowest_price: Option<f64>,
    /// Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireHibernateSupport")]
    #[builder(default)]
    pub require_hibernate_support: Option<bool>,
    /// The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spotMaxPricePercentageOverLowestPrice")]
    #[builder(default)]
    pub spot_max_price_percentage_over_lowest_price: Option<f64>,
    /// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLocalStorageGb")]
    #[builder(default)]
    pub total_local_storage_gb: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb>,
    /// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vcpuCount")]
    #[builder(default)]
    pub vcpu_count: Option<SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount>,
}

/// Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsAcceleratorTotalMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsBaselineEbsBandwidthMbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryGibPerVcpu {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsMemoryMib {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkBandwidthGbps {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsNetworkInterfaceCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsTotalLocalStorageGb {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Block describing the minimum and maximum number of vCPUs. Default is no maximum.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderLaunchTemplateConfigOverridesInstanceRequirementsVcpuCount {
    /// Maximum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<f64>,
    /// Minimum.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<f64>,
}

/// Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderSpotMaintenanceStrategies {
    /// Nested argument containing the capacity rebalance for your fleet request. Defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityRebalance")]
    #[builder(default)]
    pub capacity_rebalance: Option<SpotFleetRequestStatusAtProviderSpotMaintenanceStrategiesCapacityRebalance>,
}

/// Nested argument containing the capacity rebalance for your fleet request. Defined below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct SpotFleetRequestStatusAtProviderSpotMaintenanceStrategiesCapacityRebalance {
    /// The replacement strategy to use. Only available for spot fleets with fleet_type set to maintain. Valid values: launch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementStrategy")]
    #[builder(default)]
    pub replacement_strategy: Option<String>,
}

