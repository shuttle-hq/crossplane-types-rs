// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// PolicySpec defines the desired state of Policy
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "orgpolicy.gcp.upbound.io", version = "v1beta1", kind = "Policy", plural = "policies")]
#[kube(status = "PolicyStatus")]
pub struct PolicySpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<PolicyDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: PolicyForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<PolicyInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<PolicyProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<PolicyPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<PolicyWriteConnectionSecretToRef>,
}

/// PolicySpec defines the desired state of Policy
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProvider {
    /// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dryRunSpec")]
    #[builder(default)]
    pub dry_run_spec: Option<PolicyForProviderDryRunSpec>,
    /// The parent of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// Reference to a Folder in cloudplatform to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentRef")]
    #[builder(default)]
    pub parent_ref: Option<PolicyForProviderParentRef>,
    /// Selector for a Folder in cloudplatform to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentSelector")]
    #[builder(default)]
    pub parent_selector: Option<PolicyForProviderParentSelector>,
    /// Basic information about the Organization Policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spec: Option<PolicyForProviderSpec>,
}

/// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderDryRunSpec {
    /// Determines the inheritance behavior for this policy. If inherit_from_parent is true, policy rules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this policy becomes the new root for evaluation. This field can be set only for policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// In policies for boolean constraints, the following requirements apply: - There must be one and only one policy rule where condition is unset. - Boolean policy rules with conditions must set enforced to the opposite of the policy rule without a condition. - During policy evaluation, policy rules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyForProviderDryRunSpecRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderDryRunSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyForProviderDryRunSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyForProviderDryRunSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderDryRunSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderDryRunSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

/// Reference to a Folder in cloudplatform to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderParentRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PolicyForProviderParentRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderParentRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PolicyForProviderParentRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PolicyForProviderParentRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyForProviderParentRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyForProviderParentRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Folder in cloudplatform to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderParentSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PolicyForProviderParentSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderParentSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PolicyForProviderParentSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PolicyForProviderParentSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyForProviderParentSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyForProviderParentSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Basic information about the Organization Policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderSpec {
    /// Determines the inheritance behavior for this Policy. If inherit_from_parent is true, PolicyRules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this Policy becomes the new root for evaluation. This field can be set only for Policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific Constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// Up to 10 PolicyRules are allowed. In Policies for boolean constraints, the following requirements apply: - There must be one and only one PolicyRule where condition is unset. - BooleanPolicyRules with conditions must set enforced to the opposite of the PolicyRule without a condition. - During policy evaluation, PolicyRules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyForProviderSpecRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyForProviderSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyForProviderSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyForProviderSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProvider {
    /// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dryRunSpec")]
    #[builder(default)]
    pub dry_run_spec: Option<PolicyInitProviderDryRunSpec>,
    /// Basic information about the Organization Policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spec: Option<PolicyInitProviderSpec>,
}

/// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderDryRunSpec {
    /// Determines the inheritance behavior for this policy. If inherit_from_parent is true, policy rules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this policy becomes the new root for evaluation. This field can be set only for policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// In policies for boolean constraints, the following requirements apply: - There must be one and only one policy rule where condition is unset. - Boolean policy rules with conditions must set enforced to the opposite of the policy rule without a condition. - During policy evaluation, policy rules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyInitProviderDryRunSpecRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderDryRunSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyInitProviderDryRunSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyInitProviderDryRunSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderDryRunSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderDryRunSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

/// Basic information about the Organization Policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderSpec {
    /// Determines the inheritance behavior for this Policy. If inherit_from_parent is true, PolicyRules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this Policy becomes the new root for evaluation. This field can be set only for Policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific Constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// Up to 10 PolicyRules are allowed. In Policies for boolean constraints, the following requirements apply: - There must be one and only one PolicyRule where condition is unset. - BooleanPolicyRules with conditions must set enforced to the opposite of the PolicyRule without a condition. - During policy evaluation, PolicyRules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyInitProviderSpecRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyInitProviderSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyInitProviderSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyInitProviderSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PolicyProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PolicyProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PolicyProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<PolicyPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<PolicyPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<PolicyPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<PolicyPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<PolicyPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum PolicyPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// PolicyStatus defines the observed state of Policy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<PolicyStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProvider {
    /// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dryRunSpec")]
    #[builder(default)]
    pub dry_run_spec: Option<PolicyStatusAtProviderDryRunSpec>,
    /// Optional. An opaque tag indicating the current state of the policy, used for concurrency control. This 'etag' is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub etag: Option<String>,
    /// an identifier for the resource with format {{parent}}/policies/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The parent of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// Basic information about the Organization Policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spec: Option<PolicyStatusAtProviderSpec>,
}

/// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderDryRunSpec {
    /// (Output)
    /// An opaque tag indicating the current version of the policy, used for concurrency control. This field is ignored if used in a CreatePolicy request. When the policyis returned from either aGetPolicyor aListPoliciesrequest, thisetagindicates the version of the current policy to use when executing a read-modify-write loop. When the policy is returned from aGetEffectivePolicyrequest, theetag` will be unset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub etag: Option<String>,
    /// Determines the inheritance behavior for this policy. If inherit_from_parent is true, policy rules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this policy becomes the new root for evaluation. This field can be set only for policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// In policies for boolean constraints, the following requirements apply: - There must be one and only one policy rule where condition is unset. - Boolean policy rules with conditions must set enforced to the opposite of the policy rule without a condition. - During policy evaluation, policy rules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyStatusAtProviderDryRunSpecRules>>,
    /// (Output)
    /// Output only. The time stamp this was previously updated. This represents the last time a call to CreatePolicy or UpdatePolicy was made for that policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    #[builder(default)]
    pub update_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderDryRunSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyStatusAtProviderDryRunSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyStatusAtProviderDryRunSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderDryRunSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderDryRunSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

/// Basic information about the Organization Policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderSpec {
    /// (Output)
    /// An opaque tag indicating the current version of the Policy, used for concurrency control. This field is ignored if used in a CreatePolicy request. When the Policy is returned from either a GetPolicy or a ListPolicies request, this etag indicates the version of the current Policy to use when executing a read-modify-write loop. When the Policy is returned from a GetEffectivePolicy request, the etag will be unset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub etag: Option<String>,
    /// Determines the inheritance behavior for this Policy. If inherit_from_parent is true, PolicyRules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this Policy becomes the new root for evaluation. This field can be set only for Policies which configure list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inheritFromParent")]
    #[builder(default)]
    pub inherit_from_parent: Option<bool>,
    /// Ignores policies set above this resource and restores the constraint_default enforcement behavior of the specific Constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, rules must be empty and inherit_from_parent must be set to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reset: Option<bool>,
    /// Up to 10 PolicyRules are allowed. In Policies for boolean constraints, the following requirements apply: - There must be one and only one PolicyRule where condition is unset. - BooleanPolicyRules with conditions must set enforced to the opposite of the PolicyRule without a condition. - During policy evaluation, PolicyRules with conditions that are true for a target resource take precedence.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rules: Option<Vec<PolicyStatusAtProviderSpecRules>>,
    /// (Output)
    /// Output only. The time stamp this was previously updated. This represents the last time a call to CreatePolicy or UpdatePolicy was made for that Policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    #[builder(default)]
    pub update_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderSpecRules {
    /// Setting this to "TRUE" means that all values are allowed. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAll")]
    #[builder(default)]
    pub allow_all: Option<String>,
    /// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<PolicyStatusAtProviderSpecRulesCondition>,
    /// Setting this to "TRUE" means that all values are denied. This field can be set only in Policies for list constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyAll")]
    #[builder(default)]
    pub deny_all: Option<String>,
    /// If "TRUE", then the Policy is enforced. If "FALSE", then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enforce: Option<String>,
    /// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<PolicyStatusAtProviderSpecRulesValues>,
}

/// A condition which determines whether this rule is used in the evaluation of the policy. When set, the expression field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where key_name and value_name are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderSpecRulesCondition {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expression: Option<String>,
    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub title: Option<String>,
}

/// List of values to be used for this PolicyRule. This field can be set only in Policies for list constraints.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct PolicyStatusAtProviderSpecRulesValues {
    /// List of values allowed at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedValues")]
    #[builder(default)]
    pub allowed_values: Option<Vec<String>>,
    /// List of values denied at this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deniedValues")]
    #[builder(default)]
    pub denied_values: Option<Vec<String>>,
}

