// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// DataSourceSpec defines the desired state of DataSource
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "kendra.aws.upbound.io",
    version = "v1beta2",
    kind = "DataSource",
    plural = "datasources"
)]
#[kube(status = "DataSourceStatus")]
pub struct DataSourceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<DataSourceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: DataSourceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<DataSourceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<DataSourceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<DataSourcePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<DataSourceWriteConnectionSecretToRef>,
}

/// DataSourceSpec defines the desired state of DataSource
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProvider {
    /// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub configuration: Option<DataSourceForProviderConfiguration>,
    /// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customDocumentEnrichmentConfiguration"
    )]
    #[builder(default)]
    pub custom_document_enrichment_configuration:
        Option<DataSourceForProviderCustomDocumentEnrichmentConfiguration>,
    /// A description for the Data Source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The identifier of the index for your Amazon Kendra data source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexId")]
    #[builder(default)]
    pub index_id: Option<String>,
    /// Reference to a Index in kendra to populate indexId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "indexIdRef"
    )]
    #[builder(default)]
    pub index_id_ref: Option<DataSourceForProviderIndexIdRef>,
    /// Selector for a Index in kendra to populate indexId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "indexIdSelector"
    )]
    #[builder(default)]
    pub index_id_selector: Option<DataSourceForProviderIndexIdSelector>,
    /// The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "languageCode"
    )]
    #[builder(default)]
    pub language_code: Option<String>,
    /// A name for your data source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnRef"
    )]
    #[builder(default)]
    pub role_arn_ref: Option<DataSourceForProviderRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnSelector"
    )]
    #[builder(default)]
    pub role_arn_selector: Option<DataSourceForProviderRoleArnSelector>,
    /// Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub schedule: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// The type of data source repository. For an updated list of values, refer to Valid Values for Type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfiguration {
    /// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Configuration"
    )]
    #[builder(default)]
    pub s3_configuration: Option<DataSourceForProviderConfigurationS3Configuration>,
    /// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerConfiguration"
    )]
    #[builder(default)]
    pub web_crawler_configuration:
        Option<DataSourceForProviderConfigurationWebCrawlerConfiguration>,
}

/// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3Configuration {
    /// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessControlListConfiguration"
    )]
    #[builder(default)]
    pub access_control_list_configuration:
        Option<DataSourceForProviderConfigurationS3ConfigurationAccessControlListConfiguration>,
    /// The name of the bucket that contains the documents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameRef"
    )]
    #[builder(default)]
    pub bucket_name_ref: Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameRef>,
    /// Selector for a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameSelector"
    )]
    #[builder(default)]
    pub bucket_name_selector:
        Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameSelector>,
    /// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "documentsMetadataConfiguration"
    )]
    #[builder(default)]
    pub documents_metadata_configuration:
        Option<DataSourceForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration>,
    /// A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionPatterns"
    )]
    #[builder(default)]
    pub exclusion_patterns: Option<Vec<String>>,
    /// A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPatterns"
    )]
    #[builder(default)]
    pub inclusion_patterns: Option<Vec<String>>,
    /// A list of S3 prefixes for the documents that should be included in the index.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPrefixes"
    )]
    #[builder(default)]
    pub inclusion_prefixes: Option<Vec<String>>,
}

/// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationAccessControlListConfiguration {
    /// Path to the AWS S3 bucket that contains the ACL files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    #[builder(default)]
    pub key_path: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationBucketNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationBucketNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration {
    /// A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Prefix")]
    #[builder(default)]
    pub s3_prefix: Option<String>,
}

/// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfiguration {
    /// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationConfiguration"
    )]
    #[builder(default)]
    pub authentication_configuration: Option<
        DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration,
    >,
    /// Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlDepth"
    )]
    #[builder(default)]
    pub crawl_depth: Option<f64>,
    /// The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxContentSizePerPageInMegaBytes"
    )]
    #[builder(default)]
    pub max_content_size_per_page_in_mega_bytes: Option<f64>,
    /// The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxLinksPerPage"
    )]
    #[builder(default)]
    pub max_links_per_page: Option<f64>,
    /// The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxUrlsPerMinuteCrawlRate"
    )]
    #[builder(default)]
    pub max_urls_per_minute_crawl_rate: Option<f64>,
    /// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "proxyConfiguration"
    )]
    #[builder(default)]
    pub proxy_configuration:
        Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfiguration>,
    /// A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlExclusionPatterns"
    )]
    #[builder(default)]
    pub url_exclusion_patterns: Option<Vec<String>>,
    /// A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlInclusionPatterns"
    )]
    #[builder(default)]
    pub url_inclusion_patterns: Option<Vec<String>>,
    /// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub urls: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationUrls>,
}

/// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
    /// The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuthentication")]
    #[builder(default)]
    pub basic_authentication: Option<Vec<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication {
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// Reference to a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsRef")]
    #[builder(default)]
    pub credentials_ref: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef>,
    /// Selector for a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSelector")]
    #[builder(default)]
    pub credentials_selector: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// Reference to a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfiguration {
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// Reference to a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsRef")]
    #[builder(default)]
    pub credentials_ref: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef>,
    /// Selector for a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSelector")]
    #[builder(default)]
    pub credentials_selector: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// Reference to a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationUrls {
    /// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seedUrlConfiguration"
    )]
    #[builder(default)]
    pub seed_url_configuration:
        Option<DataSourceForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration>,
    /// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "siteMapsConfiguration"
    )]
    #[builder(default)]
    pub site_maps_configuration:
        Option<DataSourceForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration>,
}

/// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
    /// The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seedUrls")]
    #[builder(default)]
    pub seed_urls: Option<Vec<String>>,
    /// The default mode is set to HOST_ONLY. You can choose one of the following modes:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerMode"
    )]
    #[builder(default)]
    pub web_crawler_mode: Option<String>,
}

/// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
    /// The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "siteMaps")]
    #[builder(default)]
    pub site_maps: Option<Vec<String>>,
}

/// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfiguration {
    /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inlineConfigurations"
    )]
    #[builder(default)]
    pub inline_configurations:
        Option<Vec<DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations>>,
    /// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postExtractionHookConfiguration"
    )]
    #[builder(default)]
    pub post_extraction_hook_configuration: Option<
        DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration,
    >,
    /// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preExtractionHookConfiguration"
    )]
    #[builder(default)]
    pub pre_extraction_hook_configuration: Option<
        DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration,
    >,
    /// The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations {
    /// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<
        DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition,
    >,
    /// TRUE to delete content if the condition used for the target attribute is met.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "documentContentDeletion"
    )]
    #[builder(default)]
    pub document_content_deletion: Option<bool>,
    /// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<
        DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget,
    >,
}

/// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget {
    /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeKey")]
    #[builder(default)]
    pub target_document_attribute_key: Option<String>,
    /// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValue")]
    #[builder(default)]
    pub target_document_attribute_value: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue>,
    /// TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValueDeletion")]
    #[builder(default)]
    pub target_document_attribute_value_deletion: Option<bool>,
}

/// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Reference to a Index in kendra to populate indexId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderIndexIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderIndexIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderIndexIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderIndexIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderIndexIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderIndexIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderIndexIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Index in kendra to populate indexId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderIndexIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderIndexIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderIndexIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderIndexIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderIndexIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderIndexIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderIndexIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceForProviderRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceForProviderRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceForProviderRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceForProviderRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceForProviderRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProvider {
    /// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub configuration: Option<DataSourceInitProviderConfiguration>,
    /// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customDocumentEnrichmentConfiguration"
    )]
    #[builder(default)]
    pub custom_document_enrichment_configuration:
        Option<DataSourceInitProviderCustomDocumentEnrichmentConfiguration>,
    /// A description for the Data Source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The identifier of the index for your Amazon Kendra data source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexId")]
    #[builder(default)]
    pub index_id: Option<String>,
    /// Reference to a Index in kendra to populate indexId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "indexIdRef"
    )]
    #[builder(default)]
    pub index_id_ref: Option<DataSourceInitProviderIndexIdRef>,
    /// Selector for a Index in kendra to populate indexId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "indexIdSelector"
    )]
    #[builder(default)]
    pub index_id_selector: Option<DataSourceInitProviderIndexIdSelector>,
    /// The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "languageCode"
    )]
    #[builder(default)]
    pub language_code: Option<String>,
    /// A name for your data source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnRef"
    )]
    #[builder(default)]
    pub role_arn_ref: Option<DataSourceInitProviderRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "roleArnSelector"
    )]
    #[builder(default)]
    pub role_arn_selector: Option<DataSourceInitProviderRoleArnSelector>,
    /// Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub schedule: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// The type of data source repository. For an updated list of values, refer to Valid Values for Type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfiguration {
    /// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Configuration"
    )]
    #[builder(default)]
    pub s3_configuration: Option<DataSourceInitProviderConfigurationS3Configuration>,
    /// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerConfiguration"
    )]
    #[builder(default)]
    pub web_crawler_configuration:
        Option<DataSourceInitProviderConfigurationWebCrawlerConfiguration>,
}

/// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3Configuration {
    /// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessControlListConfiguration"
    )]
    #[builder(default)]
    pub access_control_list_configuration:
        Option<DataSourceInitProviderConfigurationS3ConfigurationAccessControlListConfiguration>,
    /// The name of the bucket that contains the documents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// Reference to a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameRef"
    )]
    #[builder(default)]
    pub bucket_name_ref: Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameRef>,
    /// Selector for a Bucket in s3 to populate bucketName.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketNameSelector"
    )]
    #[builder(default)]
    pub bucket_name_selector:
        Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelector>,
    /// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "documentsMetadataConfiguration"
    )]
    #[builder(default)]
    pub documents_metadata_configuration:
        Option<DataSourceInitProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration>,
    /// A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionPatterns"
    )]
    #[builder(default)]
    pub exclusion_patterns: Option<Vec<String>>,
    /// A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPatterns"
    )]
    #[builder(default)]
    pub inclusion_patterns: Option<Vec<String>>,
    /// A list of S3 prefixes for the documents that should be included in the index.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPrefixes"
    )]
    #[builder(default)]
    pub inclusion_prefixes: Option<Vec<String>>,
}

/// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationAccessControlListConfiguration {
    /// Path to the AWS S3 bucket that contains the ACL files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    #[builder(default)]
    pub key_path: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationBucketNameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucketName.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration {
    /// A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Prefix")]
    #[builder(default)]
    pub s3_prefix: Option<String>,
}

/// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfiguration {
    /// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationConfiguration"
    )]
    #[builder(default)]
    pub authentication_configuration: Option<
        DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration,
    >,
    /// Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlDepth"
    )]
    #[builder(default)]
    pub crawl_depth: Option<f64>,
    /// The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxContentSizePerPageInMegaBytes"
    )]
    #[builder(default)]
    pub max_content_size_per_page_in_mega_bytes: Option<f64>,
    /// The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxLinksPerPage"
    )]
    #[builder(default)]
    pub max_links_per_page: Option<f64>,
    /// The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxUrlsPerMinuteCrawlRate"
    )]
    #[builder(default)]
    pub max_urls_per_minute_crawl_rate: Option<f64>,
    /// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "proxyConfiguration"
    )]
    #[builder(default)]
    pub proxy_configuration:
        Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfiguration>,
    /// A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlExclusionPatterns"
    )]
    #[builder(default)]
    pub url_exclusion_patterns: Option<Vec<String>>,
    /// A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlInclusionPatterns"
    )]
    #[builder(default)]
    pub url_inclusion_patterns: Option<Vec<String>>,
    /// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub urls: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationUrls>,
}

/// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
    /// The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuthentication")]
    #[builder(default)]
    pub basic_authentication: Option<Vec<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication {
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// Reference to a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsRef")]
    #[builder(default)]
    pub credentials_ref: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef>,
    /// Selector for a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSelector")]
    #[builder(default)]
    pub credentials_selector: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// Reference to a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfiguration {
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// Reference to a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsRef")]
    #[builder(default)]
    pub credentials_ref: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef>,
    /// Selector for a Secret in secretsmanager to populate credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSelector")]
    #[builder(default)]
    pub credentials_selector: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// Reference to a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve
{
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretsmanager to populate credentials.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationUrls {
    /// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seedUrlConfiguration"
    )]
    #[builder(default)]
    pub seed_url_configuration:
        Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration>,
    /// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "siteMapsConfiguration"
    )]
    #[builder(default)]
    pub site_maps_configuration:
        Option<DataSourceInitProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration>,
}

/// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
    /// The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seedUrls")]
    #[builder(default)]
    pub seed_urls: Option<Vec<String>>,
    /// The default mode is set to HOST_ONLY. You can choose one of the following modes:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerMode"
    )]
    #[builder(default)]
    pub web_crawler_mode: Option<String>,
}

/// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
    /// The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "siteMaps")]
    #[builder(default)]
    pub site_maps: Option<Vec<String>>,
}

/// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfiguration {
    /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inlineConfigurations"
    )]
    #[builder(default)]
    pub inline_configurations: Option<
        Vec<DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurations>,
    >,
    /// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postExtractionHookConfiguration"
    )]
    #[builder(default)]
    pub post_extraction_hook_configuration: Option<
        DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration,
    >,
    /// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "preExtractionHookConfiguration"
    )]
    #[builder(default)]
    pub pre_extraction_hook_configuration: Option<
        DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration,
    >,
    /// The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurations {
    /// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<
        DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition,
    >,
    /// TRUE to delete content if the condition used for the target attribute is met.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "documentContentDeletion"
    )]
    #[builder(default)]
    pub document_content_deletion: Option<bool>,
    /// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<
        DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget,
    >,
}

/// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget {
    /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeKey")]
    #[builder(default)]
    pub target_document_attribute_key: Option<String>,
    /// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValue")]
    #[builder(default)]
    pub target_document_attribute_value: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue>,
    /// TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValueDeletion")]
    #[builder(default)]
    pub target_document_attribute_value_deletion: Option<bool>,
}

/// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Reference to a Index in kendra to populate indexId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderIndexIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderIndexIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderIndexIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderIndexIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderIndexIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderIndexIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderIndexIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Index in kendra to populate indexId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderIndexIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderIndexIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderIndexIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderIndexIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderIndexIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderIndexIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderIndexIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceInitProviderRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceInitProviderRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceInitProviderRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceInitProviderRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceInitProviderRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourcePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<DataSourcePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<DataSourcePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourcePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DataSourcePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourcePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DataSourcePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DataSourcePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourcePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DataSourcePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourcePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// DataSourceStatus defines the observed state of DataSource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<DataSourceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProvider {
    /// ARN of the Data Source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub configuration: Option<DataSourceStatusAtProviderConfiguration>,
    /// The Unix timestamp of when the Data Source was created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdAt")]
    #[builder(default)]
    pub created_at: Option<String>,
    /// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customDocumentEnrichmentConfiguration"
    )]
    #[builder(default)]
    pub custom_document_enrichment_configuration:
        Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfiguration>,
    /// The unique identifiers of the Data Source.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceId"
    )]
    #[builder(default)]
    pub data_source_id: Option<String>,
    /// A description for the Data Source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the Data Source to fail.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "errorMessage"
    )]
    #[builder(default)]
    pub error_message: Option<String>,
    /// The unique identifiers of the Data Source and index separated by a slash (/).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The identifier of the index for your Amazon Kendra data source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexId")]
    #[builder(default)]
    pub index_id: Option<String>,
    /// The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "languageCode"
    )]
    #[builder(default)]
    pub language_code: Option<String>,
    /// A name for your data source connector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub schedule: Option<String>,
    /// The current status of the Data Source. When the status is ACTIVE the Data Source is ready to use. When the status is FAILED, the error_message field contains the reason that the Data Source failed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// The type of data source repository. For an updated list of values, refer to Valid Values for Type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// The Unix timestamp of when the Data Source was last updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedAt")]
    #[builder(default)]
    pub updated_at: Option<String>,
}

/// A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfiguration {
    /// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Configuration"
    )]
    #[builder(default)]
    pub s3_configuration: Option<DataSourceStatusAtProviderConfigurationS3Configuration>,
    /// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerConfiguration"
    )]
    #[builder(default)]
    pub web_crawler_configuration:
        Option<DataSourceStatusAtProviderConfigurationWebCrawlerConfiguration>,
}

/// A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationS3Configuration {
    /// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessControlListConfiguration"
    )]
    #[builder(default)]
    pub access_control_list_configuration: Option<
        DataSourceStatusAtProviderConfigurationS3ConfigurationAccessControlListConfiguration,
    >,
    /// The name of the bucket that contains the documents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketName"
    )]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "documentsMetadataConfiguration"
    )]
    #[builder(default)]
    pub documents_metadata_configuration: Option<
        DataSourceStatusAtProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration,
    >,
    /// A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionPatterns"
    )]
    #[builder(default)]
    pub exclusion_patterns: Option<Vec<String>>,
    /// A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPatterns"
    )]
    #[builder(default)]
    pub inclusion_patterns: Option<Vec<String>>,
    /// A list of S3 prefixes for the documents that should be included in the index.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inclusionPrefixes"
    )]
    #[builder(default)]
    pub inclusion_prefixes: Option<Vec<String>>,
}

/// A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationS3ConfigurationAccessControlListConfiguration {
    /// Path to the AWS S3 bucket that contains the ACL files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    #[builder(default)]
    pub key_path: Option<String>,
}

/// A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration {
    /// A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Prefix")]
    #[builder(default)]
    pub s3_prefix: Option<String>,
}

/// A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfiguration {
    /// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "authenticationConfiguration"
    )]
    #[builder(default)]
    pub authentication_configuration: Option<
        DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration,
    >,
    /// Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crawlDepth"
    )]
    #[builder(default)]
    pub crawl_depth: Option<f64>,
    /// The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxContentSizePerPageInMegaBytes"
    )]
    #[builder(default)]
    pub max_content_size_per_page_in_mega_bytes: Option<f64>,
    /// The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxLinksPerPage"
    )]
    #[builder(default)]
    pub max_links_per_page: Option<f64>,
    /// The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxUrlsPerMinuteCrawlRate"
    )]
    #[builder(default)]
    pub max_urls_per_minute_crawl_rate: Option<f64>,
    /// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "proxyConfiguration"
    )]
    #[builder(default)]
    pub proxy_configuration:
        Option<DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationProxyConfiguration>,
    /// A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlExclusionPatterns"
    )]
    #[builder(default)]
    pub url_exclusion_patterns: Option<Vec<String>>,
    /// A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "urlInclusionPatterns"
    )]
    #[builder(default)]
    pub url_inclusion_patterns: Option<Vec<String>>,
    /// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub urls: Option<DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrls>,
}

/// A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
    /// The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuthentication")]
    #[builder(default)]
    pub basic_authentication: Option<Vec<DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication
{
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationProxyConfiguration {
    /// Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credentials: Option<String>,
    /// The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
}

/// A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrls {
    /// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seedUrlConfiguration"
    )]
    #[builder(default)]
    pub seed_url_configuration: Option<
        DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration,
    >,
    /// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "siteMapsConfiguration"
    )]
    #[builder(default)]
    pub site_maps_configuration: Option<
        DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration,
    >,
}

/// A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
    /// The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seedUrls")]
    #[builder(default)]
    pub seed_urls: Option<Vec<String>>,
    /// The default mode is set to HOST_ONLY. You can choose one of the following modes:
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "webCrawlerMode"
    )]
    #[builder(default)]
    pub web_crawler_mode: Option<String>,
}

/// A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
    /// The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "siteMaps")]
    #[builder(default)]
    pub site_maps: Option<Vec<String>>,
}

/// A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfiguration {
    /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inlineConfigurations")]
    #[builder(default)]
    pub inline_configurations: Option<Vec<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurations>>,
    /// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postExtractionHookConfiguration")]
    #[builder(default)]
    pub post_extraction_hook_configuration: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration>,
    /// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preExtractionHookConfiguration")]
    #[builder(default)]
    pub pre_extraction_hook_configuration: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration>,
    /// The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurations {
    /// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition>,
    /// TRUE to delete content if the condition used for the target attribute is met.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "documentContentDeletion")]
    #[builder(default)]
    pub document_content_deletion: Option<bool>,
    /// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub target: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget>,
}

/// Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget {
    /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeKey")]
    #[builder(default)]
    pub target_document_attribute_key: Option<String>,
    /// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValue")]
    #[builder(default)]
    pub target_document_attribute_value: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue>,
    /// TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetDocumentAttributeValueDeletion")]
    #[builder(default)]
    pub target_document_attribute_value_deletion: Option<bool>,
}

/// The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}

/// Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
    /// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invocationCondition")]
    #[builder(default)]
    pub invocation_condition: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition>,
    /// The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaArn")]
    #[builder(default)]
    pub lambda_arn: Option<String>,
    /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    #[builder(default)]
    pub s3_bucket: Option<String>,
}

/// A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
    /// The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionDocumentAttributeKey")]
    #[builder(default)]
    pub condition_document_attribute_key: Option<String>,
    /// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionOnValue")]
    #[builder(default)]
    pub condition_on_value: Option<DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue>,
    /// The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
}

/// The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DataSourceStatusAtProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue
{
    /// A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<String>,
    /// A long integer value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "longValue")]
    #[builder(default)]
    pub long_value: Option<f64>,
    /// A list of strings.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringListValue"
    )]
    #[builder(default)]
    pub string_list_value: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stringValue"
    )]
    #[builder(default)]
    pub string_value: Option<String>,
}
