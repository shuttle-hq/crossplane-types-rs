// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// UserPoolClientSpec defines the desired state of UserPoolClient
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "cognitoidp.aws.upbound.io", version = "v1beta1", kind = "UserPoolClient", plural = "userpoolclients")]
#[kube(status = "UserPoolClientStatus")]
pub struct UserPoolClientSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<UserPoolClientDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: UserPoolClientForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<UserPoolClientInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<UserPoolClientProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<UserPoolClientPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<UserPoolClientWriteConnectionSecretToRef>,
}

/// UserPoolClientSpec defines the desired state of UserPoolClient
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProvider {
    /// Time limit, between 5 minutes and 1 day, after which the access token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.access_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessTokenValidity")]
    #[builder(default)]
    pub access_token_validity: Option<f64>,
    /// List of allowed OAuth flows, including code, implicit, and client_credentials. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlows")]
    #[builder(default)]
    pub allowed_oauth_flows: Option<Vec<String>>,
    /// Whether the client is allowed to use OAuth 2.0 features. allowed_oauth_flows_user_pool_client must be set to true before you can configure the following arguments: callback_urls, logout_urls, allowed_oauth_scopes and allowed_oauth_flows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlowsUserPoolClient")]
    #[builder(default)]
    pub allowed_oauth_flows_user_pool_client: Option<bool>,
    /// List of allowed OAuth scopes, including phone, email, openid, profile, and aws.cognito.signin.user.admin. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthScopes")]
    #[builder(default)]
    pub allowed_oauth_scopes: Option<Vec<String>>,
    /// Configuration block for Amazon Pinpoint analytics that collects metrics for this user pool. See details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "analyticsConfiguration")]
    #[builder(default)]
    pub analytics_configuration: Option<Vec<UserPoolClientForProviderAnalyticsConfiguration>>,
    /// Duration, in minutes, of the session token created by Amazon Cognito for each API request in an authentication flow. The session token must be responded to by the native user of the user pool before it expires. Valid values for auth_session_validity are between 3 and 15, with a default value of 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authSessionValidity")]
    #[builder(default)]
    pub auth_session_validity: Option<f64>,
    /// List of allowed callback URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "callbackUrls")]
    #[builder(default)]
    pub callback_urls: Option<Vec<String>>,
    /// Default redirect URI and must be included in the list of callback URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRedirectUri")]
    #[builder(default)]
    pub default_redirect_uri: Option<String>,
    /// Enables the propagation of additional user context data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePropagateAdditionalUserContextData")]
    #[builder(default)]
    pub enable_propagate_additional_user_context_data: Option<bool>,
    /// Enables or disables token revocation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTokenRevocation")]
    #[builder(default)]
    pub enable_token_revocation: Option<bool>,
    /// List of authentication flows. The available options include ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY, USER_PASSWORD_AUTH, ALLOW_ADMIN_USER_PASSWORD_AUTH, ALLOW_CUSTOM_AUTH, ALLOW_USER_PASSWORD_AUTH, ALLOW_USER_SRP_AUTH, and ALLOW_REFRESH_TOKEN_AUTH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "explicitAuthFlows")]
    #[builder(default)]
    pub explicit_auth_flows: Option<Vec<String>>,
    /// Boolean flag indicating whether an application secret should be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateSecret")]
    #[builder(default)]
    pub generate_secret: Option<bool>,
    /// Time limit, between 5 minutes and 1 day, after which the ID token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.id_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idTokenValidity")]
    #[builder(default)]
    pub id_token_validity: Option<f64>,
    /// List of allowed logout URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logoutUrls")]
    #[builder(default)]
    pub logout_urls: Option<Vec<String>>,
    /// Name of the application client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Setting determines the errors and responses returned by Cognito APIs when a user does not exist in the user pool during authentication, account confirmation, and password recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preventUserExistenceErrors")]
    #[builder(default)]
    pub prevent_user_existence_errors: Option<String>,
    /// List of user pool attributes that the application client can read from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readAttributes")]
    #[builder(default)]
    pub read_attributes: Option<Vec<String>>,
    /// Time limit, between 60 minutes and 10 years, after which the refresh token is no longer valid and cannot be used. By default, the unit is days. The unit can be overridden by a value in token_validity_units.refresh_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshTokenValidity")]
    #[builder(default)]
    pub refresh_token_validity: Option<f64>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// List of provider names for the identity providers that are supported on this client. It uses the provider_name attribute of the aws_cognito_identity_provider resource(s), or the equivalent string(s).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supportedIdentityProviders")]
    #[builder(default)]
    pub supported_identity_providers: Option<Vec<String>>,
    /// Configuration block for representing the validity times in units. See details below. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenValidityUnits")]
    #[builder(default)]
    pub token_validity_units: Option<Vec<UserPoolClientForProviderTokenValidityUnits>>,
    /// User pool the client belongs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolId")]
    #[builder(default)]
    pub user_pool_id: Option<String>,
    /// Reference to a UserPool in cognitoidp to populate userPoolId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolIdRef")]
    #[builder(default)]
    pub user_pool_id_ref: Option<UserPoolClientForProviderUserPoolIdRef>,
    /// Selector for a UserPool in cognitoidp to populate userPoolId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolIdSelector")]
    #[builder(default)]
    pub user_pool_id_selector: Option<UserPoolClientForProviderUserPoolIdSelector>,
    /// List of user pool attributes that the application client can write to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeAttributes")]
    #[builder(default)]
    pub write_attributes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfiguration {
    /// Application ARN for an Amazon Pinpoint application. Conflicts with external_id and role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationArn")]
    #[builder(default)]
    pub application_arn: Option<String>,
    /// Application ID for an Amazon Pinpoint application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationId")]
    #[builder(default)]
    pub application_id: Option<String>,
    /// Reference to a App in pinpoint to populate applicationId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationIdRef")]
    #[builder(default)]
    pub application_id_ref: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdRef>,
    /// Selector for a App in pinpoint to populate applicationId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationIdSelector")]
    #[builder(default)]
    pub application_id_selector: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelector>,
    /// ID for the Analytics Configuration. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalId")]
    #[builder(default)]
    pub external_id: Option<String>,
    /// ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    #[builder(default)]
    pub role_arn_ref: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    #[builder(default)]
    pub role_arn_selector: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnSelector>,
    /// If set to true, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDataShared")]
    #[builder(default)]
    pub user_data_shared: Option<bool>,
}

/// Reference to a App in pinpoint to populate applicationId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationApplicationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationApplicationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a App in pinpoint to populate applicationId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderTokenValidityUnits {
    /// Time unit in for the value in access_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessToken")]
    #[builder(default)]
    pub access_token: Option<String>,
    /// Time unit in for the value in id_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idToken")]
    #[builder(default)]
    pub id_token: Option<String>,
    /// Time unit in for the value in refresh_token_validity, defaults to days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshToken")]
    #[builder(default)]
    pub refresh_token: Option<String>,
}

/// Reference to a UserPool in cognitoidp to populate userPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderUserPoolIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderUserPoolIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderUserPoolIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderUserPoolIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderUserPoolIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderUserPoolIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderUserPoolIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPool in cognitoidp to populate userPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderUserPoolIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientForProviderUserPoolIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientForProviderUserPoolIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientForProviderUserPoolIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientForProviderUserPoolIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderUserPoolIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientForProviderUserPoolIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProvider {
    /// Time limit, between 5 minutes and 1 day, after which the access token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.access_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessTokenValidity")]
    #[builder(default)]
    pub access_token_validity: Option<f64>,
    /// List of allowed OAuth flows, including code, implicit, and client_credentials. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlows")]
    #[builder(default)]
    pub allowed_oauth_flows: Option<Vec<String>>,
    /// Whether the client is allowed to use OAuth 2.0 features. allowed_oauth_flows_user_pool_client must be set to true before you can configure the following arguments: callback_urls, logout_urls, allowed_oauth_scopes and allowed_oauth_flows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlowsUserPoolClient")]
    #[builder(default)]
    pub allowed_oauth_flows_user_pool_client: Option<bool>,
    /// List of allowed OAuth scopes, including phone, email, openid, profile, and aws.cognito.signin.user.admin. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthScopes")]
    #[builder(default)]
    pub allowed_oauth_scopes: Option<Vec<String>>,
    /// Configuration block for Amazon Pinpoint analytics that collects metrics for this user pool. See details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "analyticsConfiguration")]
    #[builder(default)]
    pub analytics_configuration: Option<Vec<UserPoolClientInitProviderAnalyticsConfiguration>>,
    /// Duration, in minutes, of the session token created by Amazon Cognito for each API request in an authentication flow. The session token must be responded to by the native user of the user pool before it expires. Valid values for auth_session_validity are between 3 and 15, with a default value of 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authSessionValidity")]
    #[builder(default)]
    pub auth_session_validity: Option<f64>,
    /// List of allowed callback URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "callbackUrls")]
    #[builder(default)]
    pub callback_urls: Option<Vec<String>>,
    /// Default redirect URI and must be included in the list of callback URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRedirectUri")]
    #[builder(default)]
    pub default_redirect_uri: Option<String>,
    /// Enables the propagation of additional user context data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePropagateAdditionalUserContextData")]
    #[builder(default)]
    pub enable_propagate_additional_user_context_data: Option<bool>,
    /// Enables or disables token revocation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTokenRevocation")]
    #[builder(default)]
    pub enable_token_revocation: Option<bool>,
    /// List of authentication flows. The available options include ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY, USER_PASSWORD_AUTH, ALLOW_ADMIN_USER_PASSWORD_AUTH, ALLOW_CUSTOM_AUTH, ALLOW_USER_PASSWORD_AUTH, ALLOW_USER_SRP_AUTH, and ALLOW_REFRESH_TOKEN_AUTH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "explicitAuthFlows")]
    #[builder(default)]
    pub explicit_auth_flows: Option<Vec<String>>,
    /// Boolean flag indicating whether an application secret should be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateSecret")]
    #[builder(default)]
    pub generate_secret: Option<bool>,
    /// Time limit, between 5 minutes and 1 day, after which the ID token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.id_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idTokenValidity")]
    #[builder(default)]
    pub id_token_validity: Option<f64>,
    /// List of allowed logout URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logoutUrls")]
    #[builder(default)]
    pub logout_urls: Option<Vec<String>>,
    /// Name of the application client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Setting determines the errors and responses returned by Cognito APIs when a user does not exist in the user pool during authentication, account confirmation, and password recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preventUserExistenceErrors")]
    #[builder(default)]
    pub prevent_user_existence_errors: Option<String>,
    /// List of user pool attributes that the application client can read from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readAttributes")]
    #[builder(default)]
    pub read_attributes: Option<Vec<String>>,
    /// Time limit, between 60 minutes and 10 years, after which the refresh token is no longer valid and cannot be used. By default, the unit is days. The unit can be overridden by a value in token_validity_units.refresh_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshTokenValidity")]
    #[builder(default)]
    pub refresh_token_validity: Option<f64>,
    /// List of provider names for the identity providers that are supported on this client. It uses the provider_name attribute of the aws_cognito_identity_provider resource(s), or the equivalent string(s).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supportedIdentityProviders")]
    #[builder(default)]
    pub supported_identity_providers: Option<Vec<String>>,
    /// Configuration block for representing the validity times in units. See details below. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenValidityUnits")]
    #[builder(default)]
    pub token_validity_units: Option<Vec<UserPoolClientInitProviderTokenValidityUnits>>,
    /// User pool the client belongs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolId")]
    #[builder(default)]
    pub user_pool_id: Option<String>,
    /// Reference to a UserPool in cognitoidp to populate userPoolId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolIdRef")]
    #[builder(default)]
    pub user_pool_id_ref: Option<UserPoolClientInitProviderUserPoolIdRef>,
    /// Selector for a UserPool in cognitoidp to populate userPoolId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolIdSelector")]
    #[builder(default)]
    pub user_pool_id_selector: Option<UserPoolClientInitProviderUserPoolIdSelector>,
    /// List of user pool attributes that the application client can write to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeAttributes")]
    #[builder(default)]
    pub write_attributes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfiguration {
    /// Application ARN for an Amazon Pinpoint application. Conflicts with external_id and role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationArn")]
    #[builder(default)]
    pub application_arn: Option<String>,
    /// Application ID for an Amazon Pinpoint application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationId")]
    #[builder(default)]
    pub application_id: Option<String>,
    /// Reference to a App in pinpoint to populate applicationId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationIdRef")]
    #[builder(default)]
    pub application_id_ref: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRef>,
    /// Selector for a App in pinpoint to populate applicationId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationIdSelector")]
    #[builder(default)]
    pub application_id_selector: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelector>,
    /// ID for the Analytics Configuration. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalId")]
    #[builder(default)]
    pub external_id: Option<String>,
    /// ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// Reference to a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnRef")]
    #[builder(default)]
    pub role_arn_ref: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnRef>,
    /// Selector for a Role in iam to populate roleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArnSelector")]
    #[builder(default)]
    pub role_arn_selector: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelector>,
    /// If set to true, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDataShared")]
    #[builder(default)]
    pub user_data_shared: Option<bool>,
}

/// Reference to a App in pinpoint to populate applicationId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationApplicationIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a App in pinpoint to populate applicationId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate roleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderTokenValidityUnits {
    /// Time unit in for the value in access_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessToken")]
    #[builder(default)]
    pub access_token: Option<String>,
    /// Time unit in for the value in id_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idToken")]
    #[builder(default)]
    pub id_token: Option<String>,
    /// Time unit in for the value in refresh_token_validity, defaults to days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshToken")]
    #[builder(default)]
    pub refresh_token: Option<String>,
}

/// Reference to a UserPool in cognitoidp to populate userPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderUserPoolIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderUserPoolIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderUserPoolIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderUserPoolIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderUserPoolIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderUserPoolIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderUserPoolIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a UserPool in cognitoidp to populate userPoolId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderUserPoolIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientInitProviderUserPoolIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientInitProviderUserPoolIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientInitProviderUserPoolIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientInitProviderUserPoolIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderUserPoolIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientInitProviderUserPoolIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<UserPoolClientPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<UserPoolClientPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<UserPoolClientPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<UserPoolClientPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<UserPoolClientPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum UserPoolClientPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// UserPoolClientStatus defines the observed state of UserPoolClient.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<UserPoolClientStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientStatusAtProvider {
    /// Time limit, between 5 minutes and 1 day, after which the access token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.access_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessTokenValidity")]
    #[builder(default)]
    pub access_token_validity: Option<f64>,
    /// List of allowed OAuth flows, including code, implicit, and client_credentials. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlows")]
    #[builder(default)]
    pub allowed_oauth_flows: Option<Vec<String>>,
    /// Whether the client is allowed to use OAuth 2.0 features. allowed_oauth_flows_user_pool_client must be set to true before you can configure the following arguments: callback_urls, logout_urls, allowed_oauth_scopes and allowed_oauth_flows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthFlowsUserPoolClient")]
    #[builder(default)]
    pub allowed_oauth_flows_user_pool_client: Option<bool>,
    /// List of allowed OAuth scopes, including phone, email, openid, profile, and aws.cognito.signin.user.admin. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedOauthScopes")]
    #[builder(default)]
    pub allowed_oauth_scopes: Option<Vec<String>>,
    /// Configuration block for Amazon Pinpoint analytics that collects metrics for this user pool. See details below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "analyticsConfiguration")]
    #[builder(default)]
    pub analytics_configuration: Option<Vec<UserPoolClientStatusAtProviderAnalyticsConfiguration>>,
    /// Duration, in minutes, of the session token created by Amazon Cognito for each API request in an authentication flow. The session token must be responded to by the native user of the user pool before it expires. Valid values for auth_session_validity are between 3 and 15, with a default value of 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authSessionValidity")]
    #[builder(default)]
    pub auth_session_validity: Option<f64>,
    /// List of allowed callback URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "callbackUrls")]
    #[builder(default)]
    pub callback_urls: Option<Vec<String>>,
    /// Default redirect URI and must be included in the list of callback URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRedirectUri")]
    #[builder(default)]
    pub default_redirect_uri: Option<String>,
    /// Enables the propagation of additional user context data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePropagateAdditionalUserContextData")]
    #[builder(default)]
    pub enable_propagate_additional_user_context_data: Option<bool>,
    /// Enables or disables token revocation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableTokenRevocation")]
    #[builder(default)]
    pub enable_token_revocation: Option<bool>,
    /// List of authentication flows. The available options include ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY, USER_PASSWORD_AUTH, ALLOW_ADMIN_USER_PASSWORD_AUTH, ALLOW_CUSTOM_AUTH, ALLOW_USER_PASSWORD_AUTH, ALLOW_USER_SRP_AUTH, and ALLOW_REFRESH_TOKEN_AUTH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "explicitAuthFlows")]
    #[builder(default)]
    pub explicit_auth_flows: Option<Vec<String>>,
    /// Boolean flag indicating whether an application secret should be generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateSecret")]
    #[builder(default)]
    pub generate_secret: Option<bool>,
    /// ID of the user pool client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Time limit, between 5 minutes and 1 day, after which the ID token is no longer valid and cannot be used. By default, the unit is hours. The unit can be overridden by a value in token_validity_units.id_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idTokenValidity")]
    #[builder(default)]
    pub id_token_validity: Option<f64>,
    /// List of allowed logout URLs for the identity providers. allowed_oauth_flows_user_pool_client must be set to true before you can configure this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logoutUrls")]
    #[builder(default)]
    pub logout_urls: Option<Vec<String>>,
    /// Name of the application client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Setting determines the errors and responses returned by Cognito APIs when a user does not exist in the user pool during authentication, account confirmation, and password recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preventUserExistenceErrors")]
    #[builder(default)]
    pub prevent_user_existence_errors: Option<String>,
    /// List of user pool attributes that the application client can read from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readAttributes")]
    #[builder(default)]
    pub read_attributes: Option<Vec<String>>,
    /// Time limit, between 60 minutes and 10 years, after which the refresh token is no longer valid and cannot be used. By default, the unit is days. The unit can be overridden by a value in token_validity_units.refresh_token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshTokenValidity")]
    #[builder(default)]
    pub refresh_token_validity: Option<f64>,
    /// List of provider names for the identity providers that are supported on this client. It uses the provider_name attribute of the aws_cognito_identity_provider resource(s), or the equivalent string(s).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supportedIdentityProviders")]
    #[builder(default)]
    pub supported_identity_providers: Option<Vec<String>>,
    /// Configuration block for representing the validity times in units. See details below. Detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenValidityUnits")]
    #[builder(default)]
    pub token_validity_units: Option<Vec<UserPoolClientStatusAtProviderTokenValidityUnits>>,
    /// User pool the client belongs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPoolId")]
    #[builder(default)]
    pub user_pool_id: Option<String>,
    /// List of user pool attributes that the application client can write to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeAttributes")]
    #[builder(default)]
    pub write_attributes: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientStatusAtProviderAnalyticsConfiguration {
    /// Application ARN for an Amazon Pinpoint application. Conflicts with external_id and role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationArn")]
    #[builder(default)]
    pub application_arn: Option<String>,
    /// Application ID for an Amazon Pinpoint application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationId")]
    #[builder(default)]
    pub application_id: Option<String>,
    /// ID for the Analytics Configuration. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalId")]
    #[builder(default)]
    pub external_id: Option<String>,
    /// ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with application_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    #[builder(default)]
    pub role_arn: Option<String>,
    /// If set to true, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userDataShared")]
    #[builder(default)]
    pub user_data_shared: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct UserPoolClientStatusAtProviderTokenValidityUnits {
    /// Time unit in for the value in access_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessToken")]
    #[builder(default)]
    pub access_token: Option<String>,
    /// Time unit in for the value in id_token_validity, defaults to hours.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idToken")]
    #[builder(default)]
    pub id_token: Option<String>,
    /// Time unit in for the value in refresh_token_validity, defaults to days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshToken")]
    #[builder(default)]
    pub refresh_token: Option<String>,
}

