// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "datalossprevention.gcp.upbound.io",
    version = "v1beta2",
    kind = "DeidentifyTemplate",
    plural = "deidentifytemplates"
)]
#[kube(status = "DeidentifyTemplateStatus")]
pub struct DeidentifyTemplateSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<DeidentifyTemplateDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: DeidentifyTemplateForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<DeidentifyTemplateInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<DeidentifyTemplateProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<DeidentifyTemplatePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<DeidentifyTemplateWriteConnectionSecretToRef>,
}

/// DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DeidentifyTemplateDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProvider {
    /// Configuration of the deidentify template
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deidentifyConfig"
    )]
    #[builder(default)]
    pub deidentify_config: Option<DeidentifyTemplateForProviderDeidentifyConfig>,
    /// A description of the template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// User set display name of the template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// The parent of the template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "templateId"
    )]
    #[builder(default)]
    pub template_id: Option<String>,
}

/// Configuration of the deidentify template
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfig {
    /// Treat the dataset as an image and redact.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageTransformations"
    )]
    #[builder(default)]
    pub image_transformations:
        Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformations>,
    /// Treat the dataset as free-form text and apply the same free text transformation everywhere
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "infoTypeTransformations"
    )]
    #[builder(default)]
    pub info_type_transformations:
        Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformations>,
    /// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordTransformations"
    )]
    #[builder(default)]
    pub record_transformations:
        Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformations>,
}

/// Treat the dataset as an image and redact.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformations {
    /// For determination of how redaction of images should occur.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transforms:
        Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransforms>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransforms {
    /// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInfoTypes")]
    #[builder(default)]
    pub all_info_types: Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes>,
    /// Apply transformation to all text that doesn't match an infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allText")]
    #[builder(default)]
    pub all_text: Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsAllText>,
    /// The color to use when redacting content from an image. If not specified, the default is black.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactionColor")]
    #[builder(default)]
    pub redaction_color: Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor>,
    /// Apply transformation to the selected infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectedInfoTypes")]
    #[builder(default)]
    pub selected_info_types: Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes>,
}

/// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes
{}

/// Apply transformation to all text that doesn't match an infoType.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsAllText {}

/// The color to use when redacting content from an image. If not specified, the default is black.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor
{
    /// The amount of blue in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub blue: Option<f64>,
    /// The amount of green in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub green: Option<f64>,
    /// The amount of red in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub red: Option<f64>,
}

/// Apply transformation to the selected infoTypes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Treat the dataset as free-form text and apply the same free text transformation everywhere
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<
        Vec<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformations>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<bool>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<f64>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformations {
    /// Transform the record by applying various field transformations.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fieldTransformations"
    )]
    #[builder(default)]
    pub field_transformations: Option<
        Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformations>,
    >,
    /// Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordSuppressions"
    )]
    #[builder(default)]
    pub record_suppressions: Option<
        Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressions>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformations {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition>,
    /// Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
    /// FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fields: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields>>,
    /// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
    /// Only one of primitive_transformation or info_type_transformations must be specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypeTransformations")]
    #[builder(default)]
    pub info_type_transformations: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
/// Only one of primitive_transformation or info_type_transformations must be specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// Replace each matching finding with the name of the info type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig
{}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProvider {
    /// Configuration of the deidentify template
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deidentifyConfig"
    )]
    #[builder(default)]
    pub deidentify_config: Option<DeidentifyTemplateInitProviderDeidentifyConfig>,
    /// A description of the template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// User set display name of the template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// The parent of the template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "templateId"
    )]
    #[builder(default)]
    pub template_id: Option<String>,
}

/// Configuration of the deidentify template
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfig {
    /// Treat the dataset as an image and redact.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageTransformations"
    )]
    #[builder(default)]
    pub image_transformations:
        Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformations>,
    /// Treat the dataset as free-form text and apply the same free text transformation everywhere
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "infoTypeTransformations"
    )]
    #[builder(default)]
    pub info_type_transformations:
        Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformations>,
    /// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordTransformations"
    )]
    #[builder(default)]
    pub record_transformations:
        Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformations>,
}

/// Treat the dataset as an image and redact.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformations {
    /// For determination of how redaction of images should occur.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transforms:
        Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransforms>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransforms {
    /// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInfoTypes")]
    #[builder(default)]
    pub all_info_types: Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes>,
    /// Apply transformation to all text that doesn't match an infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allText")]
    #[builder(default)]
    pub all_text: Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsAllText>,
    /// The color to use when redacting content from an image. If not specified, the default is black.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactionColor")]
    #[builder(default)]
    pub redaction_color: Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor>,
    /// Apply transformation to the selected infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectedInfoTypes")]
    #[builder(default)]
    pub selected_info_types: Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes>,
}

/// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes
{}

/// Apply transformation to all text that doesn't match an infoType.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsAllText {}

/// The color to use when redacting content from an image. If not specified, the default is black.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor
{
    /// The amount of blue in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub blue: Option<f64>,
    /// The amount of green in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub green: Option<f64>,
    /// The amount of red in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub red: Option<f64>,
}

/// Apply transformation to the selected infoTypes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Treat the dataset as free-form text and apply the same free text transformation everywhere
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<
        Vec<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformations>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<bool>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<f64>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformations {
    /// Transform the record by applying various field transformations.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "fieldTransformations"
    )]
    #[builder(default)]
    pub field_transformations: Option<
        Vec<
            DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformations,
        >,
    >,
    /// Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordSuppressions"
    )]
    #[builder(default)]
    pub record_suppressions: Option<
        Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformations {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition>,
    /// Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
    /// FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fields: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields>>,
    /// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
    /// Only one of primitive_transformation or info_type_transformations must be specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypeTransformations")]
    #[builder(default)]
    pub info_type_transformations: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
/// Only one of primitive_transformation or info_type_transformations must be specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(rename = "keySecretRef")]
    pub key_secret_ref: DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(rename = "keySecretRef")]
    pub key_secret_ref: DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(rename = "keySecretRef")]
    pub key_secret_ref: DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(rename = "keySecretRef")]
    pub key_secret_ref: DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// Replace each matching finding with the name of the info type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig
{}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DeidentifyTemplateProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DeidentifyTemplateProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DeidentifyTemplateProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DeidentifyTemplateProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DeidentifyTemplateProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplatePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<DeidentifyTemplatePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<DeidentifyTemplatePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplatePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DeidentifyTemplatePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplatePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// DeidentifyTemplateStatus defines the observed state of DeidentifyTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<DeidentifyTemplateStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProvider {
    /// The creation timestamp of an deidentifyTemplate. Set by the server.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "createTime"
    )]
    #[builder(default)]
    pub create_time: Option<String>,
    /// Configuration of the deidentify template
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deidentifyConfig"
    )]
    #[builder(default)]
    pub deidentify_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfig>,
    /// A description of the template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// User set display name of the template.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// an identifier for the resource with format {{parent}}/deidentifyTemplates/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The resource name of the template. Set by the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The parent of the template in any of the following formats:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// The template id can contain uppercase and lowercase letters, numbers, and hyphens;
    /// that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is
    /// 100 characters. Can be empty to allow the system to generate one.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "templateId"
    )]
    #[builder(default)]
    pub template_id: Option<String>,
    /// The last update timestamp of an deidentifyTemplate. Set by the server.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updateTime"
    )]
    #[builder(default)]
    pub update_time: Option<String>,
}

/// Configuration of the deidentify template
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfig {
    /// Treat the dataset as an image and redact.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imageTransformations"
    )]
    #[builder(default)]
    pub image_transformations:
        Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformations>,
    /// Treat the dataset as free-form text and apply the same free text transformation everywhere
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "infoTypeTransformations"
    )]
    #[builder(default)]
    pub info_type_transformations:
        Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformations>,
    /// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "recordTransformations"
    )]
    #[builder(default)]
    pub record_transformations:
        Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformations>,
}

/// Treat the dataset as an image and redact.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformations {
    /// For determination of how redaction of images should occur.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transforms: Option<
        Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransforms>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransforms {
    /// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allInfoTypes")]
    #[builder(default)]
    pub all_info_types: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes>,
    /// Apply transformation to all text that doesn't match an infoType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allText")]
    #[builder(default)]
    pub all_text: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsAllText>,
    /// The color to use when redacting content from an image. If not specified, the default is black.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactionColor")]
    #[builder(default)]
    pub redaction_color: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsRedactionColor>,
    /// Apply transformation to the selected infoTypes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectedInfoTypes")]
    #[builder(default)]
    pub selected_info_types: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes>,
}

/// Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsAllInfoTypes
{}

/// Apply transformation to all text that doesn't match an infoType.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsAllText
{}

/// The color to use when redacting content from an image. If not specified, the default is black.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsRedactionColor
{
    /// The amount of blue in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub blue: Option<f64>,
    /// The amount of green in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub green: Option<f64>,
    /// The amount of red in the color as a value in the interval [0, 1].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub red: Option<f64>,
}

/// Apply transformation to the selected infoTypes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Treat the dataset as free-form text and apply the same free text transformation everywhere
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<bool>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<f64>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformations {
    /// Transform the record by applying various field transformations.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldTransformations")]
    #[builder(default)]
    pub field_transformations: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformations>>,
    /// Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordSuppressions")]
    #[builder(default)]
    pub record_suppressions: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformations {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition>,
    /// Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
    /// FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fields: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields>>,
    /// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
    /// Only one of primitive_transformation or info_type_transformations must be specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypeTransformations")]
    #[builder(default)]
    pub info_type_transformations: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
/// Only one of primitive_transformation or info_type_transformations must be specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
    /// Transformation for each infoType. Cannot specify more than one for a given infoType.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transformations: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
    /// InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
    /// all findings that correspond to infoTypes that were requested in InspectConfig.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infoTypes")]
    #[builder(default)]
    pub info_types: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes>>,
    /// Primitive transformation to apply to the infoType.
    /// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primitiveTransformation")]
    #[builder(default)]
    pub primitive_transformation: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// Replace each matching finding with the name of the info type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceWithInfoTypeConfig")]
    #[builder(default)]
    pub replace_with_info_type_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    #[builder(default)]
    pub key_secret_ref: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef>,
}

/// A 128/192/256 bit key.
/// A base64-encoded string.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef
{
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
{
    /// A float value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "floatValue"
    )]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "integerValue"
    )]
    #[builder(default)]
    pub integer_value: Option<String>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// Replace each matching finding with the name of the info type.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceWithInfoTypeConfig
{}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

/// Primitive transformation to apply to the infoType.
/// The primitive_transformation block must only contain one argument, corresponding to the type of transformation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
    /// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    /// This can be used on data of type: number, long, string, timestamp.
    /// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketingConfig")]
    #[builder(default)]
    pub bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig>,
    /// Partially mask a string by replacing a given number of characters with a fixed character.
    /// Masking can start from the beginning or end of the string.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "characterMaskConfig")]
    #[builder(default)]
    pub character_mask_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig>,
    /// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoDeterministicConfig")]
    #[builder(default)]
    pub crypto_deterministic_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig>,
    /// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
    /// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    /// Currently, only string and integer values can be hashed.
    /// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoHashConfig")]
    #[builder(default)]
    pub crypto_hash_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig>,
    /// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    /// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoReplaceFfxFpeConfig")]
    #[builder(default)]
    pub crypto_replace_ffx_fpe_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig>,
    /// Shifts dates by random number of days, with option to be consistent for the same context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateShiftConfig")]
    #[builder(default)]
    pub date_shift_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig>,
    /// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
    /// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
    /// This can be used on data of type: double, long.
    /// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
    /// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedSizeBucketingConfig")]
    #[builder(default)]
    pub fixed_size_bucketing_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig>,
    /// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactConfig")]
    #[builder(default)]
    pub redact_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig>,
    /// Replace each input value with a given value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceConfig")]
    #[builder(default)]
    pub replace_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig>,
    /// Replace with a value randomly drawn (with replacement) from a dictionary.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDictionaryConfig")]
    #[builder(default)]
    pub replace_dictionary_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig>,
    /// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePartConfig")]
    #[builder(default)]
    pub time_part_config: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig>,
}

/// Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on data of type: number, long, string, timestamp.
/// If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    /// Bucket is represented as a range, along with replacement values.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub buckets: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
    /// Upper bound of the range, exclusive; type must match min.
    /// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax>,
    /// Lower bound of the range, inclusive. Type should be the same as max if used.
    /// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub min: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin>,
    /// Replacement value for this bucket.
    /// The replacement_value block must only contain one argument.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacementValue")]
    #[builder(default)]
    pub replacement_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue>,
}

/// Upper bound of the range, exclusive; type must match min.
/// The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Lower bound of the range, inclusive. Type should be the same as max if used.
/// The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replacement value for this bucket.
/// The replacement_value block must only contain one argument.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Partially mask a string by replacing a given number of characters with a fixed character.
/// Masking can start from the beginning or end of the string.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "charactersToIgnore")]
    #[builder(default)]
    pub characters_to_ignore: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>>,
    /// is *
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maskingCharacter")]
    #[builder(default)]
    pub masking_character: Option<String>,
    /// 4
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberToMask")]
    #[builder(default)]
    pub number_to_mask: Option<f64>,
    /// is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reverseOrder")]
    #[builder(default)]
    pub reverse_order: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
{
    /// Characters to not transform when masking.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "charactersToSkip"
    )]
    #[builder(default)]
    pub characters_to_skip: Option<String>,
    /// Common characters to not transform when masking. Useful to avoid removing punctuation.
    /// Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "commonCharactersToIgnore"
    )]
    #[builder(default)]
    pub common_characters_to_ignore: Option<String>,
}

/// Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
/// Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
    /// Common alphabets.
    /// Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonAlphabet")]
    #[builder(default)]
    pub common_alphabet: Option<String>,
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>,
    /// This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
    /// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customAlphabet")]
    #[builder(default)]
    pub custom_alphabet: Option<String>,
    /// The native way to select the alphabet. Must be in the range [2, 95].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub radix: Option<f64>,
    /// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    /// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
    /// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "surrogateInfoType")]
    #[builder(default)]
    pub surrogate_info_type: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate
/// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc'
/// This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text.
/// In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Optional custom sensitivity for this InfoType. This only applies to data profiling.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sensitivityScore")]
    #[builder(default)]
    pub sensitivity_score: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>,
    /// Optional version name for this InfoType.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Optional custom sensitivity for this InfoType. This only applies to data profiling.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
{
    /// The sensitivity score applied to the resource.
    /// Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score: Option<String>,
}

/// Shifts dates by random number of days, with option to be consistent for the same context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub context: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext>,
    /// The key used by the encryption function.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cryptoKey")]
    #[builder(default)]
    pub crypto_key: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey>,
    /// Range of shift in days. Negative means shift to earlier in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBoundDays")]
    #[builder(default)]
    pub lower_bound_days: Option<f64>,
    /// Range of shift in days. Actual shift will be selected at random within this range (inclusive ends).
    /// Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBoundDays")]
    #[builder(default)]
    pub upper_bound_days: Option<f64>,
}

/// Points to the field that contains the context, for example, an entity id.
/// If set, must also set cryptoKey. If set, shift will be consistent for the given context.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// The key used by the encryption function.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
    /// KMS wrapped key.
    /// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
    /// For more information, see Creating a wrapped key.
    /// Note: When you use Cloud KMS for cryptographic operations, charges apply.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsWrapped")]
    #[builder(default)]
    pub kms_wrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>,
    /// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transient: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient>,
    /// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unwrapped: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>,
}

/// KMS wrapped key.
/// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
/// For more information, see Creating a wrapped key.
/// Note: When you use Cloud KMS for cryptographic operations, charges apply.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
{
    /// The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cryptoKeyName"
    )]
    #[builder(default)]
    pub crypto_key_name: Option<String>,
    /// The wrapped data crypto key.
    /// A base64-encoded string.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "wrappedKey"
    )]
    #[builder(default)]
    pub wrapped_key: Option<String>,
}

/// Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
{
    /// A 128/192/256 bit key.
    /// A base64-encoded string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
}

/// Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
/// The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
/// This can be used on data of type: double, long.
/// If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
    /// Size of each bucket (except for minimum and maximum buckets).
    /// So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
    /// Precision up to 2 decimals works.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSize")]
    #[builder(default)]
    pub bucket_size: Option<f64>,
    /// Lower bound value of buckets.
    /// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
    /// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowerBound")]
    #[builder(default)]
    pub lower_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound>,
    /// Upper bound value of buckets.
    /// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
    /// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upperBound")]
    #[builder(default)]
    pub upper_bound: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound>,
}

/// Lower bound value of buckets.
/// All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
/// The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Upper bound value of buckets.
/// All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
/// The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationRedactConfig
{}

/// Replace each input value with a given value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
    /// Replace each input value with a given value.
    /// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newValue")]
    #[builder(default)]
    pub new_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue>,
}

/// Replace each input value with a given value.
/// The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Replace with a value randomly drawn (with replacement) from a dictionary.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
    /// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wordList")]
    #[builder(default)]
    pub word_list: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList>,
}

/// A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
{
    /// Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<String>>,
}

/// For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
{
    /// The part of the time to keep.
    /// Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "partToExtract"
    )]
    #[builder(default)]
    pub part_to_extract: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
    /// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition>,
}

/// A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
    /// An expression, consisting of an operator and conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expressions: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions>,
}

/// An expression, consisting of an operator and conditions.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions>,
    /// The operator to apply to the result of conditions. Default and currently only supported value is AND.
    /// Default value is AND.
    /// Possible values are: AND.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalOperator")]
    #[builder(default)]
    pub logical_operator: Option<String>,
}

/// Conditions to apply to the expression.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
    /// Conditions to apply to the expression.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
    /// Field within the record this condition is evaluated against.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub field: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField>,
    /// Operator used to compare the field or infoType to the value.
    /// Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Value to compare against.
    /// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
    /// This argument is mandatory, except for conditions using the EXISTS operator.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue>,
}

/// Field within the record this condition is evaluated against.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
{
    /// Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// Value to compare against.
/// The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set.
/// This argument is mandatory, except for conditions using the EXISTS operator.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
    /// A boolean value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "booleanValue")]
    #[builder(default)]
    pub boolean_value: Option<bool>,
    /// Represents a whole or partial calendar date.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dateValue")]
    #[builder(default)]
    pub date_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue>,
    /// Represents a day of the week.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeekValue")]
    #[builder(default)]
    pub day_of_week_value: Option<String>,
    /// A float value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatValue")]
    #[builder(default)]
    pub float_value: Option<f64>,
    /// An integer value (int64 format)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "integerValue")]
    #[builder(default)]
    pub integer_value: Option<String>,
    /// A string value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stringValue")]
    #[builder(default)]
    pub string_value: Option<String>,
    /// Represents a time of day.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeValue")]
    #[builder(default)]
    pub time_value: Option<DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue>,
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampValue")]
    #[builder(default)]
    pub timestamp_value: Option<String>,
}

/// Represents a whole or partial calendar date.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
{
    /// Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a
    /// year by itself or a year and month where the day is not significant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Represents a time of day.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct DeidentifyTemplateStatusAtProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
{
    /// Hours of day in 24 hour format. Should be from 0 to 23.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day. Must be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time. Must normally be from 0 to 59.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}
