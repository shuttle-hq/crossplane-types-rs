// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// AlertPolicySpec defines the desired state of AlertPolicy
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "monitoring.gcp.upbound.io",
    version = "v1beta2",
    kind = "AlertPolicy",
    plural = "alertpolicies"
)]
#[kube(status = "AlertPolicyStatus")]
pub struct AlertPolicySpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<AlertPolicyDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: AlertPolicyForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<AlertPolicyInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<AlertPolicyProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<AlertPolicyPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<AlertPolicyWriteConnectionSecretToRef>,
}

/// AlertPolicySpec defines the desired state of AlertPolicy
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum AlertPolicyDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProvider {
    /// Control over how this alert policy's notification channels are notified.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alertStrategy"
    )]
    #[builder(default)]
    pub alert_strategy: Option<AlertPolicyForProviderAlertStrategy>,
    /// How to combine the results of multiple conditions to
    /// determine if an incident should be opened.
    /// Possible values are: AND, OR, AND_WITH_MATCHING_RESOURCE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub combiner: Option<String>,
    /// A list of conditions for the policy. The conditions are combined by
    /// AND or OR according to the combiner field. If the combined conditions
    /// evaluate to true, then an incident is created. A policy can have from
    /// one to six conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<AlertPolicyForProviderConditions>>,
    /// A short name or phrase used to identify the policy in
    /// dashboards, notifications, and incidents. To avoid confusion, don't use
    /// the same display name for multiple policies in the same project. The
    /// name is limited to 512 Unicode characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Documentation that is included with notifications and incidents related
    /// to this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the underlying
    /// problems detected by the alerting policy. Notification channels that have
    /// limited capacity might not show this documentation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub documentation: Option<AlertPolicyForProviderDocumentation>,
    /// Whether or not the policy is enabled. The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Identifies the notification channels to which notifications should be
    /// sent when incidents are opened or closed or when new violations occur
    /// on an already opened incident. Each element of this array corresponds
    /// to the name field in each of the NotificationChannel objects that are
    /// returned from the notificationChannels.list method. The syntax of the
    /// entries in this field is
    /// projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannels"
    )]
    #[builder(default)]
    pub notification_channels: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The severity of an alert policy indicates how important incidents generated
    /// by that policy are. The severity level will be displayed on the Incident
    /// detail page and in notifications.
    /// Possible values are: CRITICAL, ERROR, WARNING.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub severity: Option<String>,
    /// This field is intended to be used for organizing and identifying the AlertPolicy
    /// objects.The field can contain up to 64 entries. Each key and value is limited
    /// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
    /// can contain only lowercase letters, numerals, underscores, and dashes. Keys
    /// must begin with a letter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userLabels"
    )]
    #[builder(default)]
    pub user_labels: Option<HashMap<String, String>>,
}

/// Control over how this alert policy's notification channels are notified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderAlertStrategy {
    /// If an alert policy that was active has no data for this long, any open incidents will close.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoClose")]
    #[builder(default)]
    pub auto_close: Option<String>,
    /// Control over how the notification channels in notification_channels
    /// are notified when this alert fires, on a per-channel basis.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelStrategy"
    )]
    #[builder(default)]
    pub notification_channel_strategy:
        Option<Vec<AlertPolicyForProviderAlertStrategyNotificationChannelStrategy>>,
    /// Required for alert policies with a LogMatch condition.
    /// This limit is not implemented for alert policies that are not log-based.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationRateLimit"
    )]
    #[builder(default)]
    pub notification_rate_limit: Option<AlertPolicyForProviderAlertStrategyNotificationRateLimit>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderAlertStrategyNotificationChannelStrategy {
    /// The notification channels that these settings apply to. Each of these
    /// correspond to the name field in one of the NotificationChannel objects
    /// referenced in the notification_channels field of this AlertPolicy. The format is
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelNames"
    )]
    #[builder(default)]
    pub notification_channel_names: Option<Vec<String>>,
    /// The frequency at which to send reminder notifications for open incidents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "renotifyInterval"
    )]
    #[builder(default)]
    pub renotify_interval: Option<String>,
}

/// Required for alert policies with a LogMatch condition.
/// This limit is not implemented for alert policies that are not log-based.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderAlertStrategyNotificationRateLimit {
    /// Not more than one notification per period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub period: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditions {
    /// A condition that checks that a time series
    /// continues to receive new data points.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionAbsent"
    )]
    #[builder(default)]
    pub condition_absent: Option<AlertPolicyForProviderConditionsConditionAbsent>,
    /// A condition that checks for log messages matching given constraints.
    /// If set, no other conditions can be present.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMatchedLog"
    )]
    #[builder(default)]
    pub condition_matched_log: Option<AlertPolicyForProviderConditionsConditionMatchedLog>,
    /// A Monitoring Query Language query that outputs a boolean stream
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMonitoringQueryLanguage"
    )]
    #[builder(default)]
    pub condition_monitoring_query_language:
        Option<AlertPolicyForProviderConditionsConditionMonitoringQueryLanguage>,
    /// A condition type that allows alert policies to be defined using
    /// Prometheus Query Language (PromQL).
    /// The PrometheusQueryLanguageCondition message contains information
    /// from a Prometheus alerting rule and its associated rule group.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionPrometheusQueryLanguage"
    )]
    #[builder(default)]
    pub condition_prometheus_query_language:
        Option<AlertPolicyForProviderConditionsConditionPrometheusQueryLanguage>,
    /// A condition that compares a time series against a
    /// threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionThreshold"
    )]
    #[builder(default)]
    pub condition_threshold: Option<AlertPolicyForProviderConditionsConditionThreshold>,
    /// A short name or phrase used to identify the
    /// condition in dashboards, notifications, and
    /// incidents. To avoid confusion, don't use the same
    /// display name for multiple conditions in the same
    /// policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
}

/// A condition that checks that a time series
/// continues to receive new data points.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionAbsent {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations: Option<Vec<AlertPolicyForProviderConditionsConditionAbsentAggregations>>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyForProviderConditionsConditionAbsentTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionAbsentAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionAbsentTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition that checks for log messages matching given constraints.
/// If set, no other conditions can be present.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionMatchedLog {
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// A map from a label key to an extractor expression, which is used to
    /// extract the value for this label key. Each entry in this map is
    /// a specification for how data should be extracted from log entries that
    /// match filter. Each combination of extracted values is treated as
    /// a separate rule for the purposes of triggering notifications.
    /// Label keys and corresponding values can be used in notifications
    /// generated by this condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelExtractors"
    )]
    #[builder(default)]
    pub label_extractors: Option<HashMap<String, String>>,
}

/// A Monitoring Query Language query that outputs a boolean stream
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionMonitoringQueryLanguage {
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyForProviderConditionsConditionMonitoringQueryLanguageTrigger>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionMonitoringQueryLanguageTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition type that allows alert policies to be defined using
/// Prometheus Query Language (PromQL).
/// The PrometheusQueryLanguageCondition message contains information
/// from a Prometheus alerting rule and its associated rule group.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionPrometheusQueryLanguage {
    /// The alerting rule name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future.
    /// This field is optional. If this field is not empty, then it must be a
    /// valid Prometheus label name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alertRule")]
    #[builder(default)]
    pub alert_rule: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// How often this rule should be evaluated. Must be a positive multiple
    /// of 30 seconds or missing. The default value is 30 seconds. If this
    /// PrometheusQueryLanguageCondition was generated from a Prometheus
    /// alerting rule, then this value should be taken from the enclosing
    /// rule group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationInterval"
    )]
    #[builder(default)]
    pub evaluation_interval: Option<String>,
    /// Labels to add to or overwrite in the PromQL query result. Label names
    /// must be valid.
    /// Label values can be templatized by using variables. The only available
    /// variable names are the names of the labels in the PromQL result, including
    /// "name" and "value". "labels" may be empty. This field is intended to be
    /// used for organizing and identifying the AlertPolicy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The rule group name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future. This field is optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleGroup")]
    #[builder(default)]
    pub rule_group: Option<String>,
}

/// A condition that compares a time series against a
/// threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionThreshold {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations: Option<Vec<AlertPolicyForProviderConditionsConditionThresholdAggregations>>,
    /// The comparison to apply between the time
    /// series (indicated by filter and aggregation)
    /// and the threshold (indicated by
    /// threshold_value). The comparison is applied
    /// on each time series, with the time series on
    /// the left-hand side and the threshold on the
    /// right-hand side. Only COMPARISON_LT and
    /// COMPARISON_GT are supported currently.
    /// Possible values are: COMPARISON_GT, COMPARISON_GE, COMPARISON_LT, COMPARISON_LE, COMPARISON_EQ, COMPARISON_NE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub comparison: Option<String>,
    /// Specifies the alignment of data points in
    /// individual time series selected by
    /// denominatorFilter as well as how to combine
    /// the retrieved time series together (such as
    /// when aggregating multiple streams on each
    /// resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).When
    /// computing ratios, the aggregations and
    /// denominator_aggregations fields must use the
    /// same alignment period and produce time
    /// series that have the same periodicity and
    /// labels.This field is similar to the one in
    /// the MetricService.ListTimeSeries request. It
    /// is advisable to use the ListTimeSeries
    /// method when debugging this field.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorAggregations"
    )]
    #[builder(default)]
    pub denominator_aggregations:
        Option<Vec<AlertPolicyForProviderConditionsConditionThresholdDenominatorAggregations>>,
    /// A filter that identifies a time series that
    /// should be used as the denominator of a ratio
    /// that will be compared with the threshold. If
    /// a denominator_filter is specified, the time
    /// series specified by the filter field will be
    /// used as the numerator.The filter is similar
    /// to the one that is specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorFilter"
    )]
    #[builder(default)]
    pub denominator_filter: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// When this field is present, the MetricThreshold
    /// condition forecasts whether the time series is
    /// predicted to violate the threshold within the
    /// forecastHorizon. When this field is not set, the
    /// MetricThreshold tests the current value of the
    /// timeseries against the threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastOptions"
    )]
    #[builder(default)]
    pub forecast_options: Option<AlertPolicyForProviderConditionsConditionThresholdForecastOptions>,
    /// A value against which to compare the time
    /// series.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "thresholdValue"
    )]
    #[builder(default)]
    pub threshold_value: Option<f64>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyForProviderConditionsConditionThresholdTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionThresholdAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionThresholdDenominatorAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// When this field is present, the MetricThreshold
/// condition forecasts whether the time series is
/// predicted to violate the threshold within the
/// forecastHorizon. When this field is not set, the
/// MetricThreshold tests the current value of the
/// timeseries against the threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionThresholdForecastOptions {
    /// The length of time into the future to forecast
    /// whether a timeseries will violate the threshold.
    /// If the predicted value is found to violate the
    /// threshold, and the violation is observed in all
    /// forecasts made for the Configured duration,
    /// then the timeseries is considered to be failing.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastHorizon"
    )]
    #[builder(default)]
    pub forecast_horizon: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderConditionsConditionThresholdTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// Documentation that is included with notifications and incidents related
/// to this policy. Best practice is for the documentation to include information
/// to help responders understand, mitigate, escalate, and correct the underlying
/// problems detected by the alerting policy. Notification channels that have
/// limited capacity might not show this documentation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderDocumentation {
    /// The text of the documentation, interpreted according to mimeType.
    /// The content may not exceed 8,192 Unicode characters and may not
    /// exceed more than 10,240 bytes when encoded in UTF-8 format,
    /// whichever is smaller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<String>,
    /// Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub links: Option<Vec<AlertPolicyForProviderDocumentationLinks>>,
    /// The format of the content field. Presently, only the value
    /// "text/markdown" is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mimeType")]
    #[builder(default)]
    pub mime_type: Option<String>,
    /// The subject line of the notification. The subject line may not
    /// exceed 10,240 bytes. In notifications generated by this policy the contents
    /// of the subject line after variable expansion will be truncated to 255 bytes
    /// or shorter at the latest UTF-8 character boundary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subject: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyForProviderDocumentationLinks {
    /// A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProvider {
    /// Control over how this alert policy's notification channels are notified.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alertStrategy"
    )]
    #[builder(default)]
    pub alert_strategy: Option<AlertPolicyInitProviderAlertStrategy>,
    /// How to combine the results of multiple conditions to
    /// determine if an incident should be opened.
    /// Possible values are: AND, OR, AND_WITH_MATCHING_RESOURCE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub combiner: Option<String>,
    /// A list of conditions for the policy. The conditions are combined by
    /// AND or OR according to the combiner field. If the combined conditions
    /// evaluate to true, then an incident is created. A policy can have from
    /// one to six conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<AlertPolicyInitProviderConditions>>,
    /// A short name or phrase used to identify the policy in
    /// dashboards, notifications, and incidents. To avoid confusion, don't use
    /// the same display name for multiple policies in the same project. The
    /// name is limited to 512 Unicode characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Documentation that is included with notifications and incidents related
    /// to this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the underlying
    /// problems detected by the alerting policy. Notification channels that have
    /// limited capacity might not show this documentation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub documentation: Option<AlertPolicyInitProviderDocumentation>,
    /// Whether or not the policy is enabled. The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Identifies the notification channels to which notifications should be
    /// sent when incidents are opened or closed or when new violations occur
    /// on an already opened incident. Each element of this array corresponds
    /// to the name field in each of the NotificationChannel objects that are
    /// returned from the notificationChannels.list method. The syntax of the
    /// entries in this field is
    /// projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannels"
    )]
    #[builder(default)]
    pub notification_channels: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The severity of an alert policy indicates how important incidents generated
    /// by that policy are. The severity level will be displayed on the Incident
    /// detail page and in notifications.
    /// Possible values are: CRITICAL, ERROR, WARNING.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub severity: Option<String>,
    /// This field is intended to be used for organizing and identifying the AlertPolicy
    /// objects.The field can contain up to 64 entries. Each key and value is limited
    /// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
    /// can contain only lowercase letters, numerals, underscores, and dashes. Keys
    /// must begin with a letter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userLabels"
    )]
    #[builder(default)]
    pub user_labels: Option<HashMap<String, String>>,
}

/// Control over how this alert policy's notification channels are notified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderAlertStrategy {
    /// If an alert policy that was active has no data for this long, any open incidents will close.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoClose")]
    #[builder(default)]
    pub auto_close: Option<String>,
    /// Control over how the notification channels in notification_channels
    /// are notified when this alert fires, on a per-channel basis.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelStrategy"
    )]
    #[builder(default)]
    pub notification_channel_strategy:
        Option<Vec<AlertPolicyInitProviderAlertStrategyNotificationChannelStrategy>>,
    /// Required for alert policies with a LogMatch condition.
    /// This limit is not implemented for alert policies that are not log-based.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationRateLimit"
    )]
    #[builder(default)]
    pub notification_rate_limit: Option<AlertPolicyInitProviderAlertStrategyNotificationRateLimit>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderAlertStrategyNotificationChannelStrategy {
    /// The notification channels that these settings apply to. Each of these
    /// correspond to the name field in one of the NotificationChannel objects
    /// referenced in the notification_channels field of this AlertPolicy. The format is
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelNames"
    )]
    #[builder(default)]
    pub notification_channel_names: Option<Vec<String>>,
    /// The frequency at which to send reminder notifications for open incidents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "renotifyInterval"
    )]
    #[builder(default)]
    pub renotify_interval: Option<String>,
}

/// Required for alert policies with a LogMatch condition.
/// This limit is not implemented for alert policies that are not log-based.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderAlertStrategyNotificationRateLimit {
    /// Not more than one notification per period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub period: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditions {
    /// A condition that checks that a time series
    /// continues to receive new data points.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionAbsent"
    )]
    #[builder(default)]
    pub condition_absent: Option<AlertPolicyInitProviderConditionsConditionAbsent>,
    /// A condition that checks for log messages matching given constraints.
    /// If set, no other conditions can be present.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMatchedLog"
    )]
    #[builder(default)]
    pub condition_matched_log: Option<AlertPolicyInitProviderConditionsConditionMatchedLog>,
    /// A Monitoring Query Language query that outputs a boolean stream
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMonitoringQueryLanguage"
    )]
    #[builder(default)]
    pub condition_monitoring_query_language:
        Option<AlertPolicyInitProviderConditionsConditionMonitoringQueryLanguage>,
    /// A condition type that allows alert policies to be defined using
    /// Prometheus Query Language (PromQL).
    /// The PrometheusQueryLanguageCondition message contains information
    /// from a Prometheus alerting rule and its associated rule group.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionPrometheusQueryLanguage"
    )]
    #[builder(default)]
    pub condition_prometheus_query_language:
        Option<AlertPolicyInitProviderConditionsConditionPrometheusQueryLanguage>,
    /// A condition that compares a time series against a
    /// threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionThreshold"
    )]
    #[builder(default)]
    pub condition_threshold: Option<AlertPolicyInitProviderConditionsConditionThreshold>,
    /// A short name or phrase used to identify the
    /// condition in dashboards, notifications, and
    /// incidents. To avoid confusion, don't use the same
    /// display name for multiple conditions in the same
    /// policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
}

/// A condition that checks that a time series
/// continues to receive new data points.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionAbsent {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations: Option<Vec<AlertPolicyInitProviderConditionsConditionAbsentAggregations>>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyInitProviderConditionsConditionAbsentTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionAbsentAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionAbsentTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition that checks for log messages matching given constraints.
/// If set, no other conditions can be present.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionMatchedLog {
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// A map from a label key to an extractor expression, which is used to
    /// extract the value for this label key. Each entry in this map is
    /// a specification for how data should be extracted from log entries that
    /// match filter. Each combination of extracted values is treated as
    /// a separate rule for the purposes of triggering notifications.
    /// Label keys and corresponding values can be used in notifications
    /// generated by this condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelExtractors"
    )]
    #[builder(default)]
    pub label_extractors: Option<HashMap<String, String>>,
}

/// A Monitoring Query Language query that outputs a boolean stream
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionMonitoringQueryLanguage {
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyInitProviderConditionsConditionMonitoringQueryLanguageTrigger>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionMonitoringQueryLanguageTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition type that allows alert policies to be defined using
/// Prometheus Query Language (PromQL).
/// The PrometheusQueryLanguageCondition message contains information
/// from a Prometheus alerting rule and its associated rule group.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionPrometheusQueryLanguage {
    /// The alerting rule name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future.
    /// This field is optional. If this field is not empty, then it must be a
    /// valid Prometheus label name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alertRule")]
    #[builder(default)]
    pub alert_rule: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// How often this rule should be evaluated. Must be a positive multiple
    /// of 30 seconds or missing. The default value is 30 seconds. If this
    /// PrometheusQueryLanguageCondition was generated from a Prometheus
    /// alerting rule, then this value should be taken from the enclosing
    /// rule group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationInterval"
    )]
    #[builder(default)]
    pub evaluation_interval: Option<String>,
    /// Labels to add to or overwrite in the PromQL query result. Label names
    /// must be valid.
    /// Label values can be templatized by using variables. The only available
    /// variable names are the names of the labels in the PromQL result, including
    /// "name" and "value". "labels" may be empty. This field is intended to be
    /// used for organizing and identifying the AlertPolicy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The rule group name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future. This field is optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleGroup")]
    #[builder(default)]
    pub rule_group: Option<String>,
}

/// A condition that compares a time series against a
/// threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionThreshold {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations: Option<Vec<AlertPolicyInitProviderConditionsConditionThresholdAggregations>>,
    /// The comparison to apply between the time
    /// series (indicated by filter and aggregation)
    /// and the threshold (indicated by
    /// threshold_value). The comparison is applied
    /// on each time series, with the time series on
    /// the left-hand side and the threshold on the
    /// right-hand side. Only COMPARISON_LT and
    /// COMPARISON_GT are supported currently.
    /// Possible values are: COMPARISON_GT, COMPARISON_GE, COMPARISON_LT, COMPARISON_LE, COMPARISON_EQ, COMPARISON_NE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub comparison: Option<String>,
    /// Specifies the alignment of data points in
    /// individual time series selected by
    /// denominatorFilter as well as how to combine
    /// the retrieved time series together (such as
    /// when aggregating multiple streams on each
    /// resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).When
    /// computing ratios, the aggregations and
    /// denominator_aggregations fields must use the
    /// same alignment period and produce time
    /// series that have the same periodicity and
    /// labels.This field is similar to the one in
    /// the MetricService.ListTimeSeries request. It
    /// is advisable to use the ListTimeSeries
    /// method when debugging this field.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorAggregations"
    )]
    #[builder(default)]
    pub denominator_aggregations:
        Option<Vec<AlertPolicyInitProviderConditionsConditionThresholdDenominatorAggregations>>,
    /// A filter that identifies a time series that
    /// should be used as the denominator of a ratio
    /// that will be compared with the threshold. If
    /// a denominator_filter is specified, the time
    /// series specified by the filter field will be
    /// used as the numerator.The filter is similar
    /// to the one that is specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorFilter"
    )]
    #[builder(default)]
    pub denominator_filter: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// When this field is present, the MetricThreshold
    /// condition forecasts whether the time series is
    /// predicted to violate the threshold within the
    /// forecastHorizon. When this field is not set, the
    /// MetricThreshold tests the current value of the
    /// timeseries against the threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastOptions"
    )]
    #[builder(default)]
    pub forecast_options:
        Option<AlertPolicyInitProviderConditionsConditionThresholdForecastOptions>,
    /// A value against which to compare the time
    /// series.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "thresholdValue"
    )]
    #[builder(default)]
    pub threshold_value: Option<f64>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyInitProviderConditionsConditionThresholdTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionThresholdAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionThresholdDenominatorAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// When this field is present, the MetricThreshold
/// condition forecasts whether the time series is
/// predicted to violate the threshold within the
/// forecastHorizon. When this field is not set, the
/// MetricThreshold tests the current value of the
/// timeseries against the threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionThresholdForecastOptions {
    /// The length of time into the future to forecast
    /// whether a timeseries will violate the threshold.
    /// If the predicted value is found to violate the
    /// threshold, and the violation is observed in all
    /// forecasts made for the Configured duration,
    /// then the timeseries is considered to be failing.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastHorizon"
    )]
    #[builder(default)]
    pub forecast_horizon: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderConditionsConditionThresholdTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// Documentation that is included with notifications and incidents related
/// to this policy. Best practice is for the documentation to include information
/// to help responders understand, mitigate, escalate, and correct the underlying
/// problems detected by the alerting policy. Notification channels that have
/// limited capacity might not show this documentation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderDocumentation {
    /// The text of the documentation, interpreted according to mimeType.
    /// The content may not exceed 8,192 Unicode characters and may not
    /// exceed more than 10,240 bytes when encoded in UTF-8 format,
    /// whichever is smaller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<String>,
    /// Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub links: Option<Vec<AlertPolicyInitProviderDocumentationLinks>>,
    /// The format of the content field. Presently, only the value
    /// "text/markdown" is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mimeType")]
    #[builder(default)]
    pub mime_type: Option<String>,
    /// The subject line of the notification. The subject line may not
    /// exceed 10,240 bytes. In notifications generated by this policy the contents
    /// of the subject line after variable expansion will be truncated to 255 bytes
    /// or shorter at the latest UTF-8 character boundary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subject: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyInitProviderDocumentationLinks {
    /// A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<AlertPolicyProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<AlertPolicyProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<AlertPolicyProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum AlertPolicyProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum AlertPolicyProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<AlertPolicyPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<AlertPolicyPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<AlertPolicyPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<AlertPolicyPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<AlertPolicyPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum AlertPolicyPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum AlertPolicyPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// AlertPolicyStatus defines the observed state of AlertPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<AlertPolicyStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProvider {
    /// Control over how this alert policy's notification channels are notified.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alertStrategy"
    )]
    #[builder(default)]
    pub alert_strategy: Option<AlertPolicyStatusAtProviderAlertStrategy>,
    /// How to combine the results of multiple conditions to
    /// determine if an incident should be opened.
    /// Possible values are: AND, OR, AND_WITH_MATCHING_RESOURCE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub combiner: Option<String>,
    /// A list of conditions for the policy. The conditions are combined by
    /// AND or OR according to the combiner field. If the combined conditions
    /// evaluate to true, then an incident is created. A policy can have from
    /// one to six conditions.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<AlertPolicyStatusAtProviderConditions>>,
    /// A read-only record of the creation of the alerting policy.
    /// If provided in a call to create or update, this field will
    /// be ignored.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "creationRecord"
    )]
    #[builder(default)]
    pub creation_record: Option<Vec<AlertPolicyStatusAtProviderCreationRecord>>,
    /// A short name or phrase used to identify the policy in
    /// dashboards, notifications, and incidents. To avoid confusion, don't use
    /// the same display name for multiple policies in the same project. The
    /// name is limited to 512 Unicode characters.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Documentation that is included with notifications and incidents related
    /// to this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the underlying
    /// problems detected by the alerting policy. Notification channels that have
    /// limited capacity might not show this documentation.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub documentation: Option<AlertPolicyStatusAtProviderDocumentation>,
    /// Whether or not the policy is enabled. The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// an identifier for the resource with format {{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The unique resource name for this policy.
    /// Its syntax is: projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Identifies the notification channels to which notifications should be
    /// sent when incidents are opened or closed or when new violations occur
    /// on an already opened incident. Each element of this array corresponds
    /// to the name field in each of the NotificationChannel objects that are
    /// returned from the notificationChannels.list method. The syntax of the
    /// entries in this field is
    /// projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannels"
    )]
    #[builder(default)]
    pub notification_channels: Option<Vec<String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The severity of an alert policy indicates how important incidents generated
    /// by that policy are. The severity level will be displayed on the Incident
    /// detail page and in notifications.
    /// Possible values are: CRITICAL, ERROR, WARNING.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub severity: Option<String>,
    /// This field is intended to be used for organizing and identifying the AlertPolicy
    /// objects.The field can contain up to 64 entries. Each key and value is limited
    /// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
    /// can contain only lowercase letters, numerals, underscores, and dashes. Keys
    /// must begin with a letter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userLabels"
    )]
    #[builder(default)]
    pub user_labels: Option<HashMap<String, String>>,
}

/// Control over how this alert policy's notification channels are notified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderAlertStrategy {
    /// If an alert policy that was active has no data for this long, any open incidents will close.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoClose")]
    #[builder(default)]
    pub auto_close: Option<String>,
    /// Control over how the notification channels in notification_channels
    /// are notified when this alert fires, on a per-channel basis.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelStrategy"
    )]
    #[builder(default)]
    pub notification_channel_strategy:
        Option<Vec<AlertPolicyStatusAtProviderAlertStrategyNotificationChannelStrategy>>,
    /// Required for alert policies with a LogMatch condition.
    /// This limit is not implemented for alert policies that are not log-based.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationRateLimit"
    )]
    #[builder(default)]
    pub notification_rate_limit:
        Option<AlertPolicyStatusAtProviderAlertStrategyNotificationRateLimit>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderAlertStrategyNotificationChannelStrategy {
    /// The notification channels that these settings apply to. Each of these
    /// correspond to the name field in one of the NotificationChannel objects
    /// referenced in the notification_channels field of this AlertPolicy. The format is
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "notificationChannelNames"
    )]
    #[builder(default)]
    pub notification_channel_names: Option<Vec<String>>,
    /// The frequency at which to send reminder notifications for open incidents.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "renotifyInterval"
    )]
    #[builder(default)]
    pub renotify_interval: Option<String>,
}

/// Required for alert policies with a LogMatch condition.
/// This limit is not implemented for alert policies that are not log-based.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderAlertStrategyNotificationRateLimit {
    /// Not more than one notification per period.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub period: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditions {
    /// A condition that checks that a time series
    /// continues to receive new data points.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionAbsent"
    )]
    #[builder(default)]
    pub condition_absent: Option<AlertPolicyStatusAtProviderConditionsConditionAbsent>,
    /// A condition that checks for log messages matching given constraints.
    /// If set, no other conditions can be present.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMatchedLog"
    )]
    #[builder(default)]
    pub condition_matched_log: Option<AlertPolicyStatusAtProviderConditionsConditionMatchedLog>,
    /// A Monitoring Query Language query that outputs a boolean stream
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionMonitoringQueryLanguage"
    )]
    #[builder(default)]
    pub condition_monitoring_query_language:
        Option<AlertPolicyStatusAtProviderConditionsConditionMonitoringQueryLanguage>,
    /// A condition type that allows alert policies to be defined using
    /// Prometheus Query Language (PromQL).
    /// The PrometheusQueryLanguageCondition message contains information
    /// from a Prometheus alerting rule and its associated rule group.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionPrometheusQueryLanguage"
    )]
    #[builder(default)]
    pub condition_prometheus_query_language:
        Option<AlertPolicyStatusAtProviderConditionsConditionPrometheusQueryLanguage>,
    /// A condition that compares a time series against a
    /// threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "conditionThreshold"
    )]
    #[builder(default)]
    pub condition_threshold: Option<AlertPolicyStatusAtProviderConditionsConditionThreshold>,
    /// A short name or phrase used to identify the
    /// condition in dashboards, notifications, and
    /// incidents. To avoid confusion, don't use the same
    /// display name for multiple conditions in the same
    /// policy.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// (Output)
    /// The unique resource name for this condition.
    /// Its syntax is:
    /// projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
    /// [CONDITION_ID] is assigned by Stackdriver Monitoring when
    /// the condition is created as part of a new or updated alerting
    /// policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
}

/// A condition that checks that a time series
/// continues to receive new data points.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionAbsent {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations: Option<Vec<AlertPolicyStatusAtProviderConditionsConditionAbsentAggregations>>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyStatusAtProviderConditionsConditionAbsentTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionAbsentAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionAbsentTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition that checks for log messages matching given constraints.
/// If set, no other conditions can be present.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionMatchedLog {
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// A map from a label key to an extractor expression, which is used to
    /// extract the value for this label key. Each entry in this map is
    /// a specification for how data should be extracted from log entries that
    /// match filter. Each combination of extracted values is treated as
    /// a separate rule for the purposes of triggering notifications.
    /// Label keys and corresponding values can be used in notifications
    /// generated by this condition.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelExtractors"
    )]
    #[builder(default)]
    pub label_extractors: Option<HashMap<String, String>>,
}

/// A Monitoring Query Language query that outputs a boolean stream
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionMonitoringQueryLanguage {
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger:
        Option<AlertPolicyStatusAtProviderConditionsConditionMonitoringQueryLanguageTrigger>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionMonitoringQueryLanguageTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

/// A condition type that allows alert policies to be defined using
/// Prometheus Query Language (PromQL).
/// The PrometheusQueryLanguageCondition message contains information
/// from a Prometheus alerting rule and its associated rule group.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionPrometheusQueryLanguage {
    /// The alerting rule name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future.
    /// This field is optional. If this field is not empty, then it must be a
    /// valid Prometheus label name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "alertRule")]
    #[builder(default)]
    pub alert_rule: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// How often this rule should be evaluated. Must be a positive multiple
    /// of 30 seconds or missing. The default value is 30 seconds. If this
    /// PrometheusQueryLanguageCondition was generated from a Prometheus
    /// alerting rule, then this value should be taken from the enclosing
    /// rule group.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationInterval"
    )]
    #[builder(default)]
    pub evaluation_interval: Option<String>,
    /// Labels to add to or overwrite in the PromQL query result. Label names
    /// must be valid.
    /// Label values can be templatized by using variables. The only available
    /// variable names are the names of the labels in the PromQL result, including
    /// "name" and "value". "labels" may be empty. This field is intended to be
    /// used for organizing and identifying the AlertPolicy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The PromQL expression to evaluate. Every evaluation cycle this
    /// expression is evaluated at the current time, and all resultant time
    /// series become pending/firing alerts. This field must not be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub query: Option<String>,
    /// The rule group name of this alert in the corresponding Prometheus
    /// configuration file.
    /// Some external tools may require this field to be populated correctly
    /// in order to refer to the original Prometheus configuration file.
    /// The rule group name and the alert name are necessary to update the
    /// relevant AlertPolicies in case the definition of the rule group changes
    /// in the future. This field is optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleGroup")]
    #[builder(default)]
    pub rule_group: Option<String>,
}

/// A condition that compares a time series against a
/// threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionThreshold {
    /// Specifies the alignment of data points in
    /// individual time series as well as how to
    /// combine the retrieved time series together
    /// (such as when aggregating multiple streams
    /// on each resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).
    /// Multiple aggregations are applied in the
    /// order specified.This field is similar to the
    /// one in the MetricService.ListTimeSeries
    /// request. It is advisable to use the
    /// ListTimeSeries method when debugging this
    /// field.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aggregations:
        Option<Vec<AlertPolicyStatusAtProviderConditionsConditionThresholdAggregations>>,
    /// The comparison to apply between the time
    /// series (indicated by filter and aggregation)
    /// and the threshold (indicated by
    /// threshold_value). The comparison is applied
    /// on each time series, with the time series on
    /// the left-hand side and the threshold on the
    /// right-hand side. Only COMPARISON_LT and
    /// COMPARISON_GT are supported currently.
    /// Possible values are: COMPARISON_GT, COMPARISON_GE, COMPARISON_LT, COMPARISON_LE, COMPARISON_EQ, COMPARISON_NE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub comparison: Option<String>,
    /// Specifies the alignment of data points in
    /// individual time series selected by
    /// denominatorFilter as well as how to combine
    /// the retrieved time series together (such as
    /// when aggregating multiple streams on each
    /// resource to a single stream for each
    /// resource or when aggregating streams across
    /// all members of a group of resources).When
    /// computing ratios, the aggregations and
    /// denominator_aggregations fields must use the
    /// same alignment period and produce time
    /// series that have the same periodicity and
    /// labels.This field is similar to the one in
    /// the MetricService.ListTimeSeries request. It
    /// is advisable to use the ListTimeSeries
    /// method when debugging this field.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorAggregations"
    )]
    #[builder(default)]
    pub denominator_aggregations:
        Option<Vec<AlertPolicyStatusAtProviderConditionsConditionThresholdDenominatorAggregations>>,
    /// A filter that identifies a time series that
    /// should be used as the denominator of a ratio
    /// that will be compared with the threshold. If
    /// a denominator_filter is specified, the time
    /// series specified by the filter field will be
    /// used as the numerator.The filter is similar
    /// to the one that is specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "denominatorFilter"
    )]
    #[builder(default)]
    pub denominator_filter: Option<String>,
    /// The amount of time that a time series must
    /// violate the threshold to be considered
    /// failing. Currently, only values that are a
    /// multiple of a minute--e.g., 0, 60, 120, or
    /// 300 seconds--are supported. If an invalid
    /// value is given, an error will be returned.
    /// When choosing a duration, it is useful to
    /// keep in mind the frequency of the underlying
    /// time series data (which may also be affected
    /// by any alignments specified in the
    /// aggregations field); a good duration is long
    /// enough so that a single outlier does not
    /// generate spurious alerts, but short enough
    /// that unhealthy states are detected and
    /// alerted on quickly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// A condition control that determines how
    /// metric-threshold conditions are evaluated when
    /// data stops arriving.
    /// Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "evaluationMissingData"
    )]
    #[builder(default)]
    pub evaluation_missing_data: Option<String>,
    /// A filter that identifies which time series
    /// should be compared with the threshold.The
    /// filter is similar to the one that is
    /// specified in the
    /// MetricService.ListTimeSeries request (that
    /// call is useful to verify the time series
    /// that will be retrieved / processed) and must
    /// specify the metric type and optionally may
    /// contain restrictions on resource type,
    /// resource labels, and metric labels. This
    /// field may not exceed 2048 Unicode characters
    /// in length.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// When this field is present, the MetricThreshold
    /// condition forecasts whether the time series is
    /// predicted to violate the threshold within the
    /// forecastHorizon. When this field is not set, the
    /// MetricThreshold tests the current value of the
    /// timeseries against the threshold.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastOptions"
    )]
    #[builder(default)]
    pub forecast_options:
        Option<AlertPolicyStatusAtProviderConditionsConditionThresholdForecastOptions>,
    /// A value against which to compare the time
    /// series.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "thresholdValue"
    )]
    #[builder(default)]
    pub threshold_value: Option<f64>,
    /// The number/percent of time series for which
    /// the comparison must hold in order for the
    /// condition to trigger. If unspecified, then
    /// the condition will trigger if the comparison
    /// is true for any of the time series that have
    /// been identified by filter and aggregations,
    /// or by the ratio, if denominator_filter and
    /// denominator_aggregations are specified.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<AlertPolicyStatusAtProviderConditionsConditionThresholdTrigger>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionThresholdAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionThresholdDenominatorAggregations {
    /// The alignment period for per-time
    /// series alignment. If present,
    /// alignmentPeriod must be at least
    /// 60 seconds. After per-time series
    /// alignment, each time series will
    /// contain data points only on the
    /// period boundaries. If
    /// perSeriesAligner is not specified
    /// or equals ALIGN_NONE, then this
    /// field is ignored. If
    /// perSeriesAligner is specified and
    /// does not equal ALIGN_NONE, then
    /// this field must be defined;
    /// otherwise an error is returned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "alignmentPeriod"
    )]
    #[builder(default)]
    pub alignment_period: Option<String>,
    /// The approach to be used to combine
    /// time series. Not all reducer
    /// functions may be applied to all
    /// time series, depending on the
    /// metric type and the value type of
    /// the original time series.
    /// Reduction may change the metric
    /// type of value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "crossSeriesReducer"
    )]
    #[builder(default)]
    pub cross_series_reducer: Option<String>,
    /// The set of fields to preserve when
    /// crossSeriesReducer is specified.
    /// The groupByFields determine how
    /// the time series are partitioned
    /// into subsets prior to applying the
    /// aggregation function. Each subset
    /// contains time series that have the
    /// same value for each of the
    /// grouping fields. Each individual
    /// time series is a member of exactly
    /// one subset. The crossSeriesReducer
    /// is applied to each subset of time
    /// series. It is not possible to
    /// reduce across different resource
    /// types, so this field implicitly
    /// contains resource.type. Fields not
    /// specified in groupByFields are
    /// aggregated away. If groupByFields
    /// is not specified and all the time
    /// series have the same resource
    /// type, then the time series are
    /// aggregated into a single output
    /// time series. If crossSeriesReducer
    /// is not defined, this field is
    /// ignored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "groupByFields"
    )]
    #[builder(default)]
    pub group_by_fields: Option<Vec<String>>,
    /// The approach to be used to align
    /// individual time series. Not all
    /// alignment functions may be applied
    /// to all time series, depending on
    /// the metric type and value type of
    /// the original time series.
    /// Alignment may change the metric
    /// type or the value type of the time
    /// series.Time series data must be
    /// aligned in order to perform cross-
    /// time series reduction. If
    /// crossSeriesReducer is specified,
    /// then perSeriesAligner must be
    /// specified and not equal ALIGN_NONE
    /// and alignmentPeriod must be
    /// specified; otherwise, an error is
    /// returned.
    /// Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "perSeriesAligner"
    )]
    #[builder(default)]
    pub per_series_aligner: Option<String>,
}

/// When this field is present, the MetricThreshold
/// condition forecasts whether the time series is
/// predicted to violate the threshold within the
/// forecastHorizon. When this field is not set, the
/// MetricThreshold tests the current value of the
/// timeseries against the threshold.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionThresholdForecastOptions {
    /// The length of time into the future to forecast
    /// whether a timeseries will violate the threshold.
    /// If the predicted value is found to violate the
    /// threshold, and the violation is observed in all
    /// forecasts made for the Configured duration,
    /// then the timeseries is considered to be failing.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "forecastHorizon"
    )]
    #[builder(default)]
    pub forecast_horizon: Option<String>,
}

/// The number/percent of time series for which
/// the comparison must hold in order for the
/// condition to trigger. If unspecified, then
/// the condition will trigger if the comparison
/// is true for any of the time series that have
/// been identified by filter and aggregations,
/// or by the ratio, if denominator_filter and
/// denominator_aggregations are specified.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderConditionsConditionThresholdTrigger {
    /// The absolute number of time series
    /// that must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The percentage of time series that
    /// must fail the predicate for the
    /// condition to be triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percent: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderCreationRecord {
    /// (Output)
    /// When the change occurred.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mutateTime"
    )]
    #[builder(default)]
    pub mutate_time: Option<String>,
    /// (Output)
    /// The email address of the user making the change.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mutatedBy")]
    #[builder(default)]
    pub mutated_by: Option<String>,
}

/// Documentation that is included with notifications and incidents related
/// to this policy. Best practice is for the documentation to include information
/// to help responders understand, mitigate, escalate, and correct the underlying
/// problems detected by the alerting policy. Notification channels that have
/// limited capacity might not show this documentation.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderDocumentation {
    /// The text of the documentation, interpreted according to mimeType.
    /// The content may not exceed 8,192 Unicode characters and may not
    /// exceed more than 10,240 bytes when encoded in UTF-8 format,
    /// whichever is smaller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<String>,
    /// Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub links: Option<Vec<AlertPolicyStatusAtProviderDocumentationLinks>>,
    /// The format of the content field. Presently, only the value
    /// "text/markdown" is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mimeType")]
    #[builder(default)]
    pub mime_type: Option<String>,
    /// The subject line of the notification. The subject line may not
    /// exceed 10,240 bytes. In notifications generated by this policy the contents
    /// of the subject line after variable expansion will be truncated to 255 bytes
    /// or shorter at the latest UTF-8 character boundary.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subject: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct AlertPolicyStatusAtProviderDocumentationLinks {
    /// A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "displayName"
    )]
    #[builder(default)]
    pub display_name: Option<String>,
    /// The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
}
