// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// S3EndpointSpec defines the desired state of S3Endpoint
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "dms.aws.upbound.io", version = "v1beta1", kind = "S3Endpoint", plural = "s3endpoints")]
#[kube(status = "S3EndpointStatus")]
pub struct S3EndpointSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<S3EndpointDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: S3EndpointForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<S3EndpointInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<S3EndpointProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<S3EndpointPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<S3EndpointWriteConnectionSecretToRef>,
}

/// S3EndpointSpec defines the desired state of S3Endpoint
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProvider {
    /// Whether to add column name information to the .csv output file. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addColumnName")]
    #[builder(default)]
    pub add_column_name: Option<bool>,
    /// Whether to add padding. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addTrailingPaddingCharacter")]
    #[builder(default)]
    pub add_trailing_padding_character: Option<bool>,
    /// S3 object prefix.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketFolder")]
    #[builder(default)]
    pub bucket_folder: Option<String>,
    /// S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// Predefined (canned) access control list for objects created in an S3 bucket. Valid values include none, private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Default is none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAclForObjects")]
    #[builder(default)]
    pub canned_acl_for_objects: Option<String>,
    /// Whether to write insert and update operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsAndUpdates")]
    #[builder(default)]
    pub cdc_inserts_and_updates: Option<bool>,
    /// Whether to write insert operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsOnly")]
    #[builder(default)]
    pub cdc_inserts_only: Option<bool>,
    /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. (AWS default is 60.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMaxBatchInterval")]
    #[builder(default)]
    pub cdc_max_batch_interval: Option<f64>,
    /// Minimum file size condition as defined in kilobytes to output a file to Amazon S3. (AWS default is 32000 KB.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMinFileSize")]
    #[builder(default)]
    pub cdc_min_file_size: Option<f64>,
    /// Folder path of CDC files. If cdc_path is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcPath")]
    #[builder(default)]
    pub cdc_path: Option<String>,
    /// ARN for the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateArn")]
    #[builder(default)]
    pub certificate_arn: Option<String>,
    /// Set to compress target files. Valid values are GZIP and NONE. Default is NONE. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionType")]
    #[builder(default)]
    pub compression_type: Option<String>,
    /// Delimiter used to separate columns in the source files. Default is ,.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvDelimiter")]
    #[builder(default)]
    pub csv_delimiter: Option<String>,
    /// Only applies if output files for a CDC load are written in .csv format. If use_csv_no_sup_value is set to true, string to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of use_csv_no_sup_value. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNoSupValue")]
    #[builder(default)]
    pub csv_no_sup_value: Option<String>,
    /// String to as null when writing to the target. (AWS default is NULL.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNullValue")]
    #[builder(default)]
    pub csv_null_value: Option<String>,
    /// Delimiter used to separate rows in the source files. Default is newline (i.e., \n).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvRowDelimiter")]
    #[builder(default)]
    pub csv_row_delimiter: Option<String>,
    /// Output format for the files that AWS DMS uses to create S3 objects. Valid values are csv and parquet.  (Ignored for source endpoints -- only csv is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataFormat")]
    #[builder(default)]
    pub data_format: Option<String>,
    /// Size of one data page in bytes. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPageSize")]
    #[builder(default)]
    pub data_page_size: Option<f64>,
    /// Date separating delimiter to use during folder partitioning. Valid values are SLASH, UNDERSCORE, DASH, and NONE. (AWS default is SLASH.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionDelimiter")]
    #[builder(default)]
    pub date_partition_delimiter: Option<String>,
    /// Partition S3 bucket folders based on transaction commit dates. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionEnabled")]
    #[builder(default)]
    pub date_partition_enabled: Option<bool>,
    /// Date format to use during folder partitioning. Use this parameter when date_partition_enabled is set to true. Valid values are YYYYMMDD, YYYYMMDDHH, YYYYMM, MMYYYYDD, and DDMMYYYY. (AWS default is YYYYMMDD.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionSequence")]
    #[builder(default)]
    pub date_partition_sequence: Option<String>,
    /// Convert the current UTC time to a timezone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The timezone format is Area/Location (e.g., Europe/Paris). Use this when date_partition_enabled is true. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionTimezone")]
    #[builder(default)]
    pub date_partition_timezone: Option<String>,
    /// Undocumented argument for use as directed by AWS Support.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detachTargetOnLobLookupFailureParquet")]
    #[builder(default)]
    pub detach_target_on_lob_lookup_failure_parquet: Option<bool>,
    /// Maximum size in bytes of an encoded dictionary page of a column. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dictPageSizeLimit")]
    #[builder(default)]
    pub dict_page_size_limit: Option<f64>,
    /// Whether to enable statistics for Parquet pages and row groups. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableStatistics")]
    #[builder(default)]
    pub enable_statistics: Option<bool>,
    /// Type of encoding to use. Value values are rle_dictionary, plain, and plain_dictionary. (AWS default is rle_dictionary.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encodingType")]
    #[builder(default)]
    pub encoding_type: Option<String>,
    /// Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are SSE_S3 and SSE_KMS. (AWS default is SSE_S3.) (Ignored for source endpoints -- only SSE_S3 is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionMode")]
    #[builder(default)]
    pub encryption_mode: Option<String>,
    /// Type of endpoint. Valid values are source, target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointType")]
    #[builder(default)]
    pub endpoint_type: Option<String>,
    /// Bucket owner to prevent sniping. Value is an AWS account ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedBucketOwner")]
    #[builder(default)]
    pub expected_bucket_owner: Option<String>,
    /// JSON document that describes how AWS DMS should interpret the data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTableDefinition")]
    #[builder(default)]
    pub external_table_definition: Option<String>,
    /// Whether to integrate AWS Glue Data Catalog with an Amazon S3 target. See Using AWS Glue Data Catalog with an Amazon S3 target for AWS DMS for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "glueCatalogGeneration")]
    #[builder(default)]
    pub glue_catalog_generation: Option<bool>,
    /// When this value is set to 1, DMS ignores the first row header in a .csv file. (AWS default is 0.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreHeaderRows")]
    #[builder(default)]
    pub ignore_header_rows: Option<f64>,
    /// Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeOpForFullLoad")]
    #[builder(default)]
    pub include_op_for_full_load: Option<bool>,
    /// ARN for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default)]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArnRef")]
    #[builder(default)]
    pub kms_key_arn_ref: Option<S3EndpointForProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArnSelector")]
    #[builder(default)]
    pub kms_key_arn_selector: Option<S3EndpointForProviderKmsKeyArnSelector>,
    /// Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from 1 to 1048576. (AWS default is 1 GB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFileSize")]
    #[builder(default)]
    pub max_file_size: Option<f64>,
    /// - Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetTimestampInMillisecond")]
    #[builder(default)]
    pub parquet_timestamp_in_millisecond: Option<bool>,
    /// Version of the .parquet file format. Valid values are parquet-1-0 and parquet-2-0. (AWS default is parquet-1-0.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetVersion")]
    #[builder(default)]
    pub parquet_version: Option<String>,
    /// Whether DMS saves the transaction order for a CDC load on the S3 target specified by cdc_path. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveTransactions")]
    #[builder(default)]
    pub preserve_transactions: Option<bool>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rfc4180: Option<bool>,
    /// Number of rows in a row group. (AWS default is 10000.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowGroupLength")]
    #[builder(default)]
    pub row_group_length: Option<f64>,
    /// When encryption_mode is SSE_KMS, ARN for the AWS KMS key. (Ignored for source endpoints -- only SSE_S3 encryption_mode is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyId")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyIdRef")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id_ref: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdRef>,
    /// Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyIdSelector")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id_selector: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdSelector>,
    /// ARN of the IAM role with permissions to the S3 Bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArn")]
    #[builder(default)]
    pub service_access_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceAccessRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArnRef")]
    #[builder(default)]
    pub service_access_role_arn_ref: Option<S3EndpointForProviderServiceAccessRoleArnRef>,
    /// Selector for a Role in iam to populate serviceAccessRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArnSelector")]
    #[builder(default)]
    pub service_access_role_arn_selector: Option<S3EndpointForProviderServiceAccessRoleArnSelector>,
    /// SSL mode to use for the connection. Valid values are none, require, verify-ca, verify-full. (AWS default is none.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslMode")]
    #[builder(default)]
    pub ssl_mode: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Column to add with timestamp information to the endpoint data for an Amazon S3 target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampColumnName")]
    #[builder(default)]
    pub timestamp_column_name: Option<String>,
    /// Whether to use csv_no_sup_value for columns not included in the supplemental log. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useCsvNoSupValue")]
    #[builder(default)]
    pub use_csv_no_sup_value: Option<bool>,
    /// When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time.When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTaskStartTimeForFullLoadTimestamp")]
    #[builder(default)]
    pub use_task_start_time_for_full_load_timestamp: Option<bool>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServerSideEncryptionKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServerSideEncryptionKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServerSideEncryptionKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceAccessRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServiceAccessRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderServiceAccessRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServiceAccessRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderServiceAccessRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderServiceAccessRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServiceAccessRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServiceAccessRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceAccessRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServiceAccessRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointForProviderServiceAccessRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointForProviderServiceAccessRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointForProviderServiceAccessRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointForProviderServiceAccessRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServiceAccessRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointForProviderServiceAccessRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProvider {
    /// Whether to add column name information to the .csv output file. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addColumnName")]
    #[builder(default)]
    pub add_column_name: Option<bool>,
    /// Whether to add padding. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addTrailingPaddingCharacter")]
    #[builder(default)]
    pub add_trailing_padding_character: Option<bool>,
    /// S3 object prefix.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketFolder")]
    #[builder(default)]
    pub bucket_folder: Option<String>,
    /// S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// Predefined (canned) access control list for objects created in an S3 bucket. Valid values include none, private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Default is none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAclForObjects")]
    #[builder(default)]
    pub canned_acl_for_objects: Option<String>,
    /// Whether to write insert and update operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsAndUpdates")]
    #[builder(default)]
    pub cdc_inserts_and_updates: Option<bool>,
    /// Whether to write insert operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsOnly")]
    #[builder(default)]
    pub cdc_inserts_only: Option<bool>,
    /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. (AWS default is 60.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMaxBatchInterval")]
    #[builder(default)]
    pub cdc_max_batch_interval: Option<f64>,
    /// Minimum file size condition as defined in kilobytes to output a file to Amazon S3. (AWS default is 32000 KB.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMinFileSize")]
    #[builder(default)]
    pub cdc_min_file_size: Option<f64>,
    /// Folder path of CDC files. If cdc_path is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcPath")]
    #[builder(default)]
    pub cdc_path: Option<String>,
    /// ARN for the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateArn")]
    #[builder(default)]
    pub certificate_arn: Option<String>,
    /// Set to compress target files. Valid values are GZIP and NONE. Default is NONE. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionType")]
    #[builder(default)]
    pub compression_type: Option<String>,
    /// Delimiter used to separate columns in the source files. Default is ,.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvDelimiter")]
    #[builder(default)]
    pub csv_delimiter: Option<String>,
    /// Only applies if output files for a CDC load are written in .csv format. If use_csv_no_sup_value is set to true, string to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of use_csv_no_sup_value. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNoSupValue")]
    #[builder(default)]
    pub csv_no_sup_value: Option<String>,
    /// String to as null when writing to the target. (AWS default is NULL.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNullValue")]
    #[builder(default)]
    pub csv_null_value: Option<String>,
    /// Delimiter used to separate rows in the source files. Default is newline (i.e., \n).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvRowDelimiter")]
    #[builder(default)]
    pub csv_row_delimiter: Option<String>,
    /// Output format for the files that AWS DMS uses to create S3 objects. Valid values are csv and parquet.  (Ignored for source endpoints -- only csv is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataFormat")]
    #[builder(default)]
    pub data_format: Option<String>,
    /// Size of one data page in bytes. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPageSize")]
    #[builder(default)]
    pub data_page_size: Option<f64>,
    /// Date separating delimiter to use during folder partitioning. Valid values are SLASH, UNDERSCORE, DASH, and NONE. (AWS default is SLASH.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionDelimiter")]
    #[builder(default)]
    pub date_partition_delimiter: Option<String>,
    /// Partition S3 bucket folders based on transaction commit dates. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionEnabled")]
    #[builder(default)]
    pub date_partition_enabled: Option<bool>,
    /// Date format to use during folder partitioning. Use this parameter when date_partition_enabled is set to true. Valid values are YYYYMMDD, YYYYMMDDHH, YYYYMM, MMYYYYDD, and DDMMYYYY. (AWS default is YYYYMMDD.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionSequence")]
    #[builder(default)]
    pub date_partition_sequence: Option<String>,
    /// Convert the current UTC time to a timezone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The timezone format is Area/Location (e.g., Europe/Paris). Use this when date_partition_enabled is true. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionTimezone")]
    #[builder(default)]
    pub date_partition_timezone: Option<String>,
    /// Undocumented argument for use as directed by AWS Support.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detachTargetOnLobLookupFailureParquet")]
    #[builder(default)]
    pub detach_target_on_lob_lookup_failure_parquet: Option<bool>,
    /// Maximum size in bytes of an encoded dictionary page of a column. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dictPageSizeLimit")]
    #[builder(default)]
    pub dict_page_size_limit: Option<f64>,
    /// Whether to enable statistics for Parquet pages and row groups. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableStatistics")]
    #[builder(default)]
    pub enable_statistics: Option<bool>,
    /// Type of encoding to use. Value values are rle_dictionary, plain, and plain_dictionary. (AWS default is rle_dictionary.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encodingType")]
    #[builder(default)]
    pub encoding_type: Option<String>,
    /// Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are SSE_S3 and SSE_KMS. (AWS default is SSE_S3.) (Ignored for source endpoints -- only SSE_S3 is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionMode")]
    #[builder(default)]
    pub encryption_mode: Option<String>,
    /// Type of endpoint. Valid values are source, target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointType")]
    #[builder(default)]
    pub endpoint_type: Option<String>,
    /// Bucket owner to prevent sniping. Value is an AWS account ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedBucketOwner")]
    #[builder(default)]
    pub expected_bucket_owner: Option<String>,
    /// JSON document that describes how AWS DMS should interpret the data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTableDefinition")]
    #[builder(default)]
    pub external_table_definition: Option<String>,
    /// Whether to integrate AWS Glue Data Catalog with an Amazon S3 target. See Using AWS Glue Data Catalog with an Amazon S3 target for AWS DMS for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "glueCatalogGeneration")]
    #[builder(default)]
    pub glue_catalog_generation: Option<bool>,
    /// When this value is set to 1, DMS ignores the first row header in a .csv file. (AWS default is 0.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreHeaderRows")]
    #[builder(default)]
    pub ignore_header_rows: Option<f64>,
    /// Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeOpForFullLoad")]
    #[builder(default)]
    pub include_op_for_full_load: Option<bool>,
    /// ARN for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default)]
    pub kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArnRef")]
    #[builder(default)]
    pub kms_key_arn_ref: Option<S3EndpointInitProviderKmsKeyArnRef>,
    /// Selector for a Key in kms to populate kmsKeyArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArnSelector")]
    #[builder(default)]
    pub kms_key_arn_selector: Option<S3EndpointInitProviderKmsKeyArnSelector>,
    /// Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from 1 to 1048576. (AWS default is 1 GB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFileSize")]
    #[builder(default)]
    pub max_file_size: Option<f64>,
    /// - Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetTimestampInMillisecond")]
    #[builder(default)]
    pub parquet_timestamp_in_millisecond: Option<bool>,
    /// Version of the .parquet file format. Valid values are parquet-1-0 and parquet-2-0. (AWS default is parquet-1-0.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetVersion")]
    #[builder(default)]
    pub parquet_version: Option<String>,
    /// Whether DMS saves the transaction order for a CDC load on the S3 target specified by cdc_path. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveTransactions")]
    #[builder(default)]
    pub preserve_transactions: Option<bool>,
    /// For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rfc4180: Option<bool>,
    /// Number of rows in a row group. (AWS default is 10000.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowGroupLength")]
    #[builder(default)]
    pub row_group_length: Option<f64>,
    /// When encryption_mode is SSE_KMS, ARN for the AWS KMS key. (Ignored for source endpoints -- only SSE_S3 encryption_mode is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyId")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyIdRef")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id_ref: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdRef>,
    /// Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyIdSelector")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id_selector: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelector>,
    /// ARN of the IAM role with permissions to the S3 Bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArn")]
    #[builder(default)]
    pub service_access_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceAccessRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArnRef")]
    #[builder(default)]
    pub service_access_role_arn_ref: Option<S3EndpointInitProviderServiceAccessRoleArnRef>,
    /// Selector for a Role in iam to populate serviceAccessRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArnSelector")]
    #[builder(default)]
    pub service_access_role_arn_selector: Option<S3EndpointInitProviderServiceAccessRoleArnSelector>,
    /// SSL mode to use for the connection. Valid values are none, require, verify-ca, verify-full. (AWS default is none.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslMode")]
    #[builder(default)]
    pub ssl_mode: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Column to add with timestamp information to the endpoint data for an Amazon S3 target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampColumnName")]
    #[builder(default)]
    pub timestamp_column_name: Option<String>,
    /// Whether to use csv_no_sup_value for columns not included in the supplemental log. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useCsvNoSupValue")]
    #[builder(default)]
    pub use_csv_no_sup_value: Option<bool>,
    /// When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time.When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTaskStartTimeForFullLoadTimestamp")]
    #[builder(default)]
    pub use_task_start_time_for_full_load_timestamp: Option<bool>,
}

/// Reference to a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServerSideEncryptionKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServerSideEncryptionKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate serviceAccessRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServiceAccessRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderServiceAccessRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServiceAccessRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderServiceAccessRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderServiceAccessRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServiceAccessRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServiceAccessRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceAccessRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServiceAccessRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointInitProviderServiceAccessRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointInitProviderServiceAccessRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointInitProviderServiceAccessRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointInitProviderServiceAccessRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServiceAccessRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointInitProviderServiceAccessRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<S3EndpointPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<S3EndpointPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<S3EndpointPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<S3EndpointPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<S3EndpointPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum S3EndpointPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// S3EndpointStatus defines the observed state of S3Endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<S3EndpointStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct S3EndpointStatusAtProvider {
    /// Whether to add column name information to the .csv output file. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addColumnName")]
    #[builder(default)]
    pub add_column_name: Option<bool>,
    /// Whether to add padding. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addTrailingPaddingCharacter")]
    #[builder(default)]
    pub add_trailing_padding_character: Option<bool>,
    /// S3 object prefix.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketFolder")]
    #[builder(default)]
    pub bucket_folder: Option<String>,
    /// S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    #[builder(default)]
    pub bucket_name: Option<String>,
    /// Predefined (canned) access control list for objects created in an S3 bucket. Valid values include none, private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Default is none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cannedAclForObjects")]
    #[builder(default)]
    pub canned_acl_for_objects: Option<String>,
    /// Whether to write insert and update operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsAndUpdates")]
    #[builder(default)]
    pub cdc_inserts_and_updates: Option<bool>,
    /// Whether to write insert operations to .csv or .parquet output files. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcInsertsOnly")]
    #[builder(default)]
    pub cdc_inserts_only: Option<bool>,
    /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. (AWS default is 60.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMaxBatchInterval")]
    #[builder(default)]
    pub cdc_max_batch_interval: Option<f64>,
    /// Minimum file size condition as defined in kilobytes to output a file to Amazon S3. (AWS default is 32000 KB.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcMinFileSize")]
    #[builder(default)]
    pub cdc_min_file_size: Option<f64>,
    /// Folder path of CDC files. If cdc_path is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cdcPath")]
    #[builder(default)]
    pub cdc_path: Option<String>,
    /// ARN for the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateArn")]
    #[builder(default)]
    pub certificate_arn: Option<String>,
    /// Set to compress target files. Valid values are GZIP and NONE. Default is NONE. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionType")]
    #[builder(default)]
    pub compression_type: Option<String>,
    /// Delimiter used to separate columns in the source files. Default is ,.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvDelimiter")]
    #[builder(default)]
    pub csv_delimiter: Option<String>,
    /// Only applies if output files for a CDC load are written in .csv format. If use_csv_no_sup_value is set to true, string to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of use_csv_no_sup_value. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNoSupValue")]
    #[builder(default)]
    pub csv_no_sup_value: Option<String>,
    /// String to as null when writing to the target. (AWS default is NULL.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvNullValue")]
    #[builder(default)]
    pub csv_null_value: Option<String>,
    /// Delimiter used to separate rows in the source files. Default is newline (i.e., \n).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "csvRowDelimiter")]
    #[builder(default)]
    pub csv_row_delimiter: Option<String>,
    /// Output format for the files that AWS DMS uses to create S3 objects. Valid values are csv and parquet.  (Ignored for source endpoints -- only csv is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataFormat")]
    #[builder(default)]
    pub data_format: Option<String>,
    /// Size of one data page in bytes. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPageSize")]
    #[builder(default)]
    pub data_page_size: Option<f64>,
    /// Date separating delimiter to use during folder partitioning. Valid values are SLASH, UNDERSCORE, DASH, and NONE. (AWS default is SLASH.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionDelimiter")]
    #[builder(default)]
    pub date_partition_delimiter: Option<String>,
    /// Partition S3 bucket folders based on transaction commit dates. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionEnabled")]
    #[builder(default)]
    pub date_partition_enabled: Option<bool>,
    /// Date format to use during folder partitioning. Use this parameter when date_partition_enabled is set to true. Valid values are YYYYMMDD, YYYYMMDDHH, YYYYMM, MMYYYYDD, and DDMMYYYY. (AWS default is YYYYMMDD.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionSequence")]
    #[builder(default)]
    pub date_partition_sequence: Option<String>,
    /// Convert the current UTC time to a timezone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The timezone format is Area/Location (e.g., Europe/Paris). Use this when date_partition_enabled is true. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datePartitionTimezone")]
    #[builder(default)]
    pub date_partition_timezone: Option<String>,
    /// Undocumented argument for use as directed by AWS Support.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detachTargetOnLobLookupFailureParquet")]
    #[builder(default)]
    pub detach_target_on_lob_lookup_failure_parquet: Option<bool>,
    /// Maximum size in bytes of an encoded dictionary page of a column. (AWS default is 1 MiB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dictPageSizeLimit")]
    #[builder(default)]
    pub dict_page_size_limit: Option<f64>,
    /// Whether to enable statistics for Parquet pages and row groups. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableStatistics")]
    #[builder(default)]
    pub enable_statistics: Option<bool>,
    /// Type of encoding to use. Value values are rle_dictionary, plain, and plain_dictionary. (AWS default is rle_dictionary.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encodingType")]
    #[builder(default)]
    pub encoding_type: Option<String>,
    /// Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are SSE_S3 and SSE_KMS. (AWS default is SSE_S3.) (Ignored for source endpoints -- only SSE_S3 is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionMode")]
    #[builder(default)]
    pub encryption_mode: Option<String>,
    /// ARN for the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointArn")]
    #[builder(default)]
    pub endpoint_arn: Option<String>,
    /// Type of endpoint. Valid values are source, target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointType")]
    #[builder(default)]
    pub endpoint_type: Option<String>,
    /// Expanded name for the engine name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "engineDisplayName")]
    #[builder(default)]
    pub engine_display_name: Option<String>,
    /// Bucket owner to prevent sniping. Value is an AWS account ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedBucketOwner")]
    #[builder(default)]
    pub expected_bucket_owner: Option<String>,
    /// Can be used for cross-account validation. Use it in another account with aws_dms_s3_endpoint to create the endpoint cross-account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalId")]
    #[builder(default)]
    pub external_id: Option<String>,
    /// JSON document that describes how AWS DMS should interpret the data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTableDefinition")]
    #[builder(default)]
    pub external_table_definition: Option<String>,
    /// Whether to integrate AWS Glue Data Catalog with an Amazon S3 target. See Using AWS Glue Data Catalog with an Amazon S3 target for AWS DMS for more information. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "glueCatalogGeneration")]
    #[builder(default)]
    pub glue_catalog_generation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// When this value is set to 1, DMS ignores the first row header in a .csv file. (AWS default is 0.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreHeaderRows")]
    #[builder(default)]
    pub ignore_header_rows: Option<f64>,
    /// Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeOpForFullLoad")]
    #[builder(default)]
    pub include_op_for_full_load: Option<bool>,
    /// ARN for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyArn")]
    #[builder(default)]
    pub kms_key_arn: Option<String>,
    /// Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from 1 to 1048576. (AWS default is 1 GB, i.e., 1048576.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxFileSize")]
    #[builder(default)]
    pub max_file_size: Option<f64>,
    /// - Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetTimestampInMillisecond")]
    #[builder(default)]
    pub parquet_timestamp_in_millisecond: Option<bool>,
    /// Version of the .parquet file format. Valid values are parquet-1-0 and parquet-2-0. (AWS default is parquet-1-0.) (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parquetVersion")]
    #[builder(default)]
    pub parquet_version: Option<String>,
    /// Whether DMS saves the transaction order for a CDC load on the S3 target specified by cdc_path. Default is false. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveTransactions")]
    #[builder(default)]
    pub preserve_transactions: Option<bool>,
    /// For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rfc4180: Option<bool>,
    /// Number of rows in a row group. (AWS default is 10000.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowGroupLength")]
    #[builder(default)]
    pub row_group_length: Option<f64>,
    /// When encryption_mode is SSE_KMS, ARN for the AWS KMS key. (Ignored for source endpoints -- only SSE_S3 encryption_mode is valid.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverSideEncryptionKmsKeyId")]
    #[builder(default)]
    pub server_side_encryption_kms_key_id: Option<String>,
    /// ARN of the IAM role with permissions to the S3 Bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccessRoleArn")]
    #[builder(default)]
    pub service_access_role_arn: Option<String>,
    /// SSL mode to use for the connection. Valid values are none, require, verify-ca, verify-full. (AWS default is none.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslMode")]
    #[builder(default)]
    pub ssl_mode: Option<String>,
    /// Status of the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// Column to add with timestamp information to the endpoint data for an Amazon S3 target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampColumnName")]
    #[builder(default)]
    pub timestamp_column_name: Option<String>,
    /// Whether to use csv_no_sup_value for columns not included in the supplemental log. (Ignored for source endpoints.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useCsvNoSupValue")]
    #[builder(default)]
    pub use_csv_no_sup_value: Option<bool>,
    /// When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time.When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTaskStartTimeForFullLoadTimestamp")]
    #[builder(default)]
    pub use_task_start_time_for_full_load_timestamp: Option<bool>,
}

