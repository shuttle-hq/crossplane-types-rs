// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RecordSpec defines the desired state of Record
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "route53.aws.upbound.io", version = "v1beta2", kind = "Record", plural = "records")]
#[kube(status = "RecordStatus")]
pub struct RecordSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<RecordDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: RecordForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<RecordInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<RecordProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<RecordPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<RecordWriteConnectionSecretToRef>,
}

/// RecordSpec defines the desired state of Record
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProvider {
    /// An alias block. Conflicts with ttl & records.
    /// Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub alias: Option<RecordForProviderAlias>,
    /// false by default. This configuration is not recommended for most environments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOverwrite")]
    #[builder(default)]
    pub allow_overwrite: Option<bool>,
    /// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrRoutingPolicy")]
    #[builder(default)]
    pub cidr_routing_policy: Option<RecordForProviderCidrRoutingPolicy>,
    /// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverRoutingPolicy")]
    #[builder(default)]
    pub failover_routing_policy: Option<RecordForProviderFailoverRoutingPolicy>,
    /// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geolocationRoutingPolicy")]
    #[builder(default)]
    pub geolocation_routing_policy: Option<RecordForProviderGeolocationRoutingPolicy>,
    /// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoproximityRoutingPolicy")]
    #[builder(default)]
    pub geoproximity_routing_policy: Option<RecordForProviderGeoproximityRoutingPolicy>,
    /// The health check the record should be associated with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckId")]
    #[builder(default)]
    pub health_check_id: Option<String>,
    /// Reference to a HealthCheck in route53 to populate healthCheckId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIdRef")]
    #[builder(default)]
    pub health_check_id_ref: Option<RecordForProviderHealthCheckIdRef>,
    /// Selector for a HealthCheck in route53 to populate healthCheckId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIdSelector")]
    #[builder(default)]
    pub health_check_id_selector: Option<RecordForProviderHealthCheckIdSelector>,
    /// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latencyRoutingPolicy")]
    #[builder(default)]
    pub latency_routing_policy: Option<RecordForProviderLatencyRoutingPolicy>,
    /// Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multivalueAnswerRoutingPolicy")]
    #[builder(default)]
    pub multivalue_answer_routing_policy: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A string list of records.g., "first255characters\"\"morecharacters").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub records: Option<Vec<String>>,
    /// References to EIP in ec2 to populate records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordsRefs")]
    #[builder(default)]
    pub records_refs: Option<Vec<RecordForProviderRecordsRefs>>,
    /// Selector for a list of EIP in ec2 to populate records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordsSelector")]
    #[builder(default)]
    pub records_selector: Option<RecordForProviderRecordsSelector>,
    /// An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    #[builder(default)]
    pub set_identifier: Option<String>,
    /// The TTL of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ttl: Option<f64>,
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedRoutingPolicy")]
    #[builder(default)]
    pub weighted_routing_policy: Option<RecordForProviderWeightedRoutingPolicy>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
    /// Reference to a Zone in route53 to populate zoneId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneIdRef")]
    #[builder(default)]
    pub zone_id_ref: Option<RecordForProviderZoneIdRef>,
    /// Selector for a Zone in route53 to populate zoneId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneIdSelector")]
    #[builder(default)]
    pub zone_id_selector: Option<RecordForProviderZoneIdSelector>,
}

/// An alias block. Conflicts with ttl & records.
/// Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderAlias {
    /// Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluateTargetHealth")]
    #[builder(default)]
    pub evaluate_target_health: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
}

/// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderCidrRoutingPolicy {
    /// The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collectionId")]
    #[builder(default)]
    pub collection_id: Option<String>,
    /// The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationName")]
    #[builder(default)]
    pub location_name: Option<String>,
}

/// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderFailoverRoutingPolicy {
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderGeolocationRoutingPolicy {
    /// A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub continent: Option<String>,
    /// A two-character country code or * to indicate a default resource record set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub country: Option<String>,
    /// A subdivision code for a country.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subdivision: Option<String>,
}

/// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderGeoproximityRoutingPolicy {
    /// A AWS region where the resource is present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRegion")]
    #[builder(default)]
    pub aws_region: Option<String>,
    /// Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bias: Option<f64>,
    /// Specify latitude and longitude for routing traffic to non-AWS resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub coordinates: Option<Vec<RecordForProviderGeoproximityRoutingPolicyCoordinates>>,
    /// A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localZoneGroup")]
    #[builder(default)]
    pub local_zone_group: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderGeoproximityRoutingPolicyCoordinates {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub latitude: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub longitude: Option<String>,
}

/// Reference to a HealthCheck in route53 to populate healthCheckId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderHealthCheckIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderHealthCheckIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderHealthCheckIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderHealthCheckIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderHealthCheckIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderHealthCheckIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderHealthCheckIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in route53 to populate healthCheckId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderHealthCheckIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderHealthCheckIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderHealthCheckIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderHealthCheckIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderHealthCheckIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderHealthCheckIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderHealthCheckIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderLatencyRoutingPolicy {
    /// An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
    pub region: String,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderRecordsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderRecordsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderRecordsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderRecordsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderRecordsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderRecordsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderRecordsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of EIP in ec2 to populate records.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderRecordsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderRecordsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderRecordsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderRecordsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderRecordsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderRecordsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderRecordsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderWeightedRoutingPolicy {
    /// A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a Zone in route53 to populate zoneId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderZoneIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderZoneIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderZoneIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderZoneIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderZoneIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderZoneIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderZoneIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Zone in route53 to populate zoneId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderZoneIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordForProviderZoneIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordForProviderZoneIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordForProviderZoneIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordForProviderZoneIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderZoneIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordForProviderZoneIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProvider {
    /// An alias block. Conflicts with ttl & records.
    /// Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub alias: Option<RecordInitProviderAlias>,
    /// false by default. This configuration is not recommended for most environments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOverwrite")]
    #[builder(default)]
    pub allow_overwrite: Option<bool>,
    /// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrRoutingPolicy")]
    #[builder(default)]
    pub cidr_routing_policy: Option<RecordInitProviderCidrRoutingPolicy>,
    /// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverRoutingPolicy")]
    #[builder(default)]
    pub failover_routing_policy: Option<RecordInitProviderFailoverRoutingPolicy>,
    /// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geolocationRoutingPolicy")]
    #[builder(default)]
    pub geolocation_routing_policy: Option<RecordInitProviderGeolocationRoutingPolicy>,
    /// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoproximityRoutingPolicy")]
    #[builder(default)]
    pub geoproximity_routing_policy: Option<RecordInitProviderGeoproximityRoutingPolicy>,
    /// The health check the record should be associated with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckId")]
    #[builder(default)]
    pub health_check_id: Option<String>,
    /// Reference to a HealthCheck in route53 to populate healthCheckId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIdRef")]
    #[builder(default)]
    pub health_check_id_ref: Option<RecordInitProviderHealthCheckIdRef>,
    /// Selector for a HealthCheck in route53 to populate healthCheckId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIdSelector")]
    #[builder(default)]
    pub health_check_id_selector: Option<RecordInitProviderHealthCheckIdSelector>,
    /// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latencyRoutingPolicy")]
    #[builder(default)]
    pub latency_routing_policy: Option<RecordInitProviderLatencyRoutingPolicy>,
    /// Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multivalueAnswerRoutingPolicy")]
    #[builder(default)]
    pub multivalue_answer_routing_policy: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A string list of records.g., "first255characters\"\"morecharacters").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub records: Option<Vec<String>>,
    /// References to EIP in ec2 to populate records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordsRefs")]
    #[builder(default)]
    pub records_refs: Option<Vec<RecordInitProviderRecordsRefs>>,
    /// Selector for a list of EIP in ec2 to populate records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordsSelector")]
    #[builder(default)]
    pub records_selector: Option<RecordInitProviderRecordsSelector>,
    /// Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    #[builder(default)]
    pub set_identifier: Option<String>,
    /// The TTL of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ttl: Option<f64>,
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedRoutingPolicy")]
    #[builder(default)]
    pub weighted_routing_policy: Option<RecordInitProviderWeightedRoutingPolicy>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
    /// Reference to a Zone in route53 to populate zoneId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneIdRef")]
    #[builder(default)]
    pub zone_id_ref: Option<RecordInitProviderZoneIdRef>,
    /// Selector for a Zone in route53 to populate zoneId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneIdSelector")]
    #[builder(default)]
    pub zone_id_selector: Option<RecordInitProviderZoneIdSelector>,
}

/// An alias block. Conflicts with ttl & records.
/// Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderAlias {
    /// Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluateTargetHealth")]
    #[builder(default)]
    pub evaluate_target_health: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
}

/// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderCidrRoutingPolicy {
    /// The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collectionId")]
    #[builder(default)]
    pub collection_id: Option<String>,
    /// The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationName")]
    #[builder(default)]
    pub location_name: Option<String>,
}

/// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderFailoverRoutingPolicy {
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderGeolocationRoutingPolicy {
    /// A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub continent: Option<String>,
    /// A two-character country code or * to indicate a default resource record set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub country: Option<String>,
    /// A subdivision code for a country.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subdivision: Option<String>,
}

/// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderGeoproximityRoutingPolicy {
    /// A AWS region where the resource is present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRegion")]
    #[builder(default)]
    pub aws_region: Option<String>,
    /// Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bias: Option<f64>,
    /// Specify latitude and longitude for routing traffic to non-AWS resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub coordinates: Option<Vec<RecordInitProviderGeoproximityRoutingPolicyCoordinates>>,
    /// A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localZoneGroup")]
    #[builder(default)]
    pub local_zone_group: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderGeoproximityRoutingPolicyCoordinates {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub latitude: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub longitude: Option<String>,
}

/// Reference to a HealthCheck in route53 to populate healthCheckId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderHealthCheckIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderHealthCheckIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderHealthCheckIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderHealthCheckIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderHealthCheckIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderHealthCheckIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderHealthCheckIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a HealthCheck in route53 to populate healthCheckId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderHealthCheckIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderHealthCheckIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderHealthCheckIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderHealthCheckIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderHealthCheckIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderHealthCheckIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderHealthCheckIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderLatencyRoutingPolicy {
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderRecordsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderRecordsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderRecordsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderRecordsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderRecordsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderRecordsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderRecordsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of EIP in ec2 to populate records.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderRecordsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderRecordsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderRecordsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderRecordsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderRecordsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderRecordsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderRecordsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderWeightedRoutingPolicy {
    /// A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a Zone in route53 to populate zoneId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderZoneIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderZoneIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderZoneIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderZoneIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderZoneIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderZoneIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderZoneIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Zone in route53 to populate zoneId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderZoneIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordInitProviderZoneIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordInitProviderZoneIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordInitProviderZoneIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordInitProviderZoneIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderZoneIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordInitProviderZoneIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<RecordPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<RecordPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<RecordPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<RecordPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<RecordPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum RecordPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// RecordStatus defines the observed state of Record.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<RecordStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProvider {
    /// An alias block. Conflicts with ttl & records.
    /// Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub alias: Option<RecordStatusAtProviderAlias>,
    /// false by default. This configuration is not recommended for most environments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOverwrite")]
    #[builder(default)]
    pub allow_overwrite: Option<bool>,
    /// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrRoutingPolicy")]
    #[builder(default)]
    pub cidr_routing_policy: Option<RecordStatusAtProviderCidrRoutingPolicy>,
    /// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverRoutingPolicy")]
    #[builder(default)]
    pub failover_routing_policy: Option<RecordStatusAtProviderFailoverRoutingPolicy>,
    /// FQDN built using the zone domain and name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fqdn: Option<String>,
    /// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geolocationRoutingPolicy")]
    #[builder(default)]
    pub geolocation_routing_policy: Option<RecordStatusAtProviderGeolocationRoutingPolicy>,
    /// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "geoproximityRoutingPolicy")]
    #[builder(default)]
    pub geoproximity_routing_policy: Option<RecordStatusAtProviderGeoproximityRoutingPolicy>,
    /// The health check the record should be associated with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckId")]
    #[builder(default)]
    pub health_check_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latencyRoutingPolicy")]
    #[builder(default)]
    pub latency_routing_policy: Option<RecordStatusAtProviderLatencyRoutingPolicy>,
    /// Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multivalueAnswerRoutingPolicy")]
    #[builder(default)]
    pub multivalue_answer_routing_policy: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A string list of records.g., "first255characters\"\"morecharacters").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub records: Option<Vec<String>>,
    /// Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    #[builder(default)]
    pub set_identifier: Option<String>,
    /// The TTL of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ttl: Option<f64>,
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
    /// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedRoutingPolicy")]
    #[builder(default)]
    pub weighted_routing_policy: Option<RecordStatusAtProviderWeightedRoutingPolicy>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
}

/// An alias block. Conflicts with ttl & records.
/// Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderAlias {
    /// Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "evaluateTargetHealth")]
    #[builder(default)]
    pub evaluate_target_health: Option<bool>,
    /// The name of the record.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the hosted zone to contain this record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zoneId")]
    #[builder(default)]
    pub zone_id: Option<String>,
}

/// A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderCidrRoutingPolicy {
    /// The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collectionId")]
    #[builder(default)]
    pub collection_id: Option<String>,
    /// The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationName")]
    #[builder(default)]
    pub location_name: Option<String>,
}

/// A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderFailoverRoutingPolicy {
    /// The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderGeolocationRoutingPolicy {
    /// A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub continent: Option<String>,
    /// A two-character country code or * to indicate a default resource record set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub country: Option<String>,
    /// A subdivision code for a country.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subdivision: Option<String>,
}

/// A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderGeoproximityRoutingPolicy {
    /// A AWS region where the resource is present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRegion")]
    #[builder(default)]
    pub aws_region: Option<String>,
    /// Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bias: Option<f64>,
    /// Specify latitude and longitude for routing traffic to non-AWS resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub coordinates: Option<Vec<RecordStatusAtProviderGeoproximityRoutingPolicyCoordinates>>,
    /// A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localZoneGroup")]
    #[builder(default)]
    pub local_zone_group: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderGeoproximityRoutingPolicyCoordinates {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub latitude: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub longitude: Option<String>,
}

/// A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderLatencyRoutingPolicy {
    /// An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
}

/// A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct RecordStatusAtProviderWeightedRoutingPolicy {
    /// A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

