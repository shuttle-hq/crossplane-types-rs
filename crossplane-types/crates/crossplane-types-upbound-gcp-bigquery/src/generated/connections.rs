// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ConnectionSpec defines the desired state of Connection
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "bigquery.gcp.upbound.io",
    version = "v1beta2",
    kind = "Connection",
    plural = "connections"
)]
#[kube(status = "ConnectionStatus")]
pub struct ConnectionSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<ConnectionDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ConnectionForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<ConnectionInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<ConnectionProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<ConnectionPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<ConnectionWriteConnectionSecretToRef>,
}

/// ConnectionSpec defines the desired state of Connection
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProvider {
    /// Connection properties specific to Amazon Web Services.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aws: Option<ConnectionForProviderAws>,
    /// Container for connection properties specific to Azure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub azure: Option<ConnectionForProviderAzure>,
    /// Container for connection properties for delegation of access to GCP resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudResource"
    )]
    #[builder(default)]
    pub cloud_resource: Option<ConnectionForProviderCloudResource>,
    /// Connection properties specific to Cloud Spanner
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudSpanner"
    )]
    #[builder(default)]
    pub cloud_spanner: Option<ConnectionForProviderCloudSpanner>,
    /// Connection properties specific to the Cloud SQL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSql")]
    #[builder(default)]
    pub cloud_sql: Option<ConnectionForProviderCloudSql>,
    /// Optional connection id that should be assigned to the created connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default)]
    pub connection_id: Option<String>,
    /// A descriptive description for the connection
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// A descriptive name for the connection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "friendlyName"
    )]
    #[builder(default)]
    pub friendly_name: Option<String>,
    /// Optional. The Cloud KMS key that is used for encryption.
    /// Example: projects/[kms_project_id]/locations/[region]/keyRings/[key_region]/cryptoKeys/[key]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyName"
    )]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// The geographic location where the connection should reside.
    /// Cloud SQL instance must be in the same location as the connection
    /// with following exceptions: Cloud SQL us-central1 maps to BigQuery US, Cloud SQL europe-west1 maps to BigQuery EU.
    /// Examples: US, EU, asia-northeast1, us-central1, europe-west1.
    /// Spanner Connections same as spanner region
    /// AWS allowed regions are aws-us-east-1
    /// Azure allowed regions are azure-eastus2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Container for connection properties to execute stored procedures for Apache Spark. resources.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spark: Option<ConnectionForProviderSpark>,
}

/// Connection properties specific to Amazon Web Services.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderAws {
    /// Authentication using Google owned service account to assume into customer's AWS IAM Role.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessRole"
    )]
    #[builder(default)]
    pub access_role: Option<ConnectionForProviderAwsAccessRole>,
}

/// Authentication using Google owned service account to assume into customer's AWS IAM Role.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderAwsAccessRole {
    /// The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleId")]
    #[builder(default)]
    pub iam_role_id: Option<String>,
}

/// Container for connection properties specific to Azure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderAzure {
    /// The id of customer's directory that host the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerTenantId"
    )]
    #[builder(default)]
    pub customer_tenant_id: Option<String>,
    /// The Azure Application (client) ID where the federated credentials will be hosted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "federatedApplicationClientId"
    )]
    #[builder(default)]
    pub federated_application_client_id: Option<String>,
}

/// Container for connection properties for delegation of access to GCP resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudResource {}

/// Connection properties specific to Cloud Spanner
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSpanner {
    /// Cloud Spanner database in the form `project/instance/database'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as SELECT and INSERT. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRole"
    )]
    #[builder(default)]
    pub database_role: Option<String>,
    /// Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. useParallelism and useDataBoost must be set when setting max parallelism.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxParallelism"
    )]
    #[builder(default)]
    pub max_parallelism: Option<f64>,
    /// If set, the request will be executed via Spanner independent compute resources. use_parallelism must be set when using data boost.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useDataBoost"
    )]
    #[builder(default)]
    pub use_data_boost: Option<bool>,
    /// If parallelism should be used when reading from Cloud Spanner.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useParallelism"
    )]
    #[builder(default)]
    pub use_parallelism: Option<bool>,
    /// If the serverless analytics service should be used to read data from Cloud Spanner. useParallelism must be set when using serverless analytics.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useServerlessAnalytics"
    )]
    #[builder(default)]
    pub use_serverless_analytics: Option<bool>,
}

/// Connection properties specific to the Cloud SQL.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSql {
    /// Cloud SQL properties.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credential: Option<ConnectionForProviderCloudSqlCredential>,
    /// Database name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Reference to a Database in sql to populate database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRef"
    )]
    #[builder(default)]
    pub database_ref: Option<ConnectionForProviderCloudSqlDatabaseRef>,
    /// Selector for a Database in sql to populate database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseSelector"
    )]
    #[builder(default)]
    pub database_selector: Option<ConnectionForProviderCloudSqlDatabaseSelector>,
    /// Cloud SQL instance ID in the form project:location:instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceId"
    )]
    #[builder(default)]
    pub instance_id: Option<String>,
    /// Reference to a DatabaseInstance in sql to populate instanceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceIdRef"
    )]
    #[builder(default)]
    pub instance_id_ref: Option<ConnectionForProviderCloudSqlInstanceIdRef>,
    /// Selector for a DatabaseInstance in sql to populate instanceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceIdSelector"
    )]
    #[builder(default)]
    pub instance_id_selector: Option<ConnectionForProviderCloudSqlInstanceIdSelector>,
    /// Type of the Cloud SQL database.
    /// Possible values are: DATABASE_TYPE_UNSPECIFIED, POSTGRES, MYSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Cloud SQL properties.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredential {
    /// Password for database.
    /// Note: This property is sensitive and will not be displayed in the plan.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "passwordSecretRef"
    )]
    #[builder(default)]
    pub password_secret_ref: Option<ConnectionForProviderCloudSqlCredentialPasswordSecretRef>,
    /// Username for database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
    /// Reference to a User in sql to populate username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameRef"
    )]
    #[builder(default)]
    pub username_ref: Option<ConnectionForProviderCloudSqlCredentialUsernameRef>,
    /// Selector for a User in sql to populate username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameSelector"
    )]
    #[builder(default)]
    pub username_selector: Option<ConnectionForProviderCloudSqlCredentialUsernameSelector>,
}

/// Password for database.
/// Note: This property is sensitive and will not be displayed in the plan.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredentialPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a User in sql to populate username.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredentialUsernameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlCredentialUsernameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredentialUsernameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlCredentialUsernameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlCredentialUsernameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlCredentialUsernameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlCredentialUsernameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a User in sql to populate username.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredentialUsernameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlCredentialUsernameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Database in sql to populate database.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlDatabaseRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlDatabaseRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlDatabaseRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlDatabaseRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlDatabaseRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlDatabaseRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlDatabaseRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Database in sql to populate database.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlDatabaseSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlDatabaseSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlDatabaseSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlDatabaseSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlDatabaseSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlDatabaseSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlDatabaseSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a DatabaseInstance in sql to populate instanceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlInstanceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlInstanceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlInstanceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlInstanceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlInstanceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlInstanceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlInstanceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DatabaseInstance in sql to populate instanceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlInstanceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderCloudSqlInstanceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderCloudSqlInstanceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionForProviderCloudSqlInstanceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionForProviderCloudSqlInstanceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlInstanceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderCloudSqlInstanceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Container for connection properties to execute stored procedures for Apache Spark. resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSpark {
    /// Dataproc Metastore Service configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreServiceConfig"
    )]
    #[builder(default)]
    pub metastore_service_config: Option<ConnectionForProviderSparkMetastoreServiceConfig>,
    /// Spark History Server configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sparkHistoryServerConfig"
    )]
    #[builder(default)]
    pub spark_history_server_config: Option<ConnectionForProviderSparkSparkHistoryServerConfig>,
}

/// Dataproc Metastore Service configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkMetastoreServiceConfig {
    /// Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreService"
    )]
    #[builder(default)]
    pub metastore_service: Option<String>,
}

/// Spark History Server configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkSparkHistoryServerConfig {
    /// Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocCluster"
    )]
    #[builder(default)]
    pub dataproc_cluster: Option<String>,
    /// Reference to a Cluster in dataproc to populate dataprocCluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocClusterRef"
    )]
    #[builder(default)]
    pub dataproc_cluster_ref:
        Option<ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRef>,
    /// Selector for a Cluster in dataproc to populate dataprocCluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocClusterSelector"
    )]
    #[builder(default)]
    pub dataproc_cluster_selector:
        Option<ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelector>,
}

/// Reference to a Cluster in dataproc to populate dataprocCluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in dataproc to populate dataprocCluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<
        ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionForProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProvider {
    /// Connection properties specific to Amazon Web Services.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aws: Option<ConnectionInitProviderAws>,
    /// Container for connection properties specific to Azure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub azure: Option<ConnectionInitProviderAzure>,
    /// Container for connection properties for delegation of access to GCP resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudResource"
    )]
    #[builder(default)]
    pub cloud_resource: Option<ConnectionInitProviderCloudResource>,
    /// Connection properties specific to Cloud Spanner
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudSpanner"
    )]
    #[builder(default)]
    pub cloud_spanner: Option<ConnectionInitProviderCloudSpanner>,
    /// Connection properties specific to the Cloud SQL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSql")]
    #[builder(default)]
    pub cloud_sql: Option<ConnectionInitProviderCloudSql>,
    /// Optional connection id that should be assigned to the created connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default)]
    pub connection_id: Option<String>,
    /// A descriptive description for the connection
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// A descriptive name for the connection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "friendlyName"
    )]
    #[builder(default)]
    pub friendly_name: Option<String>,
    /// Optional. The Cloud KMS key that is used for encryption.
    /// Example: projects/[kms_project_id]/locations/[region]/keyRings/[key_region]/cryptoKeys/[key]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyName"
    )]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// The geographic location where the connection should reside.
    /// Cloud SQL instance must be in the same location as the connection
    /// with following exceptions: Cloud SQL us-central1 maps to BigQuery US, Cloud SQL europe-west1 maps to BigQuery EU.
    /// Examples: US, EU, asia-northeast1, us-central1, europe-west1.
    /// Spanner Connections same as spanner region
    /// AWS allowed regions are aws-us-east-1
    /// Azure allowed regions are azure-eastus2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Container for connection properties to execute stored procedures for Apache Spark. resources.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spark: Option<ConnectionInitProviderSpark>,
}

/// Connection properties specific to Amazon Web Services.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderAws {
    /// Authentication using Google owned service account to assume into customer's AWS IAM Role.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessRole"
    )]
    #[builder(default)]
    pub access_role: Option<ConnectionInitProviderAwsAccessRole>,
}

/// Authentication using Google owned service account to assume into customer's AWS IAM Role.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderAwsAccessRole {
    /// The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleId")]
    #[builder(default)]
    pub iam_role_id: Option<String>,
}

/// Container for connection properties specific to Azure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderAzure {
    /// The id of customer's directory that host the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerTenantId"
    )]
    #[builder(default)]
    pub customer_tenant_id: Option<String>,
    /// The Azure Application (client) ID where the federated credentials will be hosted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "federatedApplicationClientId"
    )]
    #[builder(default)]
    pub federated_application_client_id: Option<String>,
}

/// Container for connection properties for delegation of access to GCP resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudResource {}

/// Connection properties specific to Cloud Spanner
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSpanner {
    /// Cloud Spanner database in the form `project/instance/database'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as SELECT and INSERT. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRole"
    )]
    #[builder(default)]
    pub database_role: Option<String>,
    /// Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. useParallelism and useDataBoost must be set when setting max parallelism.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxParallelism"
    )]
    #[builder(default)]
    pub max_parallelism: Option<f64>,
    /// If set, the request will be executed via Spanner independent compute resources. use_parallelism must be set when using data boost.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useDataBoost"
    )]
    #[builder(default)]
    pub use_data_boost: Option<bool>,
    /// If parallelism should be used when reading from Cloud Spanner.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useParallelism"
    )]
    #[builder(default)]
    pub use_parallelism: Option<bool>,
    /// If the serverless analytics service should be used to read data from Cloud Spanner. useParallelism must be set when using serverless analytics.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useServerlessAnalytics"
    )]
    #[builder(default)]
    pub use_serverless_analytics: Option<bool>,
}

/// Connection properties specific to the Cloud SQL.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSql {
    /// Cloud SQL properties.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credential: Option<ConnectionInitProviderCloudSqlCredential>,
    /// Database name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Reference to a Database in sql to populate database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRef"
    )]
    #[builder(default)]
    pub database_ref: Option<ConnectionInitProviderCloudSqlDatabaseRef>,
    /// Selector for a Database in sql to populate database.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseSelector"
    )]
    #[builder(default)]
    pub database_selector: Option<ConnectionInitProviderCloudSqlDatabaseSelector>,
    /// Cloud SQL instance ID in the form project:location:instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceId"
    )]
    #[builder(default)]
    pub instance_id: Option<String>,
    /// Reference to a DatabaseInstance in sql to populate instanceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceIdRef"
    )]
    #[builder(default)]
    pub instance_id_ref: Option<ConnectionInitProviderCloudSqlInstanceIdRef>,
    /// Selector for a DatabaseInstance in sql to populate instanceId.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceIdSelector"
    )]
    #[builder(default)]
    pub instance_id_selector: Option<ConnectionInitProviderCloudSqlInstanceIdSelector>,
    /// Type of the Cloud SQL database.
    /// Possible values are: DATABASE_TYPE_UNSPECIFIED, POSTGRES, MYSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Cloud SQL properties.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredential {
    /// Password for database.
    /// Note: This property is sensitive and will not be displayed in the plan.
    #[serde(rename = "passwordSecretRef")]
    pub password_secret_ref: ConnectionInitProviderCloudSqlCredentialPasswordSecretRef,
    /// Username for database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
    /// Reference to a User in sql to populate username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameRef"
    )]
    #[builder(default)]
    pub username_ref: Option<ConnectionInitProviderCloudSqlCredentialUsernameRef>,
    /// Selector for a User in sql to populate username.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usernameSelector"
    )]
    #[builder(default)]
    pub username_selector: Option<ConnectionInitProviderCloudSqlCredentialUsernameSelector>,
}

/// Password for database.
/// Note: This property is sensitive and will not be displayed in the plan.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredentialPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Reference to a User in sql to populate username.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredentialUsernameRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlCredentialUsernameRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredentialUsernameRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionInitProviderCloudSqlCredentialUsernameRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlCredentialUsernameRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlCredentialUsernameRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlCredentialUsernameRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a User in sql to populate username.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredentialUsernameSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlCredentialUsernameSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Database in sql to populate database.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlDatabaseRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlDatabaseRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlDatabaseRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionInitProviderCloudSqlDatabaseRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlDatabaseRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlDatabaseRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlDatabaseRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Database in sql to populate database.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlDatabaseSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlDatabaseSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlDatabaseSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionInitProviderCloudSqlDatabaseSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlDatabaseSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlDatabaseSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlDatabaseSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a DatabaseInstance in sql to populate instanceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlInstanceIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlInstanceIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlInstanceIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionInitProviderCloudSqlInstanceIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlInstanceIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlInstanceIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlInstanceIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DatabaseInstance in sql to populate instanceId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlInstanceIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderCloudSqlInstanceIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderCloudSqlInstanceIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionInitProviderCloudSqlInstanceIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionInitProviderCloudSqlInstanceIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlInstanceIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderCloudSqlInstanceIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Container for connection properties to execute stored procedures for Apache Spark. resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSpark {
    /// Dataproc Metastore Service configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreServiceConfig"
    )]
    #[builder(default)]
    pub metastore_service_config: Option<ConnectionInitProviderSparkMetastoreServiceConfig>,
    /// Spark History Server configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sparkHistoryServerConfig"
    )]
    #[builder(default)]
    pub spark_history_server_config: Option<ConnectionInitProviderSparkSparkHistoryServerConfig>,
}

/// Dataproc Metastore Service configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkMetastoreServiceConfig {
    /// Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreService"
    )]
    #[builder(default)]
    pub metastore_service: Option<String>,
}

/// Spark History Server configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkSparkHistoryServerConfig {
    /// Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocCluster"
    )]
    #[builder(default)]
    pub dataproc_cluster: Option<String>,
    /// Reference to a Cluster in dataproc to populate dataprocCluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocClusterRef"
    )]
    #[builder(default)]
    pub dataproc_cluster_ref:
        Option<ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRef>,
    /// Selector for a Cluster in dataproc to populate dataprocCluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocClusterSelector"
    )]
    #[builder(default)]
    pub dataproc_cluster_selector:
        Option<ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelector>,
}

/// Reference to a Cluster in dataproc to populate dataprocCluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in dataproc to populate dataprocCluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<
        ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolve,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionInitProviderSparkSparkHistoryServerConfigDataprocClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<ConnectionPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<ConnectionPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ConnectionPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ConnectionPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ConnectionPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ConnectionPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ConnectionStatus defines the observed state of Connection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<ConnectionStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProvider {
    /// Connection properties specific to Amazon Web Services.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aws: Option<ConnectionStatusAtProviderAws>,
    /// Container for connection properties specific to Azure.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub azure: Option<ConnectionStatusAtProviderAzure>,
    /// Container for connection properties for delegation of access to GCP resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudResource"
    )]
    #[builder(default)]
    pub cloud_resource: Option<ConnectionStatusAtProviderCloudResource>,
    /// Connection properties specific to Cloud Spanner
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudSpanner"
    )]
    #[builder(default)]
    pub cloud_spanner: Option<ConnectionStatusAtProviderCloudSpanner>,
    /// Connection properties specific to the Cloud SQL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSql")]
    #[builder(default)]
    pub cloud_sql: Option<ConnectionStatusAtProviderCloudSql>,
    /// Optional connection id that should be assigned to the created connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionId"
    )]
    #[builder(default)]
    pub connection_id: Option<String>,
    /// A descriptive description for the connection
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// A descriptive name for the connection
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "friendlyName"
    )]
    #[builder(default)]
    pub friendly_name: Option<String>,
    /// True if the connection has credential assigned.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hasCredential"
    )]
    #[builder(default)]
    pub has_credential: Option<bool>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/connections/{{connection_id}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Optional. The Cloud KMS key that is used for encryption.
    /// Example: projects/[kms_project_id]/locations/[region]/keyRings/[key_region]/cryptoKeys/[key]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kmsKeyName"
    )]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// The geographic location where the connection should reside.
    /// Cloud SQL instance must be in the same location as the connection
    /// with following exceptions: Cloud SQL us-central1 maps to BigQuery US, Cloud SQL europe-west1 maps to BigQuery EU.
    /// Examples: US, EU, asia-northeast1, us-central1, europe-west1.
    /// Spanner Connections same as spanner region
    /// AWS allowed regions are aws-us-east-1
    /// Azure allowed regions are azure-eastus2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The resource name of the connection in the form of:
    /// "projects/{project_id}/locations/{location_id}/connections/{connectionId}"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Container for connection properties to execute stored procedures for Apache Spark. resources.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spark: Option<ConnectionStatusAtProviderSpark>,
}

/// Connection properties specific to Amazon Web Services.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderAws {
    /// Authentication using Google owned service account to assume into customer's AWS IAM Role.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessRole"
    )]
    #[builder(default)]
    pub access_role: Option<ConnectionStatusAtProviderAwsAccessRole>,
}

/// Authentication using Google owned service account to assume into customer's AWS IAM Role.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderAwsAccessRole {
    /// The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamRoleId")]
    #[builder(default)]
    pub iam_role_id: Option<String>,
    /// (Output)
    /// A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's AWS IAM Role.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub identity: Option<String>,
}

/// Container for connection properties specific to Azure.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderAzure {
    /// (Output)
    /// The name of the Azure Active Directory Application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub application: Option<String>,
    /// (Output)
    /// The client id of the Azure Active Directory Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    #[builder(default)]
    pub client_id: Option<String>,
    /// The id of customer's directory that host the data.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customerTenantId"
    )]
    #[builder(default)]
    pub customer_tenant_id: Option<String>,
    /// The Azure Application (client) ID where the federated credentials will be hosted.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "federatedApplicationClientId"
    )]
    #[builder(default)]
    pub federated_application_client_id: Option<String>,
    /// (Output)
    /// A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's Azure Active Directory Application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub identity: Option<String>,
    /// (Output)
    /// The object id of the Azure Active Directory Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectId")]
    #[builder(default)]
    pub object_id: Option<String>,
    /// (Output)
    /// The URL user will be redirected to after granting consent during connection setup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "redirectUri"
    )]
    #[builder(default)]
    pub redirect_uri: Option<String>,
}

/// Container for connection properties for delegation of access to GCP resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderCloudResource {
    /// (Output)
    /// The account ID of the service created for the purpose of this connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountId"
    )]
    #[builder(default)]
    pub service_account_id: Option<String>,
}

/// Connection properties specific to Cloud Spanner
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderCloudSpanner {
    /// Cloud Spanner database in the form `project/instance/database'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as SELECT and INSERT. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRole"
    )]
    #[builder(default)]
    pub database_role: Option<String>,
    /// Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. useParallelism and useDataBoost must be set when setting max parallelism.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxParallelism"
    )]
    #[builder(default)]
    pub max_parallelism: Option<f64>,
    /// If set, the request will be executed via Spanner independent compute resources. use_parallelism must be set when using data boost.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useDataBoost"
    )]
    #[builder(default)]
    pub use_data_boost: Option<bool>,
    /// If parallelism should be used when reading from Cloud Spanner.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useParallelism"
    )]
    #[builder(default)]
    pub use_parallelism: Option<bool>,
    /// If the serverless analytics service should be used to read data from Cloud Spanner. useParallelism must be set when using serverless analytics.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useServerlessAnalytics"
    )]
    #[builder(default)]
    pub use_serverless_analytics: Option<bool>,
}

/// Connection properties specific to the Cloud SQL.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderCloudSql {
    /// Cloud SQL properties.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub credential: Option<ConnectionStatusAtProviderCloudSqlCredential>,
    /// Database name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub database: Option<String>,
    /// Cloud SQL instance ID in the form project:location:instance.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceId"
    )]
    #[builder(default)]
    pub instance_id: Option<String>,
    /// (Output)
    /// When the connection is used in the context of an operation in BigQuery, this service account will serve as the identity being used for connecting to the CloudSQL instance specified in this connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountId"
    )]
    #[builder(default)]
    pub service_account_id: Option<String>,
    /// Type of the Cloud SQL database.
    /// Possible values are: DATABASE_TYPE_UNSPECIFIED, POSTGRES, MYSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Cloud SQL properties.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderCloudSqlCredential {
    /// Username for database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
}

/// Container for connection properties to execute stored procedures for Apache Spark. resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderSpark {
    /// Dataproc Metastore Service configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreServiceConfig"
    )]
    #[builder(default)]
    pub metastore_service_config: Option<ConnectionStatusAtProviderSparkMetastoreServiceConfig>,
    /// (Output)
    /// The account ID of the service created for the purpose of this connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountId"
    )]
    #[builder(default)]
    pub service_account_id: Option<String>,
    /// Spark History Server configuration for the connection.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sparkHistoryServerConfig"
    )]
    #[builder(default)]
    pub spark_history_server_config:
        Option<ConnectionStatusAtProviderSparkSparkHistoryServerConfig>,
}

/// Dataproc Metastore Service configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderSparkMetastoreServiceConfig {
    /// Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "metastoreService"
    )]
    #[builder(default)]
    pub metastore_service: Option<String>,
}

/// Spark History Server configuration for the connection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ConnectionStatusAtProviderSparkSparkHistoryServerConfig {
    /// Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataprocCluster"
    )]
    #[builder(default)]
    pub dataproc_cluster: Option<String>,
}
