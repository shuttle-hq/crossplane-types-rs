// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ReplicatorSpec defines the desired state of Replicator
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "kafka.aws.upbound.io", version = "v1beta1", kind = "Replicator", plural = "replicators")]
#[kube(status = "ReplicatorStatus")]
pub struct ReplicatorSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<ReplicatorDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ReplicatorForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<ReplicatorInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<ReplicatorProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<ReplicatorPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<ReplicatorWriteConnectionSecretToRef>,
}

/// ReplicatorSpec defines the desired state of Replicator
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProvider {
    /// A summary description of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// A list of Kafka clusters which are targets of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafkaCluster")]
    #[builder(default)]
    pub kafka_cluster: Option<Vec<ReplicatorForProviderKafkaCluster>>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationInfoList")]
    #[builder(default)]
    pub replication_info_list: Option<ReplicatorForProviderReplicationInfoList>,
    /// The name of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicatorName")]
    #[builder(default)]
    pub replicator_name: Option<String>,
    /// The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArn")]
    #[builder(default)]
    pub service_execution_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArnRef")]
    #[builder(default)]
    pub service_execution_role_arn_ref: Option<ReplicatorForProviderServiceExecutionRoleArnRef>,
    /// Selector for a Role in iam to populate serviceExecutionRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArnSelector")]
    #[builder(default)]
    pub service_execution_role_arn_selector: Option<ReplicatorForProviderServiceExecutionRoleArnSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaCluster {
    /// Details of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amazonMskCluster")]
    #[builder(default)]
    pub amazon_msk_cluster: Option<ReplicatorForProviderKafkaClusterAmazonMskCluster>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default)]
    pub vpc_config: Option<ReplicatorForProviderKafkaClusterVpcConfig>,
}

/// Details of an Amazon MSK cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterAmazonMskCluster {
    /// The ARN of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArn")]
    #[builder(default)]
    pub msk_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate mskClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArnRef")]
    #[builder(default)]
    pub msk_cluster_arn_ref: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRef>,
    /// Selector for a Cluster in kafka to populate mskClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArnSelector")]
    #[builder(default)]
    pub msk_cluster_arn_selector: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelector>,
}

/// Reference to a Cluster in kafka to populate mskClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate mskClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfig {
    /// The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    #[builder(default)]
    pub security_groups_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupsIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIdsRefs")]
    #[builder(default)]
    pub security_groups_ids_refs: Option<Vec<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupsIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIdsSelector")]
    #[builder(default)]
    pub security_groups_ids_selector: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelector>,
    /// The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdsRefs")]
    #[builder(default)]
    pub subnet_ids_refs: Option<Vec<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdsSelector")]
    #[builder(default)]
    pub subnet_ids_selector: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupsIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoList {
    /// Configuration relating to consumer group replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupReplication")]
    #[builder(default)]
    pub consumer_group_replication: Option<Vec<ReplicatorForProviderReplicationInfoListConsumerGroupReplication>>,
    /// The ARN of the source Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArn")]
    #[builder(default)]
    pub source_kafka_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate sourceKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArnRef")]
    #[builder(default)]
    pub source_kafka_cluster_arn_ref: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRef>,
    /// Selector for a Cluster in kafka to populate sourceKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArnSelector")]
    #[builder(default)]
    pub source_kafka_cluster_arn_selector: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelector>,
    /// The type of compression to use writing records to target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCompressionType")]
    #[builder(default)]
    pub target_compression_type: Option<String>,
    /// The ARN of the target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArn")]
    #[builder(default)]
    pub target_kafka_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate targetKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArnRef")]
    #[builder(default)]
    pub target_kafka_cluster_arn_ref: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRef>,
    /// Selector for a Cluster in kafka to populate targetKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArnSelector")]
    #[builder(default)]
    pub target_kafka_cluster_arn_selector: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelector>,
    /// Configuration relating to topic replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicReplication")]
    #[builder(default)]
    pub topic_replication: Option<Vec<ReplicatorForProviderReplicationInfoListTopicReplication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListConsumerGroupReplication {
    /// List of regular expression patterns indicating the consumer groups that should not be replicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToExclude")]
    #[builder(default)]
    pub consumer_groups_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the consumer groups to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToReplicate")]
    #[builder(default)]
    pub consumer_groups_to_replicate: Option<Vec<String>>,
    /// Whether to periodically check for new consumer groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewConsumerGroups")]
    #[builder(default)]
    pub detect_and_copy_new_consumer_groups: Option<bool>,
    /// Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "synchroniseConsumerGroupOffsets")]
    #[builder(default)]
    pub synchronise_consumer_group_offsets: Option<bool>,
}

/// Reference to a Cluster in kafka to populate sourceKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate sourceKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Cluster in kafka to populate targetKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate targetKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTopicReplication {
    /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyAccessControlListsForTopics")]
    #[builder(default)]
    pub copy_access_control_lists_for_topics: Option<bool>,
    /// Whether to periodically configure remote topics to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTopicConfigurations")]
    #[builder(default)]
    pub copy_topic_configurations: Option<bool>,
    /// Whether to periodically check for new topics and partitions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewTopics")]
    #[builder(default)]
    pub detect_and_copy_new_topics: Option<bool>,
    /// Configuration for specifying the position in the topics to start replicating from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startingPosition")]
    #[builder(default)]
    pub starting_position: Option<ReplicatorForProviderReplicationInfoListTopicReplicationStartingPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicNameConfiguration")]
    #[builder(default)]
    pub topic_name_configuration: Option<ReplicatorForProviderReplicationInfoListTopicReplicationTopicNameConfiguration>,
    /// List of regular expression patterns indicating the topics that should not be replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToExclude")]
    #[builder(default)]
    pub topics_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the topics to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToReplicate")]
    #[builder(default)]
    pub topics_to_replicate: Option<Vec<String>>,
}

/// Configuration for specifying the position in the topics to start replicating from.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTopicReplicationStartingPosition {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderReplicationInfoListTopicReplicationTopicNameConfiguration {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Reference to a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderServiceExecutionRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderServiceExecutionRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderServiceExecutionRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderServiceExecutionRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderServiceExecutionRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderServiceExecutionRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderServiceExecutionRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderServiceExecutionRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorForProviderServiceExecutionRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorForProviderServiceExecutionRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorForProviderServiceExecutionRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorForProviderServiceExecutionRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderServiceExecutionRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorForProviderServiceExecutionRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProvider {
    /// A summary description of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// A list of Kafka clusters which are targets of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafkaCluster")]
    #[builder(default)]
    pub kafka_cluster: Option<Vec<ReplicatorInitProviderKafkaCluster>>,
    /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationInfoList")]
    #[builder(default)]
    pub replication_info_list: Option<ReplicatorInitProviderReplicationInfoList>,
    /// The name of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicatorName")]
    #[builder(default)]
    pub replicator_name: Option<String>,
    /// The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArn")]
    #[builder(default)]
    pub service_execution_role_arn: Option<String>,
    /// Reference to a Role in iam to populate serviceExecutionRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArnRef")]
    #[builder(default)]
    pub service_execution_role_arn_ref: Option<ReplicatorInitProviderServiceExecutionRoleArnRef>,
    /// Selector for a Role in iam to populate serviceExecutionRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArnSelector")]
    #[builder(default)]
    pub service_execution_role_arn_selector: Option<ReplicatorInitProviderServiceExecutionRoleArnSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaCluster {
    /// Details of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amazonMskCluster")]
    #[builder(default)]
    pub amazon_msk_cluster: Option<ReplicatorInitProviderKafkaClusterAmazonMskCluster>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default)]
    pub vpc_config: Option<ReplicatorInitProviderKafkaClusterVpcConfig>,
}

/// Details of an Amazon MSK cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterAmazonMskCluster {
    /// The ARN of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArn")]
    #[builder(default)]
    pub msk_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate mskClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArnRef")]
    #[builder(default)]
    pub msk_cluster_arn_ref: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRef>,
    /// Selector for a Cluster in kafka to populate mskClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArnSelector")]
    #[builder(default)]
    pub msk_cluster_arn_selector: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelector>,
}

/// Reference to a Cluster in kafka to populate mskClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate mskClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterAmazonMskClusterMskClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfig {
    /// The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    #[builder(default)]
    pub security_groups_ids: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroupsIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIdsRefs")]
    #[builder(default)]
    pub security_groups_ids_refs: Option<Vec<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupsIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIdsSelector")]
    #[builder(default)]
    pub security_groups_ids_selector: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelector>,
    /// The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdsRefs")]
    #[builder(default)]
    pub subnet_ids_refs: Option<Vec<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdsSelector")]
    #[builder(default)]
    pub subnet_ids_selector: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelector>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupsIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSecurityGroupsIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderKafkaClusterVpcConfigSubnetIdsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoList {
    /// Configuration relating to consumer group replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupReplication")]
    #[builder(default)]
    pub consumer_group_replication: Option<Vec<ReplicatorInitProviderReplicationInfoListConsumerGroupReplication>>,
    /// The ARN of the source Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArn")]
    #[builder(default)]
    pub source_kafka_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate sourceKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArnRef")]
    #[builder(default)]
    pub source_kafka_cluster_arn_ref: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRef>,
    /// Selector for a Cluster in kafka to populate sourceKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArnSelector")]
    #[builder(default)]
    pub source_kafka_cluster_arn_selector: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelector>,
    /// The type of compression to use writing records to target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCompressionType")]
    #[builder(default)]
    pub target_compression_type: Option<String>,
    /// The ARN of the target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArn")]
    #[builder(default)]
    pub target_kafka_cluster_arn: Option<String>,
    /// Reference to a Cluster in kafka to populate targetKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArnRef")]
    #[builder(default)]
    pub target_kafka_cluster_arn_ref: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRef>,
    /// Selector for a Cluster in kafka to populate targetKafkaClusterArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArnSelector")]
    #[builder(default)]
    pub target_kafka_cluster_arn_selector: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelector>,
    /// Configuration relating to topic replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicReplication")]
    #[builder(default)]
    pub topic_replication: Option<Vec<ReplicatorInitProviderReplicationInfoListTopicReplication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListConsumerGroupReplication {
    /// List of regular expression patterns indicating the consumer groups that should not be replicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToExclude")]
    #[builder(default)]
    pub consumer_groups_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the consumer groups to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToReplicate")]
    #[builder(default)]
    pub consumer_groups_to_replicate: Option<Vec<String>>,
    /// Whether to periodically check for new consumer groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewConsumerGroups")]
    #[builder(default)]
    pub detect_and_copy_new_consumer_groups: Option<bool>,
    /// Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "synchroniseConsumerGroupOffsets")]
    #[builder(default)]
    pub synchronise_consumer_group_offsets: Option<bool>,
}

/// Reference to a Cluster in kafka to populate sourceKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate sourceKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListSourceKafkaClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Cluster in kafka to populate targetKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in kafka to populate targetKafkaClusterArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderReplicationInfoListTargetKafkaClusterArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTopicReplication {
    /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyAccessControlListsForTopics")]
    #[builder(default)]
    pub copy_access_control_lists_for_topics: Option<bool>,
    /// Whether to periodically configure remote topics to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTopicConfigurations")]
    #[builder(default)]
    pub copy_topic_configurations: Option<bool>,
    /// Whether to periodically check for new topics and partitions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewTopics")]
    #[builder(default)]
    pub detect_and_copy_new_topics: Option<bool>,
    /// Configuration for specifying the position in the topics to start replicating from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startingPosition")]
    #[builder(default)]
    pub starting_position: Option<ReplicatorInitProviderReplicationInfoListTopicReplicationStartingPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicNameConfiguration")]
    #[builder(default)]
    pub topic_name_configuration: Option<ReplicatorInitProviderReplicationInfoListTopicReplicationTopicNameConfiguration>,
    /// List of regular expression patterns indicating the topics that should not be replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToExclude")]
    #[builder(default)]
    pub topics_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the topics to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToReplicate")]
    #[builder(default)]
    pub topics_to_replicate: Option<Vec<String>>,
}

/// Configuration for specifying the position in the topics to start replicating from.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTopicReplicationStartingPosition {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderReplicationInfoListTopicReplicationTopicNameConfiguration {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Reference to a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderServiceExecutionRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderServiceExecutionRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderServiceExecutionRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderServiceExecutionRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderServiceExecutionRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderServiceExecutionRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderServiceExecutionRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate serviceExecutionRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderServiceExecutionRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorInitProviderServiceExecutionRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<ReplicatorPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<ReplicatorPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ReplicatorPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ReplicatorPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ReplicatorPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ReplicatorPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ReplicatorStatus defines the observed state of Replicator.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<ReplicatorStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProvider {
    /// ARN of the Replicator. Do not begin the description with "An", "The", "Defines", "Indicates", or "Specifies," as these are verbose. In other words, "Indicates the amount of storage," can be rewritten as "Amount of storage," without losing any information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentVersion")]
    #[builder(default)]
    pub current_version: Option<String>,
    /// A summary description of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// A list of Kafka clusters which are targets of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafkaCluster")]
    #[builder(default)]
    pub kafka_cluster: Option<Vec<ReplicatorStatusAtProviderKafkaCluster>>,
    /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationInfoList")]
    #[builder(default)]
    pub replication_info_list: Option<ReplicatorStatusAtProviderReplicationInfoList>,
    /// The name of the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicatorName")]
    #[builder(default)]
    pub replicator_name: Option<String>,
    /// The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceExecutionRoleArn")]
    #[builder(default)]
    pub service_execution_role_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderKafkaCluster {
    /// Details of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amazonMskCluster")]
    #[builder(default)]
    pub amazon_msk_cluster: Option<ReplicatorStatusAtProviderKafkaClusterAmazonMskCluster>,
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConfig")]
    #[builder(default)]
    pub vpc_config: Option<ReplicatorStatusAtProviderKafkaClusterVpcConfig>,
}

/// Details of an Amazon MSK cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderKafkaClusterAmazonMskCluster {
    /// The ARN of an Amazon MSK cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mskClusterArn")]
    #[builder(default)]
    pub msk_cluster_arn: Option<String>,
}

/// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderKafkaClusterVpcConfig {
    /// The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    #[builder(default)]
    pub security_groups_ids: Option<Vec<String>>,
    /// The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
}

/// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderReplicationInfoList {
    /// Configuration relating to consumer group replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupReplication")]
    #[builder(default)]
    pub consumer_group_replication: Option<Vec<ReplicatorStatusAtProviderReplicationInfoListConsumerGroupReplication>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterAlias")]
    #[builder(default)]
    pub source_kafka_cluster_alias: Option<String>,
    /// The ARN of the source Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceKafkaClusterArn")]
    #[builder(default)]
    pub source_kafka_cluster_arn: Option<String>,
    /// The type of compression to use writing records to target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCompressionType")]
    #[builder(default)]
    pub target_compression_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterAlias")]
    #[builder(default)]
    pub target_kafka_cluster_alias: Option<String>,
    /// The ARN of the target Kafka cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetKafkaClusterArn")]
    #[builder(default)]
    pub target_kafka_cluster_arn: Option<String>,
    /// Configuration relating to topic replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicReplication")]
    #[builder(default)]
    pub topic_replication: Option<Vec<ReplicatorStatusAtProviderReplicationInfoListTopicReplication>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderReplicationInfoListConsumerGroupReplication {
    /// List of regular expression patterns indicating the consumer groups that should not be replicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToExclude")]
    #[builder(default)]
    pub consumer_groups_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the consumer groups to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerGroupsToReplicate")]
    #[builder(default)]
    pub consumer_groups_to_replicate: Option<Vec<String>>,
    /// Whether to periodically check for new consumer groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewConsumerGroups")]
    #[builder(default)]
    pub detect_and_copy_new_consumer_groups: Option<bool>,
    /// Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "synchroniseConsumerGroupOffsets")]
    #[builder(default)]
    pub synchronise_consumer_group_offsets: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderReplicationInfoListTopicReplication {
    /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyAccessControlListsForTopics")]
    #[builder(default)]
    pub copy_access_control_lists_for_topics: Option<bool>,
    /// Whether to periodically configure remote topics to match their corresponding upstream topics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTopicConfigurations")]
    #[builder(default)]
    pub copy_topic_configurations: Option<bool>,
    /// Whether to periodically check for new topics and partitions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "detectAndCopyNewTopics")]
    #[builder(default)]
    pub detect_and_copy_new_topics: Option<bool>,
    /// Configuration for specifying the position in the topics to start replicating from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startingPosition")]
    #[builder(default)]
    pub starting_position: Option<ReplicatorStatusAtProviderReplicationInfoListTopicReplicationStartingPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicNameConfiguration")]
    #[builder(default)]
    pub topic_name_configuration: Option<ReplicatorStatusAtProviderReplicationInfoListTopicReplicationTopicNameConfiguration>,
    /// List of regular expression patterns indicating the topics that should not be replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToExclude")]
    #[builder(default)]
    pub topics_to_exclude: Option<Vec<String>>,
    /// List of regular expression patterns indicating the topics to copy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicsToReplicate")]
    #[builder(default)]
    pub topics_to_replicate: Option<Vec<String>>,
}

/// Configuration for specifying the position in the topics to start replicating from.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderReplicationInfoListTopicReplicationStartingPosition {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ReplicatorStatusAtProviderReplicationInfoListTopicReplicationTopicNameConfiguration {
    /// The type of topic configuration name. Supports PREFIXED_WITH_SOURCE_CLUSTER_ALIAS and IDENTICAL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

