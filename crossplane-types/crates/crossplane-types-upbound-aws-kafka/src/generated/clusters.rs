// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "kafka.aws.upbound.io",
    version = "v1beta3",
    kind = "Cluster",
    plural = "clusters"
)]
#[kube(status = "ClusterStatus")]
pub struct ClusterSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<ClusterDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: ClusterForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<ClusterInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<ClusterProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<ClusterPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<ClusterWriteConnectionSecretToRef>,
}

/// ClusterSpec defines the desired state of Cluster
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProvider {
    /// Configuration block for the broker nodes of the Kafka cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerNodeGroupInfo"
    )]
    #[builder(default)]
    pub broker_node_group_info: Option<ClusterForProviderBrokerNodeGroupInfo>,
    /// Configuration block for specifying a client authentication. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientAuthentication"
    )]
    #[builder(default)]
    pub client_authentication: Option<ClusterForProviderClientAuthentication>,
    /// Name of the MSK cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterName"
    )]
    #[builder(default)]
    pub cluster_name: Option<String>,
    /// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationInfo"
    )]
    #[builder(default)]
    pub configuration_info: Option<ClusterForProviderConfigurationInfo>,
    /// Configuration block for specifying encryption. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInfo"
    )]
    #[builder(default)]
    pub encryption_info: Option<ClusterForProviderEncryptionInfo>,
    /// Specify the desired enhanced MSK CloudWatch monitoring level. See Monitoring Amazon MSK with Amazon CloudWatch
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enhancedMonitoring"
    )]
    #[builder(default)]
    pub enhanced_monitoring: Option<String>,
    /// Specify the desired Kafka software version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaVersion"
    )]
    #[builder(default)]
    pub kafka_version: Option<String>,
    /// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingInfo"
    )]
    #[builder(default)]
    pub logging_info: Option<ClusterForProviderLoggingInfo>,
    /// The desired total number of broker nodes in the kafka cluster.  It must be a multiple of the number of specified client subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberOfBrokerNodes"
    )]
    #[builder(default)]
    pub number_of_broker_nodes: Option<f64>,
    /// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "openMonitoring"
    )]
    #[builder(default)]
    pub open_monitoring: Option<ClusterForProviderOpenMonitoring>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// Controls storage mode for supported storage tiers. Valid values are: LOCAL or TIERED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageMode"
    )]
    #[builder(default)]
    pub storage_mode: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
}

/// Configuration block for the broker nodes of the Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfo {
    /// The distribution of broker nodes across availability zones (documentation). Currently the only valid value is DEFAULT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "azDistribution"
    )]
    #[builder(default)]
    pub az_distribution: Option<String>,
    /// A list of subnets to connect to in client VPC (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnets"
    )]
    #[builder(default)]
    pub client_subnets: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate clientSubnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnetsRefs"
    )]
    #[builder(default)]
    pub client_subnets_refs: Option<Vec<ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate clientSubnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnetsSelector"
    )]
    #[builder(default)]
    pub client_subnets_selector: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelector>,
    /// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectivityInfo"
    )]
    #[builder(default)]
    pub connectivity_info: Option<ClusterForProviderBrokerNodeGroupInfoConnectivityInfo>,
    /// Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. (Pricing info)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default)]
    pub security_groups: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupsRefs"
    )]
    #[builder(default)]
    pub security_groups_refs: Option<Vec<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupsSelector"
    )]
    #[builder(default)]
    pub security_groups_selector:
        Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelector>,
    /// A block that contains information about storage volumes attached to MSK broker nodes. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageInfo"
    )]
    #[builder(default)]
    pub storage_info: Option<ClusterForProviderBrokerNodeGroupInfoStorageInfo>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate clientSubnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoConnectivityInfo {
    /// Access control settings for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicAccess"
    )]
    #[builder(default)]
    pub public_access: Option<ClusterForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess>,
    /// VPC connectivity access control for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConnectivity"
    )]
    #[builder(default)]
    pub vpc_connectivity:
        Option<ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity>,
}

/// Access control settings for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess {
    /// Public access type. Valid values: DISABLED, SERVICE_PROVIDED_EIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// VPC connectivity access control for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity {
    /// Configuration block for specifying a client authentication. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientAuthentication"
    )]
    #[builder(default)]
    pub client_authentication: Option<
        ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication,
    >,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl
{
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block that contains information about storage volumes attached to MSK broker nodes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoStorageInfo {
    /// A block that contains EBS volume information. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsStorageInfo"
    )]
    #[builder(default)]
    pub ebs_storage_info: Option<ClusterForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo>,
}

/// A block that contains EBS volume information. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
    /// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedThroughput"
    )]
    #[builder(default)]
    pub provisioned_throughput:
        Option<ClusterForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput>,
    /// The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of 1 and maximum value of 16384.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default)]
    pub volume_size: Option<f64>,
}

/// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is 250. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following documentation on throughput bottlenecks
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeThroughput"
    )]
    #[builder(default)]
    pub volume_throughput: Option<f64>,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterForProviderClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<ClusterForProviderClientAuthenticationTls>,
    /// Enables unauthenticated access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unauthenticated: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderClientAuthenticationSasl {
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// Enables TLS authentication for VPC connectivity.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderClientAuthenticationTls {
    /// List of ACM Certificate Authority Amazon Resource Names (ARNs).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default)]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderConfigurationInfo {
    /// Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// Reference to a Configuration in kafka to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default)]
    pub arn_ref: Option<ClusterForProviderConfigurationInfoArnRef>,
    /// Selector for a Configuration in kafka to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default)]
    pub arn_selector: Option<ClusterForProviderConfigurationInfoArnSelector>,
    /// Revision of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<f64>,
}

/// Reference to a Configuration in kafka to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderConfigurationInfoArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderConfigurationInfoArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderConfigurationInfoArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderConfigurationInfoArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderConfigurationInfoArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderConfigurationInfoArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderConfigurationInfoArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Configuration in kafka to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderConfigurationInfoArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderConfigurationInfoArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderConfigurationInfoArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderConfigurationInfoArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderConfigurationInfoArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderConfigurationInfoArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderConfigurationInfoArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for specifying encryption. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfo {
    /// The ARN of the KMS key used for encryption at rest of the broker data volumes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArn"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArnRef"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn_ref:
        Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef>,
    /// Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArnSelector"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn_selector:
        Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector>,
    /// Configuration block to specify encryption in transit. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInTransit"
    )]
    #[builder(default)]
    pub encryption_in_transit: Option<ClusterForProviderEncryptionInfoEncryptionInTransit>,
}

/// Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block to specify encryption in transit. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderEncryptionInfoEncryptionInTransit {
    /// Encryption setting for data in transit between clients and brokers. Valid values: TLS, TLS_PLAINTEXT, and PLAINTEXT. Default value is TLS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientBroker"
    )]
    #[builder(default)]
    pub client_broker: Option<String>,
    /// Whether data communication among broker nodes is encrypted. Default value: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inCluster")]
    #[builder(default)]
    pub in_cluster: Option<bool>,
}

/// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfo {
    /// Configuration block for Broker Logs settings for logging info. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerLogs"
    )]
    #[builder(default)]
    pub broker_logs: Option<ClusterForProviderLoggingInfoBrokerLogs>,
}

/// Configuration block for Broker Logs settings for logging info. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogs {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default)]
    pub cloudwatch_logs: Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub firehose: Option<ClusterForProviderLoggingInfoBrokerLogsFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub s3: Option<ClusterForProviderLoggingInfoBrokerLogsS3>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogs {
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Name of the Cloudwatch Log Group to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default)]
    pub log_group: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupRef"
    )]
    #[builder(default)]
    pub log_group_ref: Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef>,
    /// Selector for a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupSelector"
    )]
    #[builder(default)]
    pub log_group_selector:
        Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector>,
}

/// Reference to a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsFirehose {
    /// Name of the Kinesis Data Firehose delivery stream to deliver logs to.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default)]
    pub delivery_stream: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamRef"
    )]
    #[builder(default)]
    pub delivery_stream_ref:
        Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef>,
    /// Selector for a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamSelector"
    )]
    #[builder(default)]
    pub delivery_stream_selector:
        Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// Reference to a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsS3 {
    /// Name of the S3 bucket to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default)]
    pub bucket_ref: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default)]
    pub bucket_selector: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketSelector>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Prefix to append to the folder name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderOpenMonitoring {
    /// Configuration block for Prometheus settings for open monitoring. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prometheus: Option<ClusterForProviderOpenMonitoringPrometheus>,
}

/// Configuration block for Prometheus settings for open monitoring. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderOpenMonitoringPrometheus {
    /// Configuration block for JMX Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jmxExporter"
    )]
    #[builder(default)]
    pub jmx_exporter: Option<ClusterForProviderOpenMonitoringPrometheusJmxExporter>,
    /// Configuration block for Node Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeExporter"
    )]
    #[builder(default)]
    pub node_exporter: Option<ClusterForProviderOpenMonitoringPrometheusNodeExporter>,
}

/// Configuration block for JMX Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderOpenMonitoringPrometheusJmxExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}

/// Configuration block for Node Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterForProviderOpenMonitoringPrometheusNodeExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProvider {
    /// Configuration block for the broker nodes of the Kafka cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerNodeGroupInfo"
    )]
    #[builder(default)]
    pub broker_node_group_info: Option<ClusterInitProviderBrokerNodeGroupInfo>,
    /// Configuration block for specifying a client authentication. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientAuthentication"
    )]
    #[builder(default)]
    pub client_authentication: Option<ClusterInitProviderClientAuthentication>,
    /// Name of the MSK cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterName"
    )]
    #[builder(default)]
    pub cluster_name: Option<String>,
    /// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationInfo"
    )]
    #[builder(default)]
    pub configuration_info: Option<ClusterInitProviderConfigurationInfo>,
    /// Configuration block for specifying encryption. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInfo"
    )]
    #[builder(default)]
    pub encryption_info: Option<ClusterInitProviderEncryptionInfo>,
    /// Specify the desired enhanced MSK CloudWatch monitoring level. See Monitoring Amazon MSK with Amazon CloudWatch
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enhancedMonitoring"
    )]
    #[builder(default)]
    pub enhanced_monitoring: Option<String>,
    /// Specify the desired Kafka software version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaVersion"
    )]
    #[builder(default)]
    pub kafka_version: Option<String>,
    /// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingInfo"
    )]
    #[builder(default)]
    pub logging_info: Option<ClusterInitProviderLoggingInfo>,
    /// The desired total number of broker nodes in the kafka cluster.  It must be a multiple of the number of specified client subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberOfBrokerNodes"
    )]
    #[builder(default)]
    pub number_of_broker_nodes: Option<f64>,
    /// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "openMonitoring"
    )]
    #[builder(default)]
    pub open_monitoring: Option<ClusterInitProviderOpenMonitoring>,
    /// Controls storage mode for supported storage tiers. Valid values are: LOCAL or TIERED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageMode"
    )]
    #[builder(default)]
    pub storage_mode: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
}

/// Configuration block for the broker nodes of the Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfo {
    /// The distribution of broker nodes across availability zones (documentation). Currently the only valid value is DEFAULT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "azDistribution"
    )]
    #[builder(default)]
    pub az_distribution: Option<String>,
    /// A list of subnets to connect to in client VPC (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnets"
    )]
    #[builder(default)]
    pub client_subnets: Option<Vec<String>>,
    /// References to Subnet in ec2 to populate clientSubnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnetsRefs"
    )]
    #[builder(default)]
    pub client_subnets_refs: Option<Vec<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefs>>,
    /// Selector for a list of Subnet in ec2 to populate clientSubnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnetsSelector"
    )]
    #[builder(default)]
    pub client_subnets_selector:
        Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelector>,
    /// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectivityInfo"
    )]
    #[builder(default)]
    pub connectivity_info: Option<ClusterInitProviderBrokerNodeGroupInfoConnectivityInfo>,
    /// Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. (Pricing info)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default)]
    pub security_groups: Option<Vec<String>>,
    /// References to SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupsRefs"
    )]
    #[builder(default)]
    pub security_groups_refs: Option<Vec<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroupsSelector"
    )]
    #[builder(default)]
    pub security_groups_selector:
        Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelector>,
    /// A block that contains information about storage volumes attached to MSK broker nodes. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageInfo"
    )]
    #[builder(default)]
    pub storage_info: Option<ClusterInitProviderBrokerNodeGroupInfoStorageInfo>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate clientSubnets.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoConnectivityInfo {
    /// Access control settings for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicAccess"
    )]
    #[builder(default)]
    pub public_access: Option<ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess>,
    /// VPC connectivity access control for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConnectivity"
    )]
    #[builder(default)]
    pub vpc_connectivity:
        Option<ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity>,
}

/// Access control settings for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess {
    /// Public access type. Valid values: DISABLED, SERVICE_PROVIDED_EIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// VPC connectivity access control for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity {
    /// Configuration block for specifying a client authentication. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientAuthentication"
    )]
    #[builder(default)]
    pub client_authentication: Option<
        ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication,
    >,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl
{
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A block that contains information about storage volumes attached to MSK broker nodes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoStorageInfo {
    /// A block that contains EBS volume information. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsStorageInfo"
    )]
    #[builder(default)]
    pub ebs_storage_info: Option<ClusterInitProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo>,
}

/// A block that contains EBS volume information. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
    /// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedThroughput"
    )]
    #[builder(default)]
    pub provisioned_throughput: Option<
        ClusterInitProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput,
    >,
    /// The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of 1 and maximum value of 16384.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default)]
    pub volume_size: Option<f64>,
}

/// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is 250. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following documentation on throughput bottlenecks
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeThroughput"
    )]
    #[builder(default)]
    pub volume_throughput: Option<f64>,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterInitProviderClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<ClusterInitProviderClientAuthenticationTls>,
    /// Enables unauthenticated access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unauthenticated: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderClientAuthenticationSasl {
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// Enables TLS authentication for VPC connectivity.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderClientAuthenticationTls {
    /// List of ACM Certificate Authority Amazon Resource Names (ARNs).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default)]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderConfigurationInfo {
    /// Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// Reference to a Configuration in kafka to populate arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arnRef")]
    #[builder(default)]
    pub arn_ref: Option<ClusterInitProviderConfigurationInfoArnRef>,
    /// Selector for a Configuration in kafka to populate arn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "arnSelector"
    )]
    #[builder(default)]
    pub arn_selector: Option<ClusterInitProviderConfigurationInfoArnSelector>,
    /// Revision of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<f64>,
}

/// Reference to a Configuration in kafka to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderConfigurationInfoArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderConfigurationInfoArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderConfigurationInfoArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterInitProviderConfigurationInfoArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderConfigurationInfoArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderConfigurationInfoArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderConfigurationInfoArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Configuration in kafka to populate arn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderConfigurationInfoArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderConfigurationInfoArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderConfigurationInfoArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterInitProviderConfigurationInfoArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderConfigurationInfoArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderConfigurationInfoArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderConfigurationInfoArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for specifying encryption. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfo {
    /// The ARN of the KMS key used for encryption at rest of the broker data volumes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArn"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn: Option<String>,
    /// Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArnRef"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn_ref:
        Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef>,
    /// Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArnSelector"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn_selector:
        Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector>,
    /// Configuration block to specify encryption in transit. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInTransit"
    )]
    #[builder(default)]
    pub encryption_in_transit: Option<ClusterInitProviderEncryptionInfoEncryptionInTransit>,
}

/// Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block to specify encryption in transit. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderEncryptionInfoEncryptionInTransit {
    /// Encryption setting for data in transit between clients and brokers. Valid values: TLS, TLS_PLAINTEXT, and PLAINTEXT. Default value is TLS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientBroker"
    )]
    #[builder(default)]
    pub client_broker: Option<String>,
    /// Whether data communication among broker nodes is encrypted. Default value: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inCluster")]
    #[builder(default)]
    pub in_cluster: Option<bool>,
}

/// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfo {
    /// Configuration block for Broker Logs settings for logging info. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerLogs"
    )]
    #[builder(default)]
    pub broker_logs: Option<ClusterInitProviderLoggingInfoBrokerLogs>,
}

/// Configuration block for Broker Logs settings for logging info. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogs {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default)]
    pub cloudwatch_logs: Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub firehose: Option<ClusterInitProviderLoggingInfoBrokerLogsFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub s3: Option<ClusterInitProviderLoggingInfoBrokerLogsS3>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogs {
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Name of the Cloudwatch Log Group to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default)]
    pub log_group: Option<String>,
    /// Reference to a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupRef"
    )]
    #[builder(default)]
    pub log_group_ref: Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef>,
    /// Selector for a Group in cloudwatchlogs to populate logGroup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "logGroupSelector"
    )]
    #[builder(default)]
    pub log_group_selector:
        Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector>,
}

/// Reference to a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Group in cloudwatchlogs to populate logGroup.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsFirehose {
    /// Name of the Kinesis Data Firehose delivery stream to deliver logs to.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default)]
    pub delivery_stream: Option<String>,
    /// Reference to a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamRef"
    )]
    #[builder(default)]
    pub delivery_stream_ref:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef>,
    /// Selector for a DeliveryStream in firehose to populate deliveryStream.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStreamSelector"
    )]
    #[builder(default)]
    pub delivery_stream_selector:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// Reference to a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a DeliveryStream in firehose to populate deliveryStream.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve:
        Option<ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsS3 {
    /// Name of the S3 bucket to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Reference to a Bucket in s3 to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default)]
    pub bucket_ref: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketRef>,
    /// Selector for a Bucket in s3 to populate bucket.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bucketSelector"
    )]
    #[builder(default)]
    pub bucket_selector: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelector>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Prefix to append to the folder name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prefix: Option<String>,
}

/// Reference to a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsS3BucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in s3 to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution:
        Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterInitProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderOpenMonitoring {
    /// Configuration block for Prometheus settings for open monitoring. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prometheus: Option<ClusterInitProviderOpenMonitoringPrometheus>,
}

/// Configuration block for Prometheus settings for open monitoring. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderOpenMonitoringPrometheus {
    /// Configuration block for JMX Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jmxExporter"
    )]
    #[builder(default)]
    pub jmx_exporter: Option<ClusterInitProviderOpenMonitoringPrometheusJmxExporter>,
    /// Configuration block for Node Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeExporter"
    )]
    #[builder(default)]
    pub node_exporter: Option<ClusterInitProviderOpenMonitoringPrometheusNodeExporter>,
}

/// Configuration block for JMX Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderOpenMonitoringPrometheusJmxExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}

/// Configuration block for Node Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterInitProviderOpenMonitoringPrometheusNodeExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<ClusterPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<ClusterPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<ClusterPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<ClusterPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ClusterPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<ClusterStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProvider {
    /// Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// Comma separated list of one or more hostname:port pairs of kafka brokers suitable to bootstrap connectivity to the kafka cluster. Contains a value if encryption_info.0.encryption_in_transit.0.client_broker is set to PLAINTEXT or TLS_PLAINTEXT. The resource sorts values alphabetically. AWS may not always return all endpoints so this value is not guaranteed to be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokers"
    )]
    #[builder(default)]
    pub bootstrap_brokers: Option<String>,
    /// One or more DNS names (or IP addresses) and SASL IAM port pairs. For example, b-1-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9198,b-2-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9198,b-3-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9198. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS and client_authentication.0.sasl.0.iam is set to true and broker_node_group_info.0.connectivity_info.0.public_access.0.type is set to SERVICE_PROVIDED_EIPS and the cluster fulfill all other requirements for public access. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersPublicSaslIam"
    )]
    #[builder(default)]
    pub bootstrap_brokers_public_sasl_iam: Option<String>,
    /// One or more DNS names (or IP addresses) and SASL SCRAM port pairs. For example, b-1-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9196,b-2-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9196,b-3-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9196. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS and client_authentication.0.sasl.0.scram is set to true and broker_node_group_info.0.connectivity_info.0.public_access.0.type is set to SERVICE_PROVIDED_EIPS and the cluster fulfill all other requirements for public access. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersPublicSaslScram"
    )]
    #[builder(default)]
    pub bootstrap_brokers_public_sasl_scram: Option<String>,
    /// One or more DNS names (or IP addresses) and TLS port pairs. For example, b-1-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9194,b-2-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9194,b-3-public.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9194. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS and broker_node_group_info.0.connectivity_info.0.public_access.0.type is set to SERVICE_PROVIDED_EIPS and the cluster fulfill all other requirements for public access. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersPublicTls"
    )]
    #[builder(default)]
    pub bootstrap_brokers_public_tls: Option<String>,
    /// One or more DNS names (or IP addresses) and SASL IAM port pairs. For example, b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098,b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS and client_authentication.0.sasl.0.iam is set to true. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersSaslIam"
    )]
    #[builder(default)]
    pub bootstrap_brokers_sasl_iam: Option<String>,
    /// One or more DNS names (or IP addresses) and SASL SCRAM port pairs. For example, b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096,b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS and client_authentication.0.sasl.0.scram is set to true. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersSaslScram"
    )]
    #[builder(default)]
    pub bootstrap_brokers_sasl_scram: Option<String>,
    /// One or more DNS names (or IP addresses) and TLS port pairs. For example, b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094. This attribute will have a value if encryption_info.0.encryption_in_transit.0.client_broker is set to TLS_PLAINTEXT or TLS. The resource sorts the list alphabetically. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersTls"
    )]
    #[builder(default)]
    pub bootstrap_brokers_tls: Option<String>,
    /// A string containing one or more DNS names (or IP addresses) and SASL IAM port pairs for VPC connectivity. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersVpcConnectivitySaslIam"
    )]
    #[builder(default)]
    pub bootstrap_brokers_vpc_connectivity_sasl_iam: Option<String>,
    /// A string containing one or more DNS names (or IP addresses) and SASL SCRAM port pairs for VPC connectivity. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersVpcConnectivitySaslScram"
    )]
    #[builder(default)]
    pub bootstrap_brokers_vpc_connectivity_sasl_scram: Option<String>,
    /// A string containing one or more DNS names (or IP addresses) and TLS port pairs for VPC connectivity. AWS may not always return all endpoints so the values may not be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "bootstrapBrokersVpcConnectivityTls"
    )]
    #[builder(default)]
    pub bootstrap_brokers_vpc_connectivity_tls: Option<String>,
    /// Configuration block for the broker nodes of the Kafka cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerNodeGroupInfo"
    )]
    #[builder(default)]
    pub broker_node_group_info: Option<ClusterStatusAtProviderBrokerNodeGroupInfo>,
    /// Configuration block for specifying a client authentication. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientAuthentication"
    )]
    #[builder(default)]
    pub client_authentication: Option<ClusterStatusAtProviderClientAuthentication>,
    /// Name of the MSK cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterName"
    )]
    #[builder(default)]
    pub cluster_name: Option<String>,
    /// UUID of the MSK cluster, for use in IAM policies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterUuid"
    )]
    #[builder(default)]
    pub cluster_uuid: Option<String>,
    /// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configurationInfo"
    )]
    #[builder(default)]
    pub configuration_info: Option<ClusterStatusAtProviderConfigurationInfo>,
    /// Current version of the MSK Cluster used for updates, e.g., K13V1IB3VIYZZH
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "currentVersion"
    )]
    #[builder(default)]
    pub current_version: Option<String>,
    /// Configuration block for specifying encryption. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInfo"
    )]
    #[builder(default)]
    pub encryption_info: Option<ClusterStatusAtProviderEncryptionInfo>,
    /// Specify the desired enhanced MSK CloudWatch monitoring level. See Monitoring Amazon MSK with Amazon CloudWatch
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enhancedMonitoring"
    )]
    #[builder(default)]
    pub enhanced_monitoring: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Specify the desired Kafka software version.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "kafkaVersion"
    )]
    #[builder(default)]
    pub kafka_version: Option<String>,
    /// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loggingInfo"
    )]
    #[builder(default)]
    pub logging_info: Option<ClusterStatusAtProviderLoggingInfo>,
    /// The desired total number of broker nodes in the kafka cluster.  It must be a multiple of the number of specified client subnets.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "numberOfBrokerNodes"
    )]
    #[builder(default)]
    pub number_of_broker_nodes: Option<f64>,
    /// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "openMonitoring"
    )]
    #[builder(default)]
    pub open_monitoring: Option<ClusterStatusAtProviderOpenMonitoring>,
    /// Controls storage mode for supported storage tiers. Valid values are: LOCAL or TIERED.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageMode"
    )]
    #[builder(default)]
    pub storage_mode: Option<String>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// A comma separated list of one or more hostname:port pairs to use to connect to the Apache Zookeeper cluster. The returned values are sorted alphabetically. The AWS API may not return all endpoints, so this value is not guaranteed to be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "zookeeperConnectString"
    )]
    #[builder(default)]
    pub zookeeper_connect_string: Option<String>,
    /// A comma separated list of one or more hostname:port pairs to use to connect to the Apache Zookeeper cluster via TLS. The returned values are sorted alphabetically. The AWS API may not return all endpoints, so this value is not guaranteed to be stable across applies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "zookeeperConnectStringTls"
    )]
    #[builder(default)]
    pub zookeeper_connect_string_tls: Option<String>,
}

/// Configuration block for the broker nodes of the Kafka cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfo {
    /// The distribution of broker nodes across availability zones (documentation). Currently the only valid value is DEFAULT.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "azDistribution"
    )]
    #[builder(default)]
    pub az_distribution: Option<String>,
    /// A list of subnets to connect to in client VPC (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientSubnets"
    )]
    #[builder(default)]
    pub client_subnets: Option<Vec<String>>,
    /// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectivityInfo"
    )]
    #[builder(default)]
    pub connectivity_info: Option<ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfo>,
    /// Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. (Pricing info)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceType"
    )]
    #[builder(default)]
    pub instance_type: Option<String>,
    /// A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityGroups"
    )]
    #[builder(default)]
    pub security_groups: Option<Vec<String>>,
    /// A block that contains information about storage volumes attached to MSK broker nodes. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageInfo"
    )]
    #[builder(default)]
    pub storage_info: Option<ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfo>,
}

/// Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfo {
    /// Access control settings for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publicAccess"
    )]
    #[builder(default)]
    pub public_access:
        Option<ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess>,
    /// VPC connectivity access control for brokers. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "vpcConnectivity"
    )]
    #[builder(default)]
    pub vpc_connectivity:
        Option<ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity>,
}

/// Access control settings for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess {
    /// Public access type. Valid values: DISABLED, SERVICE_PROVIDED_EIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// VPC connectivity access control for brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity {
    /// Configuration block for specifying a client authentication. See below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientAuthentication")]
    #[builder(default)]
    pub client_authentication: Option<ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication>,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl
{
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// A block that contains information about storage volumes attached to MSK broker nodes. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfo {
    /// A block that contains EBS volume information. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ebsStorageInfo"
    )]
    #[builder(default)]
    pub ebs_storage_info:
        Option<ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo>,
}

/// A block that contains EBS volume information. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
    /// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "provisionedThroughput"
    )]
    #[builder(default)]
    pub provisioned_throughput: Option<
        ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput,
    >,
    /// The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of 1 and maximum value of 16384.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeSize"
    )]
    #[builder(default)]
    pub volume_size: Option<f64>,
}

/// A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput
{
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is 250. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following documentation on throughput bottlenecks
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeThroughput"
    )]
    #[builder(default)]
    pub volume_throughput: Option<f64>,
}

/// Configuration block for specifying a client authentication. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderClientAuthentication {
    /// SASL authentication type details for VPC connectivity. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sasl: Option<ClusterStatusAtProviderClientAuthenticationSasl>,
    /// Enables TLS authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tls: Option<ClusterStatusAtProviderClientAuthenticationTls>,
    /// Enables unauthenticated access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub unauthenticated: Option<bool>,
}

/// SASL authentication type details for VPC connectivity. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderClientAuthenticationSasl {
    /// Enables SASL/IAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iam: Option<bool>,
    /// Enables SASL/SCRAM authentication for VPC connectivity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scram: Option<bool>,
}

/// Enables TLS authentication for VPC connectivity.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderClientAuthenticationTls {
    /// List of ACM Certificate Authority Amazon Resource Names (ARNs).
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "certificateAuthorityArns"
    )]
    #[builder(default)]
    pub certificate_authority_arns: Option<Vec<String>>,
}

/// Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderConfigurationInfo {
    /// Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// Revision of the MSK Configuration to use in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<f64>,
}

/// Configuration block for specifying encryption. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderEncryptionInfo {
    /// The ARN of the KMS key used for encryption at rest of the broker data volumes.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionAtRestKmsKeyArn"
    )]
    #[builder(default)]
    pub encryption_at_rest_kms_key_arn: Option<String>,
    /// Configuration block to specify encryption in transit. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionInTransit"
    )]
    #[builder(default)]
    pub encryption_in_transit: Option<ClusterStatusAtProviderEncryptionInfoEncryptionInTransit>,
}

/// Configuration block to specify encryption in transit. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderEncryptionInfoEncryptionInTransit {
    /// Encryption setting for data in transit between clients and brokers. Valid values: TLS, TLS_PLAINTEXT, and PLAINTEXT. Default value is TLS.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientBroker"
    )]
    #[builder(default)]
    pub client_broker: Option<String>,
    /// Whether data communication among broker nodes is encrypted. Default value: true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inCluster")]
    #[builder(default)]
    pub in_cluster: Option<bool>,
}

/// Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderLoggingInfo {
    /// Configuration block for Broker Logs settings for logging info. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "brokerLogs"
    )]
    #[builder(default)]
    pub broker_logs: Option<ClusterStatusAtProviderLoggingInfoBrokerLogs>,
}

/// Configuration block for Broker Logs settings for logging info. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderLoggingInfoBrokerLogs {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cloudwatchLogs"
    )]
    #[builder(default)]
    pub cloudwatch_logs: Option<ClusterStatusAtProviderLoggingInfoBrokerLogsCloudwatchLogs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub firehose: Option<ClusterStatusAtProviderLoggingInfoBrokerLogsFirehose>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub s3: Option<ClusterStatusAtProviderLoggingInfoBrokerLogsS3>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderLoggingInfoBrokerLogsCloudwatchLogs {
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Name of the Cloudwatch Log Group to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroup")]
    #[builder(default)]
    pub log_group: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderLoggingInfoBrokerLogsFirehose {
    /// Name of the Kinesis Data Firehose delivery stream to deliver logs to.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deliveryStream"
    )]
    #[builder(default)]
    pub delivery_stream: Option<String>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderLoggingInfoBrokerLogsS3 {
    /// Name of the S3 bucket to deliver logs to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Controls whether provisioned throughput is enabled or not. Default value: false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Prefix to append to the folder name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prefix: Option<String>,
}

/// Configuration block for JMX and Node monitoring for the MSK cluster. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderOpenMonitoring {
    /// Configuration block for Prometheus settings for open monitoring. See below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prometheus: Option<ClusterStatusAtProviderOpenMonitoringPrometheus>,
}

/// Configuration block for Prometheus settings for open monitoring. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderOpenMonitoringPrometheus {
    /// Configuration block for JMX Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "jmxExporter"
    )]
    #[builder(default)]
    pub jmx_exporter: Option<ClusterStatusAtProviderOpenMonitoringPrometheusJmxExporter>,
    /// Configuration block for Node Exporter. See below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeExporter"
    )]
    #[builder(default)]
    pub node_exporter: Option<ClusterStatusAtProviderOpenMonitoringPrometheusNodeExporter>,
}

/// Configuration block for JMX Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderOpenMonitoringPrometheusJmxExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}

/// Configuration block for Node Exporter. See below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct ClusterStatusAtProviderOpenMonitoringPrometheusNodeExporter {
    /// Indicates whether you want to enable or disable the JMX Exporter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "enabledInBroker"
    )]
    #[builder(default)]
    pub enabled_in_broker: Option<bool>,
}
