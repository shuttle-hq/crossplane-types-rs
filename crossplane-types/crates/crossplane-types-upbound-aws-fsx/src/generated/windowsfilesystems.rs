// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// WindowsFileSystemSpec defines the desired state of WindowsFileSystem
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "fsx.aws.upbound.io", version = "v1beta2", kind = "WindowsFileSystem", plural = "windowsfilesystems")]
#[kube(status = "WindowsFileSystemStatus")]
pub struct WindowsFileSystemSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<WindowsFileSystemDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: WindowsFileSystemForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<WindowsFileSystemInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<WindowsFileSystemProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<WindowsFileSystemPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<WindowsFileSystemWriteConnectionSecretToRef>,
}

/// WindowsFileSystemSpec defines the desired state of WindowsFileSystem
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProvider {
    /// The ID for an existing Microsoft Active Directory instance that the file system should join when it's created. Cannot be specified with self_managed_active_directory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryId")]
    #[builder(default)]
    pub active_directory_id: Option<String>,
    /// Reference to a Directory in ds to populate activeDirectoryId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryIdRef")]
    #[builder(default)]
    pub active_directory_id_ref: Option<WindowsFileSystemForProviderActiveDirectoryIdRef>,
    /// Selector for a Directory in ds to populate activeDirectoryId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryIdSelector")]
    #[builder(default)]
    pub active_directory_id_selector: Option<WindowsFileSystemForProviderActiveDirectoryIdSelector>,
    /// An array DNS alias names that you want to associate with the Amazon FSx file system.  For more information, see Working with DNS Aliases
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aliases: Option<Vec<String>>,
    /// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogConfiguration")]
    #[builder(default)]
    pub audit_log_configuration: Option<WindowsFileSystemForProviderAuditLogConfiguration>,
    /// The number of days to retain automatic backups. Minimum of 0 and maximum of 90. Defaults to 7. Set to 0 to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticBackupRetentionDays")]
    #[builder(default)]
    pub automatic_backup_retention_days: Option<f64>,
    /// The ID of the source backup to create the filesystem from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupId")]
    #[builder(default)]
    pub backup_id: Option<String>,
    /// A boolean flag indicating whether tags on the file system should be copied to backups. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTagsToBackups")]
    #[builder(default)]
    pub copy_tags_to_backups: Option<bool>,
    /// The preferred time (in HH:MM format) to take daily automatic backups, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyAutomaticBackupStartTime")]
    #[builder(default)]
    pub daily_automatic_backup_start_time: Option<String>,
    /// Specifies the file system deployment type, valid values are MULTI_AZ_1, SINGLE_AZ_1 and SINGLE_AZ_2. Default value is SINGLE_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentType")]
    #[builder(default)]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskIopsConfiguration")]
    #[builder(default)]
    pub disk_iops_configuration: Option<WindowsFileSystemForProviderDiskIopsConfiguration>,
    /// A map of tags to apply to the file system's final backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalBackupTags")]
    #[builder(default)]
    pub final_backup_tags: Option<HashMap<String, String>>,
    /// ARN for the KMS Key to encrypt the file system at rest. Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdRef")]
    #[builder(default)]
    pub kms_key_id_ref: Option<WindowsFileSystemForProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdSelector")]
    #[builder(default)]
    pub kms_key_id_selector: Option<WindowsFileSystemForProviderKmsKeyIdSelector>,
    /// Specifies the subnet in which you want the preferred file server to be located. Required for when deployment type is MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredSubnetId")]
    #[builder(default)]
    pub preferred_subnet_id: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIdRefs")]
    #[builder(default)]
    pub security_group_id_refs: Option<Vec<WindowsFileSystemForProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIdSelector")]
    #[builder(default)]
    pub security_group_id_selector: Option<WindowsFileSystemForProviderSecurityGroupIdSelector>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIds")]
    #[builder(default)]
    pub security_group_ids: Option<Vec<String>>,
    /// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfManagedActiveDirectory")]
    #[builder(default)]
    pub self_managed_active_directory: Option<WindowsFileSystemForProviderSelfManagedActiveDirectory>,
    /// When enabled, will skip the default final backup taken when the file system is deleted. This configuration must be applied separately before attempting to delete the resource to have the desired behavior. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipFinalBackup")]
    #[builder(default)]
    pub skip_final_backup: Option<bool>,
    /// Storage capacity (GiB) of the file system. Minimum of 32 and maximum of 65536. If the storage type is set to HDD the minimum value is 2000. Required when not creating filesystem for a backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageCapacity")]
    #[builder(default)]
    pub storage_capacity: Option<f64>,
    /// Specifies the storage type, Valid values are SSD and HDD. HDD is supported on SINGLE_AZ_2 and MULTI_AZ_1 Windows file system deployment types. Default value is SSD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageType")]
    #[builder(default)]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdRefs")]
    #[builder(default)]
    pub subnet_id_refs: Option<Vec<WindowsFileSystemForProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdSelector")]
    #[builder(default)]
    pub subnet_id_selector: Option<WindowsFileSystemForProviderSubnetIdSelector>,
    /// A list of IDs for the subnets that the file system will be accessible from. To specify more than a single subnet set deployment_type to MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Throughput (megabytes per second) of the file system. For valid values, refer to the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputCapacity")]
    #[builder(default)]
    pub throughput_capacity: Option<f64>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklyMaintenanceStartTime")]
    #[builder(default)]
    pub weekly_maintenance_start_time: Option<String>,
}

/// Reference to a Directory in ds to populate activeDirectoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderActiveDirectoryIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderActiveDirectoryIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderActiveDirectoryIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderActiveDirectoryIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderActiveDirectoryIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderActiveDirectoryIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderActiveDirectoryIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Directory in ds to populate activeDirectoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderActiveDirectoryIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderActiveDirectoryIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderAuditLogConfiguration {
    /// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when file_access_audit_log_level and file_share_access_audit_log_level are not set to DISABLED. The name of the Amazon CloudWatch Logs log group must begin with the /aws/fsx prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the aws-fsx prefix. If you do not provide a destination in audit_log_destionation, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogDestination")]
    #[builder(default)]
    pub audit_log_destination: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileAccessAuditLogLevel")]
    #[builder(default)]
    pub file_access_audit_log_level: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileShareAccessAuditLogLevel")]
    #[builder(default)]
    pub file_share_access_audit_log_level: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderDiskIopsConfiguration {
    /// The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSelfManagedActiveDirectory {
    /// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in RFC 1918.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsIps")]
    #[builder(default)]
    pub dns_ips: Option<Vec<String>>,
    /// The fully qualified domain name of the self-managed AD directory. For example, corp.example.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    #[builder(default)]
    pub domain_name: Option<String>,
    /// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to Domain Admins.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemAdministratorsGroup")]
    #[builder(default)]
    pub file_system_administrators_group: Option<String>,
    /// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, OU=FSx,DC=yourdomain,DC=corp,DC=com. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see RFC 2253.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "organizationalUnitDistinguishedName")]
    #[builder(default)]
    pub organizational_unit_distinguished_name: Option<String>,
    /// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    #[builder(default)]
    pub password_secret_ref: Option<WindowsFileSystemForProviderSelfManagedActiveDirectoryPasswordSecretRef>,
    /// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
}

/// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSelfManagedActiveDirectoryPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemForProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemForProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemForProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemForProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemForProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProvider {
    /// The ID for an existing Microsoft Active Directory instance that the file system should join when it's created. Cannot be specified with self_managed_active_directory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryId")]
    #[builder(default)]
    pub active_directory_id: Option<String>,
    /// Reference to a Directory in ds to populate activeDirectoryId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryIdRef")]
    #[builder(default)]
    pub active_directory_id_ref: Option<WindowsFileSystemInitProviderActiveDirectoryIdRef>,
    /// Selector for a Directory in ds to populate activeDirectoryId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryIdSelector")]
    #[builder(default)]
    pub active_directory_id_selector: Option<WindowsFileSystemInitProviderActiveDirectoryIdSelector>,
    /// An array DNS alias names that you want to associate with the Amazon FSx file system.  For more information, see Working with DNS Aliases
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aliases: Option<Vec<String>>,
    /// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogConfiguration")]
    #[builder(default)]
    pub audit_log_configuration: Option<WindowsFileSystemInitProviderAuditLogConfiguration>,
    /// The number of days to retain automatic backups. Minimum of 0 and maximum of 90. Defaults to 7. Set to 0 to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticBackupRetentionDays")]
    #[builder(default)]
    pub automatic_backup_retention_days: Option<f64>,
    /// The ID of the source backup to create the filesystem from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupId")]
    #[builder(default)]
    pub backup_id: Option<String>,
    /// A boolean flag indicating whether tags on the file system should be copied to backups. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTagsToBackups")]
    #[builder(default)]
    pub copy_tags_to_backups: Option<bool>,
    /// The preferred time (in HH:MM format) to take daily automatic backups, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyAutomaticBackupStartTime")]
    #[builder(default)]
    pub daily_automatic_backup_start_time: Option<String>,
    /// Specifies the file system deployment type, valid values are MULTI_AZ_1, SINGLE_AZ_1 and SINGLE_AZ_2. Default value is SINGLE_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentType")]
    #[builder(default)]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskIopsConfiguration")]
    #[builder(default)]
    pub disk_iops_configuration: Option<WindowsFileSystemInitProviderDiskIopsConfiguration>,
    /// A map of tags to apply to the file system's final backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalBackupTags")]
    #[builder(default)]
    pub final_backup_tags: Option<HashMap<String, String>>,
    /// ARN for the KMS Key to encrypt the file system at rest. Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// Reference to a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdRef")]
    #[builder(default)]
    pub kms_key_id_ref: Option<WindowsFileSystemInitProviderKmsKeyIdRef>,
    /// Selector for a Key in kms to populate kmsKeyId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyIdSelector")]
    #[builder(default)]
    pub kms_key_id_selector: Option<WindowsFileSystemInitProviderKmsKeyIdSelector>,
    /// Specifies the subnet in which you want the preferred file server to be located. Required for when deployment type is MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredSubnetId")]
    #[builder(default)]
    pub preferred_subnet_id: Option<String>,
    /// References to SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIdRefs")]
    #[builder(default)]
    pub security_group_id_refs: Option<Vec<WindowsFileSystemInitProviderSecurityGroupIdRefs>>,
    /// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIdSelector")]
    #[builder(default)]
    pub security_group_id_selector: Option<WindowsFileSystemInitProviderSecurityGroupIdSelector>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIds")]
    #[builder(default)]
    pub security_group_ids: Option<Vec<String>>,
    /// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfManagedActiveDirectory")]
    #[builder(default)]
    pub self_managed_active_directory: Option<WindowsFileSystemInitProviderSelfManagedActiveDirectory>,
    /// When enabled, will skip the default final backup taken when the file system is deleted. This configuration must be applied separately before attempting to delete the resource to have the desired behavior. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipFinalBackup")]
    #[builder(default)]
    pub skip_final_backup: Option<bool>,
    /// Storage capacity (GiB) of the file system. Minimum of 32 and maximum of 65536. If the storage type is set to HDD the minimum value is 2000. Required when not creating filesystem for a backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageCapacity")]
    #[builder(default)]
    pub storage_capacity: Option<f64>,
    /// Specifies the storage type, Valid values are SSD and HDD. HDD is supported on SINGLE_AZ_2 and MULTI_AZ_1 Windows file system deployment types. Default value is SSD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageType")]
    #[builder(default)]
    pub storage_type: Option<String>,
    /// References to Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdRefs")]
    #[builder(default)]
    pub subnet_id_refs: Option<Vec<WindowsFileSystemInitProviderSubnetIdRefs>>,
    /// Selector for a list of Subnet in ec2 to populate subnetIds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIdSelector")]
    #[builder(default)]
    pub subnet_id_selector: Option<WindowsFileSystemInitProviderSubnetIdSelector>,
    /// A list of IDs for the subnets that the file system will be accessible from. To specify more than a single subnet set deployment_type to MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Throughput (megabytes per second) of the file system. For valid values, refer to the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputCapacity")]
    #[builder(default)]
    pub throughput_capacity: Option<f64>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklyMaintenanceStartTime")]
    #[builder(default)]
    pub weekly_maintenance_start_time: Option<String>,
}

/// Reference to a Directory in ds to populate activeDirectoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderActiveDirectoryIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderActiveDirectoryIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderActiveDirectoryIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderActiveDirectoryIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderActiveDirectoryIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderActiveDirectoryIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderActiveDirectoryIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Directory in ds to populate activeDirectoryId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderActiveDirectoryIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderActiveDirectoryIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderAuditLogConfiguration {
    /// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when file_access_audit_log_level and file_share_access_audit_log_level are not set to DISABLED. The name of the Amazon CloudWatch Logs log group must begin with the /aws/fsx prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the aws-fsx prefix. If you do not provide a destination in audit_log_destionation, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogDestination")]
    #[builder(default)]
    pub audit_log_destination: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileAccessAuditLogLevel")]
    #[builder(default)]
    pub file_access_audit_log_level: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileShareAccessAuditLogLevel")]
    #[builder(default)]
    pub file_share_access_audit_log_level: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderDiskIopsConfiguration {
    /// The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Reference to a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderKmsKeyIdRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderKmsKeyIdRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderKmsKeyIdRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderKmsKeyIdRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderKmsKeyIdRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderKmsKeyIdRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderKmsKeyIdRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Key in kms to populate kmsKeyId.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderKmsKeyIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderKmsKeyIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderKmsKeyIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderKmsKeyIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderKmsKeyIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderKmsKeyIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderKmsKeyIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSecurityGroupIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderSecurityGroupIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSecurityGroupIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderSecurityGroupIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderSecurityGroupIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSecurityGroupIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSecurityGroupIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSecurityGroupIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSecurityGroupIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSelfManagedActiveDirectory {
    /// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in RFC 1918.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsIps")]
    #[builder(default)]
    pub dns_ips: Option<Vec<String>>,
    /// The fully qualified domain name of the self-managed AD directory. For example, corp.example.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    #[builder(default)]
    pub domain_name: Option<String>,
    /// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to Domain Admins.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemAdministratorsGroup")]
    #[builder(default)]
    pub file_system_administrators_group: Option<String>,
    /// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, OU=FSx,DC=yourdomain,DC=corp,DC=com. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see RFC 2253.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "organizationalUnitDistinguishedName")]
    #[builder(default)]
    pub organizational_unit_distinguished_name: Option<String>,
    /// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
    #[serde(rename = "passwordSecretRef")]
    pub password_secret_ref: WindowsFileSystemInitProviderSelfManagedActiveDirectoryPasswordSecretRef,
    /// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
}

/// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSelfManagedActiveDirectoryPasswordSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// A Reference to a named object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSubnetIdRefs {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderSubnetIdRefsPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSubnetIdRefsPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderSubnetIdRefsPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderSubnetIdRefsPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSubnetIdRefsPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSubnetIdRefsPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a list of Subnet in ec2 to populate subnetIds.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSubnetIdSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemInitProviderSubnetIdSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemInitProviderSubnetIdSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemInitProviderSubnetIdSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemInitProviderSubnetIdSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSubnetIdSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemInitProviderSubnetIdSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<WindowsFileSystemPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<WindowsFileSystemPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<WindowsFileSystemPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<WindowsFileSystemPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<WindowsFileSystemPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum WindowsFileSystemPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// WindowsFileSystemStatus defines the observed state of WindowsFileSystem.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<WindowsFileSystemStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemStatusAtProvider {
    /// The ID for an existing Microsoft Active Directory instance that the file system should join when it's created. Cannot be specified with self_managed_active_directory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDirectoryId")]
    #[builder(default)]
    pub active_directory_id: Option<String>,
    /// An array DNS alias names that you want to associate with the Amazon FSx file system.  For more information, see Working with DNS Aliases
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub aliases: Option<Vec<String>>,
    /// Amazon Resource Name of the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogConfiguration")]
    #[builder(default)]
    pub audit_log_configuration: Option<WindowsFileSystemStatusAtProviderAuditLogConfiguration>,
    /// The number of days to retain automatic backups. Minimum of 0 and maximum of 90. Defaults to 7. Set to 0 to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticBackupRetentionDays")]
    #[builder(default)]
    pub automatic_backup_retention_days: Option<f64>,
    /// The ID of the source backup to create the filesystem from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupId")]
    #[builder(default)]
    pub backup_id: Option<String>,
    /// A boolean flag indicating whether tags on the file system should be copied to backups. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "copyTagsToBackups")]
    #[builder(default)]
    pub copy_tags_to_backups: Option<bool>,
    /// The preferred time (in HH:MM format) to take daily automatic backups, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dailyAutomaticBackupStartTime")]
    #[builder(default)]
    pub daily_automatic_backup_start_time: Option<String>,
    /// Specifies the file system deployment type, valid values are MULTI_AZ_1, SINGLE_AZ_1 and SINGLE_AZ_2. Default value is SINGLE_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentType")]
    #[builder(default)]
    pub deployment_type: Option<String>,
    /// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskIopsConfiguration")]
    #[builder(default)]
    pub disk_iops_configuration: Option<WindowsFileSystemStatusAtProviderDiskIopsConfiguration>,
    /// DNS name for the file system, e.g., fs-12345678.corp.example.com (domain name matching the Active Directory domain name)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    #[builder(default)]
    pub dns_name: Option<String>,
    /// A map of tags to apply to the file system's final backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalBackupTags")]
    #[builder(default)]
    pub final_backup_tags: Option<HashMap<String, String>>,
    /// Identifier of the file system (e.g. fs-12345678).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// ARN for the KMS Key to encrypt the file system at rest. Defaults to an AWS managed KMS Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyId")]
    #[builder(default)]
    pub kms_key_id: Option<String>,
    /// Set of Elastic Network Interface identifiers from which the file system is accessible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterfaceIds")]
    #[builder(default)]
    pub network_interface_ids: Option<Vec<String>>,
    /// AWS account identifier that created the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerId")]
    #[builder(default)]
    pub owner_id: Option<String>,
    /// The IP address of the primary, or preferred, file server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredFileServerIp")]
    #[builder(default)]
    pub preferred_file_server_ip: Option<String>,
    /// Specifies the subnet in which you want the preferred file server to be located. Required for when deployment type is MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredSubnetId")]
    #[builder(default)]
    pub preferred_subnet_id: Option<String>,
    /// For MULTI_AZ_1 deployment types, use this endpoint when performing administrative tasks on the file system using Amazon FSx Remote PowerShell. For SINGLE_AZ_1 deployment types, this is the DNS name of the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAdministrationEndpoint")]
    #[builder(default)]
    pub remote_administration_endpoint: Option<String>,
    /// A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIds")]
    #[builder(default)]
    pub security_group_ids: Option<Vec<String>>,
    /// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfManagedActiveDirectory")]
    #[builder(default)]
    pub self_managed_active_directory: Option<WindowsFileSystemStatusAtProviderSelfManagedActiveDirectory>,
    /// When enabled, will skip the default final backup taken when the file system is deleted. This configuration must be applied separately before attempting to delete the resource to have the desired behavior. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipFinalBackup")]
    #[builder(default)]
    pub skip_final_backup: Option<bool>,
    /// Storage capacity (GiB) of the file system. Minimum of 32 and maximum of 65536. If the storage type is set to HDD the minimum value is 2000. Required when not creating filesystem for a backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageCapacity")]
    #[builder(default)]
    pub storage_capacity: Option<f64>,
    /// Specifies the storage type, Valid values are SSD and HDD. HDD is supported on SINGLE_AZ_2 and MULTI_AZ_1 Windows file system deployment types. Default value is SSD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageType")]
    #[builder(default)]
    pub storage_type: Option<String>,
    /// A list of IDs for the subnets that the file system will be accessible from. To specify more than a single subnet set deployment_type to MULTI_AZ_1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIds")]
    #[builder(default)]
    pub subnet_ids: Option<Vec<String>>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// Throughput (megabytes per second) of the file system. For valid values, refer to the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throughputCapacity")]
    #[builder(default)]
    pub throughput_capacity: Option<f64>,
    /// Identifier of the Virtual Private Cloud for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcId")]
    #[builder(default)]
    pub vpc_id: Option<String>,
    /// The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weeklyMaintenanceStartTime")]
    #[builder(default)]
    pub weekly_maintenance_start_time: Option<String>,
}

/// The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See audit_log_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemStatusAtProviderAuditLogConfiguration {
    /// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when file_access_audit_log_level and file_share_access_audit_log_level are not set to DISABLED. The name of the Amazon CloudWatch Logs log group must begin with the /aws/fsx prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the aws-fsx prefix. If you do not provide a destination in audit_log_destionation, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditLogDestination")]
    #[builder(default)]
    pub audit_log_destination: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileAccessAuditLogLevel")]
    #[builder(default)]
    pub file_access_audit_log_level: Option<String>,
    /// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileShareAccessAuditLogLevel")]
    #[builder(default)]
    pub file_share_access_audit_log_level: Option<String>,
}

/// The SSD IOPS configuration for the Amazon FSx for Windows File Server file system. See disk_iops_configuration Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemStatusAtProviderDiskIopsConfiguration {
    /// The total number of SSD IOPS provisioned for the file system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub iops: Option<f64>,
    /// Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. See self_managed_active_directory Block for details.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct WindowsFileSystemStatusAtProviderSelfManagedActiveDirectory {
    /// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in RFC 1918.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsIps")]
    #[builder(default)]
    pub dns_ips: Option<Vec<String>>,
    /// The fully qualified domain name of the self-managed AD directory. For example, corp.example.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    #[builder(default)]
    pub domain_name: Option<String>,
    /// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to Domain Admins.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSystemAdministratorsGroup")]
    #[builder(default)]
    pub file_system_administrators_group: Option<String>,
    /// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, OU=FSx,DC=yourdomain,DC=corp,DC=com. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see RFC 2253.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "organizationalUnitDistinguishedName")]
    #[builder(default)]
    pub organizational_unit_distinguished_name: Option<String>,
    /// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub username: Option<String>,
}

