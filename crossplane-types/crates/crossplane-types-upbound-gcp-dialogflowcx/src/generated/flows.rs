// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// FlowSpec defines the desired state of Flow
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "dialogflowcx.gcp.upbound.io", version = "v1beta2", kind = "Flow", plural = "flows")]
#[kube(status = "FlowStatus")]
pub struct FlowSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<FlowDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: FlowForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<FlowInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<FlowProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<FlowPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<FlowWriteConnectionSecretToRef>,
}

/// FlowSpec defines the desired state of Flow
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProvider {
    /// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
    /// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedSettings")]
    #[builder(default)]
    pub advanced_settings: Option<FlowForProviderAdvancedSettings>,
    /// The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The human-readable name of the flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// A flow's event handlers serve two purposes:
    /// They are responsible for handling events (e.g. no match, webhook errors) in the flow.
    /// They are inherited by every page's [event handlers][Page.event_handlers], which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow.
    /// Unlike transitionRoutes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventHandlers")]
    #[builder(default)]
    pub event_handlers: Option<Vec<FlowForProviderEventHandlers>>,
    /// Marks this as the Default Start Flow for an agent. When you create an agent, the Default Start Flow is created automatically.
    /// The Default Start Flow cannot be deleted; deleting the google_dialogflow_cx_flow resource does nothing to the underlying GCP resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isDefaultStartFlow")]
    #[builder(default)]
    pub is_default_start_flow: Option<bool>,
    /// The language of the following fields in flow:
    /// Flow.event_handlers.trigger_fulfillment.messages
    /// Flow.event_handlers.trigger_fulfillment.conditional_cases
    /// Flow.transition_routes.trigger_fulfillment.messages
    /// Flow.transition_routes.trigger_fulfillment.conditional_cases
    /// If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "languageCode")]
    #[builder(default)]
    pub language_code: Option<String>,
    /// NLU related settings of the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nluSettings")]
    #[builder(default)]
    pub nlu_settings: Option<FlowForProviderNluSettings>,
    /// The agent to create a flow for.
    /// Format: projects//locations//agents/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// Reference to a Agent in dialogflowcx to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentRef")]
    #[builder(default)]
    pub parent_ref: Option<FlowForProviderParentRef>,
    /// Selector for a Agent in dialogflowcx to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentSelector")]
    #[builder(default)]
    pub parent_selector: Option<FlowForProviderParentSelector>,
    /// A flow's transition route group serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition route groups][Page.transition_route_groups]. Transition route groups defined in the page have higher priority than those defined in the flow.
    /// Format:projects//locations//agents//flows//transitionRouteGroups/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRouteGroups")]
    #[builder(default)]
    pub transition_route_groups: Option<Vec<String>>,
    /// A flow's transition routes serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition routes][Page.transition_routes] and can support use cases such as the user saying "help" or "can I talk to a human?", which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow.
    /// TransitionRoutes are evalauted in the following order:
    /// TransitionRoutes with intent specified.
    /// TransitionRoutes with only condition specified.
    /// TransitionRoutes with intent specified are inherited by pages in the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRoutes")]
    #[builder(default)]
    pub transition_routes: Option<Vec<FlowForProviderTransitionRoutes>>,
}

/// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
/// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderAdvancedSettings {
    /// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioExportGcsDestination")]
    #[builder(default)]
    pub audio_export_gcs_destination: Option<FlowForProviderAdvancedSettingsAudioExportGcsDestination>,
    /// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dtmfSettings")]
    #[builder(default)]
    pub dtmf_settings: Option<FlowForProviderAdvancedSettingsDtmfSettings>,
}

/// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderAdvancedSettingsAudioExportGcsDestination {
    /// The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
    /// Format: gs://bucket/object-name-or-prefix
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderAdvancedSettingsDtmfSettings {
    /// If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The digit that terminates a DTMF digit sequence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishDigit")]
    #[builder(default)]
    pub finish_digit: Option<String>,
    /// Max length of DTMF digits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDigits")]
    #[builder(default)]
    pub max_digits: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlers {
    /// The name of the event to handle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub event: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowForProviderEventHandlersTriggerFulfillment>,
}

/// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowForProviderEventHandlersTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowForProviderEventHandlersTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowForProviderEventHandlersTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowForProviderEventHandlersTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText {
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesPlayAudio {
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentMessagesText {
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderEventHandlersTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// NLU related settings of the flow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderNluSettings {
    /// To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
    /// If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classificationThreshold")]
    #[builder(default)]
    pub classification_threshold: Option<f64>,
    /// Indicates NLU model training mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelTrainingMode")]
    #[builder(default)]
    pub model_training_mode: Option<String>,
    /// Indicates the type of NLU model.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelType")]
    #[builder(default)]
    pub model_type: Option<String>,
}

/// Reference to a Agent in dialogflowcx to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderParentRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowForProviderParentRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderParentRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowForProviderParentRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowForProviderParentRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderParentRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderParentRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Agent in dialogflowcx to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderParentSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowForProviderParentSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderParentSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowForProviderParentSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowForProviderParentSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderParentSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderParentSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutes {
    /// The condition to evaluate against form parameters or session parameters.
    /// At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<String>,
    /// The unique identifier of an Intent.
    /// Format: projects//locations//agents//intents/. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub intent: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// Reference to a Agent in dialogflowcx to populate targetFlow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlowRef")]
    #[builder(default)]
    pub target_flow_ref: Option<FlowForProviderTransitionRoutesTargetFlowRef>,
    /// Selector for a Agent in dialogflowcx to populate targetFlow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlowSelector")]
    #[builder(default)]
    pub target_flow_selector: Option<FlowForProviderTransitionRoutesTargetFlowSelector>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowForProviderTransitionRoutesTriggerFulfillment>,
}

/// Reference to a Agent in dialogflowcx to populate targetFlow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTargetFlowRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowForProviderTransitionRoutesTargetFlowRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTargetFlowRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowForProviderTransitionRoutesTargetFlowRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowForProviderTransitionRoutesTargetFlowRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderTransitionRoutesTargetFlowRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderTransitionRoutesTargetFlowRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Agent in dialogflowcx to populate targetFlow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTargetFlowSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowForProviderTransitionRoutesTargetFlowSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTargetFlowSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowForProviderTransitionRoutesTargetFlowSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowForProviderTransitionRoutesTargetFlowSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderTransitionRoutesTargetFlowSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowForProviderTransitionRoutesTargetFlowSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowForProviderTransitionRoutesTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowForProviderTransitionRoutesTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowForProviderTransitionRoutesTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowForProviderTransitionRoutesTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText {
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio {
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentMessagesText {
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowForProviderTransitionRoutesTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProvider {
    /// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
    /// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedSettings")]
    #[builder(default)]
    pub advanced_settings: Option<FlowInitProviderAdvancedSettings>,
    /// The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The human-readable name of the flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// A flow's event handlers serve two purposes:
    /// They are responsible for handling events (e.g. no match, webhook errors) in the flow.
    /// They are inherited by every page's [event handlers][Page.event_handlers], which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow.
    /// Unlike transitionRoutes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventHandlers")]
    #[builder(default)]
    pub event_handlers: Option<Vec<FlowInitProviderEventHandlers>>,
    /// Marks this as the Default Start Flow for an agent. When you create an agent, the Default Start Flow is created automatically.
    /// The Default Start Flow cannot be deleted; deleting the google_dialogflow_cx_flow resource does nothing to the underlying GCP resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isDefaultStartFlow")]
    #[builder(default)]
    pub is_default_start_flow: Option<bool>,
    /// The language of the following fields in flow:
    /// Flow.event_handlers.trigger_fulfillment.messages
    /// Flow.event_handlers.trigger_fulfillment.conditional_cases
    /// Flow.transition_routes.trigger_fulfillment.messages
    /// Flow.transition_routes.trigger_fulfillment.conditional_cases
    /// If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "languageCode")]
    #[builder(default)]
    pub language_code: Option<String>,
    /// NLU related settings of the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nluSettings")]
    #[builder(default)]
    pub nlu_settings: Option<FlowInitProviderNluSettings>,
    /// The agent to create a flow for.
    /// Format: projects//locations//agents/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// Reference to a Agent in dialogflowcx to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentRef")]
    #[builder(default)]
    pub parent_ref: Option<FlowInitProviderParentRef>,
    /// Selector for a Agent in dialogflowcx to populate parent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentSelector")]
    #[builder(default)]
    pub parent_selector: Option<FlowInitProviderParentSelector>,
    /// A flow's transition route group serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition route groups][Page.transition_route_groups]. Transition route groups defined in the page have higher priority than those defined in the flow.
    /// Format:projects//locations//agents//flows//transitionRouteGroups/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRouteGroups")]
    #[builder(default)]
    pub transition_route_groups: Option<Vec<String>>,
    /// A flow's transition routes serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition routes][Page.transition_routes] and can support use cases such as the user saying "help" or "can I talk to a human?", which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow.
    /// TransitionRoutes are evalauted in the following order:
    /// TransitionRoutes with intent specified.
    /// TransitionRoutes with only condition specified.
    /// TransitionRoutes with intent specified are inherited by pages in the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRoutes")]
    #[builder(default)]
    pub transition_routes: Option<Vec<FlowInitProviderTransitionRoutes>>,
}

/// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
/// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderAdvancedSettings {
    /// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioExportGcsDestination")]
    #[builder(default)]
    pub audio_export_gcs_destination: Option<FlowInitProviderAdvancedSettingsAudioExportGcsDestination>,
    /// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dtmfSettings")]
    #[builder(default)]
    pub dtmf_settings: Option<FlowInitProviderAdvancedSettingsDtmfSettings>,
}

/// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderAdvancedSettingsAudioExportGcsDestination {
    /// The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
    /// Format: gs://bucket/object-name-or-prefix
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderAdvancedSettingsDtmfSettings {
    /// If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The digit that terminates a DTMF digit sequence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishDigit")]
    #[builder(default)]
    pub finish_digit: Option<String>,
    /// Max length of DTMF digits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDigits")]
    #[builder(default)]
    pub max_digits: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlers {
    /// The name of the event to handle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub event: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowInitProviderEventHandlersTriggerFulfillment>,
}

/// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowInitProviderEventHandlersTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowInitProviderEventHandlersTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowInitProviderEventHandlersTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowInitProviderEventHandlersTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText {
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesPlayAudio {
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentMessagesText {
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderEventHandlersTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// NLU related settings of the flow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderNluSettings {
    /// To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
    /// If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classificationThreshold")]
    #[builder(default)]
    pub classification_threshold: Option<f64>,
    /// Indicates NLU model training mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelTrainingMode")]
    #[builder(default)]
    pub model_training_mode: Option<String>,
    /// Indicates the type of NLU model.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelType")]
    #[builder(default)]
    pub model_type: Option<String>,
}

/// Reference to a Agent in dialogflowcx to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderParentRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowInitProviderParentRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderParentRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowInitProviderParentRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowInitProviderParentRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderParentRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderParentRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Agent in dialogflowcx to populate parent.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderParentSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowInitProviderParentSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderParentSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowInitProviderParentSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowInitProviderParentSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderParentSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderParentSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutes {
    /// The condition to evaluate against form parameters or session parameters.
    /// At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<String>,
    /// The unique identifier of an Intent.
    /// Format: projects//locations//agents//intents/. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub intent: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// Reference to a Agent in dialogflowcx to populate targetFlow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlowRef")]
    #[builder(default)]
    pub target_flow_ref: Option<FlowInitProviderTransitionRoutesTargetFlowRef>,
    /// Selector for a Agent in dialogflowcx to populate targetFlow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlowSelector")]
    #[builder(default)]
    pub target_flow_selector: Option<FlowInitProviderTransitionRoutesTargetFlowSelector>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowInitProviderTransitionRoutesTriggerFulfillment>,
}

/// Reference to a Agent in dialogflowcx to populate targetFlow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTargetFlowRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowInitProviderTransitionRoutesTargetFlowRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTargetFlowRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowInitProviderTransitionRoutesTargetFlowRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowInitProviderTransitionRoutesTargetFlowRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderTransitionRoutesTargetFlowRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderTransitionRoutesTargetFlowRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Agent in dialogflowcx to populate targetFlow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTargetFlowSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowInitProviderTransitionRoutesTargetFlowSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTargetFlowSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowInitProviderTransitionRoutesTargetFlowSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowInitProviderTransitionRoutesTargetFlowSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderTransitionRoutesTargetFlowSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowInitProviderTransitionRoutesTargetFlowSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowInitProviderTransitionRoutesTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowInitProviderTransitionRoutesTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowInitProviderTransitionRoutesTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText {
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio {
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentMessagesText {
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowInitProviderTransitionRoutesTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<FlowPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<FlowPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FlowPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FlowPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FlowPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FlowPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// FlowStatus defines the observed state of Flow.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<FlowStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProvider {
    /// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
    /// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedSettings")]
    #[builder(default)]
    pub advanced_settings: Option<FlowStatusAtProviderAdvancedSettings>,
    /// The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The human-readable name of the flow.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// A flow's event handlers serve two purposes:
    /// They are responsible for handling events (e.g. no match, webhook errors) in the flow.
    /// They are inherited by every page's [event handlers][Page.event_handlers], which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow.
    /// Unlike transitionRoutes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventHandlers")]
    #[builder(default)]
    pub event_handlers: Option<Vec<FlowStatusAtProviderEventHandlers>>,
    /// an identifier for the resource with format {{parent}}/flows/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Marks this as the Default Start Flow for an agent. When you create an agent, the Default Start Flow is created automatically.
    /// The Default Start Flow cannot be deleted; deleting the google_dialogflow_cx_flow resource does nothing to the underlying GCP resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isDefaultStartFlow")]
    #[builder(default)]
    pub is_default_start_flow: Option<bool>,
    /// The language of the following fields in flow:
    /// Flow.event_handlers.trigger_fulfillment.messages
    /// Flow.event_handlers.trigger_fulfillment.conditional_cases
    /// Flow.transition_routes.trigger_fulfillment.messages
    /// Flow.transition_routes.trigger_fulfillment.conditional_cases
    /// If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "languageCode")]
    #[builder(default)]
    pub language_code: Option<String>,
    /// The unique identifier of the flow.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// NLU related settings of the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nluSettings")]
    #[builder(default)]
    pub nlu_settings: Option<FlowStatusAtProviderNluSettings>,
    /// The agent to create a flow for.
    /// Format: projects//locations//agents/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parent: Option<String>,
    /// A flow's transition route group serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition route groups][Page.transition_route_groups]. Transition route groups defined in the page have higher priority than those defined in the flow.
    /// Format:projects//locations//agents//flows//transitionRouteGroups/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRouteGroups")]
    #[builder(default)]
    pub transition_route_groups: Option<Vec<String>>,
    /// A flow's transition routes serve two purposes:
    /// They are responsible for matching the user's first utterances in the flow.
    /// They are inherited by every page's [transition routes][Page.transition_routes] and can support use cases such as the user saying "help" or "can I talk to a human?", which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow.
    /// TransitionRoutes are evalauted in the following order:
    /// TransitionRoutes with intent specified.
    /// TransitionRoutes with only condition specified.
    /// TransitionRoutes with intent specified are inherited by pages in the flow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitionRoutes")]
    #[builder(default)]
    pub transition_routes: Option<Vec<FlowStatusAtProviderTransitionRoutes>>,
}

/// Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
/// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderAdvancedSettings {
    /// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioExportGcsDestination")]
    #[builder(default)]
    pub audio_export_gcs_destination: Option<FlowStatusAtProviderAdvancedSettingsAudioExportGcsDestination>,
    /// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dtmfSettings")]
    #[builder(default)]
    pub dtmf_settings: Option<FlowStatusAtProviderAdvancedSettingsDtmfSettings>,
}

/// If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderAdvancedSettingsAudioExportGcsDestination {
    /// The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
    /// Format: gs://bucket/object-name-or-prefix
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderAdvancedSettingsDtmfSettings {
    /// If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// The digit that terminates a DTMF digit sequence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishDigit")]
    #[builder(default)]
    pub finish_digit: Option<String>,
    /// Max length of DTMF digits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDigits")]
    #[builder(default)]
    pub max_digits: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlers {
    /// The name of the event to handle.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub event: Option<String>,
    /// (Output)
    /// The unique identifier of this event handler.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowStatusAtProviderEventHandlersTriggerFulfillment>,
}

/// The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowStatusAtProviderEventHandlersTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowStatusAtProviderEventHandlersTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesOutputAudioText {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesPlayAudio {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentMessagesText {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderEventHandlersTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// NLU related settings of the flow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderNluSettings {
    /// To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
    /// If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classificationThreshold")]
    #[builder(default)]
    pub classification_threshold: Option<f64>,
    /// Indicates NLU model training mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelTrainingMode")]
    #[builder(default)]
    pub model_training_mode: Option<String>,
    /// Indicates the type of NLU model.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelType")]
    #[builder(default)]
    pub model_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutes {
    /// The condition to evaluate against form parameters or session parameters.
    /// At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub condition: Option<String>,
    /// The unique identifier of an Intent.
    /// Format: projects//locations//agents//intents/. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub intent: Option<String>,
    /// (Output)
    /// The unique identifier of this transition route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The target flow to transition to.
    /// Format: projects//locations//agents//flows/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetFlow")]
    #[builder(default)]
    pub target_flow: Option<String>,
    /// The target page to transition to.
    /// Format: projects//locations//agents//flows//pages/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPage")]
    #[builder(default)]
    pub target_page: Option<String>,
    /// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerFulfillment")]
    #[builder(default)]
    pub trigger_fulfillment: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillment>,
}

/// The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillment {
    /// Conditional cases for this fulfillment.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalCases")]
    #[builder(default)]
    pub conditional_cases: Option<Vec<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentConditionalCases>>,
    /// The list of rich message responses to present to the user.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessages>>,
    /// Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "returnPartialResponses")]
    #[builder(default)]
    pub return_partial_responses: Option<bool>,
    /// Set parameter values before executing the webhook.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setParameterActions")]
    #[builder(default)]
    pub set_parameter_actions: Option<Vec<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentSetParameterActions>>,
    /// The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
    /// The webhook to call. Format: projects//locations//agents//webhooks/.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub webhook: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentConditionalCases {
    /// A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
    /// See Case for the schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cases: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessages {
    /// The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub channel: Option<String>,
    /// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
    /// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conversationSuccess")]
    #[builder(default)]
    pub conversation_success: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess>,
    /// Indicates that the conversation should be handed off to a live agent.
    /// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
    /// You may set this, for example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "liveAgentHandoff")]
    #[builder(default)]
    pub live_agent_handoff: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff>,
    /// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputAudioText")]
    #[builder(default)]
    pub output_audio_text: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText>,
    /// A custom, platform-specific payload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub payload: Option<String>,
    /// Specifies an audio clip to be played by the client as part of the response.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "playAudio")]
    #[builder(default)]
    pub play_audio: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio>,
    /// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telephonyTransferCall")]
    #[builder(default)]
    pub telephony_transfer_call: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesText>,
}

/// Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
/// Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesConversationSuccess {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// Indicates that the conversation should be handed off to a live agent.
/// Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
/// You may set this, for example:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesLiveAgentHandoff {
    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<String>,
}

/// A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesOutputAudioText {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// The SSML text to be synthesized. For more information, see SSML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ssml: Option<String>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
}

/// Specifies an audio clip to be played by the client as part of the response.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesPlayAudio {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "audioUri")]
    #[builder(default)]
    pub audio_uri: Option<String>,
}

/// Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesTelephonyTransferCall {
    /// Transfer the call to a phone number in E.164 format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    #[builder(default)]
    pub phone_number: Option<String>,
}

/// A collection of text responses.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentMessagesText {
    /// (Output)
    /// Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPlaybackInterruption")]
    #[builder(default)]
    pub allow_playback_interruption: Option<bool>,
    /// A collection of text responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FlowStatusAtProviderTransitionRoutesTriggerFulfillmentSetParameterActions {
    /// Display name of the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameter: Option<String>,
    /// The new JSON-encoded value of the parameter. A null value clears the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

