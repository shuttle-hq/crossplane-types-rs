// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// MetastoreServiceSpec defines the desired state of MetastoreService
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "dataproc.gcp.upbound.io", version = "v1beta2", kind = "MetastoreService", plural = "metastoreservices")]
#[kube(status = "MetastoreServiceStatus")]
pub struct MetastoreServiceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<MetastoreServiceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: MetastoreServiceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<MetastoreServiceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<MetastoreServiceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<MetastoreServicePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<MetastoreServiceWriteConnectionSecretToRef>,
}

/// MetastoreServiceSpec defines the desired state of MetastoreService
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProvider {
    /// The database type that the Metastore service stores its data.
    /// Default value is MYSQL.
    /// Possible values are: MYSQL, SPANNER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseType")]
    #[builder(default)]
    pub database_type: Option<String>,
    /// Information used to configure the Dataproc Metastore service to encrypt
    /// customer data at rest.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    #[builder(default)]
    pub encryption_config: Option<MetastoreServiceForProviderEncryptionConfig>,
    /// Configuration information specific to running Hive metastore software as the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hiveMetastoreConfig")]
    #[builder(default)]
    pub hive_metastore_config: Option<MetastoreServiceForProviderHiveMetastoreConfig>,
    /// User-defined labels for the metastore service.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the metastore service should reside.
    /// The default value is global.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The one hour maintenance window of the metastore service.
    /// This specifies when the service can be restarted for maintenance purposes in UTC time.
    /// Maintenance window is not needed for services with the SPANNER database type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindow")]
    #[builder(default)]
    pub maintenance_window: Option<MetastoreServiceForProviderMaintenanceWindow>,
    /// The setting that defines how metastore metadata should be integrated with external services and systems.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataIntegration")]
    #[builder(default)]
    pub metadata_integration: Option<MetastoreServiceForProviderMetadataIntegration>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The configuration specifying the network settings for the Dataproc Metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<MetastoreServiceForProviderNetworkConfig>,
    /// The TCP port at which the metastore service is reached. Default: 9083.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The release channel of the service. If unspecified, defaults to STABLE.
    /// Default value is STABLE.
    /// Possible values are: CANARY, STABLE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    #[builder(default)]
    pub release_channel: Option<String>,
    /// Represents the scaling configuration of a metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingConfig")]
    #[builder(default)]
    pub scaling_config: Option<MetastoreServiceForProviderScalingConfig>,
    /// The configuration of scheduled backup for the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduledBackup")]
    #[builder(default)]
    pub scheduled_backup: Option<MetastoreServiceForProviderScheduledBackup>,
    /// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telemetryConfig")]
    #[builder(default)]
    pub telemetry_config: Option<MetastoreServiceForProviderTelemetryConfig>,
    /// The tier of the service.
    /// Possible values are: DEVELOPER, ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tier: Option<String>,
}

/// Information used to configure the Dataproc Metastore service to encrypt
/// customer data at rest.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderEncryptionConfig {
    /// The fully qualified customer provided Cloud KMS key name to use for customer data encryption.
    /// Use the following format: projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    #[builder(default)]
    pub kms_key: Option<String>,
    /// Reference to a CryptoKey in kms to populate kmsKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyRef")]
    #[builder(default)]
    pub kms_key_ref: Option<MetastoreServiceForProviderEncryptionConfigKmsKeyRef>,
    /// Selector for a CryptoKey in kms to populate kmsKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelector")]
    #[builder(default)]
    pub kms_key_selector: Option<MetastoreServiceForProviderEncryptionConfigKmsKeySelector>,
}

/// Reference to a CryptoKey in kms to populate kmsKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderEncryptionConfigKmsKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderEncryptionConfigKmsKeyRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CryptoKey in kms to populate kmsKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderEncryptionConfigKmsKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderEncryptionConfigKmsKeySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration information specific to running Hive metastore software as the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderHiveMetastoreConfig {
    /// A mapping of Hive metastore version to the auxiliary version configuration.
    /// When specified, a secondary Hive metastore service is created along with the primary service.
    /// All auxiliary versions must be less than the service's primary version.
    /// The key is the auxiliary service name and it must match the regular expression a-z?.
    /// This means that the first character must be a lowercase letter, and all the following characters must be hyphens, lowercase letters, or digits, except the last character, which cannot be a hyphen.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auxiliaryVersions")]
    #[builder(default)]
    pub auxiliary_versions: Option<Vec<MetastoreServiceForProviderHiveMetastoreConfigAuxiliaryVersions>>,
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The protocol to use for the metastore service endpoint. If unspecified, defaults to THRIFT.
    /// Default value is THRIFT.
    /// Possible values are: THRIFT, GRPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointProtocol")]
    #[builder(default)]
    pub endpoint_protocol: Option<String>,
    /// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kerberosConfig")]
    #[builder(default)]
    pub kerberos_config: Option<MetastoreServiceForProviderHiveMetastoreConfigKerberosConfig>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderHiveMetastoreConfigAuxiliaryVersions {
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderHiveMetastoreConfigKerberosConfig {
    /// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub keytab: Option<MetastoreServiceForProviderHiveMetastoreConfigKerberosConfigKeytab>,
    /// A Cloud Storage URI that specifies the path to a krb5.conf file. It is of the form gs://{bucket_name}/path/to/krb5.conf, although the file does not need to be named krb5.conf explicitly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "krb5ConfigGcsUri")]
    #[builder(default)]
    pub krb5_config_gcs_uri: Option<String>,
    /// A Kerberos principal that exists in the both the keytab the KDC to authenticate as. A typical principal is of the form "primary/instance@REALM", but there is no exact format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub principal: Option<String>,
}

/// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderHiveMetastoreConfigKerberosConfigKeytab {
    /// The relative resource name of a Secret Manager secret version, in the following form:
    /// "projects/{projectNumber}/secrets/{secret_id}/versions/{version_id}".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSecret")]
    #[builder(default)]
    pub cloud_secret: Option<String>,
}

/// The one hour maintenance window of the metastore service.
/// This specifies when the service can be restarted for maintenance purposes in UTC time.
/// Maintenance window is not needed for services with the SPANNER database type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderMaintenanceWindow {
    /// The day of week, when the window starts.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default)]
    pub day_of_week: Option<String>,
    /// The hour of day (0-23) when the window starts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hourOfDay")]
    #[builder(default)]
    pub hour_of_day: Option<f64>,
}

/// The setting that defines how metastore metadata should be integrated with external services and systems.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderMetadataIntegration {
    /// The integration config for the Data Catalog service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataCatalogConfig")]
    #[builder(default)]
    pub data_catalog_config: Option<MetastoreServiceForProviderMetadataIntegrationDataCatalogConfig>,
}

/// The integration config for the Data Catalog service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderMetadataIntegrationDataCatalogConfig {
    /// Defines whether the metastore metadata should be synced to Data Catalog. The default value is to disable syncing metastore metadata to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// The configuration specifying the network settings for the Dataproc Metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfig {
    /// The consumer-side network configuration for the Dataproc Metastore instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub consumers: Option<Vec<MetastoreServiceForProviderNetworkConfigConsumers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfigConsumers {
    /// The subnetwork of the customer project from which an IP address is reserved and used as the Dataproc Metastore service's endpoint.
    /// It is accessible to hosts in the subnet and to all hosts in a subnet in the same region and same network.
    /// There must be at least one IP address available in the subnet's primary range. The subnet is specified in the following form:
    /// `projects/{projectNumber}/regions/{region_id}/subnetworks/{subnetwork_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelector>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderNetworkConfigConsumersSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceForProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Represents the scaling configuration of a metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderScalingConfig {
    /// Metastore instance sizes.
    /// Possible values are: EXTRA_SMALL, SMALL, MEDIUM, LARGE, EXTRA_LARGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceSize")]
    #[builder(default)]
    pub instance_size: Option<String>,
    /// Scaling factor, in increments of 0.1 for values less than 1.0, and increments of 1.0 for values greater than 1.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingFactor")]
    #[builder(default)]
    pub scaling_factor: Option<f64>,
}

/// The configuration of scheduled backup for the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderScheduledBackup {
    /// A Cloud Storage URI of a folder, in the format gs://<bucket_name>/<path_inside_bucket>. A sub-folder <backup_folder> containing backup files will be stored below it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupLocation")]
    #[builder(default)]
    pub backup_location: Option<String>,
    /// The scheduled interval in Cron format, see https://en.wikipedia.org/wiki/Cron The default is empty: scheduled backup is not enabled. Must be specified to enable scheduled backups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronSchedule")]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// Defines whether the scheduled backup is enabled. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Specifies the time zone to be used when interpreting cronSchedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones), e.g. America/Los_Angeles or Africa/Abidjan. If left unspecified, the default is UTC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default)]
    pub time_zone: Option<String>,
}

/// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceForProviderTelemetryConfig {
    /// The output format of the Dataproc Metastore service's logs.
    /// Default value is JSON.
    /// Possible values are: LEGACY, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default)]
    pub log_format: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProvider {
    /// The database type that the Metastore service stores its data.
    /// Default value is MYSQL.
    /// Possible values are: MYSQL, SPANNER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseType")]
    #[builder(default)]
    pub database_type: Option<String>,
    /// Information used to configure the Dataproc Metastore service to encrypt
    /// customer data at rest.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    #[builder(default)]
    pub encryption_config: Option<MetastoreServiceInitProviderEncryptionConfig>,
    /// Configuration information specific to running Hive metastore software as the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hiveMetastoreConfig")]
    #[builder(default)]
    pub hive_metastore_config: Option<MetastoreServiceInitProviderHiveMetastoreConfig>,
    /// User-defined labels for the metastore service.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The one hour maintenance window of the metastore service.
    /// This specifies when the service can be restarted for maintenance purposes in UTC time.
    /// Maintenance window is not needed for services with the SPANNER database type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindow")]
    #[builder(default)]
    pub maintenance_window: Option<MetastoreServiceInitProviderMaintenanceWindow>,
    /// The setting that defines how metastore metadata should be integrated with external services and systems.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataIntegration")]
    #[builder(default)]
    pub metadata_integration: Option<MetastoreServiceInitProviderMetadataIntegration>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The configuration specifying the network settings for the Dataproc Metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<MetastoreServiceInitProviderNetworkConfig>,
    /// The TCP port at which the metastore service is reached. Default: 9083.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The release channel of the service. If unspecified, defaults to STABLE.
    /// Default value is STABLE.
    /// Possible values are: CANARY, STABLE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    #[builder(default)]
    pub release_channel: Option<String>,
    /// Represents the scaling configuration of a metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingConfig")]
    #[builder(default)]
    pub scaling_config: Option<MetastoreServiceInitProviderScalingConfig>,
    /// The configuration of scheduled backup for the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduledBackup")]
    #[builder(default)]
    pub scheduled_backup: Option<MetastoreServiceInitProviderScheduledBackup>,
    /// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telemetryConfig")]
    #[builder(default)]
    pub telemetry_config: Option<MetastoreServiceInitProviderTelemetryConfig>,
    /// The tier of the service.
    /// Possible values are: DEVELOPER, ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tier: Option<String>,
}

/// Information used to configure the Dataproc Metastore service to encrypt
/// customer data at rest.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderEncryptionConfig {
    /// The fully qualified customer provided Cloud KMS key name to use for customer data encryption.
    /// Use the following format: projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    #[builder(default)]
    pub kms_key: Option<String>,
    /// Reference to a CryptoKey in kms to populate kmsKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyRef")]
    #[builder(default)]
    pub kms_key_ref: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeyRef>,
    /// Selector for a CryptoKey in kms to populate kmsKey.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelector")]
    #[builder(default)]
    pub kms_key_selector: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeySelector>,
}

/// Reference to a CryptoKey in kms to populate kmsKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderEncryptionConfigKmsKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderEncryptionConfigKmsKeyRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CryptoKey in kms to populate kmsKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderEncryptionConfigKmsKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderEncryptionConfigKmsKeySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Configuration information specific to running Hive metastore software as the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderHiveMetastoreConfig {
    /// A mapping of Hive metastore version to the auxiliary version configuration.
    /// When specified, a secondary Hive metastore service is created along with the primary service.
    /// All auxiliary versions must be less than the service's primary version.
    /// The key is the auxiliary service name and it must match the regular expression a-z?.
    /// This means that the first character must be a lowercase letter, and all the following characters must be hyphens, lowercase letters, or digits, except the last character, which cannot be a hyphen.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auxiliaryVersions")]
    #[builder(default)]
    pub auxiliary_versions: Option<Vec<MetastoreServiceInitProviderHiveMetastoreConfigAuxiliaryVersions>>,
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The protocol to use for the metastore service endpoint. If unspecified, defaults to THRIFT.
    /// Default value is THRIFT.
    /// Possible values are: THRIFT, GRPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointProtocol")]
    #[builder(default)]
    pub endpoint_protocol: Option<String>,
    /// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kerberosConfig")]
    #[builder(default)]
    pub kerberos_config: Option<MetastoreServiceInitProviderHiveMetastoreConfigKerberosConfig>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderHiveMetastoreConfigAuxiliaryVersions {
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderHiveMetastoreConfigKerberosConfig {
    /// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub keytab: Option<MetastoreServiceInitProviderHiveMetastoreConfigKerberosConfigKeytab>,
    /// A Cloud Storage URI that specifies the path to a krb5.conf file. It is of the form gs://{bucket_name}/path/to/krb5.conf, although the file does not need to be named krb5.conf explicitly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "krb5ConfigGcsUri")]
    #[builder(default)]
    pub krb5_config_gcs_uri: Option<String>,
    /// A Kerberos principal that exists in the both the keytab the KDC to authenticate as. A typical principal is of the form "primary/instance@REALM", but there is no exact format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub principal: Option<String>,
}

/// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderHiveMetastoreConfigKerberosConfigKeytab {
    /// The relative resource name of a Secret Manager secret version, in the following form:
    /// "projects/{projectNumber}/secrets/{secret_id}/versions/{version_id}".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSecret")]
    #[builder(default)]
    pub cloud_secret: Option<String>,
}

/// The one hour maintenance window of the metastore service.
/// This specifies when the service can be restarted for maintenance purposes in UTC time.
/// Maintenance window is not needed for services with the SPANNER database type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderMaintenanceWindow {
    /// The day of week, when the window starts.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default)]
    pub day_of_week: Option<String>,
    /// The hour of day (0-23) when the window starts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hourOfDay")]
    #[builder(default)]
    pub hour_of_day: Option<f64>,
}

/// The setting that defines how metastore metadata should be integrated with external services and systems.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderMetadataIntegration {
    /// The integration config for the Data Catalog service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataCatalogConfig")]
    #[builder(default)]
    pub data_catalog_config: Option<MetastoreServiceInitProviderMetadataIntegrationDataCatalogConfig>,
}

/// The integration config for the Data Catalog service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderMetadataIntegrationDataCatalogConfig {
    /// Defines whether the metastore metadata should be synced to Data Catalog. The default value is to disable syncing metastore metadata to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// The configuration specifying the network settings for the Dataproc Metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfig {
    /// The consumer-side network configuration for the Dataproc Metastore instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub consumers: Option<Vec<MetastoreServiceInitProviderNetworkConfigConsumers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfigConsumers {
    /// The subnetwork of the customer project from which an IP address is reserved and used as the Dataproc Metastore service's endpoint.
    /// It is accessible to hosts in the subnet and to all hosts in a subnet in the same region and same network.
    /// There must be at least one IP address available in the subnet's primary range. The subnet is specified in the following form:
    /// `projects/{projectNumber}/regions/{region_id}/subnetworks/{subnetwork_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelector>,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceInitProviderNetworkConfigConsumersSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Represents the scaling configuration of a metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderScalingConfig {
    /// Metastore instance sizes.
    /// Possible values are: EXTRA_SMALL, SMALL, MEDIUM, LARGE, EXTRA_LARGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceSize")]
    #[builder(default)]
    pub instance_size: Option<String>,
    /// Scaling factor, in increments of 0.1 for values less than 1.0, and increments of 1.0 for values greater than 1.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingFactor")]
    #[builder(default)]
    pub scaling_factor: Option<f64>,
}

/// The configuration of scheduled backup for the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderScheduledBackup {
    /// A Cloud Storage URI of a folder, in the format gs://<bucket_name>/<path_inside_bucket>. A sub-folder <backup_folder> containing backup files will be stored below it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupLocation")]
    #[builder(default)]
    pub backup_location: Option<String>,
    /// The scheduled interval in Cron format, see https://en.wikipedia.org/wiki/Cron The default is empty: scheduled backup is not enabled. Must be specified to enable scheduled backups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronSchedule")]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// Defines whether the scheduled backup is enabled. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Specifies the time zone to be used when interpreting cronSchedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones), e.g. America/Los_Angeles or Africa/Abidjan. If left unspecified, the default is UTC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default)]
    pub time_zone: Option<String>,
}

/// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceInitProviderTelemetryConfig {
    /// The output format of the Dataproc Metastore service's logs.
    /// Default value is JSON.
    /// Possible values are: LEGACY, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default)]
    pub log_format: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServiceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServiceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServiceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServiceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServicePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<MetastoreServicePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<MetastoreServicePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServicePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<MetastoreServicePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServicePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<MetastoreServicePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<MetastoreServicePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServicePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum MetastoreServicePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServicePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// MetastoreServiceStatus defines the observed state of MetastoreService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<MetastoreServiceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProvider {
    /// A Cloud Storage URI (starting with gs://) that specifies where artifacts related to the metastore service are stored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactGcsUri")]
    #[builder(default)]
    pub artifact_gcs_uri: Option<String>,
    /// The database type that the Metastore service stores its data.
    /// Default value is MYSQL.
    /// Possible values are: MYSQL, SPANNER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "databaseType")]
    #[builder(default)]
    pub database_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// Information used to configure the Dataproc Metastore service to encrypt
    /// customer data at rest.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionConfig")]
    #[builder(default)]
    pub encryption_config: Option<MetastoreServiceStatusAtProviderEncryptionConfig>,
    /// The URI of the endpoint used to access the metastore service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointUri")]
    #[builder(default)]
    pub endpoint_uri: Option<String>,
    /// Configuration information specific to running Hive metastore software as the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hiveMetastoreConfig")]
    #[builder(default)]
    pub hive_metastore_config: Option<MetastoreServiceStatusAtProviderHiveMetastoreConfig>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/services/{{service_id}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// User-defined labels for the metastore service.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field effective_labels for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location where the metastore service should reside.
    /// The default value is global.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The one hour maintenance window of the metastore service.
    /// This specifies when the service can be restarted for maintenance purposes in UTC time.
    /// Maintenance window is not needed for services with the SPANNER database type.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindow")]
    #[builder(default)]
    pub maintenance_window: Option<MetastoreServiceStatusAtProviderMaintenanceWindow>,
    /// The setting that defines how metastore metadata should be integrated with external services and systems.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataIntegration")]
    #[builder(default)]
    pub metadata_integration: Option<MetastoreServiceStatusAtProviderMetadataIntegration>,
    /// The relative resource name of the metastore service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The relative resource name of the VPC network on which the instance can be accessed. It is specified in the following form:
    /// "projects/{projectNumber}/global/networks/{network_id}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The configuration specifying the network settings for the Dataproc Metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<MetastoreServiceStatusAtProviderNetworkConfig>,
    /// The TCP port at which the metastore service is reached. Default: 9083.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub port: Option<f64>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The release channel of the service. If unspecified, defaults to STABLE.
    /// Default value is STABLE.
    /// Possible values are: CANARY, STABLE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseChannel")]
    #[builder(default)]
    pub release_channel: Option<String>,
    /// Represents the scaling configuration of a metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingConfig")]
    #[builder(default)]
    pub scaling_config: Option<MetastoreServiceStatusAtProviderScalingConfig>,
    /// The configuration of scheduled backup for the metastore service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduledBackup")]
    #[builder(default)]
    pub scheduled_backup: Option<MetastoreServiceStatusAtProviderScheduledBackup>,
    /// The current state of the metastore service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
    /// Additional information about the current state of the metastore service, if available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMessage")]
    #[builder(default)]
    pub state_message: Option<String>,
    /// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telemetryConfig")]
    #[builder(default)]
    pub telemetry_config: Option<MetastoreServiceStatusAtProviderTelemetryConfig>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// The tier of the service.
    /// Possible values are: DEVELOPER, ENTERPRISE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tier: Option<String>,
    /// The globally unique resource identifier of the metastore service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uid: Option<String>,
}

/// Information used to configure the Dataproc Metastore service to encrypt
/// customer data at rest.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderEncryptionConfig {
    /// The fully qualified customer provided Cloud KMS key name to use for customer data encryption.
    /// Use the following format: projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKey")]
    #[builder(default)]
    pub kms_key: Option<String>,
}

/// Configuration information specific to running Hive metastore software as the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderHiveMetastoreConfig {
    /// A mapping of Hive metastore version to the auxiliary version configuration.
    /// When specified, a secondary Hive metastore service is created along with the primary service.
    /// All auxiliary versions must be less than the service's primary version.
    /// The key is the auxiliary service name and it must match the regular expression a-z?.
    /// This means that the first character must be a lowercase letter, and all the following characters must be hyphens, lowercase letters, or digits, except the last character, which cannot be a hyphen.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auxiliaryVersions")]
    #[builder(default)]
    pub auxiliary_versions: Option<Vec<MetastoreServiceStatusAtProviderHiveMetastoreConfigAuxiliaryVersions>>,
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The protocol to use for the metastore service endpoint. If unspecified, defaults to THRIFT.
    /// Default value is THRIFT.
    /// Possible values are: THRIFT, GRPC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointProtocol")]
    #[builder(default)]
    pub endpoint_protocol: Option<String>,
    /// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kerberosConfig")]
    #[builder(default)]
    pub kerberos_config: Option<MetastoreServiceStatusAtProviderHiveMetastoreConfigKerberosConfig>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderHiveMetastoreConfigAuxiliaryVersions {
    /// A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
    /// The mappings override system defaults (some keys cannot be overridden)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configOverrides")]
    #[builder(default)]
    pub config_overrides: Option<HashMap<String, String>>,
    /// The identifier for this object. Format specified above.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The Hive metastore schema version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderHiveMetastoreConfigKerberosConfig {
    /// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub keytab: Option<MetastoreServiceStatusAtProviderHiveMetastoreConfigKerberosConfigKeytab>,
    /// A Cloud Storage URI that specifies the path to a krb5.conf file. It is of the form gs://{bucket_name}/path/to/krb5.conf, although the file does not need to be named krb5.conf explicitly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "krb5ConfigGcsUri")]
    #[builder(default)]
    pub krb5_config_gcs_uri: Option<String>,
    /// A Kerberos principal that exists in the both the keytab the KDC to authenticate as. A typical principal is of the form "primary/instance@REALM", but there is no exact format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub principal: Option<String>,
}

/// A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderHiveMetastoreConfigKerberosConfigKeytab {
    /// The relative resource name of a Secret Manager secret version, in the following form:
    /// "projects/{projectNumber}/secrets/{secret_id}/versions/{version_id}".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudSecret")]
    #[builder(default)]
    pub cloud_secret: Option<String>,
}

/// The one hour maintenance window of the metastore service.
/// This specifies when the service can be restarted for maintenance purposes in UTC time.
/// Maintenance window is not needed for services with the SPANNER database type.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderMaintenanceWindow {
    /// The day of week, when the window starts.
    /// Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    #[builder(default)]
    pub day_of_week: Option<String>,
    /// The hour of day (0-23) when the window starts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hourOfDay")]
    #[builder(default)]
    pub hour_of_day: Option<f64>,
}

/// The setting that defines how metastore metadata should be integrated with external services and systems.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderMetadataIntegration {
    /// The integration config for the Data Catalog service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataCatalogConfig")]
    #[builder(default)]
    pub data_catalog_config: Option<MetastoreServiceStatusAtProviderMetadataIntegrationDataCatalogConfig>,
}

/// The integration config for the Data Catalog service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderMetadataIntegrationDataCatalogConfig {
    /// Defines whether the metastore metadata should be synced to Data Catalog. The default value is to disable syncing metastore metadata to Data Catalog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// The configuration specifying the network settings for the Dataproc Metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderNetworkConfig {
    /// The consumer-side network configuration for the Dataproc Metastore instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub consumers: Option<Vec<MetastoreServiceStatusAtProviderNetworkConfigConsumers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderNetworkConfigConsumers {
    /// The URI of the endpoint used to access the metastore service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointUri")]
    #[builder(default)]
    pub endpoint_uri: Option<String>,
    /// The subnetwork of the customer project from which an IP address is reserved and used as the Dataproc Metastore service's endpoint.
    /// It is accessible to hosts in the subnet and to all hosts in a subnet in the same region and same network.
    /// There must be at least one IP address available in the subnet's primary range. The subnet is specified in the following form:
    /// `projects/{projectNumber}/regions/{region_id}/subnetworks/{subnetwork_id}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

/// Represents the scaling configuration of a metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderScalingConfig {
    /// Metastore instance sizes.
    /// Possible values are: EXTRA_SMALL, SMALL, MEDIUM, LARGE, EXTRA_LARGE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceSize")]
    #[builder(default)]
    pub instance_size: Option<String>,
    /// Scaling factor, in increments of 0.1 for values less than 1.0, and increments of 1.0 for values greater than 1.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingFactor")]
    #[builder(default)]
    pub scaling_factor: Option<f64>,
}

/// The configuration of scheduled backup for the metastore service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderScheduledBackup {
    /// A Cloud Storage URI of a folder, in the format gs://<bucket_name>/<path_inside_bucket>. A sub-folder <backup_folder> containing backup files will be stored below it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupLocation")]
    #[builder(default)]
    pub backup_location: Option<String>,
    /// The scheduled interval in Cron format, see https://en.wikipedia.org/wiki/Cron The default is empty: scheduled backup is not enabled. Must be specified to enable scheduled backups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronSchedule")]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// Defines whether the scheduled backup is enabled. The default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
    /// Specifies the time zone to be used when interpreting cronSchedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones), e.g. America/Los_Angeles or Africa/Abidjan. If left unspecified, the default is UTC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    #[builder(default)]
    pub time_zone: Option<String>,
}

/// The configuration specifying telemetry settings for the Dataproc Metastore service. If unspecified defaults to JSON.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct MetastoreServiceStatusAtProviderTelemetryConfig {
    /// The output format of the Dataproc Metastore service's logs.
    /// Default value is JSON.
    /// Possible values are: LEGACY, JSON.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    #[builder(default)]
    pub log_format: Option<String>,
}

