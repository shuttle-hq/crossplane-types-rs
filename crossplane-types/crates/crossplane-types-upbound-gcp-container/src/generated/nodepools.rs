// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// NodePoolSpec defines the desired state of NodePool
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "container.gcp.upbound.io", version = "v1beta2", kind = "NodePool", plural = "nodepools")]
#[kube(status = "NodePoolStatus")]
pub struct NodePoolSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<NodePoolDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: NodePoolForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<NodePoolInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<NodePoolProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<NodePoolPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<NodePoolWriteConnectionSecretToRef>,
}

/// NodePoolSpec defines the desired state of NodePool
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProvider {
    /// Configuration required by cluster autoscaler to adjust
    /// the size of the node pool to the current cluster usage. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub autoscaling: Option<NodePoolForProviderAutoscaling>,
    /// The cluster to create the node pool for. Cluster must be present in location provided for clusters. May be specified in the format projects/{{project}}/locations/{{location}}/clusters/{{cluster}} or as just the name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// Reference to a Cluster in container to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    #[builder(default)]
    pub cluster_ref: Option<NodePoolForProviderClusterRef>,
    /// Selector for a Cluster in container to populate cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSelector")]
    #[builder(default)]
    pub cluster_selector: Option<NodePoolForProviderClusterSelector>,
    /// The initial number of nodes for the pool. In
    /// regional or multi-zonal clusters, this is the number of nodes per zone. Changing
    /// this will force recreation of the resource.  If you don't
    /// need this value, don't set it.  If you do need it, you can use a lifecycle block to
    /// ignore subsequent changes to this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    #[builder(default)]
    pub initial_node_count: Option<f64>,
    /// The location (region or zone) of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Node management configuration, wherein auto-repair and
    /// auto-upgrade is configured. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub management: Option<NodePoolForProviderManagement>,
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The network configuration of the pool. Such as
    /// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
    /// documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<NodePoolForProviderNetworkConfig>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    #[builder(default)]
    pub node_config: Option<NodePoolForProviderNodeConfig>,
    /// The number of nodes per instance group. This field can be used to
    /// update the number of nodes per instance group but should not be used alongside autoscaling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeCount")]
    #[builder(default)]
    pub node_count: Option<f64>,
    /// The list of zones in which the node pool's nodes should be located. Nodes must
    /// be in the region of their regional cluster or in the same region as their
    /// cluster's zone for zonal clusters. If unspecified, the cluster-level
    /// node_locations will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    #[builder(default)]
    pub node_locations: Option<Vec<String>>,
    /// Specifies a custom placement policy for the
    /// nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementPolicy")]
    #[builder(default)]
    pub placement_policy: Option<NodePoolForProviderPlacementPolicy>,
    /// The ID of the project in which to create the node pool. If blank,
    /// the provider-configured project will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies node pool-level settings of queued provisioning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedProvisioning")]
    #[builder(default)]
    pub queued_provisioning: Option<NodePoolForProviderQueuedProvisioning>,
    /// Specify node upgrade settings to change how GKE upgrades nodes.
    /// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    #[builder(default)]
    pub upgrade_settings: Option<NodePoolForProviderUpgradeSettings>,
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Configuration required by cluster autoscaler to adjust
/// the size of the node pool to the current cluster usage. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderAutoscaling {
    /// Location policy specifies the algorithm used when
    /// scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationPolicy")]
    #[builder(default)]
    pub location_policy: Option<String>,
    /// Maximum number of nodes per zone in the NodePool.
    /// Must be >= min_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxNodeCount")]
    #[builder(default)]
    pub max_node_count: Option<f64>,
    /// Minimum number of nodes per zone in the NodePool.
    /// Must be >=0 and <= max_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCount")]
    #[builder(default)]
    pub min_node_count: Option<f64>,
    /// Total maximum number of nodes in the NodePool.
    /// Must be >= total_min_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMaxNodeCount")]
    #[builder(default)]
    pub total_max_node_count: Option<f64>,
    /// Total minimum number of nodes in the NodePool.
    /// Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMinNodeCount")]
    #[builder(default)]
    pub total_min_node_count: Option<f64>,
}

/// Reference to a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolForProviderClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolForProviderClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolForProviderClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolForProviderClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolForProviderClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolForProviderClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Node management configuration, wherein auto-repair and
/// auto-upgrade is configured. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderManagement {
    /// Whether the nodes will be automatically repaired. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    #[builder(default)]
    pub auto_repair: Option<bool>,
    /// Whether the nodes will be automatically upgraded. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    #[builder(default)]
    pub auto_upgrade: Option<bool>,
}

/// The network configuration of the pool. Such as
/// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
/// documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNetworkConfig {
    /// We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalNodeNetworkConfigs")]
    #[builder(default)]
    pub additional_node_network_configs: Option<Vec<NodePoolForProviderNetworkConfigAdditionalNodeNetworkConfigs>>,
    /// We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodNetworkConfigs")]
    #[builder(default)]
    pub additional_pod_network_configs: Option<Vec<NodePoolForProviderNetworkConfigAdditionalPodNetworkConfigs>>,
    /// Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPodRange")]
    #[builder(default)]
    pub create_pod_range: Option<bool>,
    /// Whether nodes have internal IP addresses only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    #[builder(default)]
    pub enable_private_nodes: Option<bool>,
    /// Network bandwidth tier configuration. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<NodePoolForProviderNetworkConfigNetworkPerformanceConfig>,
    /// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    #[builder(default)]
    pub pod_cidr_overprovision_config: Option<NodePoolForProviderNetworkConfigPodCidrOverprovisionConfig>,
    /// The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podIpv4CidrBlock")]
    #[builder(default)]
    pub pod_ipv4_cidr_block: Option<String>,
    /// The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRange")]
    #[builder(default)]
    pub pod_range: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNetworkConfigAdditionalNodeNetworkConfigs {
    /// Name of the VPC where the additional interface belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNetworkConfigAdditionalPodNetworkConfigs {
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The name of the secondary range on the subnet which provides IP address for this pod range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryPodRange")]
    #[builder(default)]
    pub secondary_pod_range: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

/// Network bandwidth tier configuration. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNetworkConfigNetworkPerformanceConfig {
    /// Specifies the total network bandwidth tier for the NodePool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNetworkConfigPodCidrOverprovisionConfig {
    /// Whether pod cidr overprovision is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<NodePoolForProviderNodeConfigAdvancedMachineFeatures>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    #[builder(default)]
    pub boot_disk_kms_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    #[builder(default)]
    pub confidential_nodes: Option<NodePoolForProviderNodeConfigConfidentialNodes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    #[builder(default)]
    pub containerd_config: Option<NodePoolForProviderNodeConfigContainerdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    #[builder(default)]
    pub enable_confidential_storage: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    #[builder(default)]
    pub ephemeral_storage_local_ssd_config: Option<NodePoolForProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    #[builder(default)]
    pub fast_socket: Option<NodePoolForProviderNodeConfigFastSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    #[builder(default)]
    pub gcfs_config: Option<NodePoolForProviderNodeConfigGcfsConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<NodePoolForProviderNodeConfigGuestAccelerator>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gvnic: Option<NodePoolForProviderNodeConfigGvnic>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    #[builder(default)]
    pub host_maintenance_policy: Option<NodePoolForProviderNodeConfigHostMaintenancePolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    #[builder(default)]
    pub image_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    #[builder(default)]
    pub kubelet_config: Option<NodePoolForProviderNodeConfigKubeletConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    #[builder(default)]
    pub linux_node_config: Option<NodePoolForProviderNodeConfigLinuxNodeConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    #[builder(default)]
    pub local_nvme_ssd_block_config: Option<NodePoolForProviderNodeConfigLocalNvmeSsdBlockConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    #[builder(default)]
    pub logging_variant: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    #[builder(default)]
    pub node_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    #[builder(default)]
    pub oauth_scopes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<NodePoolForProviderNodeConfigReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    #[builder(default)]
    pub resource_labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    #[builder(default)]
    pub secondary_boot_disks: Option<Vec<NodePoolForProviderNodeConfigSecondaryBootDisks>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<NodePoolForProviderNodeConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<NodePoolForProviderNodeConfigServiceAccountSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<NodePoolForProviderNodeConfigShieldedInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    #[builder(default)]
    pub sole_tenant_config: Option<NodePoolForProviderNodeConfigSoleTenantConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub taint: Option<Vec<NodePoolForProviderNodeConfigTaint>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    #[builder(default)]
    pub workload_metadata_config: Option<NodePoolForProviderNodeConfigWorkloadMetadataConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigConfidentialNodes {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigContainerdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    #[builder(default)]
    pub private_registry_access_config: Option<NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    #[builder(default)]
    pub certificate_authority_domain_config: Option<Vec<NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    #[builder(default)]
    pub gcp_secret_manager_certificate_config: Option<NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    #[builder(default)]
    pub secret_uri: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigEphemeralStorageLocalSsdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigFastSocket {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigGcfsConfig {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    #[builder(default)]
    pub gpu_driver_installation_config: Option<NodePoolForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    #[builder(default)]
    pub gpu_partition_size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    #[builder(default)]
    pub gpu_sharing_config: Option<NodePoolForProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    #[builder(default)]
    pub gpu_driver_version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    #[builder(default)]
    pub gpu_sharing_strategy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    #[builder(default)]
    pub max_shared_clients_per_gpu: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigGvnic {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    #[builder(default)]
    pub maintenance_interval: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigKubeletConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    #[builder(default)]
    pub cpu_cfs_quota: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    #[builder(default)]
    pub cpu_cfs_quota_period: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    #[builder(default)]
    pub cpu_manager_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    #[builder(default)]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    #[builder(default)]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigLinuxNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    #[builder(default)]
    pub cgroup_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sysctls: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigLocalNvmeSsdBlockConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    #[builder(default)]
    pub consume_reservation_type: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigSecondaryBootDisks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    #[builder(default)]
    pub disk_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolForProviderNodeConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolForProviderNodeConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolForProviderNodeConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderNodeConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderNodeConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolForProviderNodeConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolForProviderNodeConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolForProviderNodeConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderNodeConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolForProviderNodeConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    #[builder(default)]
    pub node_affinity: Option<Vec<NodePoolForProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigTaint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effect: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderNodeConfigWorkloadMetadataConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Specifies a custom placement policy for the
/// nodes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderPlacementPolicy {
    /// If set, refers to the name of a custom resource policy supplied by the user.
    /// The resource policy must be in the same project and region as the node pool.
    /// If not found, InvalidArgument error is returned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyName")]
    #[builder(default)]
    pub policy_name: Option<String>,
    /// The TPU placement topology for pod slice node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tpuTopology")]
    #[builder(default)]
    pub tpu_topology: Option<String>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies node pool-level settings of queued provisioning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderQueuedProvisioning {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// Specify node upgrade settings to change how GKE upgrades nodes.
/// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderUpgradeSettings {
    /// The settings to adjust blue green upgrades.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    #[builder(default)]
    pub blue_green_settings: Option<NodePoolForProviderUpgradeSettingsBlueGreenSettings>,
    /// The number of additional nodes that can be added to the node pool during
    /// an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
    /// Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    #[builder(default)]
    pub max_surge: Option<f64>,
    /// The number of nodes that can be simultaneously unavailable during
    /// an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
    /// parallel. Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    #[builder(default)]
    pub max_unavailable: Option<f64>,
    /// (Default SURGE) The upgrade strategy to be used for upgrading the nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub strategy: Option<String>,
}

/// The settings to adjust blue green upgrades.
/// Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining the entire blue pool.
    /// After this period, the blue pool will be cleaned up.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    #[builder(default)]
    pub node_pool_soak_duration: Option<String>,
    /// Specifies the standard policy settings for blue-green upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    #[builder(default)]
    pub standard_rollout_policy: Option<NodePoolForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// Specifies the standard policy settings for blue-green upgrades.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    #[builder(default)]
    pub batch_node_count: Option<f64>,
    /// Percentage of the blue pool nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    #[builder(default)]
    pub batch_percentage: Option<f64>,
    /// (Optionial) Soak time after each batch gets drained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    #[builder(default)]
    pub batch_soak_duration: Option<String>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProvider {
    /// Configuration required by cluster autoscaler to adjust
    /// the size of the node pool to the current cluster usage. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub autoscaling: Option<NodePoolInitProviderAutoscaling>,
    /// The initial number of nodes for the pool. In
    /// regional or multi-zonal clusters, this is the number of nodes per zone. Changing
    /// this will force recreation of the resource.  If you don't
    /// need this value, don't set it.  If you do need it, you can use a lifecycle block to
    /// ignore subsequent changes to this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    #[builder(default)]
    pub initial_node_count: Option<f64>,
    /// Node management configuration, wherein auto-repair and
    /// auto-upgrade is configured. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub management: Option<NodePoolInitProviderManagement>,
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The network configuration of the pool. Such as
    /// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
    /// documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<NodePoolInitProviderNetworkConfig>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    #[builder(default)]
    pub node_config: Option<NodePoolInitProviderNodeConfig>,
    /// The number of nodes per instance group. This field can be used to
    /// update the number of nodes per instance group but should not be used alongside autoscaling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeCount")]
    #[builder(default)]
    pub node_count: Option<f64>,
    /// The list of zones in which the node pool's nodes should be located. Nodes must
    /// be in the region of their regional cluster or in the same region as their
    /// cluster's zone for zonal clusters. If unspecified, the cluster-level
    /// node_locations will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    #[builder(default)]
    pub node_locations: Option<Vec<String>>,
    /// Specifies a custom placement policy for the
    /// nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementPolicy")]
    #[builder(default)]
    pub placement_policy: Option<NodePoolInitProviderPlacementPolicy>,
    /// The ID of the project in which to create the node pool. If blank,
    /// the provider-configured project will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies node pool-level settings of queued provisioning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedProvisioning")]
    #[builder(default)]
    pub queued_provisioning: Option<NodePoolInitProviderQueuedProvisioning>,
    /// Specify node upgrade settings to change how GKE upgrades nodes.
    /// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    #[builder(default)]
    pub upgrade_settings: Option<NodePoolInitProviderUpgradeSettings>,
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Configuration required by cluster autoscaler to adjust
/// the size of the node pool to the current cluster usage. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderAutoscaling {
    /// Location policy specifies the algorithm used when
    /// scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationPolicy")]
    #[builder(default)]
    pub location_policy: Option<String>,
    /// Maximum number of nodes per zone in the NodePool.
    /// Must be >= min_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxNodeCount")]
    #[builder(default)]
    pub max_node_count: Option<f64>,
    /// Minimum number of nodes per zone in the NodePool.
    /// Must be >=0 and <= max_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCount")]
    #[builder(default)]
    pub min_node_count: Option<f64>,
    /// Total maximum number of nodes in the NodePool.
    /// Must be >= total_min_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMaxNodeCount")]
    #[builder(default)]
    pub total_max_node_count: Option<f64>,
    /// Total minimum number of nodes in the NodePool.
    /// Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMinNodeCount")]
    #[builder(default)]
    pub total_min_node_count: Option<f64>,
}

/// Node management configuration, wherein auto-repair and
/// auto-upgrade is configured. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderManagement {
    /// Whether the nodes will be automatically repaired. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    #[builder(default)]
    pub auto_repair: Option<bool>,
    /// Whether the nodes will be automatically upgraded. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    #[builder(default)]
    pub auto_upgrade: Option<bool>,
}

/// The network configuration of the pool. Such as
/// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
/// documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNetworkConfig {
    /// We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalNodeNetworkConfigs")]
    #[builder(default)]
    pub additional_node_network_configs: Option<Vec<NodePoolInitProviderNetworkConfigAdditionalNodeNetworkConfigs>>,
    /// We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodNetworkConfigs")]
    #[builder(default)]
    pub additional_pod_network_configs: Option<Vec<NodePoolInitProviderNetworkConfigAdditionalPodNetworkConfigs>>,
    /// Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPodRange")]
    #[builder(default)]
    pub create_pod_range: Option<bool>,
    /// Whether nodes have internal IP addresses only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    #[builder(default)]
    pub enable_private_nodes: Option<bool>,
    /// Network bandwidth tier configuration. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<NodePoolInitProviderNetworkConfigNetworkPerformanceConfig>,
    /// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    #[builder(default)]
    pub pod_cidr_overprovision_config: Option<NodePoolInitProviderNetworkConfigPodCidrOverprovisionConfig>,
    /// The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podIpv4CidrBlock")]
    #[builder(default)]
    pub pod_ipv4_cidr_block: Option<String>,
    /// The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRange")]
    #[builder(default)]
    pub pod_range: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNetworkConfigAdditionalNodeNetworkConfigs {
    /// Name of the VPC where the additional interface belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNetworkConfigAdditionalPodNetworkConfigs {
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The name of the secondary range on the subnet which provides IP address for this pod range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryPodRange")]
    #[builder(default)]
    pub secondary_pod_range: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

/// Network bandwidth tier configuration. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNetworkConfigNetworkPerformanceConfig {
    /// Specifies the total network bandwidth tier for the NodePool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNetworkConfigPodCidrOverprovisionConfig {
    /// Whether pod cidr overprovision is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<NodePoolInitProviderNodeConfigAdvancedMachineFeatures>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    #[builder(default)]
    pub boot_disk_kms_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    #[builder(default)]
    pub confidential_nodes: Option<NodePoolInitProviderNodeConfigConfidentialNodes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    #[builder(default)]
    pub containerd_config: Option<NodePoolInitProviderNodeConfigContainerdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    #[builder(default)]
    pub enable_confidential_storage: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    #[builder(default)]
    pub ephemeral_storage_local_ssd_config: Option<NodePoolInitProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    #[builder(default)]
    pub fast_socket: Option<NodePoolInitProviderNodeConfigFastSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    #[builder(default)]
    pub gcfs_config: Option<NodePoolInitProviderNodeConfigGcfsConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<NodePoolInitProviderNodeConfigGuestAccelerator>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gvnic: Option<NodePoolInitProviderNodeConfigGvnic>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    #[builder(default)]
    pub host_maintenance_policy: Option<NodePoolInitProviderNodeConfigHostMaintenancePolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    #[builder(default)]
    pub image_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    #[builder(default)]
    pub kubelet_config: Option<NodePoolInitProviderNodeConfigKubeletConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    #[builder(default)]
    pub linux_node_config: Option<NodePoolInitProviderNodeConfigLinuxNodeConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    #[builder(default)]
    pub local_nvme_ssd_block_config: Option<NodePoolInitProviderNodeConfigLocalNvmeSsdBlockConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    #[builder(default)]
    pub logging_variant: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    #[builder(default)]
    pub node_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    #[builder(default)]
    pub oauth_scopes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<NodePoolInitProviderNodeConfigReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    #[builder(default)]
    pub resource_labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    #[builder(default)]
    pub secondary_boot_disks: Option<Vec<NodePoolInitProviderNodeConfigSecondaryBootDisks>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<NodePoolInitProviderNodeConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<NodePoolInitProviderNodeConfigServiceAccountSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<NodePoolInitProviderNodeConfigShieldedInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    #[builder(default)]
    pub sole_tenant_config: Option<NodePoolInitProviderNodeConfigSoleTenantConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub taint: Option<Vec<NodePoolInitProviderNodeConfigTaint>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    #[builder(default)]
    pub workload_metadata_config: Option<NodePoolInitProviderNodeConfigWorkloadMetadataConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigConfidentialNodes {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigContainerdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    #[builder(default)]
    pub private_registry_access_config: Option<NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    #[builder(default)]
    pub certificate_authority_domain_config: Option<Vec<NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    #[builder(default)]
    pub gcp_secret_manager_certificate_config: Option<NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    #[builder(default)]
    pub secret_uri: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigFastSocket {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigGcfsConfig {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    #[builder(default)]
    pub gpu_driver_installation_config: Option<NodePoolInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    #[builder(default)]
    pub gpu_partition_size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    #[builder(default)]
    pub gpu_sharing_config: Option<NodePoolInitProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    #[builder(default)]
    pub gpu_driver_version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    #[builder(default)]
    pub gpu_sharing_strategy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    #[builder(default)]
    pub max_shared_clients_per_gpu: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigGvnic {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    #[builder(default)]
    pub maintenance_interval: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigKubeletConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    #[builder(default)]
    pub cpu_cfs_quota: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    #[builder(default)]
    pub cpu_cfs_quota_period: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    #[builder(default)]
    pub cpu_manager_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    #[builder(default)]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    #[builder(default)]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigLinuxNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    #[builder(default)]
    pub cgroup_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sysctls: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigLocalNvmeSsdBlockConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    #[builder(default)]
    pub consume_reservation_type: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigSecondaryBootDisks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    #[builder(default)]
    pub disk_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolInitProviderNodeConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolInitProviderNodeConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolInitProviderNodeConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolInitProviderNodeConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolInitProviderNodeConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolInitProviderNodeConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolInitProviderNodeConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolInitProviderNodeConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    #[builder(default)]
    pub node_affinity: Option<Vec<NodePoolInitProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigTaint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effect: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderNodeConfigWorkloadMetadataConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Specifies a custom placement policy for the
/// nodes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderPlacementPolicy {
    /// If set, refers to the name of a custom resource policy supplied by the user.
    /// The resource policy must be in the same project and region as the node pool.
    /// If not found, InvalidArgument error is returned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyName")]
    #[builder(default)]
    pub policy_name: Option<String>,
    /// The TPU placement topology for pod slice node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tpuTopology")]
    #[builder(default)]
    pub tpu_topology: Option<String>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies node pool-level settings of queued provisioning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderQueuedProvisioning {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// Specify node upgrade settings to change how GKE upgrades nodes.
/// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderUpgradeSettings {
    /// The settings to adjust blue green upgrades.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    #[builder(default)]
    pub blue_green_settings: Option<NodePoolInitProviderUpgradeSettingsBlueGreenSettings>,
    /// The number of additional nodes that can be added to the node pool during
    /// an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
    /// Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    #[builder(default)]
    pub max_surge: Option<f64>,
    /// The number of nodes that can be simultaneously unavailable during
    /// an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
    /// parallel. Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    #[builder(default)]
    pub max_unavailable: Option<f64>,
    /// (Default SURGE) The upgrade strategy to be used for upgrading the nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub strategy: Option<String>,
}

/// The settings to adjust blue green upgrades.
/// Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining the entire blue pool.
    /// After this period, the blue pool will be cleaned up.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    #[builder(default)]
    pub node_pool_soak_duration: Option<String>,
    /// Specifies the standard policy settings for blue-green upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    #[builder(default)]
    pub standard_rollout_policy: Option<NodePoolInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// Specifies the standard policy settings for blue-green upgrades.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    #[builder(default)]
    pub batch_node_count: Option<f64>,
    /// Percentage of the blue pool nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    #[builder(default)]
    pub batch_percentage: Option<f64>,
    /// (Optionial) Soak time after each batch gets drained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    #[builder(default)]
    pub batch_soak_duration: Option<String>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<NodePoolPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<NodePoolPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<NodePoolPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<NodePoolPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<NodePoolPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum NodePoolPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// NodePoolStatus defines the observed state of NodePool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<NodePoolStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProvider {
    /// Configuration required by cluster autoscaler to adjust
    /// the size of the node pool to the current cluster usage. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub autoscaling: Option<NodePoolStatusAtProviderAutoscaling>,
    /// The cluster to create the node pool for. Cluster must be present in location provided for clusters. May be specified in the format projects/{{project}}/locations/{{location}}/clusters/{{cluster}} or as just the name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// an identifier for the resource with format {{project}}/{{location}}/{{cluster}}/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The initial number of nodes for the pool. In
    /// regional or multi-zonal clusters, this is the number of nodes per zone. Changing
    /// this will force recreation of the resource.  If you don't
    /// need this value, don't set it.  If you do need it, you can use a lifecycle block to
    /// ignore subsequent changes to this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialNodeCount")]
    #[builder(default)]
    pub initial_node_count: Option<f64>,
    /// The resource URLs of the managed instance groups associated with this node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceGroupUrls")]
    #[builder(default)]
    pub instance_group_urls: Option<Vec<String>>,
    /// The location (region or zone) of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// List of instance group URLs which have been assigned to this node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedInstanceGroupUrls")]
    #[builder(default)]
    pub managed_instance_group_urls: Option<Vec<String>>,
    /// Node management configuration, wherein auto-repair and
    /// auto-upgrade is configured. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub management: Option<NodePoolStatusAtProviderManagement>,
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The network configuration of the pool. Such as
    /// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
    /// documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkConfig")]
    #[builder(default)]
    pub network_config: Option<NodePoolStatusAtProviderNetworkConfig>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeConfig")]
    #[builder(default)]
    pub node_config: Option<NodePoolStatusAtProviderNodeConfig>,
    /// The number of nodes per instance group. This field can be used to
    /// update the number of nodes per instance group but should not be used alongside autoscaling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeCount")]
    #[builder(default)]
    pub node_count: Option<f64>,
    /// The list of zones in which the node pool's nodes should be located. Nodes must
    /// be in the region of their regional cluster or in the same region as their
    /// cluster's zone for zonal clusters. If unspecified, the cluster-level
    /// node_locations will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLocations")]
    #[builder(default)]
    pub node_locations: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operation: Option<String>,
    /// Specifies a custom placement policy for the
    /// nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "placementPolicy")]
    #[builder(default)]
    pub placement_policy: Option<NodePoolStatusAtProviderPlacementPolicy>,
    /// The ID of the project in which to create the node pool. If blank,
    /// the provider-configured project will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies node pool-level settings of queued provisioning.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedProvisioning")]
    #[builder(default)]
    pub queued_provisioning: Option<NodePoolStatusAtProviderQueuedProvisioning>,
    /// Specify node upgrade settings to change how GKE upgrades nodes.
    /// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeSettings")]
    #[builder(default)]
    pub upgrade_settings: Option<NodePoolStatusAtProviderUpgradeSettings>,
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Configuration required by cluster autoscaler to adjust
/// the size of the node pool to the current cluster usage. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderAutoscaling {
    /// Location policy specifies the algorithm used when
    /// scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "locationPolicy")]
    #[builder(default)]
    pub location_policy: Option<String>,
    /// Maximum number of nodes per zone in the NodePool.
    /// Must be >= min_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxNodeCount")]
    #[builder(default)]
    pub max_node_count: Option<f64>,
    /// Minimum number of nodes per zone in the NodePool.
    /// Must be >=0 and <= max_node_count. Cannot be used with total limits.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCount")]
    #[builder(default)]
    pub min_node_count: Option<f64>,
    /// Total maximum number of nodes in the NodePool.
    /// Must be >= total_min_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMaxNodeCount")]
    #[builder(default)]
    pub total_max_node_count: Option<f64>,
    /// Total minimum number of nodes in the NodePool.
    /// Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
    /// Total size limits are supported only in 1.24.1+ clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalMinNodeCount")]
    #[builder(default)]
    pub total_min_node_count: Option<f64>,
}

/// Node management configuration, wherein auto-repair and
/// auto-upgrade is configured. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderManagement {
    /// Whether the nodes will be automatically repaired. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRepair")]
    #[builder(default)]
    pub auto_repair: Option<bool>,
    /// Whether the nodes will be automatically upgraded. Enabled by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoUpgrade")]
    #[builder(default)]
    pub auto_upgrade: Option<bool>,
}

/// The network configuration of the pool. Such as
/// configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
/// documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNetworkConfig {
    /// We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalNodeNetworkConfigs")]
    #[builder(default)]
    pub additional_node_network_configs: Option<Vec<NodePoolStatusAtProviderNetworkConfigAdditionalNodeNetworkConfigs>>,
    /// We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalPodNetworkConfigs")]
    #[builder(default)]
    pub additional_pod_network_configs: Option<Vec<NodePoolStatusAtProviderNetworkConfigAdditionalPodNetworkConfigs>>,
    /// Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPodRange")]
    #[builder(default)]
    pub create_pod_range: Option<bool>,
    /// Whether nodes have internal IP addresses only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePrivateNodes")]
    #[builder(default)]
    pub enable_private_nodes: Option<bool>,
    /// Network bandwidth tier configuration. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<NodePoolStatusAtProviderNetworkConfigNetworkPerformanceConfig>,
    /// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCidrOverprovisionConfig")]
    #[builder(default)]
    pub pod_cidr_overprovision_config: Option<NodePoolStatusAtProviderNetworkConfigPodCidrOverprovisionConfig>,
    /// The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podIpv4CidrBlock")]
    #[builder(default)]
    pub pod_ipv4_cidr_block: Option<String>,
    /// The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podRange")]
    #[builder(default)]
    pub pod_range: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNetworkConfigAdditionalNodeNetworkConfigs {
    /// Name of the VPC where the additional interface belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNetworkConfigAdditionalPodNetworkConfigs {
    /// The maximum number of pods per node in this node pool.
    /// Note that this does not work on node pools which are "route-based" - that is, node
    /// pools belonging to clusters that do not have IP Aliasing enabled.
    /// See the official documentation
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPodsPerNode")]
    #[builder(default)]
    pub max_pods_per_node: Option<f64>,
    /// The name of the secondary range on the subnet which provides IP address for this pod range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryPodRange")]
    #[builder(default)]
    pub secondary_pod_range: Option<String>,
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
}

/// Network bandwidth tier configuration. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNetworkConfigNetworkPerformanceConfig {
    /// Specifies the total network bandwidth tier for the NodePool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNetworkConfigPodCidrOverprovisionConfig {
    /// Whether pod cidr overprovision is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<NodePoolStatusAtProviderNodeConfigAdvancedMachineFeatures>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDiskKmsKey")]
    #[builder(default)]
    pub boot_disk_kms_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialNodes")]
    #[builder(default)]
    pub confidential_nodes: Option<NodePoolStatusAtProviderNodeConfigConfidentialNodes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerdConfig")]
    #[builder(default)]
    pub containerd_config: Option<NodePoolStatusAtProviderNodeConfigContainerdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskType")]
    #[builder(default)]
    pub disk_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveTaints")]
    #[builder(default)]
    pub effective_taints: Option<Vec<NodePoolStatusAtProviderNodeConfigEffectiveTaints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialStorage")]
    #[builder(default)]
    pub enable_confidential_storage: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralStorageLocalSsdConfig")]
    #[builder(default)]
    pub ephemeral_storage_local_ssd_config: Option<NodePoolStatusAtProviderNodeConfigEphemeralStorageLocalSsdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fastSocket")]
    #[builder(default)]
    pub fast_socket: Option<NodePoolStatusAtProviderNodeConfigFastSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfsConfig")]
    #[builder(default)]
    pub gcfs_config: Option<NodePoolStatusAtProviderNodeConfigGcfsConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<NodePoolStatusAtProviderNodeConfigGuestAccelerator>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub gvnic: Option<NodePoolStatusAtProviderNodeConfigGvnic>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostMaintenancePolicy")]
    #[builder(default)]
    pub host_maintenance_policy: Option<NodePoolStatusAtProviderNodeConfigHostMaintenancePolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageType")]
    #[builder(default)]
    pub image_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletConfig")]
    #[builder(default)]
    pub kubelet_config: Option<NodePoolStatusAtProviderNodeConfigKubeletConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Parameters used in creating the node pool. See
    /// google_container_cluster for schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linuxNodeConfig")]
    #[builder(default)]
    pub linux_node_config: Option<NodePoolStatusAtProviderNodeConfigLinuxNodeConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localNvmeSsdBlockConfig")]
    #[builder(default)]
    pub local_nvme_ssd_block_config: Option<NodePoolStatusAtProviderNodeConfigLocalNvmeSsdBlockConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loggingVariant")]
    #[builder(default)]
    pub logging_variant: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeGroup")]
    #[builder(default)]
    pub node_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthScopes")]
    #[builder(default)]
    pub oauth_scopes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// The configuration of the desired reservation which instances could take capacity from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<NodePoolStatusAtProviderNodeConfigReservationAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    #[builder(default)]
    pub resource_labels: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryBootDisks")]
    #[builder(default)]
    pub secondary_boot_disks: Option<Vec<NodePoolStatusAtProviderNodeConfigSecondaryBootDisks>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<NodePoolStatusAtProviderNodeConfigShieldedInstanceConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "soleTenantConfig")]
    #[builder(default)]
    pub sole_tenant_config: Option<NodePoolStatusAtProviderNodeConfigSoleTenantConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub spot: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub taint: Option<Vec<NodePoolStatusAtProviderNodeConfigTaint>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadMetadataConfig")]
    #[builder(default)]
    pub workload_metadata_config: Option<NodePoolStatusAtProviderNodeConfigWorkloadMetadataConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigAdvancedMachineFeatures {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigConfidentialNodes {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigContainerdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateRegistryAccessConfig")]
    #[builder(default)]
    pub private_registry_access_config: Option<NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityDomainConfig")]
    #[builder(default)]
    pub certificate_authority_domain_config: Option<Vec<NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>>,
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fqdns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpSecretManagerCertificateConfig")]
    #[builder(default)]
    pub gcp_secret_manager_certificate_config: Option<NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUri")]
    #[builder(default)]
    pub secret_uri: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigEffectiveTaints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effect: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigEphemeralStorageLocalSsdConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigFastSocket {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigGcfsConfig {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigGuestAccelerator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverInstallationConfig")]
    #[builder(default)]
    pub gpu_driver_installation_config: Option<NodePoolStatusAtProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuPartitionSize")]
    #[builder(default)]
    pub gpu_partition_size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingConfig")]
    #[builder(default)]
    pub gpu_sharing_config: Option<NodePoolStatusAtProviderNodeConfigGuestAcceleratorGpuSharingConfig>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
    /// The Kubernetes version for the nodes in this pool. Note that if this field
    /// and auto_upgrade are both specified, they will fight each other for what the node version should
    /// be, so setting both is highly discouraged.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuDriverVersion")]
    #[builder(default)]
    pub gpu_driver_version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigGuestAcceleratorGpuSharingConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gpuSharingStrategy")]
    #[builder(default)]
    pub gpu_sharing_strategy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSharedClientsPerGpu")]
    #[builder(default)]
    pub max_shared_clients_per_gpu: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigGvnic {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigHostMaintenancePolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInterval")]
    #[builder(default)]
    pub maintenance_interval: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigKubeletConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuota")]
    #[builder(default)]
    pub cpu_cfs_quota: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuCfsQuotaPeriod")]
    #[builder(default)]
    pub cpu_cfs_quota_period: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuManagerPolicy")]
    #[builder(default)]
    pub cpu_manager_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureKubeletReadonlyPortEnabled")]
    #[builder(default)]
    pub insecure_kubelet_readonly_port_enabled: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPidsLimit")]
    #[builder(default)]
    pub pod_pids_limit: Option<f64>,
}

/// Parameters used in creating the node pool. See
/// google_container_cluster for schema.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigLinuxNodeConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupMode")]
    #[builder(default)]
    pub cgroup_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub sysctls: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigLocalNvmeSsdBlockConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdCount")]
    #[builder(default)]
    pub local_ssd_count: Option<f64>,
}

/// The configuration of the desired reservation which instances could take capacity from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigReservationAffinity {
    /// The type of reservation consumption
    /// Accepted values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumeReservationType")]
    #[builder(default)]
    pub consume_reservation_type: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigSecondaryBootDisks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskImage")]
    #[builder(default)]
    pub disk_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigShieldedInstanceConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigSoleTenantConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    #[builder(default)]
    pub node_affinity: Option<Vec<NodePoolStatusAtProviderNodeConfigSoleTenantConfigNodeAffinity>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigSoleTenantConfigNodeAffinity {
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// name"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigTaint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effect: Option<String>,
    /// name" as the key and specify the name of your reservation as its value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderNodeConfigWorkloadMetadataConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
}

/// Specifies a custom placement policy for the
/// nodes.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderPlacementPolicy {
    /// If set, refers to the name of a custom resource policy supplied by the user.
    /// The resource policy must be in the same project and region as the node pool.
    /// If not found, InvalidArgument error is returned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyName")]
    #[builder(default)]
    pub policy_name: Option<String>,
    /// The TPU placement topology for pod slice node pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tpuTopology")]
    #[builder(default)]
    pub tpu_topology: Option<String>,
    /// The type of the policy. Supports a single value: COMPACT.
    /// Specifying COMPACT placement policy type places node pool's nodes in a closer
    /// physical proximity in order to reduce network latency between nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies node pool-level settings of queued provisioning.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderQueuedProvisioning {
    /// Makes nodes obtainable through the ProvisioningRequest API exclusively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub enabled: Option<bool>,
}

/// Specify node upgrade settings to change how GKE upgrades nodes.
/// The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderUpgradeSettings {
    /// The settings to adjust blue green upgrades.
    /// Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blueGreenSettings")]
    #[builder(default)]
    pub blue_green_settings: Option<NodePoolStatusAtProviderUpgradeSettingsBlueGreenSettings>,
    /// The number of additional nodes that can be added to the node pool during
    /// an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
    /// Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    #[builder(default)]
    pub max_surge: Option<f64>,
    /// The number of nodes that can be simultaneously unavailable during
    /// an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
    /// parallel. Can be set to 0 or greater.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    #[builder(default)]
    pub max_unavailable: Option<f64>,
    /// (Default SURGE) The upgrade strategy to be used for upgrading the nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub strategy: Option<String>,
}

/// The settings to adjust blue green upgrades.
/// Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderUpgradeSettingsBlueGreenSettings {
    /// Time needed after draining the entire blue pool.
    /// After this period, the blue pool will be cleaned up.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePoolSoakDuration")]
    #[builder(default)]
    pub node_pool_soak_duration: Option<String>,
    /// Specifies the standard policy settings for blue-green upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardRolloutPolicy")]
    #[builder(default)]
    pub standard_rollout_policy: Option<NodePoolStatusAtProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>,
}

/// Specifies the standard policy settings for blue-green upgrades.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct NodePoolStatusAtProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
    /// Number of blue nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchNodeCount")]
    #[builder(default)]
    pub batch_node_count: Option<f64>,
    /// Percentage of the blue pool nodes to drain in a batch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchPercentage")]
    #[builder(default)]
    pub batch_percentage: Option<f64>,
    /// (Optionial) Soak time after each batch gets drained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSoakDuration")]
    #[builder(default)]
    pub batch_soak_duration: Option<String>,
}

