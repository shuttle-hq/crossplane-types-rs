// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TriggerSpec defines the desired state of Trigger
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "cloudbuild.gcp.upbound.io", version = "v1beta2", kind = "Trigger", plural = "triggers")]
#[kube(status = "TriggerStatus")]
pub struct TriggerSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<TriggerDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TriggerForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<TriggerInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<TriggerProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<TriggerPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<TriggerWriteConnectionSecretToRef>,
}

/// TriggerSpec defines the desired state of Trigger
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProvider {
    /// Configuration for manual approval to start a build invocation of this BuildTrigger.
    /// Builds created by this trigger will require approval before they execute.
    /// Any user with a Cloud Build Approver role for the project can approve a build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalConfig")]
    #[builder(default)]
    pub approval_config: Option<TriggerForProviderApprovalConfig>,
    /// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerTriggerConfig")]
    #[builder(default)]
    pub bitbucket_server_trigger_config: Option<TriggerForProviderBitbucketServerTriggerConfig>,
    /// Contents of the build template. Either a filename or build template must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(prefix = "with_"))]
    pub build: Option<TriggerForProviderBuild>,
    /// Human-readable description of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Path, from the source root, to a file whose contents is used for the template.
    /// Either a filename or build template must be provided. Set this only when using trigger_template or github.
    /// When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filename: Option<String>,
    /// A Common Expression Language string. Used only with Pub/Sub and Webhook.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The file source describing the local or remote Build template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitFileSource")]
    #[builder(default)]
    pub git_file_source: Option<TriggerForProviderGitFileSource>,
    /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
    /// One of trigger_template, github, pubsub_config or webhook_config must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub github: Option<TriggerForProviderGithub>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If ignoredFiles and changed files are both empty, then they are not
    /// used to determine whether or not to trigger a build.
    /// If ignoredFiles is not empty, then we ignore any files that match any
    /// of the ignored_file globs. If the change has no files that are outside
    /// of the ignoredFiles globs, then we do not trigger a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoredFiles")]
    #[builder(default)]
    pub ignored_files: Option<Vec<String>>,
    /// Build logs will be sent back to GitHub as part of the checkrun
    /// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
    /// INCLUDE_BUILD_LOGS_WITH_STATUS
    /// Possible values are: INCLUDE_BUILD_LOGS_UNSPECIFIED, INCLUDE_BUILD_LOGS_WITH_STATUS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBuildLogs")]
    #[builder(default)]
    pub include_build_logs: Option<String>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is empty, then as far as this filter is concerned, we
    /// should trigger the build.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is not empty, then we make sure that at least one of
    /// those files matches a includedFiles glob. If not, then we do not trigger
    /// a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFiles")]
    #[builder(default)]
    pub included_files: Option<Vec<String>>,
    /// The Cloud Build location for the trigger.
    /// If not specified, "global" is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Name of the trigger. Must be unique within the project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// PubsubConfig describes the configuration of a trigger that creates
    /// a build whenever a Pub/Sub message is published.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubConfig")]
    #[builder(default)]
    pub pubsub_config: Option<TriggerForProviderPubsubConfig>,
    /// The configuration of a trigger that creates a build whenever an event from Repo API is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repositoryEventConfig")]
    #[builder(default)]
    pub repository_event_config: Option<TriggerForProviderRepositoryEventConfig>,
    /// The service account used for all user-controlled operations including
    /// triggers.patch, triggers.run, builds.create, and builds.cancel.
    /// If no service account is set, then the standard Cloud Build service account
    /// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
    /// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<TriggerForProviderServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<TriggerForProviderServiceAccountSelector>,
    /// The repo and ref of the repository from which to build.
    /// This field is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceToBuild")]
    #[builder(default)]
    pub source_to_build: Option<TriggerForProviderSourceToBuild>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a BuildTrigger
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// Template describing the types of source changes to trigger a build.
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular
    /// expression will trigger a build.
    /// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerTemplate")]
    #[builder(default)]
    pub trigger_template: Option<TriggerForProviderTriggerTemplate>,
    /// WebhookConfig describes the configuration of a trigger that creates
    /// a build whenever a webhook is sent to a trigger's webhook URL.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfig")]
    #[builder(default)]
    pub webhook_config: Option<TriggerForProviderWebhookConfig>,
}

/// Configuration for manual approval to start a build invocation of this BuildTrigger.
/// Builds created by this trigger will require approval before they execute.
/// Any user with a Cloud Build Approver role for the project can approve a build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will become pending when run,
    /// and will need to be explicitly approved to start.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalRequired")]
    #[builder(default)]
    pub approval_required: Option<bool>,
}

/// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBitbucketServerTriggerConfig {
    /// The Bitbucket server config resource that this trigger config maps to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfigResource")]
    #[builder(default)]
    pub bitbucket_server_config_resource: Option<String>,
    /// Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is "TEST".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectKey")]
    #[builder(default)]
    pub project_key: Option<String>,
    /// Filter to match changes in pull requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerForProviderBitbucketServerTriggerConfigPullRequest>,
    /// Filter to match changes in refs like branches, tags.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerForProviderBitbucketServerTriggerConfigPush>,
    /// Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
    /// For example, if the repository name is 'test repo', in the URL it would become 'test-repo' as in https://mybitbucket.server/projects/TEST/repos/test-repo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSlug")]
    #[builder(default)]
    pub repo_slug: Option<String>,
}

/// Filter to match changes in pull requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBitbucketServerTriggerConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Filter to match changes in refs like branches, tags.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBitbucketServerTriggerConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// Contents of the build template. Either a filename or build template must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuild {
    /// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub artifacts: Option<TriggerForProviderBuildArtifacts>,
    /// Secrets and secret environment variables.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableSecrets")]
    #[builder(default)]
    pub available_secrets: Option<TriggerForProviderBuildAvailableSecrets>,
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// Google Cloud Storage bucket where logs should be written.
    /// Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsBucket")]
    #[builder(default)]
    pub logs_bucket: Option<String>,
    /// Special options for this build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub options: Option<TriggerForProviderBuildOptions>,
    /// TTL in queue for this build. If provided and the build is enqueued longer than this value,
    /// the build will expire and the build status will be EXPIRED.
    /// The TTL starts ticking from createTime.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueTtl")]
    #[builder(default)]
    pub queue_ttl: Option<String>,
    /// Secrets to decrypt using Cloud Key Management Service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<Vec<TriggerForProviderBuildSecret>>,
    /// The location of the source files to build.
    /// One of storageSource or repoSource must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<TriggerForProviderBuildSource>,
    /// The operations to be performed on the workspace.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub step: Option<Vec<TriggerForProviderBuildStep>>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a Build. These are not docker tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// Amount of time that this build should be allowed to run, to second granularity.
    /// If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.
    /// This timeout must be equal to or greater than the sum of the timeouts for build steps within the build.
    /// The expected format is the number of seconds followed by s.
    /// Default time is ten minutes (600s).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
}

/// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildArtifacts {
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// A Maven artifact to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mavenArtifacts")]
    #[builder(default)]
    pub maven_artifacts: Option<Vec<TriggerForProviderBuildArtifactsMavenArtifacts>>,
    /// Npm package to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "npmPackages")]
    #[builder(default)]
    pub npm_packages: Option<Vec<TriggerForProviderBuildArtifactsNpmPackages>>,
    /// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
    /// Files in the workspace matching specified paths globs will be uploaded to the
    /// Cloud Storage location using the builder service account's credentials.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub objects: Option<TriggerForProviderBuildArtifactsObjects>,
    /// Python package to upload to Artifact Registry upon successful completion of all build steps. A package can encapsulate multiple objects to be uploaded to a single repository.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pythonPackages")]
    #[builder(default)]
    pub python_packages: Option<Vec<TriggerForProviderBuildArtifactsPythonPackages>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildArtifactsMavenArtifacts {
    /// Maven artifactId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactId")]
    #[builder(default)]
    pub artifact_id: Option<String>,
    /// Maven groupId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupId")]
    #[builder(default)]
    pub group_id: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// Maven version value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildArtifactsNpmPackages {
    /// Path to the package.json. e.g. workspace/path/to/package
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packagePath")]
    #[builder(default)]
    pub package_path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
/// Files in the workspace matching specified paths globs will be uploaded to the
/// Cloud Storage location using the builder service account's credentials.
/// The location and generation of the uploaded objects will be stored in the Build resource's results field.
/// If any objects fail to be pushed, the build is marked FAILURE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildArtifactsObjects {
    /// Cloud Storage bucket and optional object path, in the form "gs://bucket/path/to/somewhere/".
    /// Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
    /// this location as a prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildArtifactsPythonPackages {
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Secrets and secret environment variables.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildAvailableSecrets {
    /// Pairs a secret environment variable with a SecretVersion in Secret Manager.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretManager")]
    #[builder(default)]
    pub secret_manager: Option<Vec<TriggerForProviderBuildAvailableSecretsSecretManager>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildAvailableSecretsSecretManager {
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<String>,
    /// Resource name of the SecretVersion. In format: projects//secrets//versions/*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionName")]
    #[builder(default)]
    pub version_name: Option<String>,
}

/// Special options for this build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildOptions {
    /// Requested disk size for the VM that runs the build. Note that this is NOT "disk free";
    /// some of the space will be used by the operating system and build utilities.
    /// Also note that this is the minimum disk size that will be allocated for the build --
    /// the build may run with a larger disk than requested. At present, the maximum disk size
    /// is 1000GB; builds that request more than the maximum are rejected with an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// Option to specify whether or not to apply bash style string operations to the substitutions.
    /// NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicSubstitutions")]
    #[builder(default)]
    pub dynamic_substitutions: Option<bool>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Option to define build log streaming behavior to Google Cloud Storage.
    /// Possible values are: STREAM_DEFAULT, STREAM_ON, STREAM_OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamingOption")]
    #[builder(default)]
    pub log_streaming_option: Option<String>,
    /// Option to specify the logging mode, which determines if and where build logs are stored.
    /// Possible values are: LOGGING_UNSPECIFIED, LEGACY, GCS_ONLY, STACKDRIVER_ONLY, CLOUD_LOGGING_ONLY, NONE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logging: Option<String>,
    /// Compute Engine machine type on which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Requested verifiability options.
    /// Possible values are: NOT_VERIFIED, VERIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestedVerifyOption")]
    #[builder(default)]
    pub requested_verify_option: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Requested hash for SourceProvenance.
    /// Each value may be one of: NONE, SHA256, MD5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceProvenanceHash")]
    #[builder(default)]
    pub source_provenance_hash: Option<Vec<String>>,
    /// Option to specify behavior when there is an error in the substitution checks.
    /// NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden
    /// in the build configuration file.
    /// Possible values are: MUST_MATCH, ALLOW_LOOSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "substitutionOption")]
    #[builder(default)]
    pub substitution_option: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerForProviderBuildOptionsVolumes>>,
    /// Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}
    /// This field is experimental.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildOptionsVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildSecret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<HashMap<String, String>>,
}

/// The location of the source files to build.
/// One of storageSource or repoSource must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildSource {
    /// Location of the source in a Google Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<TriggerForProviderBuildSourceRepoSource>,
    /// Location of the source in an archive file in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<TriggerForProviderBuildSourceStorageSource>,
}

/// Location of the source in a Google Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildSourceRepoSource {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// Location of the source in an archive file in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildSourceStorageSource {
    /// Google Cloud Storage bucket containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Google Cloud Storage generation for the object.
    /// If the generation is omitted, the latest generation will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<String>,
    /// Google Cloud Storage object containing the source.
    /// This object must be a gzipped archive file (.tar.gz) containing source to build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildStep {
    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes.
    /// If allowFailure is also specified, this field will take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowExitCodes")]
    #[builder(default)]
    pub allow_exit_codes: Option<Vec<f64>>,
    /// Allow this build step to fail without failing the entire build.
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failureDetail field.
    /// allowExitCodes takes precedence over this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowFailure")]
    #[builder(default)]
    pub allow_failure: Option<bool>,
    /// A list of arguments that will be presented to the step when it is started.
    /// If the image used to run the step's container has an entrypoint, the args
    /// are used as arguments to that entrypoint. If the image does not define an
    /// entrypoint, the first element in args is used as the entrypoint, and the
    /// remainder will be used as arguments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub args: Option<Vec<String>>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Entrypoint to be used instead of the build step image's
    /// default entrypoint.
    /// If unset, the image's default entrypoint is used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub entrypoint: Option<String>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Unique identifier for this build step, used in wait_for to
    /// reference this build step as a dependency.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A shell script to be executed in the step.
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub script: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Time limit for executing this build step. If not defined,
    /// the step has no
    /// time limit and will be allowed to continue to run until either it
    /// completes or the build itself times out.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
    /// Output only. Stores timing information for executing this
    /// build step.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timing: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerForProviderBuildStepVolumes>>,
    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in wait_for
    /// have completed successfully. If wait_for is empty, this build step
    /// will start when all previous build steps in the Build.Steps list
    /// have completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitFor")]
    #[builder(default)]
    pub wait_for: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderBuildStepVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

/// The file source describing the local or remote Build template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderGitFileSource {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The path of the file, with the repo root as the root of the path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The fully qualified resource name of the Repo API repository. The fully qualified resource name of the Repo API repository.
    /// If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the
    /// filename . This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions
    /// If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<String>,
    /// The URI of the repo . If unspecified, the repo from which the trigger
    /// invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
/// One of trigger_template, github, pubsub_config or webhook_config must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderGithub {
    /// The resource name of the github enterprise config that should be applied to this installation.
    /// For example: "projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enterpriseConfigResourceName")]
    #[builder(default)]
    pub enterprise_config_resource_name: Option<String>,
    /// Name of the repository. For example: The name for
    /// https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Owner of the repository. For example: The owner for
    /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub owner: Option<String>,
    /// filter to match changes in pull requests. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerForProviderGithubPullRequest>,
    /// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerForProviderGithubPush>,
}

/// filter to match changes in pull requests. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderGithubPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderGithubPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// PubsubConfig describes the configuration of a trigger that creates
/// a build whenever a Pub/Sub message is published.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderPubsubConfig {
    /// Service account that will make the push request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// The name of the topic from which this subscription is receiving messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
    /// Reference to a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicRef")]
    #[builder(default)]
    pub topic_ref: Option<TriggerForProviderPubsubConfigTopicRef>,
    /// Selector for a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicSelector")]
    #[builder(default)]
    pub topic_selector: Option<TriggerForProviderPubsubConfigTopicSelector>,
}

/// Reference to a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderPubsubConfigTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderPubsubConfigTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderPubsubConfigTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderPubsubConfigTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderPubsubConfigTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderPubsubConfigTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderPubsubConfigTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderPubsubConfigTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderPubsubConfigTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderPubsubConfigTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderPubsubConfigTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderPubsubConfigTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderPubsubConfigTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderPubsubConfigTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The configuration of a trigger that creates a build whenever an event from Repo API is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderRepositoryEventConfig {
    /// Contains filter properties for matching Pull Requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerForProviderRepositoryEventConfigPullRequest>,
    /// Contains filter properties for matching git pushes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerForProviderRepositoryEventConfigPush>,
    /// The resource name of the Repo API resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Contains filter properties for matching Pull Requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderRepositoryEventConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Contains filter properties for matching git pushes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderRepositoryEventConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The repo and ref of the repository from which to build.
/// This field is used only for those triggers that do not respond to SCM events.
/// Triggers that respond to such events build source at whatever commit caused the event.
/// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderSourceToBuild {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The branch or tag to use. Must start with "refs/" .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    #[builder(default)]
    pub r#ref: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The URI of the repo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Template describing the types of source changes to trigger a build.
/// Branch and tag names in trigger templates are interpreted as regular
/// expressions. Any branch or tag change that matches that regular
/// expression will trigger a build.
/// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderTriggerTemplate {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// WebhookConfig describes the configuration of a trigger that creates
/// a build whenever a webhook is sent to a trigger's webhook URL.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderWebhookConfig {
    /// Resource name for the secret required as a URL parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a SecretVersion in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<TriggerForProviderWebhookConfigSecretRef>,
    /// Selector for a SecretVersion in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<TriggerForProviderWebhookConfigSecretSelector>,
}

/// Reference to a SecretVersion in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderWebhookConfigSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderWebhookConfigSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderWebhookConfigSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderWebhookConfigSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderWebhookConfigSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderWebhookConfigSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderWebhookConfigSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SecretVersion in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderWebhookConfigSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerForProviderWebhookConfigSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerForProviderWebhookConfigSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerForProviderWebhookConfigSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerForProviderWebhookConfigSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderWebhookConfigSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerForProviderWebhookConfigSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProvider {
    /// Configuration for manual approval to start a build invocation of this BuildTrigger.
    /// Builds created by this trigger will require approval before they execute.
    /// Any user with a Cloud Build Approver role for the project can approve a build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalConfig")]
    #[builder(default)]
    pub approval_config: Option<TriggerInitProviderApprovalConfig>,
    /// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerTriggerConfig")]
    #[builder(default)]
    pub bitbucket_server_trigger_config: Option<TriggerInitProviderBitbucketServerTriggerConfig>,
    /// Contents of the build template. Either a filename or build template must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(prefix = "with_"))]
    pub build: Option<TriggerInitProviderBuild>,
    /// Human-readable description of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Path, from the source root, to a file whose contents is used for the template.
    /// Either a filename or build template must be provided. Set this only when using trigger_template or github.
    /// When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filename: Option<String>,
    /// A Common Expression Language string. Used only with Pub/Sub and Webhook.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The file source describing the local or remote Build template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitFileSource")]
    #[builder(default)]
    pub git_file_source: Option<TriggerInitProviderGitFileSource>,
    /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
    /// One of trigger_template, github, pubsub_config or webhook_config must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub github: Option<TriggerInitProviderGithub>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If ignoredFiles and changed files are both empty, then they are not
    /// used to determine whether or not to trigger a build.
    /// If ignoredFiles is not empty, then we ignore any files that match any
    /// of the ignored_file globs. If the change has no files that are outside
    /// of the ignoredFiles globs, then we do not trigger a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoredFiles")]
    #[builder(default)]
    pub ignored_files: Option<Vec<String>>,
    /// Build logs will be sent back to GitHub as part of the checkrun
    /// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
    /// INCLUDE_BUILD_LOGS_WITH_STATUS
    /// Possible values are: INCLUDE_BUILD_LOGS_UNSPECIFIED, INCLUDE_BUILD_LOGS_WITH_STATUS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBuildLogs")]
    #[builder(default)]
    pub include_build_logs: Option<String>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is empty, then as far as this filter is concerned, we
    /// should trigger the build.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is not empty, then we make sure that at least one of
    /// those files matches a includedFiles glob. If not, then we do not trigger
    /// a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFiles")]
    #[builder(default)]
    pub included_files: Option<Vec<String>>,
    /// The Cloud Build location for the trigger.
    /// If not specified, "global" is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Name of the trigger. Must be unique within the project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// PubsubConfig describes the configuration of a trigger that creates
    /// a build whenever a Pub/Sub message is published.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubConfig")]
    #[builder(default)]
    pub pubsub_config: Option<TriggerInitProviderPubsubConfig>,
    /// The configuration of a trigger that creates a build whenever an event from Repo API is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repositoryEventConfig")]
    #[builder(default)]
    pub repository_event_config: Option<TriggerInitProviderRepositoryEventConfig>,
    /// The service account used for all user-controlled operations including
    /// triggers.patch, triggers.run, builds.create, and builds.cancel.
    /// If no service account is set, then the standard Cloud Build service account
    /// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
    /// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<TriggerInitProviderServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<TriggerInitProviderServiceAccountSelector>,
    /// The repo and ref of the repository from which to build.
    /// This field is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceToBuild")]
    #[builder(default)]
    pub source_to_build: Option<TriggerInitProviderSourceToBuild>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a BuildTrigger
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// Template describing the types of source changes to trigger a build.
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular
    /// expression will trigger a build.
    /// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerTemplate")]
    #[builder(default)]
    pub trigger_template: Option<TriggerInitProviderTriggerTemplate>,
    /// WebhookConfig describes the configuration of a trigger that creates
    /// a build whenever a webhook is sent to a trigger's webhook URL.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfig")]
    #[builder(default)]
    pub webhook_config: Option<TriggerInitProviderWebhookConfig>,
}

/// Configuration for manual approval to start a build invocation of this BuildTrigger.
/// Builds created by this trigger will require approval before they execute.
/// Any user with a Cloud Build Approver role for the project can approve a build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will become pending when run,
    /// and will need to be explicitly approved to start.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalRequired")]
    #[builder(default)]
    pub approval_required: Option<bool>,
}

/// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBitbucketServerTriggerConfig {
    /// The Bitbucket server config resource that this trigger config maps to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfigResource")]
    #[builder(default)]
    pub bitbucket_server_config_resource: Option<String>,
    /// Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is "TEST".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectKey")]
    #[builder(default)]
    pub project_key: Option<String>,
    /// Filter to match changes in pull requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerInitProviderBitbucketServerTriggerConfigPullRequest>,
    /// Filter to match changes in refs like branches, tags.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerInitProviderBitbucketServerTriggerConfigPush>,
    /// Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
    /// For example, if the repository name is 'test repo', in the URL it would become 'test-repo' as in https://mybitbucket.server/projects/TEST/repos/test-repo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSlug")]
    #[builder(default)]
    pub repo_slug: Option<String>,
}

/// Filter to match changes in pull requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBitbucketServerTriggerConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Filter to match changes in refs like branches, tags.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBitbucketServerTriggerConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// Contents of the build template. Either a filename or build template must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuild {
    /// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub artifacts: Option<TriggerInitProviderBuildArtifacts>,
    /// Secrets and secret environment variables.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableSecrets")]
    #[builder(default)]
    pub available_secrets: Option<TriggerInitProviderBuildAvailableSecrets>,
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// Google Cloud Storage bucket where logs should be written.
    /// Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsBucket")]
    #[builder(default)]
    pub logs_bucket: Option<String>,
    /// Special options for this build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub options: Option<TriggerInitProviderBuildOptions>,
    /// TTL in queue for this build. If provided and the build is enqueued longer than this value,
    /// the build will expire and the build status will be EXPIRED.
    /// The TTL starts ticking from createTime.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueTtl")]
    #[builder(default)]
    pub queue_ttl: Option<String>,
    /// Secrets to decrypt using Cloud Key Management Service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<Vec<TriggerInitProviderBuildSecret>>,
    /// The location of the source files to build.
    /// One of storageSource or repoSource must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<TriggerInitProviderBuildSource>,
    /// The operations to be performed on the workspace.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub step: Option<Vec<TriggerInitProviderBuildStep>>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a Build. These are not docker tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// Amount of time that this build should be allowed to run, to second granularity.
    /// If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.
    /// This timeout must be equal to or greater than the sum of the timeouts for build steps within the build.
    /// The expected format is the number of seconds followed by s.
    /// Default time is ten minutes (600s).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
}

/// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildArtifacts {
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// A Maven artifact to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mavenArtifacts")]
    #[builder(default)]
    pub maven_artifacts: Option<Vec<TriggerInitProviderBuildArtifactsMavenArtifacts>>,
    /// Npm package to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "npmPackages")]
    #[builder(default)]
    pub npm_packages: Option<Vec<TriggerInitProviderBuildArtifactsNpmPackages>>,
    /// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
    /// Files in the workspace matching specified paths globs will be uploaded to the
    /// Cloud Storage location using the builder service account's credentials.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub objects: Option<TriggerInitProviderBuildArtifactsObjects>,
    /// Python package to upload to Artifact Registry upon successful completion of all build steps. A package can encapsulate multiple objects to be uploaded to a single repository.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pythonPackages")]
    #[builder(default)]
    pub python_packages: Option<Vec<TriggerInitProviderBuildArtifactsPythonPackages>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildArtifactsMavenArtifacts {
    /// Maven artifactId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactId")]
    #[builder(default)]
    pub artifact_id: Option<String>,
    /// Maven groupId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupId")]
    #[builder(default)]
    pub group_id: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// Maven version value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildArtifactsNpmPackages {
    /// Path to the package.json. e.g. workspace/path/to/package
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packagePath")]
    #[builder(default)]
    pub package_path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
/// Files in the workspace matching specified paths globs will be uploaded to the
/// Cloud Storage location using the builder service account's credentials.
/// The location and generation of the uploaded objects will be stored in the Build resource's results field.
/// If any objects fail to be pushed, the build is marked FAILURE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildArtifactsObjects {
    /// Cloud Storage bucket and optional object path, in the form "gs://bucket/path/to/somewhere/".
    /// Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
    /// this location as a prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildArtifactsPythonPackages {
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Secrets and secret environment variables.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildAvailableSecrets {
    /// Pairs a secret environment variable with a SecretVersion in Secret Manager.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretManager")]
    #[builder(default)]
    pub secret_manager: Option<Vec<TriggerInitProviderBuildAvailableSecretsSecretManager>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildAvailableSecretsSecretManager {
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<String>,
    /// Resource name of the SecretVersion. In format: projects//secrets//versions/*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionName")]
    #[builder(default)]
    pub version_name: Option<String>,
}

/// Special options for this build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildOptions {
    /// Requested disk size for the VM that runs the build. Note that this is NOT "disk free";
    /// some of the space will be used by the operating system and build utilities.
    /// Also note that this is the minimum disk size that will be allocated for the build --
    /// the build may run with a larger disk than requested. At present, the maximum disk size
    /// is 1000GB; builds that request more than the maximum are rejected with an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// Option to specify whether or not to apply bash style string operations to the substitutions.
    /// NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicSubstitutions")]
    #[builder(default)]
    pub dynamic_substitutions: Option<bool>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Option to define build log streaming behavior to Google Cloud Storage.
    /// Possible values are: STREAM_DEFAULT, STREAM_ON, STREAM_OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamingOption")]
    #[builder(default)]
    pub log_streaming_option: Option<String>,
    /// Option to specify the logging mode, which determines if and where build logs are stored.
    /// Possible values are: LOGGING_UNSPECIFIED, LEGACY, GCS_ONLY, STACKDRIVER_ONLY, CLOUD_LOGGING_ONLY, NONE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logging: Option<String>,
    /// Compute Engine machine type on which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Requested verifiability options.
    /// Possible values are: NOT_VERIFIED, VERIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestedVerifyOption")]
    #[builder(default)]
    pub requested_verify_option: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Requested hash for SourceProvenance.
    /// Each value may be one of: NONE, SHA256, MD5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceProvenanceHash")]
    #[builder(default)]
    pub source_provenance_hash: Option<Vec<String>>,
    /// Option to specify behavior when there is an error in the substitution checks.
    /// NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden
    /// in the build configuration file.
    /// Possible values are: MUST_MATCH, ALLOW_LOOSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "substitutionOption")]
    #[builder(default)]
    pub substitution_option: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerInitProviderBuildOptionsVolumes>>,
    /// Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}
    /// This field is experimental.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildOptionsVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildSecret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<HashMap<String, String>>,
}

/// The location of the source files to build.
/// One of storageSource or repoSource must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildSource {
    /// Location of the source in a Google Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<TriggerInitProviderBuildSourceRepoSource>,
    /// Location of the source in an archive file in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<TriggerInitProviderBuildSourceStorageSource>,
}

/// Location of the source in a Google Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildSourceRepoSource {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// Location of the source in an archive file in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildSourceStorageSource {
    /// Google Cloud Storage bucket containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Google Cloud Storage generation for the object.
    /// If the generation is omitted, the latest generation will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<String>,
    /// Google Cloud Storage object containing the source.
    /// This object must be a gzipped archive file (.tar.gz) containing source to build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildStep {
    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes.
    /// If allowFailure is also specified, this field will take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowExitCodes")]
    #[builder(default)]
    pub allow_exit_codes: Option<Vec<f64>>,
    /// Allow this build step to fail without failing the entire build.
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failureDetail field.
    /// allowExitCodes takes precedence over this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowFailure")]
    #[builder(default)]
    pub allow_failure: Option<bool>,
    /// A list of arguments that will be presented to the step when it is started.
    /// If the image used to run the step's container has an entrypoint, the args
    /// are used as arguments to that entrypoint. If the image does not define an
    /// entrypoint, the first element in args is used as the entrypoint, and the
    /// remainder will be used as arguments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub args: Option<Vec<String>>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Entrypoint to be used instead of the build step image's
    /// default entrypoint.
    /// If unset, the image's default entrypoint is used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub entrypoint: Option<String>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Unique identifier for this build step, used in wait_for to
    /// reference this build step as a dependency.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A shell script to be executed in the step.
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub script: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Time limit for executing this build step. If not defined,
    /// the step has no
    /// time limit and will be allowed to continue to run until either it
    /// completes or the build itself times out.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
    /// Output only. Stores timing information for executing this
    /// build step.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timing: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerInitProviderBuildStepVolumes>>,
    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in wait_for
    /// have completed successfully. If wait_for is empty, this build step
    /// will start when all previous build steps in the Build.Steps list
    /// have completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitFor")]
    #[builder(default)]
    pub wait_for: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderBuildStepVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

/// The file source describing the local or remote Build template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderGitFileSource {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The path of the file, with the repo root as the root of the path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The fully qualified resource name of the Repo API repository. The fully qualified resource name of the Repo API repository.
    /// If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the
    /// filename . This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions
    /// If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<String>,
    /// The URI of the repo . If unspecified, the repo from which the trigger
    /// invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
/// One of trigger_template, github, pubsub_config or webhook_config must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderGithub {
    /// The resource name of the github enterprise config that should be applied to this installation.
    /// For example: "projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enterpriseConfigResourceName")]
    #[builder(default)]
    pub enterprise_config_resource_name: Option<String>,
    /// Name of the repository. For example: The name for
    /// https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Owner of the repository. For example: The owner for
    /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub owner: Option<String>,
    /// filter to match changes in pull requests. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerInitProviderGithubPullRequest>,
    /// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerInitProviderGithubPush>,
}

/// filter to match changes in pull requests. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderGithubPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderGithubPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// PubsubConfig describes the configuration of a trigger that creates
/// a build whenever a Pub/Sub message is published.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderPubsubConfig {
    /// Service account that will make the push request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// The name of the topic from which this subscription is receiving messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
    /// Reference to a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicRef")]
    #[builder(default)]
    pub topic_ref: Option<TriggerInitProviderPubsubConfigTopicRef>,
    /// Selector for a Topic in pubsub to populate topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicSelector")]
    #[builder(default)]
    pub topic_selector: Option<TriggerInitProviderPubsubConfigTopicSelector>,
}

/// Reference to a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderPubsubConfigTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderPubsubConfigTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderPubsubConfigTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderPubsubConfigTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderPubsubConfigTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderPubsubConfigTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderPubsubConfigTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate topic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderPubsubConfigTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderPubsubConfigTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderPubsubConfigTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderPubsubConfigTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderPubsubConfigTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderPubsubConfigTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderPubsubConfigTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The configuration of a trigger that creates a build whenever an event from Repo API is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderRepositoryEventConfig {
    /// Contains filter properties for matching Pull Requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerInitProviderRepositoryEventConfigPullRequest>,
    /// Contains filter properties for matching git pushes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerInitProviderRepositoryEventConfigPush>,
    /// The resource name of the Repo API resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Contains filter properties for matching Pull Requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderRepositoryEventConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Contains filter properties for matching git pushes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderRepositoryEventConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The repo and ref of the repository from which to build.
/// This field is used only for those triggers that do not respond to SCM events.
/// Triggers that respond to such events build source at whatever commit caused the event.
/// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderSourceToBuild {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The branch or tag to use. Must start with "refs/" .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    #[builder(default)]
    pub r#ref: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The URI of the repo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Template describing the types of source changes to trigger a build.
/// Branch and tag names in trigger templates are interpreted as regular
/// expressions. Any branch or tag change that matches that regular
/// expression will trigger a build.
/// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderTriggerTemplate {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// WebhookConfig describes the configuration of a trigger that creates
/// a build whenever a webhook is sent to a trigger's webhook URL.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderWebhookConfig {
    /// Resource name for the secret required as a URL parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a SecretVersion in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<TriggerInitProviderWebhookConfigSecretRef>,
    /// Selector for a SecretVersion in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<TriggerInitProviderWebhookConfigSecretSelector>,
}

/// Reference to a SecretVersion in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderWebhookConfigSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderWebhookConfigSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderWebhookConfigSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderWebhookConfigSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderWebhookConfigSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderWebhookConfigSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderWebhookConfigSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a SecretVersion in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderWebhookConfigSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerInitProviderWebhookConfigSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerInitProviderWebhookConfigSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerInitProviderWebhookConfigSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerInitProviderWebhookConfigSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderWebhookConfigSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerInitProviderWebhookConfigSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<TriggerPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<TriggerPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TriggerPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TriggerPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TriggerPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TriggerPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TriggerStatus defines the observed state of Trigger.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<TriggerStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProvider {
    /// Configuration for manual approval to start a build invocation of this BuildTrigger.
    /// Builds created by this trigger will require approval before they execute.
    /// Any user with a Cloud Build Approver role for the project can approve a build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalConfig")]
    #[builder(default)]
    pub approval_config: Option<TriggerStatusAtProviderApprovalConfig>,
    /// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerTriggerConfig")]
    #[builder(default)]
    pub bitbucket_server_trigger_config: Option<TriggerStatusAtProviderBitbucketServerTriggerConfig>,
    /// Contents of the build template. Either a filename or build template must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(prefix = "with_"))]
    pub build: Option<TriggerStatusAtProviderBuild>,
    /// Time when the trigger was created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createTime")]
    #[builder(default)]
    pub create_time: Option<String>,
    /// Human-readable description of the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Path, from the source root, to a file whose contents is used for the template.
    /// Either a filename or build template must be provided. Set this only when using trigger_template or github.
    /// When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filename: Option<String>,
    /// A Common Expression Language string. Used only with Pub/Sub and Webhook.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filter: Option<String>,
    /// The file source describing the local or remote Build template.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitFileSource")]
    #[builder(default)]
    pub git_file_source: Option<TriggerStatusAtProviderGitFileSource>,
    /// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
    /// One of trigger_template, github, pubsub_config or webhook_config must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub github: Option<TriggerStatusAtProviderGithub>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If ignoredFiles and changed files are both empty, then they are not
    /// used to determine whether or not to trigger a build.
    /// If ignoredFiles is not empty, then we ignore any files that match any
    /// of the ignored_file globs. If the change has no files that are outside
    /// of the ignoredFiles globs, then we do not trigger a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoredFiles")]
    #[builder(default)]
    pub ignored_files: Option<Vec<String>>,
    /// Build logs will be sent back to GitHub as part of the checkrun
    /// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
    /// INCLUDE_BUILD_LOGS_WITH_STATUS
    /// Possible values are: INCLUDE_BUILD_LOGS_UNSPECIFIED, INCLUDE_BUILD_LOGS_WITH_STATUS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeBuildLogs")]
    #[builder(default)]
    pub include_build_logs: Option<String>,
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for **.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is empty, then as far as this filter is concerned, we
    /// should trigger the build.
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is not empty, then we make sure that at least one of
    /// those files matches a includedFiles glob. If not, then we do not trigger
    /// a build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includedFiles")]
    #[builder(default)]
    pub included_files: Option<Vec<String>>,
    /// The Cloud Build location for the trigger.
    /// If not specified, "global" is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Name of the trigger. Must be unique within the project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// PubsubConfig describes the configuration of a trigger that creates
    /// a build whenever a Pub/Sub message is published.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubConfig")]
    #[builder(default)]
    pub pubsub_config: Option<TriggerStatusAtProviderPubsubConfig>,
    /// The configuration of a trigger that creates a build whenever an event from Repo API is received.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repositoryEventConfig")]
    #[builder(default)]
    pub repository_event_config: Option<TriggerStatusAtProviderRepositoryEventConfig>,
    /// The service account used for all user-controlled operations including
    /// triggers.patch, triggers.run, builds.create, and builds.cancel.
    /// If no service account is set, then the standard Cloud Build service account
    /// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
    /// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// The repo and ref of the repository from which to build.
    /// This field is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceToBuild")]
    #[builder(default)]
    pub source_to_build: Option<TriggerStatusAtProviderSourceToBuild>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a BuildTrigger
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// The unique identifier for the trigger.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerId")]
    #[builder(default)]
    pub trigger_id: Option<String>,
    /// Template describing the types of source changes to trigger a build.
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular
    /// expression will trigger a build.
    /// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerTemplate")]
    #[builder(default)]
    pub trigger_template: Option<TriggerStatusAtProviderTriggerTemplate>,
    /// WebhookConfig describes the configuration of a trigger that creates
    /// a build whenever a webhook is sent to a trigger's webhook URL.
    /// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfig")]
    #[builder(default)]
    pub webhook_config: Option<TriggerStatusAtProviderWebhookConfig>,
}

/// Configuration for manual approval to start a build invocation of this BuildTrigger.
/// Builds created by this trigger will require approval before they execute.
/// Any user with a Cloud Build Approver role for the project can approve a build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will become pending when run,
    /// and will need to be explicitly approved to start.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "approvalRequired")]
    #[builder(default)]
    pub approval_required: Option<bool>,
}

/// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBitbucketServerTriggerConfig {
    /// The Bitbucket server config resource that this trigger config maps to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfigResource")]
    #[builder(default)]
    pub bitbucket_server_config_resource: Option<String>,
    /// Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is "TEST".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectKey")]
    #[builder(default)]
    pub project_key: Option<String>,
    /// Filter to match changes in pull requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerStatusAtProviderBitbucketServerTriggerConfigPullRequest>,
    /// Filter to match changes in refs like branches, tags.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerStatusAtProviderBitbucketServerTriggerConfigPush>,
    /// Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
    /// For example, if the repository name is 'test repo', in the URL it would become 'test-repo' as in https://mybitbucket.server/projects/TEST/repos/test-repo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSlug")]
    #[builder(default)]
    pub repo_slug: Option<String>,
}

/// Filter to match changes in pull requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBitbucketServerTriggerConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Filter to match changes in refs like branches, tags.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBitbucketServerTriggerConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// Contents of the build template. Either a filename or build template must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuild {
    /// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub artifacts: Option<TriggerStatusAtProviderBuildArtifacts>,
    /// Secrets and secret environment variables.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableSecrets")]
    #[builder(default)]
    pub available_secrets: Option<TriggerStatusAtProviderBuildAvailableSecrets>,
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// Google Cloud Storage bucket where logs should be written.
    /// Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsBucket")]
    #[builder(default)]
    pub logs_bucket: Option<String>,
    /// Special options for this build.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub options: Option<TriggerStatusAtProviderBuildOptions>,
    /// TTL in queue for this build. If provided and the build is enqueued longer than this value,
    /// the build will expire and the build status will be EXPIRED.
    /// The TTL starts ticking from createTime.
    /// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueTtl")]
    #[builder(default)]
    pub queue_ttl: Option<String>,
    /// Secrets to decrypt using Cloud Key Management Service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<Vec<TriggerStatusAtProviderBuildSecret>>,
    /// The location of the source files to build.
    /// One of storageSource or repoSource must be provided.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<TriggerStatusAtProviderBuildSource>,
    /// The operations to be performed on the workspace.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub step: Option<Vec<TriggerStatusAtProviderBuildStep>>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Tags for annotation of a Build. These are not docker tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// Amount of time that this build should be allowed to run, to second granularity.
    /// If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.
    /// This timeout must be equal to or greater than the sum of the timeouts for build steps within the build.
    /// The expected format is the number of seconds followed by s.
    /// Default time is ten minutes (600s).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
}

/// Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifacts {
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account's credentials.
    /// The digests of the pushed images will be stored in the Build resource's results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub images: Option<Vec<String>>,
    /// A Maven artifact to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mavenArtifacts")]
    #[builder(default)]
    pub maven_artifacts: Option<Vec<TriggerStatusAtProviderBuildArtifactsMavenArtifacts>>,
    /// Npm package to upload to Artifact Registry upon successful completion of all build steps.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "npmPackages")]
    #[builder(default)]
    pub npm_packages: Option<Vec<TriggerStatusAtProviderBuildArtifactsNpmPackages>>,
    /// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
    /// Files in the workspace matching specified paths globs will be uploaded to the
    /// Cloud Storage location using the builder service account's credentials.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub objects: Option<TriggerStatusAtProviderBuildArtifactsObjects>,
    /// Python package to upload to Artifact Registry upon successful completion of all build steps. A package can encapsulate multiple objects to be uploaded to a single repository.
    /// The location and generation of the uploaded objects will be stored in the Build resource's results field.
    /// If any objects fail to be pushed, the build is marked FAILURE.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pythonPackages")]
    #[builder(default)]
    pub python_packages: Option<Vec<TriggerStatusAtProviderBuildArtifactsPythonPackages>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifactsMavenArtifacts {
    /// Maven artifactId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactId")]
    #[builder(default)]
    pub artifact_id: Option<String>,
    /// Maven groupId value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupId")]
    #[builder(default)]
    pub group_id: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// Maven version value used when uploading the artifact to Artifact Registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifactsNpmPackages {
    /// Path to the package.json. e.g. workspace/path/to/package
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packagePath")]
    #[builder(default)]
    pub package_path: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
/// Files in the workspace matching specified paths globs will be uploaded to the
/// Cloud Storage location using the builder service account's credentials.
/// The location and generation of the uploaded objects will be stored in the Build resource's results field.
/// If any objects fail to be pushed, the build is marked FAILURE.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifactsObjects {
    /// Cloud Storage bucket and optional object path, in the form "gs://bucket/path/to/somewhere/".
    /// Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
    /// this location as a prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// Output only. Stores timing information for executing this
    /// build step.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timing: Option<Vec<TriggerStatusAtProviderBuildArtifactsObjectsTiming>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifactsObjectsTiming {
    /// End of time span.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to
    /// nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    #[builder(default)]
    pub end_time: Option<String>,
    /// Start of time span.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to
    /// nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    #[builder(default)]
    pub start_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildArtifactsPythonPackages {
    /// Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Secrets and secret environment variables.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildAvailableSecrets {
    /// Pairs a secret environment variable with a SecretVersion in Secret Manager.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretManager")]
    #[builder(default)]
    pub secret_manager: Option<Vec<TriggerStatusAtProviderBuildAvailableSecretsSecretManager>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildAvailableSecretsSecretManager {
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<String>,
    /// Resource name of the SecretVersion. In format: projects//secrets//versions/*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versionName")]
    #[builder(default)]
    pub version_name: Option<String>,
}

/// Special options for this build.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildOptions {
    /// Requested disk size for the VM that runs the build. Note that this is NOT "disk free";
    /// some of the space will be used by the operating system and build utilities.
    /// Also note that this is the minimum disk size that will be allocated for the build --
    /// the build may run with a larger disk than requested. At present, the maximum disk size
    /// is 1000GB; builds that request more than the maximum are rejected with an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSizeGb")]
    #[builder(default)]
    pub disk_size_gb: Option<f64>,
    /// Option to specify whether or not to apply bash style string operations to the substitutions.
    /// NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicSubstitutions")]
    #[builder(default)]
    pub dynamic_substitutions: Option<bool>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Option to define build log streaming behavior to Google Cloud Storage.
    /// Possible values are: STREAM_DEFAULT, STREAM_ON, STREAM_OFF.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamingOption")]
    #[builder(default)]
    pub log_streaming_option: Option<String>,
    /// Option to specify the logging mode, which determines if and where build logs are stored.
    /// Possible values are: LOGGING_UNSPECIFIED, LEGACY, GCS_ONLY, STACKDRIVER_ONLY, CLOUD_LOGGING_ONLY, NONE.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logging: Option<String>,
    /// Compute Engine machine type on which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Requested verifiability options.
    /// Possible values are: NOT_VERIFIED, VERIFIED.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestedVerifyOption")]
    #[builder(default)]
    pub requested_verify_option: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Requested hash for SourceProvenance.
    /// Each value may be one of: NONE, SHA256, MD5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceProvenanceHash")]
    #[builder(default)]
    pub source_provenance_hash: Option<Vec<String>>,
    /// Option to specify behavior when there is an error in the substitution checks.
    /// NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden
    /// in the build configuration file.
    /// Possible values are: MUST_MATCH, ALLOW_LOOSE.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "substitutionOption")]
    #[builder(default)]
    pub substitution_option: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerStatusAtProviderBuildOptionsVolumes>>,
    /// Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}
    /// This field is experimental.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildOptionsVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildSecret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<HashMap<String, String>>,
}

/// The location of the source files to build.
/// One of storageSource or repoSource must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildSource {
    /// Location of the source in a Google Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<TriggerStatusAtProviderBuildSourceRepoSource>,
    /// Location of the source in an archive file in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<TriggerStatusAtProviderBuildSourceStorageSource>,
}

/// Location of the source in a Google Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildSourceRepoSource {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Substitutions data for Build resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub substitutions: Option<HashMap<String, String>>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// Location of the source in an archive file in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildSourceStorageSource {
    /// Google Cloud Storage bucket containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Google Cloud Storage generation for the object.
    /// If the generation is omitted, the latest generation will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<String>,
    /// Google Cloud Storage object containing the source.
    /// This object must be a gzipped archive file (.tar.gz) containing source to build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildStep {
    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes.
    /// If allowFailure is also specified, this field will take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowExitCodes")]
    #[builder(default)]
    pub allow_exit_codes: Option<Vec<f64>>,
    /// Allow this build step to fail without failing the entire build.
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failureDetail field.
    /// allowExitCodes takes precedence over this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowFailure")]
    #[builder(default)]
    pub allow_failure: Option<bool>,
    /// A list of arguments that will be presented to the step when it is started.
    /// If the image used to run the step's container has an entrypoint, the args
    /// are used as arguments to that entrypoint. If the image does not define an
    /// entrypoint, the first element in args is used as the entrypoint, and the
    /// remainder will be used as arguments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub args: Option<Vec<String>>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Entrypoint to be used instead of the build step image's
    /// default entrypoint.
    /// If unset, the image's default entrypoint is used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub entrypoint: Option<String>,
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// The elements are of the form "KEY=VALUE" for the environment variable
    /// "KEY" being given the value "VALUE".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub env: Option<Vec<String>>,
    /// Unique identifier for this build step, used in wait_for to
    /// reference this build step as a dependency.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// A shell script to be executed in the step.
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub script: Option<String>,
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build's Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnv")]
    #[builder(default)]
    pub secret_env: Option<Vec<String>>,
    /// Time limit for executing this build step. If not defined,
    /// the step has no
    /// time limit and will be allowed to continue to run until either it
    /// completes or the build itself times out.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<String>,
    /// Output only. Stores timing information for executing this
    /// build step.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timing: Option<String>,
    /// List of volumes to mount into the build step.
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents
    /// are discarded.
    /// Using a named volume in only one step is not valid as it is
    /// indicative of a build request with an incorrect configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub volumes: Option<Vec<TriggerStatusAtProviderBuildStepVolumes>>,
    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in wait_for
    /// have completed successfully. If wait_for is empty, this build step
    /// will start when all previous build steps in the Build.Steps list
    /// have completed successfully.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitFor")]
    #[builder(default)]
    pub wait_for: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderBuildStepVolumes {
    /// Name of the volume to mount.
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Path at which to mount the volume.
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
}

/// The file source describing the local or remote Build template.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderGitFileSource {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The path of the file, with the repo root as the root of the path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The fully qualified resource name of the Repo API repository. The fully qualified resource name of the Repo API repository.
    /// If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the
    /// filename . This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions
    /// If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revision: Option<String>,
    /// The URI of the repo . If unspecified, the repo from which the trigger
    /// invocation originated is assumed to be the repo from which to read the specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
/// One of trigger_template, github, pubsub_config or webhook_config must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderGithub {
    /// The resource name of the github enterprise config that should be applied to this installation.
    /// For example: "projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enterpriseConfigResourceName")]
    #[builder(default)]
    pub enterprise_config_resource_name: Option<String>,
    /// Name of the repository. For example: The name for
    /// https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Owner of the repository. For example: The owner for
    /// https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub owner: Option<String>,
    /// filter to match changes in pull requests. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerStatusAtProviderGithubPullRequest>,
    /// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerStatusAtProviderGithubPush>,
}

/// filter to match changes in pull requests. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderGithubPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// filter to match changes in refs, like branches or tags. Specify only one of pull_request or push.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderGithubPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// PubsubConfig describes the configuration of a trigger that creates
/// a build whenever a Pub/Sub message is published.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderPubsubConfig {
    /// Service account that will make the push request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// (Output)
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
    /// (Output)
    /// Output only. Name of the subscription.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subscription: Option<String>,
    /// The name of the topic from which this subscription is receiving messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub topic: Option<String>,
}

/// The configuration of a trigger that creates a build whenever an event from Repo API is received.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderRepositoryEventConfig {
    /// Contains filter properties for matching Pull Requests.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullRequest")]
    #[builder(default)]
    pub pull_request: Option<TriggerStatusAtProviderRepositoryEventConfigPullRequest>,
    /// Contains filter properties for matching git pushes.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub push: Option<TriggerStatusAtProviderRepositoryEventConfigPush>,
    /// The resource name of the Repo API resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
}

/// Contains filter properties for matching Pull Requests.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderRepositoryEventConfigPullRequest {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
    /// Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commentControl")]
    #[builder(default)]
    pub comment_control: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
}

/// Contains filter properties for matching git pushes.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderRepositoryEventConfigPush {
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub branch: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Regex of tags to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tag: Option<String>,
}

/// The repo and ref of the repository from which to build.
/// This field is used only for those triggers that do not respond to SCM events.
/// Triggers that respond to such events build source at whatever commit caused the event.
/// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderSourceToBuild {
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bitbucketServerConfig")]
    #[builder(default)]
    pub bitbucket_server_config: Option<String>,
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubEnterpriseConfig")]
    #[builder(default)]
    pub github_enterprise_config: Option<String>,
    /// The branch or tag to use. Must start with "refs/" .
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    #[builder(default)]
    pub r#ref: Option<String>,
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
    /// Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoType")]
    #[builder(default)]
    pub repo_type: Option<String>,
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub repository: Option<String>,
    /// The URI of the repo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
}

/// Template describing the types of source changes to trigger a build.
/// Branch and tag names in trigger templates are interpreted as regular
/// expressions. Any branch or tag change that matches that regular
/// expression will trigger a build.
/// One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderTriggerTemplate {
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step's dir is specified and
    /// is an absolute path, this value is ignored for that step's
    /// execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// WebhookConfig describes the configuration of a trigger that creates
/// a build whenever a webhook is sent to a trigger's webhook URL.
/// One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TriggerStatusAtProviderWebhookConfig {
    /// Resource name for the secret required as a URL parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// (Output)
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
}

