// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TopicSpec defines the desired state of Topic
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "sns.aws.upbound.io", version = "v1beta1", kind = "Topic", plural = "topics")]
#[kube(status = "TopicStatus")]
pub struct TopicSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<TopicDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: TopicForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<TopicInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<TopicProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<TopicPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<TopicWriteConnectionSecretToRef>,
}

/// TopicSpec defines the desired state of Topic
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProvider {
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArn")]
    #[builder(default)]
    pub application_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub application_failure_feedback_role_arn_ref: Option<TopicForProviderApplicationFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub application_failure_feedback_role_arn_selector: Option<TopicForProviderApplicationFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub application_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub application_success_feedback_role_arn_ref: Option<TopicForProviderApplicationSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub application_success_feedback_role_arn_selector: Option<TopicForProviderApplicationSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub application_success_feedback_sample_rate: Option<f64>,
    /// The message archive policy for FIFO topics. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archivePolicy")]
    #[builder(default)]
    pub archive_policy: Option<String>,
    /// Enables content-based deduplication for FIFO topics. For more information, see the related documentation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentBasedDeduplication")]
    #[builder(default)]
    pub content_based_deduplication: Option<bool>,
    /// The SNS delivery policy. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryPolicy")]
    #[builder(default)]
    pub delivery_policy: Option<String>,
    /// The display name for the topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Boolean indicating whether or not to create a FIFO (first-in-first-out) topic. FIFO topics can't deliver messages to customer managed endpoints, such as email addresses, mobile apps, SMS, or HTTP(S) endpoints. These endpoint types aren't guaranteed to preserve strict message ordering. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fifoTopic")]
    #[builder(default)]
    pub fifo_topic: Option<bool>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn_ref: Option<TopicForProviderFirehoseFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn_selector: Option<TopicForProviderFirehoseFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn_ref: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn_selector: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub firehose_success_feedback_sample_rate: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArn")]
    #[builder(default)]
    pub http_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub http_failure_feedback_role_arn_ref: Option<TopicForProviderHttpFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub http_failure_feedback_role_arn_selector: Option<TopicForProviderHttpFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub http_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub http_success_feedback_role_arn_ref: Option<TopicForProviderHttpSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub http_success_feedback_role_arn_selector: Option<TopicForProviderHttpSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub http_success_feedback_sample_rate: Option<f64>,
    /// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see Key Terms
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsMasterKeyId")]
    #[builder(default)]
    pub kms_master_key_id: Option<String>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn_ref: Option<TopicForProviderLambdaFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn_selector: Option<TopicForProviderLambdaFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn_ref: Option<TopicForProviderLambdaSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn_selector: Option<TopicForProviderLambdaSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub lambda_success_feedback_sample_rate: Option<f64>,
    /// The fully-formed AWS policy as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<String>,
    /// Region is the region you'd like your resource to be created in.
    pub region: String,
    /// If SignatureVersion should be 1 (SHA1) or 2 (SHA256). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signatureVersion")]
    #[builder(default)]
    pub signature_version: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn_ref: Option<TopicForProviderSqsFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn_selector: Option<TopicForProviderSqsFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn_ref: Option<TopicForProviderSqsSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn_selector: Option<TopicForProviderSqsSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub sqs_success_feedback_sample_rate: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Tracing mode of an Amazon SNS topic. Valid values: "PassThrough", "Active".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tracingConfig")]
    #[builder(default)]
    pub tracing_config: Option<String>,
}

/// Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderApplicationFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderApplicationFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderApplicationFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderHttpFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderHttpFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderHttpFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderHttpSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderHttpSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderHttpSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderLambdaFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderLambdaFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderLambdaFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderSqsFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderSqsFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderSqsFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderSqsSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderSqsSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderSqsSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProvider {
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArn")]
    #[builder(default)]
    pub application_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub application_failure_feedback_role_arn_ref: Option<TopicInitProviderApplicationFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub application_failure_feedback_role_arn_selector: Option<TopicInitProviderApplicationFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub application_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub application_success_feedback_role_arn_ref: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub application_success_feedback_role_arn_selector: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub application_success_feedback_sample_rate: Option<f64>,
    /// The message archive policy for FIFO topics. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archivePolicy")]
    #[builder(default)]
    pub archive_policy: Option<String>,
    /// Enables content-based deduplication for FIFO topics. For more information, see the related documentation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentBasedDeduplication")]
    #[builder(default)]
    pub content_based_deduplication: Option<bool>,
    /// The SNS delivery policy. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryPolicy")]
    #[builder(default)]
    pub delivery_policy: Option<String>,
    /// The display name for the topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Boolean indicating whether or not to create a FIFO (first-in-first-out) topic. FIFO topics can't deliver messages to customer managed endpoints, such as email addresses, mobile apps, SMS, or HTTP(S) endpoints. These endpoint types aren't guaranteed to preserve strict message ordering. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fifoTopic")]
    #[builder(default)]
    pub fifo_topic: Option<bool>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn_ref: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn_selector: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn_ref: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn_selector: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub firehose_success_feedback_sample_rate: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArn")]
    #[builder(default)]
    pub http_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub http_failure_feedback_role_arn_ref: Option<TopicInitProviderHttpFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub http_failure_feedback_role_arn_selector: Option<TopicInitProviderHttpFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub http_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub http_success_feedback_role_arn_ref: Option<TopicInitProviderHttpSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub http_success_feedback_role_arn_selector: Option<TopicInitProviderHttpSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub http_success_feedback_sample_rate: Option<f64>,
    /// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see Key Terms
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsMasterKeyId")]
    #[builder(default)]
    pub kms_master_key_id: Option<String>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn_ref: Option<TopicInitProviderLambdaFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn_selector: Option<TopicInitProviderLambdaFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn_ref: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn_selector: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub lambda_success_feedback_sample_rate: Option<f64>,
    /// The fully-formed AWS policy as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<String>,
    /// If SignatureVersion should be 1 (SHA1) or 2 (SHA256). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signatureVersion")]
    #[builder(default)]
    pub signature_version: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArnRef")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn_ref: Option<TopicInitProviderSqsFailureFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArnSelector")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn_selector: Option<TopicInitProviderSqsFailureFeedbackRoleArnSelector>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn: Option<String>,
    /// Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArnRef")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn_ref: Option<TopicInitProviderSqsSuccessFeedbackRoleArnRef>,
    /// Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArnSelector")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn_selector: Option<TopicInitProviderSqsSuccessFeedbackRoleArnSelector>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub sqs_success_feedback_sample_rate: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// Tracing mode of an Amazon SNS topic. Valid values: "PassThrough", "Active".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tracingConfig")]
    #[builder(default)]
    pub tracing_config: Option<String>,
}

/// Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderHttpFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderHttpFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderHttpFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsFailureFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderSqsFailureFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsFailureFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderSqsFailureFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderSqsFailureFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsFailureFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsFailureFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsFailureFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsSuccessFeedbackRoleArnRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsSuccessFeedbackRoleArnRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsSuccessFeedbackRoleArnSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicInitProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<TopicPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<TopicPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<TopicPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<TopicPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<TopicPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TopicPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// TopicStatus defines the observed state of Topic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<TopicStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct TopicStatusAtProvider {
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationFailureFeedbackRoleArn")]
    #[builder(default)]
    pub application_failure_feedback_role_arn: Option<String>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub application_success_feedback_role_arn: Option<String>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub application_success_feedback_sample_rate: Option<f64>,
    /// The message archive policy for FIFO topics. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "archivePolicy")]
    #[builder(default)]
    pub archive_policy: Option<String>,
    /// The ARN of the SNS topic, as a more obvious property (clone of id)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arn: Option<String>,
    /// The oldest timestamp at which a FIFO topic subscriber can start a replay.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "beginningArchiveTime")]
    #[builder(default)]
    pub beginning_archive_time: Option<String>,
    /// Enables content-based deduplication for FIFO topics. For more information, see the related documentation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentBasedDeduplication")]
    #[builder(default)]
    pub content_based_deduplication: Option<bool>,
    /// The SNS delivery policy. More details in the AWS documentation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliveryPolicy")]
    #[builder(default)]
    pub delivery_policy: Option<String>,
    /// The display name for the topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "displayName")]
    #[builder(default)]
    pub display_name: Option<String>,
    /// Boolean indicating whether or not to create a FIFO (first-in-first-out) topic. FIFO topics can't deliver messages to customer managed endpoints, such as email addresses, mobile apps, SMS, or HTTP(S) endpoints. These endpoint types aren't guaranteed to preserve strict message ordering. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fifoTopic")]
    #[builder(default)]
    pub fifo_topic: Option<bool>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseFailureFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_failure_feedback_role_arn: Option<String>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub firehose_success_feedback_role_arn: Option<String>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firehoseSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub firehose_success_feedback_sample_rate: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpFailureFeedbackRoleArn")]
    #[builder(default)]
    pub http_failure_feedback_role_arn: Option<String>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub http_success_feedback_role_arn: Option<String>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub http_success_feedback_sample_rate: Option<f64>,
    /// The ARN of the SNS topic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see Key Terms
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsMasterKeyId")]
    #[builder(default)]
    pub kms_master_key_id: Option<String>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaFailureFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_failure_feedback_role_arn: Option<String>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub lambda_success_feedback_role_arn: Option<String>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lambdaSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub lambda_success_feedback_sample_rate: Option<f64>,
    /// The AWS Account ID of the SNS topic owner
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub owner: Option<String>,
    /// The fully-formed AWS policy as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<String>,
    /// If SignatureVersion should be 1 (SHA1) or 2 (SHA256). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signatureVersion")]
    #[builder(default)]
    pub signature_version: Option<f64>,
    /// IAM role for failure feedback
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsFailureFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_failure_feedback_role_arn: Option<String>,
    /// The IAM role permitted to receive success feedback for this topic
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackRoleArn")]
    #[builder(default)]
    pub sqs_success_feedback_role_arn: Option<String>,
    /// Percentage of success to sample
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqsSuccessFeedbackSampleRate")]
    #[builder(default)]
    pub sqs_success_feedback_sample_rate: Option<f64>,
    /// Key-value map of resource tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<HashMap<String, String>>,
    /// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsAll")]
    #[builder(default)]
    pub tags_all: Option<HashMap<String, String>>,
    /// Tracing mode of an Amazon SNS topic. Valid values: "PassThrough", "Active".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tracingConfig")]
    #[builder(default)]
    pub tracing_config: Option<String>,
}

