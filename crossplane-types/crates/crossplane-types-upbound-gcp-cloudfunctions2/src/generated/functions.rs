// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// FunctionSpec defines the desired state of Function
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "cloudfunctions2.gcp.upbound.io", version = "v1beta2", kind = "Function", plural = "functions")]
#[kube(status = "FunctionStatus")]
pub struct FunctionSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<FunctionDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: FunctionForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<FunctionInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<FunctionProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<FunctionPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<FunctionWriteConnectionSecretToRef>,
}

/// FunctionSpec defines the desired state of Function
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProvider {
    /// Describes the Build step of the function that builds a container
    /// from the given source.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "buildConfig")]
    #[builder(default)]
    pub build_config: Option<FunctionForProviderBuildConfig>,
    /// User-provided description of a function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// An Eventarc trigger managed by Google Cloud Functions that fires events in
    /// response to a condition in another service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventTrigger")]
    #[builder(default)]
    pub event_trigger: Option<FunctionForProviderEventTrigger>,
    /// Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources.
    /// It must match the pattern projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A set of key/value label pairs associated with this Cloud Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location of this cloud function.
    pub location: String,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Describes the Service being deployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConfig")]
    #[builder(default)]
    pub service_config: Option<FunctionForProviderServiceConfig>,
}

/// Describes the Build step of the function that builds a container
/// from the given source.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfig {
    /// Security patches are applied automatically to the runtime without requiring
    /// the function to be redeployed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticUpdatePolicy")]
    #[builder(default)]
    pub automatic_update_policy: Option<FunctionForProviderBuildConfigAutomaticUpdatePolicy>,
    /// User managed repository created in Artifact Registry optionally with a customer managed encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepository")]
    #[builder(default)]
    pub docker_repository: Option<String>,
    /// Reference to a RegistryRepository in artifact to populate dockerRepository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepositoryRef")]
    #[builder(default)]
    pub docker_repository_ref: Option<FunctionForProviderBuildConfigDockerRepositoryRef>,
    /// Selector for a RegistryRepository in artifact to populate dockerRepository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepositorySelector")]
    #[builder(default)]
    pub docker_repository_selector: Option<FunctionForProviderBuildConfigDockerRepositorySelector>,
    /// The name of the function (as defined in source code) that will be executed.
    /// Defaults to the resource name suffix, if not specified. For backward
    /// compatibility, if function with given name is not found, then the system
    /// will try to use function named "function". For Node.js this is name of a
    /// function exported by the module specified in source_location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "entryPoint")]
    #[builder(default)]
    pub entry_point: Option<String>,
    /// User-provided build-time environment variables for the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// Security patches are only applied when a function is redeployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeployUpdatePolicy")]
    #[builder(default)]
    pub on_deploy_update_policy: Option<FunctionForProviderBuildConfigOnDeployUpdatePolicy>,
    /// The runtime in which to run the function. Required when deploying a new
    /// function, optional when updating an existing function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub runtime: Option<String>,
    /// The fully-qualified name of the service account to be used for building the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<FunctionForProviderBuildConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<FunctionForProviderBuildConfigServiceAccountSelector>,
    /// The location of the function source code.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<FunctionForProviderBuildConfigSource>,
    /// Name of the Cloud Build Custom Worker Pool that should be used to build the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
    /// Reference to a WorkerPool in cloudbuild to populate workerPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPoolRef")]
    #[builder(default)]
    pub worker_pool_ref: Option<FunctionForProviderBuildConfigWorkerPoolRef>,
    /// Selector for a WorkerPool in cloudbuild to populate workerPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPoolSelector")]
    #[builder(default)]
    pub worker_pool_selector: Option<FunctionForProviderBuildConfigWorkerPoolSelector>,
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigAutomaticUpdatePolicy {
}

/// Reference to a RegistryRepository in artifact to populate dockerRepository.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigDockerRepositoryRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigDockerRepositoryRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigDockerRepositoryRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigDockerRepositoryRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigDockerRepositoryRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigDockerRepositoryRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigDockerRepositoryRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegistryRepository in artifact to populate dockerRepository.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigDockerRepositorySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigDockerRepositorySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigDockerRepositorySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigDockerRepositorySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigDockerRepositorySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigDockerRepositorySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigDockerRepositorySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Security patches are only applied when a function is redeployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigOnDeployUpdatePolicy {
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The location of the function source code.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSource {
    /// If provided, get the source from this location in a Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<FunctionForProviderBuildConfigSourceRepoSource>,
    /// If provided, get the source from this location in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<FunctionForProviderBuildConfigSourceStorageSource>,
}

/// If provided, get the source from this location in a Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceRepoSource {
    /// Regex matching branches to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does
    /// NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// If provided, get the source from this location in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSource {
    /// Google Cloud Storage bucket containing the source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Reference to a Bucket in storage to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default)]
    pub bucket_ref: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketRef>,
    /// Selector for a Bucket in storage to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSelector")]
    #[builder(default)]
    pub bucket_selector: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketSelector>,
    /// Google Cloud Storage generation for the object. If the generation
    /// is omitted, the latest generation will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<f64>,
    /// Google Cloud Storage object containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
    /// Reference to a BucketObject in storage to populate object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectRef")]
    #[builder(default)]
    pub object_ref: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectRef>,
    /// Selector for a BucketObject in storage to populate object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    #[builder(default)]
    pub object_selector: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectSelector>,
}

/// Reference to a Bucket in storage to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in storage to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a BucketObject in storage to populate object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceObjectRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BucketObject in storage to populate object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceObjectSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a WorkerPool in cloudbuild to populate workerPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigWorkerPoolRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigWorkerPoolRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigWorkerPoolRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigWorkerPoolRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigWorkerPoolRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigWorkerPoolRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigWorkerPoolRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a WorkerPool in cloudbuild to populate workerPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigWorkerPoolSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderBuildConfigWorkerPoolSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderBuildConfigWorkerPoolSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderBuildConfigWorkerPoolSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderBuildConfigWorkerPoolSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigWorkerPoolSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderBuildConfigWorkerPoolSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// An Eventarc trigger managed by Google Cloud Functions that fires events in
/// response to a condition in another service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTrigger {
    /// Criteria used to filter events.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventFilters")]
    #[builder(default)]
    pub event_filters: Option<Vec<FunctionForProviderEventTriggerEventFilters>>,
    /// Required. The type of event to observe.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    #[builder(default)]
    pub event_type: Option<String>,
    /// The name of a Pub/Sub topic in the same project that will be used
    /// as the transport topic for the event delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopic")]
    #[builder(default)]
    pub pubsub_topic: Option<String>,
    /// Reference to a Topic in pubsub to populate pubsubTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopicRef")]
    #[builder(default)]
    pub pubsub_topic_ref: Option<FunctionForProviderEventTriggerPubsubTopicRef>,
    /// Selector for a Topic in pubsub to populate pubsubTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopicSelector")]
    #[builder(default)]
    pub pubsub_topic_selector: Option<FunctionForProviderEventTriggerPubsubTopicSelector>,
    /// Describes the retry policy in case of function's execution failure.
    /// Retried execution is charged as any other execution.
    /// Possible values are: RETRY_POLICY_UNSPECIFIED, RETRY_POLICY_DO_NOT_RETRY, RETRY_POLICY_RETRY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<String>,
    /// Optional. The email of the trigger's service account. The service account
    /// must have permission to invoke Cloud Run services. If empty, defaults to the
    /// Compute Engine default service account: {project_number}-compute@developer.gserviceaccount.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    #[builder(default)]
    pub service_account_email_ref: Option<FunctionForProviderEventTriggerServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    #[builder(default)]
    pub service_account_email_selector: Option<FunctionForProviderEventTriggerServiceAccountEmailSelector>,
    /// The region that the trigger will be in. The trigger will only receive
    /// events originating in this region. It can be the same
    /// region as the function, a different region or multi-region, or the global
    /// region. If not provided, defaults to the same region as the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerRegion")]
    #[builder(default)]
    pub trigger_region: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerEventFilters {
    /// 'Required. The name of a CloudEvents attribute.
    /// Currently, only a subset of attributes are supported for filtering. Use the gcloud eventarc providers describe command to learn more about events and their attributes.
    /// Do not filter for the 'type' attribute here, as this is already achieved by the resource's event_type attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of
    /// the filter. If not specified, only events that have an exact key-value
    /// pair specified in the filter are matched.
    /// The only allowed value is match-path-pattern.
    /// See documentation on path patterns here'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute.
    /// If the operator field is set as match-path-pattern, this value can be a path pattern instead of an exact value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
    /// Reference to a Bucket in storage to populate value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueRef")]
    #[builder(default)]
    pub value_ref: Option<FunctionForProviderEventTriggerEventFiltersValueRef>,
    /// Selector for a Bucket in storage to populate value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueSelector")]
    #[builder(default)]
    pub value_selector: Option<FunctionForProviderEventTriggerEventFiltersValueSelector>,
}

/// Reference to a Bucket in storage to populate value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerEventFiltersValueRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerEventFiltersValueRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerEventFiltersValueRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerEventFiltersValueRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerEventFiltersValueRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerEventFiltersValueRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerEventFiltersValueRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in storage to populate value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerEventFiltersValueSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerEventFiltersValueSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerEventFiltersValueSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerEventFiltersValueSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerEventFiltersValueSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerEventFiltersValueSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerEventFiltersValueSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in pubsub to populate pubsubTopic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerPubsubTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerPubsubTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerPubsubTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerPubsubTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerPubsubTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerPubsubTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerPubsubTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate pubsubTopic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerPubsubTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerPubsubTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerPubsubTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerPubsubTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerPubsubTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerPubsubTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerPubsubTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderEventTriggerServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Describes the Service being deployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfig {
    /// Whether 100% of traffic is routed to the latest revision. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTrafficOnLatestRevision")]
    #[builder(default)]
    pub all_traffic_on_latest_revision: Option<bool>,
    /// The number of CPUs used in a single container instance. Default value is calculated from available memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableCpu")]
    #[builder(default)]
    pub available_cpu: Option<String>,
    /// The amount of memory available for a function.
    /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
    /// supplied the value is interpreted as bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableMemory")]
    #[builder(default)]
    pub available_memory: Option<String>,
    /// Environment variables that shall be available during function execution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// Available ingress settings. Defaults to "ALLOW_ALL" if unspecified.
    /// Default value is ALLOW_ALL.
    /// Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressSettings")]
    #[builder(default)]
    pub ingress_settings: Option<String>,
    /// The limit on the maximum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceCount")]
    #[builder(default)]
    pub max_instance_count: Option<f64>,
    /// Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceRequestConcurrency")]
    #[builder(default)]
    pub max_instance_request_concurrency: Option<f64>,
    /// The limit on the minimum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minInstanceCount")]
    #[builder(default)]
    pub min_instance_count: Option<f64>,
    /// Secret environment variables configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnvironmentVariables")]
    #[builder(default)]
    pub secret_environment_variables: Option<Vec<FunctionForProviderServiceConfigSecretEnvironmentVariables>>,
    /// Secret volumes configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretVolumes")]
    #[builder(default)]
    pub secret_volumes: Option<Vec<FunctionForProviderServiceConfigSecretVolumes>>,
    /// Name of the service associated with a Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// The email of the service account for this function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    #[builder(default)]
    pub service_account_email_ref: Option<FunctionForProviderServiceConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    #[builder(default)]
    pub service_account_email_selector: Option<FunctionForProviderServiceConfigServiceAccountEmailSelector>,
    /// The function execution timeout. Execution is considered failed and
    /// can be terminated if the function is not completed at the end of the
    /// timeout period. Defaults to 60 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    #[builder(default)]
    pub timeout_seconds: Option<f64>,
    /// The Serverless VPC Access connector that this cloud function can connect to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnector")]
    #[builder(default)]
    pub vpc_connector: Option<String>,
    /// Available egress settings.
    /// Possible values are: VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED, PRIVATE_RANGES_ONLY, ALL_TRAFFIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnectorEgressSettings")]
    #[builder(default)]
    pub vpc_connector_egress_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretEnvironmentVariables {
    /// Name of the environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRef>,
    /// Selector for a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelector>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Reference to a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumes {
    /// The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    #[builder(default)]
    pub mount_path: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<FunctionForProviderServiceConfigSecretVolumesSecretRef>,
    /// Selector for a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<FunctionForProviderServiceConfigSecretVolumesSecretSelector>,
    /// List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.'
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub versions: Option<Vec<FunctionForProviderServiceConfigSecretVolumesVersions>>,
}

/// Reference to a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumesSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigSecretVolumesSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumesSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigSecretVolumesSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigSecretVolumesSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretVolumesSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretVolumesSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumesSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigSecretVolumesVersions {
    /// Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionForProviderServiceConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProvider {
    /// Describes the Build step of the function that builds a container
    /// from the given source.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "buildConfig")]
    #[builder(default)]
    pub build_config: Option<FunctionInitProviderBuildConfig>,
    /// User-provided description of a function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// An Eventarc trigger managed by Google Cloud Functions that fires events in
    /// response to a condition in another service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventTrigger")]
    #[builder(default)]
    pub event_trigger: Option<FunctionInitProviderEventTrigger>,
    /// Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources.
    /// It must match the pattern projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A set of key/value label pairs associated with this Cloud Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Describes the Service being deployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConfig")]
    #[builder(default)]
    pub service_config: Option<FunctionInitProviderServiceConfig>,
}

/// Describes the Build step of the function that builds a container
/// from the given source.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfig {
    /// Security patches are applied automatically to the runtime without requiring
    /// the function to be redeployed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticUpdatePolicy")]
    #[builder(default)]
    pub automatic_update_policy: Option<FunctionInitProviderBuildConfigAutomaticUpdatePolicy>,
    /// User managed repository created in Artifact Registry optionally with a customer managed encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepository")]
    #[builder(default)]
    pub docker_repository: Option<String>,
    /// Reference to a RegistryRepository in artifact to populate dockerRepository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepositoryRef")]
    #[builder(default)]
    pub docker_repository_ref: Option<FunctionInitProviderBuildConfigDockerRepositoryRef>,
    /// Selector for a RegistryRepository in artifact to populate dockerRepository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepositorySelector")]
    #[builder(default)]
    pub docker_repository_selector: Option<FunctionInitProviderBuildConfigDockerRepositorySelector>,
    /// The name of the function (as defined in source code) that will be executed.
    /// Defaults to the resource name suffix, if not specified. For backward
    /// compatibility, if function with given name is not found, then the system
    /// will try to use function named "function". For Node.js this is name of a
    /// function exported by the module specified in source_location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "entryPoint")]
    #[builder(default)]
    pub entry_point: Option<String>,
    /// User-provided build-time environment variables for the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// Security patches are only applied when a function is redeployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeployUpdatePolicy")]
    #[builder(default)]
    pub on_deploy_update_policy: Option<FunctionInitProviderBuildConfigOnDeployUpdatePolicy>,
    /// The runtime in which to run the function. Required when deploying a new
    /// function, optional when updating an existing function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub runtime: Option<String>,
    /// The fully-qualified name of the service account to be used for building the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    #[builder(default)]
    pub service_account_ref: Option<FunctionInitProviderBuildConfigServiceAccountRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSelector")]
    #[builder(default)]
    pub service_account_selector: Option<FunctionInitProviderBuildConfigServiceAccountSelector>,
    /// The location of the function source code.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<FunctionInitProviderBuildConfigSource>,
    /// Name of the Cloud Build Custom Worker Pool that should be used to build the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
    /// Reference to a WorkerPool in cloudbuild to populate workerPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPoolRef")]
    #[builder(default)]
    pub worker_pool_ref: Option<FunctionInitProviderBuildConfigWorkerPoolRef>,
    /// Selector for a WorkerPool in cloudbuild to populate workerPool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPoolSelector")]
    #[builder(default)]
    pub worker_pool_selector: Option<FunctionInitProviderBuildConfigWorkerPoolSelector>,
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigAutomaticUpdatePolicy {
}

/// Reference to a RegistryRepository in artifact to populate dockerRepository.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigDockerRepositoryRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigDockerRepositoryRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigDockerRepositoryRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigDockerRepositoryRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigDockerRepositoryRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigDockerRepositoryRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigDockerRepositoryRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a RegistryRepository in artifact to populate dockerRepository.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigDockerRepositorySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigDockerRepositorySelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigDockerRepositorySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigDockerRepositorySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigDockerRepositorySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigDockerRepositorySelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigDockerRepositorySelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Security patches are only applied when a function is redeployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigOnDeployUpdatePolicy {
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigServiceAccountRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigServiceAccountRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigServiceAccountRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigServiceAccountRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigServiceAccountRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigServiceAccountRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigServiceAccountRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigServiceAccountSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigServiceAccountSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigServiceAccountSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigServiceAccountSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigServiceAccountSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigServiceAccountSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigServiceAccountSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// The location of the function source code.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSource {
    /// If provided, get the source from this location in a Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<FunctionInitProviderBuildConfigSourceRepoSource>,
    /// If provided, get the source from this location in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<FunctionInitProviderBuildConfigSourceStorageSource>,
}

/// If provided, get the source from this location in a Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceRepoSource {
    /// Regex matching branches to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does
    /// NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// If provided, get the source from this location in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSource {
    /// Google Cloud Storage bucket containing the source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Reference to a Bucket in storage to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRef")]
    #[builder(default)]
    pub bucket_ref: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketRef>,
    /// Selector for a Bucket in storage to populate bucket.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketSelector")]
    #[builder(default)]
    pub bucket_selector: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketSelector>,
    /// Google Cloud Storage generation for the object. If the generation
    /// is omitted, the latest generation will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<f64>,
    /// Google Cloud Storage object containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
    /// Reference to a BucketObject in storage to populate object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectRef")]
    #[builder(default)]
    pub object_ref: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectRef>,
    /// Selector for a BucketObject in storage to populate object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    #[builder(default)]
    pub object_selector: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectSelector>,
}

/// Reference to a Bucket in storage to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceBucketRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in storage to populate bucket.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceBucketSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a BucketObject in storage to populate object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceObjectRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BucketObject in storage to populate object.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceObjectSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a WorkerPool in cloudbuild to populate workerPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigWorkerPoolRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigWorkerPoolRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigWorkerPoolRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigWorkerPoolRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigWorkerPoolRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigWorkerPoolRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigWorkerPoolRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a WorkerPool in cloudbuild to populate workerPool.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigWorkerPoolSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderBuildConfigWorkerPoolSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderBuildConfigWorkerPoolSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderBuildConfigWorkerPoolSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderBuildConfigWorkerPoolSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigWorkerPoolSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderBuildConfigWorkerPoolSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// An Eventarc trigger managed by Google Cloud Functions that fires events in
/// response to a condition in another service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTrigger {
    /// Criteria used to filter events.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventFilters")]
    #[builder(default)]
    pub event_filters: Option<Vec<FunctionInitProviderEventTriggerEventFilters>>,
    /// Required. The type of event to observe.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    #[builder(default)]
    pub event_type: Option<String>,
    /// The name of a Pub/Sub topic in the same project that will be used
    /// as the transport topic for the event delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopic")]
    #[builder(default)]
    pub pubsub_topic: Option<String>,
    /// Reference to a Topic in pubsub to populate pubsubTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopicRef")]
    #[builder(default)]
    pub pubsub_topic_ref: Option<FunctionInitProviderEventTriggerPubsubTopicRef>,
    /// Selector for a Topic in pubsub to populate pubsubTopic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopicSelector")]
    #[builder(default)]
    pub pubsub_topic_selector: Option<FunctionInitProviderEventTriggerPubsubTopicSelector>,
    /// Describes the retry policy in case of function's execution failure.
    /// Retried execution is charged as any other execution.
    /// Possible values are: RETRY_POLICY_UNSPECIFIED, RETRY_POLICY_DO_NOT_RETRY, RETRY_POLICY_RETRY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<String>,
    /// Optional. The email of the trigger's service account. The service account
    /// must have permission to invoke Cloud Run services. If empty, defaults to the
    /// Compute Engine default service account: {project_number}-compute@developer.gserviceaccount.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    #[builder(default)]
    pub service_account_email_ref: Option<FunctionInitProviderEventTriggerServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    #[builder(default)]
    pub service_account_email_selector: Option<FunctionInitProviderEventTriggerServiceAccountEmailSelector>,
    /// The region that the trigger will be in. The trigger will only receive
    /// events originating in this region. It can be the same
    /// region as the function, a different region or multi-region, or the global
    /// region. If not provided, defaults to the same region as the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerRegion")]
    #[builder(default)]
    pub trigger_region: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerEventFilters {
    /// 'Required. The name of a CloudEvents attribute.
    /// Currently, only a subset of attributes are supported for filtering. Use the gcloud eventarc providers describe command to learn more about events and their attributes.
    /// Do not filter for the 'type' attribute here, as this is already achieved by the resource's event_type attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of
    /// the filter. If not specified, only events that have an exact key-value
    /// pair specified in the filter are matched.
    /// The only allowed value is match-path-pattern.
    /// See documentation on path patterns here'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute.
    /// If the operator field is set as match-path-pattern, this value can be a path pattern instead of an exact value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
    /// Reference to a Bucket in storage to populate value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueRef")]
    #[builder(default)]
    pub value_ref: Option<FunctionInitProviderEventTriggerEventFiltersValueRef>,
    /// Selector for a Bucket in storage to populate value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueSelector")]
    #[builder(default)]
    pub value_selector: Option<FunctionInitProviderEventTriggerEventFiltersValueSelector>,
}

/// Reference to a Bucket in storage to populate value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerEventFiltersValueRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerEventFiltersValueRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerEventFiltersValueRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerEventFiltersValueRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerEventFiltersValueRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerEventFiltersValueRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerEventFiltersValueRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Bucket in storage to populate value.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerEventFiltersValueSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerEventFiltersValueSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Topic in pubsub to populate pubsubTopic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerPubsubTopicRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerPubsubTopicRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerPubsubTopicRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerPubsubTopicRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerPubsubTopicRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerPubsubTopicRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerPubsubTopicRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Topic in pubsub to populate pubsubTopic.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerPubsubTopicSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerPubsubTopicSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerPubsubTopicSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerPubsubTopicSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerPubsubTopicSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerPubsubTopicSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerPubsubTopicSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderEventTriggerServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Describes the Service being deployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfig {
    /// Whether 100% of traffic is routed to the latest revision. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTrafficOnLatestRevision")]
    #[builder(default)]
    pub all_traffic_on_latest_revision: Option<bool>,
    /// The number of CPUs used in a single container instance. Default value is calculated from available memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableCpu")]
    #[builder(default)]
    pub available_cpu: Option<String>,
    /// The amount of memory available for a function.
    /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
    /// supplied the value is interpreted as bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableMemory")]
    #[builder(default)]
    pub available_memory: Option<String>,
    /// Environment variables that shall be available during function execution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// Available ingress settings. Defaults to "ALLOW_ALL" if unspecified.
    /// Default value is ALLOW_ALL.
    /// Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressSettings")]
    #[builder(default)]
    pub ingress_settings: Option<String>,
    /// The limit on the maximum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceCount")]
    #[builder(default)]
    pub max_instance_count: Option<f64>,
    /// Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceRequestConcurrency")]
    #[builder(default)]
    pub max_instance_request_concurrency: Option<f64>,
    /// The limit on the minimum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minInstanceCount")]
    #[builder(default)]
    pub min_instance_count: Option<f64>,
    /// Secret environment variables configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnvironmentVariables")]
    #[builder(default)]
    pub secret_environment_variables: Option<Vec<FunctionInitProviderServiceConfigSecretEnvironmentVariables>>,
    /// Secret volumes configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretVolumes")]
    #[builder(default)]
    pub secret_volumes: Option<Vec<FunctionInitProviderServiceConfigSecretVolumes>>,
    /// Name of the service associated with a Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// The email of the service account for this function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailRef")]
    #[builder(default)]
    pub service_account_email_ref: Option<FunctionInitProviderServiceConfigServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmailSelector")]
    #[builder(default)]
    pub service_account_email_selector: Option<FunctionInitProviderServiceConfigServiceAccountEmailSelector>,
    /// The function execution timeout. Execution is considered failed and
    /// can be terminated if the function is not completed at the end of the
    /// timeout period. Defaults to 60 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    #[builder(default)]
    pub timeout_seconds: Option<f64>,
    /// The Serverless VPC Access connector that this cloud function can connect to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnector")]
    #[builder(default)]
    pub vpc_connector: Option<String>,
    /// Available egress settings.
    /// Possible values are: VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED, PRIVATE_RANGES_ONLY, ALL_TRAFFIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnectorEgressSettings")]
    #[builder(default)]
    pub vpc_connector_egress_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretEnvironmentVariables {
    /// Name of the environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRef>,
    /// Selector for a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelector>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Reference to a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumes {
    /// The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    #[builder(default)]
    pub mount_path: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Reference to a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    #[builder(default)]
    pub secret_ref: Option<FunctionInitProviderServiceConfigSecretVolumesSecretRef>,
    /// Selector for a Secret in secretmanager to populate secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretSelector")]
    #[builder(default)]
    pub secret_selector: Option<FunctionInitProviderServiceConfigSecretVolumesSecretSelector>,
    /// List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.'
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub versions: Option<Vec<FunctionInitProviderServiceConfigSecretVolumesVersions>>,
}

/// Reference to a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumesSecretRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretVolumesSecretRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Secret in secretmanager to populate secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumesSecretSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigSecretVolumesVersions {
    /// Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

/// Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionInitProviderServiceConfigServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<FunctionPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<FunctionPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<FunctionPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<FunctionPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<FunctionPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum FunctionPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// FunctionStatus defines the observed state of Function.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<FunctionStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProvider {
    /// Describes the Build step of the function that builds a container
    /// from the given source.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "buildConfig")]
    #[builder(default)]
    pub build_config: Option<FunctionStatusAtProviderBuildConfig>,
    /// User-provided description of a function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// The environment the function is hosted on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub environment: Option<String>,
    /// An Eventarc trigger managed by Google Cloud Functions that fires events in
    /// response to a condition in another service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventTrigger")]
    #[builder(default)]
    pub event_trigger: Option<FunctionStatusAtProviderEventTrigger>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/functions/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources.
    /// It must match the pattern projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyName")]
    #[builder(default)]
    pub kms_key_name: Option<String>,
    /// A set of key/value label pairs associated with this Cloud Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The location of this cloud function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Describes the Service being deployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceConfig")]
    #[builder(default)]
    pub service_config: Option<FunctionStatusAtProviderServiceConfig>,
    /// Describes the current state of the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// The last update timestamp of a Cloud Function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateTime")]
    #[builder(default)]
    pub update_time: Option<String>,
    /// Output only. The deployed url for the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
}

/// Describes the Build step of the function that builds a container
/// from the given source.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfig {
    /// Security patches are applied automatically to the runtime without requiring
    /// the function to be redeployed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticUpdatePolicy")]
    #[builder(default)]
    pub automatic_update_policy: Option<FunctionStatusAtProviderBuildConfigAutomaticUpdatePolicy>,
    /// (Output)
    /// The Cloud Build name of the latest successful
    /// deployment of the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default, setter(prefix = "with_"))]
    pub build: Option<String>,
    /// User managed repository created in Artifact Registry optionally with a customer managed encryption key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerRepository")]
    #[builder(default)]
    pub docker_repository: Option<String>,
    /// The name of the function (as defined in source code) that will be executed.
    /// Defaults to the resource name suffix, if not specified. For backward
    /// compatibility, if function with given name is not found, then the system
    /// will try to use function named "function". For Node.js this is name of a
    /// function exported by the module specified in source_location.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "entryPoint")]
    #[builder(default)]
    pub entry_point: Option<String>,
    /// User-provided build-time environment variables for the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// Security patches are only applied when a function is redeployed.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onDeployUpdatePolicy")]
    #[builder(default)]
    pub on_deploy_update_policy: Option<FunctionStatusAtProviderBuildConfigOnDeployUpdatePolicy>,
    /// The runtime in which to run the function. Required when deploying a new
    /// function, optional when updating an existing function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub runtime: Option<String>,
    /// The fully-qualified name of the service account to be used for building the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<String>,
    /// The location of the function source code.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<FunctionStatusAtProviderBuildConfigSource>,
    /// Name of the Cloud Build Custom Worker Pool that should be used to build the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerPool")]
    #[builder(default)]
    pub worker_pool: Option<String>,
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfigAutomaticUpdatePolicy {
}

/// Security patches are only applied when a function is redeployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfigOnDeployUpdatePolicy {
    /// (Output)
    /// The runtime version which was used during latest function deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeVersion")]
    #[builder(default)]
    pub runtime_version: Option<String>,
}

/// The location of the function source code.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfigSource {
    /// If provided, get the source from this location in a Cloud Source Repository.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoSource")]
    #[builder(default)]
    pub repo_source: Option<FunctionStatusAtProviderBuildConfigSourceRepoSource>,
    /// If provided, get the source from this location in Google Cloud Storage.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSource")]
    #[builder(default)]
    pub storage_source: Option<FunctionStatusAtProviderBuildConfigSourceStorageSource>,
}

/// If provided, get the source from this location in a Cloud Source Repository.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfigSourceRepoSource {
    /// Regex matching branches to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "branchName")]
    #[builder(default)]
    pub branch_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commitSha")]
    #[builder(default)]
    pub commit_sha: Option<String>,
    /// Directory, relative to the source root, in which to run the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dir: Option<String>,
    /// Only trigger a build if the revision regex does
    /// NOT match the revision regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertRegex")]
    #[builder(default)]
    pub invert_regex: Option<bool>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the Cloud Source Repository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    #[builder(default)]
    pub repo_name: Option<String>,
    /// Regex matching tags to build.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagName")]
    #[builder(default)]
    pub tag_name: Option<String>,
}

/// If provided, get the source from this location in Google Cloud Storage.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderBuildConfigSourceStorageSource {
    /// Google Cloud Storage bucket containing the source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bucket: Option<String>,
    /// Google Cloud Storage generation for the object. If the generation
    /// is omitted, the latest generation will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generation: Option<f64>,
    /// Google Cloud Storage object containing the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
}

/// An Eventarc trigger managed by Google Cloud Functions that fires events in
/// response to a condition in another service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderEventTrigger {
    /// Criteria used to filter events.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventFilters")]
    #[builder(default)]
    pub event_filters: Option<Vec<FunctionStatusAtProviderEventTriggerEventFilters>>,
    /// Required. The type of event to observe.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    #[builder(default)]
    pub event_type: Option<String>,
    /// The name of a Pub/Sub topic in the same project that will be used
    /// as the transport topic for the event delivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pubsubTopic")]
    #[builder(default)]
    pub pubsub_topic: Option<String>,
    /// Describes the retry policy in case of function's execution failure.
    /// Retried execution is charged as any other execution.
    /// Possible values are: RETRY_POLICY_UNSPECIFIED, RETRY_POLICY_DO_NOT_RETRY, RETRY_POLICY_RETRY.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<String>,
    /// Optional. The email of the trigger's service account. The service account
    /// must have permission to invoke Cloud Run services. If empty, defaults to the
    /// Compute Engine default service account: {project_number}-compute@developer.gserviceaccount.com.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// (Output)
    /// Output only. The resource name of the Eventarc trigger.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub trigger: Option<String>,
    /// The region that the trigger will be in. The trigger will only receive
    /// events originating in this region. It can be the same
    /// region as the function, a different region or multi-region, or the global
    /// region. If not provided, defaults to the same region as the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerRegion")]
    #[builder(default)]
    pub trigger_region: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderEventTriggerEventFilters {
    /// 'Required. The name of a CloudEvents attribute.
    /// Currently, only a subset of attributes are supported for filtering. Use the gcloud eventarc providers describe command to learn more about events and their attributes.
    /// Do not filter for the 'type' attribute here, as this is already achieved by the resource's event_type attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attribute: Option<String>,
    /// Optional. The operator used for matching the events with the value of
    /// the filter. If not specified, only events that have an exact key-value
    /// pair specified in the filter are matched.
    /// The only allowed value is match-path-pattern.
    /// See documentation on path patterns here'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Required. The value for the attribute.
    /// If the operator field is set as match-path-pattern, this value can be a path pattern instead of an exact value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

/// Describes the Service being deployed.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderServiceConfig {
    /// Whether 100% of traffic is routed to the latest revision. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTrafficOnLatestRevision")]
    #[builder(default)]
    pub all_traffic_on_latest_revision: Option<bool>,
    /// The number of CPUs used in a single container instance. Default value is calculated from available memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableCpu")]
    #[builder(default)]
    pub available_cpu: Option<String>,
    /// The amount of memory available for a function.
    /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
    /// supplied the value is interpreted as bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableMemory")]
    #[builder(default)]
    pub available_memory: Option<String>,
    /// Environment variables that shall be available during function execution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentVariables")]
    #[builder(default)]
    pub environment_variables: Option<HashMap<String, String>>,
    /// (Output)
    /// URIs of the Service deployed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcfUri")]
    #[builder(default)]
    pub gcf_uri: Option<String>,
    /// Available ingress settings. Defaults to "ALLOW_ALL" if unspecified.
    /// Default value is ALLOW_ALL.
    /// Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressSettings")]
    #[builder(default)]
    pub ingress_settings: Option<String>,
    /// The limit on the maximum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceCount")]
    #[builder(default)]
    pub max_instance_count: Option<f64>,
    /// Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInstanceRequestConcurrency")]
    #[builder(default)]
    pub max_instance_request_concurrency: Option<f64>,
    /// The limit on the minimum number of function instances that may coexist at a
    /// given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minInstanceCount")]
    #[builder(default)]
    pub min_instance_count: Option<f64>,
    /// Secret environment variables configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnvironmentVariables")]
    #[builder(default)]
    pub secret_environment_variables: Option<Vec<FunctionStatusAtProviderServiceConfigSecretEnvironmentVariables>>,
    /// Secret volumes configuration.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretVolumes")]
    #[builder(default)]
    pub secret_volumes: Option<Vec<FunctionStatusAtProviderServiceConfigSecretVolumes>>,
    /// Name of the service associated with a Function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// The email of the service account for this function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    #[builder(default)]
    pub service_account_email: Option<String>,
    /// The function execution timeout. Execution is considered failed and
    /// can be terminated if the function is not completed at the end of the
    /// timeout period. Defaults to 60 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    #[builder(default)]
    pub timeout_seconds: Option<f64>,
    /// (Output)
    /// URI of the Service deployed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uri: Option<String>,
    /// The Serverless VPC Access connector that this cloud function can connect to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnector")]
    #[builder(default)]
    pub vpc_connector: Option<String>,
    /// Available egress settings.
    /// Possible values are: VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED, PRIVATE_RANGES_ONLY, ALL_TRAFFIC.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcConnectorEgressSettings")]
    #[builder(default)]
    pub vpc_connector_egress_settings: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderServiceConfigSecretEnvironmentVariables {
    /// Name of the environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderServiceConfigSecretVolumes {
    /// The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    #[builder(default)]
    pub mount_path: Option<String>,
    /// Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    #[builder(default)]
    pub project_id: Option<String>,
    /// Name of the secret in secret manager (not the full resource name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub secret: Option<String>,
    /// List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.'
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub versions: Option<Vec<FunctionStatusAtProviderServiceConfigSecretVolumesVersions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct FunctionStatusAtProviderServiceConfigSecretVolumesVersions {
    /// Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
}

