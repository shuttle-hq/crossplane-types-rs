// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use std::collections::HashMap;

    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use typed_builder::TypedBuilder;
}
use self::prelude::*;

/// BackupBackupPlanSpec defines the desired state of BackupBackupPlan
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(
    group = "gke.gcp.upbound.io",
    version = "v1beta2",
    kind = "BackupBackupPlan",
    plural = "backupbackupplans"
)]
#[kube(status = "BackupBackupPlanStatus")]
pub struct BackupBackupPlanSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "deletionPolicy"
    )]
    #[builder(default)]
    pub deletion_policy: Option<BackupBackupPlanDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: BackupBackupPlanForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initProvider"
    )]
    #[builder(default)]
    pub init_provider: Option<BackupBackupPlanInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "managementPolicies"
    )]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "providerConfigRef"
    )]
    #[builder(default)]
    pub provider_config_ref: Option<BackupBackupPlanProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "publishConnectionDetailsTo"
    )]
    #[builder(default)]
    pub publish_connection_details_to: Option<BackupBackupPlanPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "writeConnectionSecretToRef"
    )]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<BackupBackupPlanWriteConnectionSecretToRef>,
}

/// BackupBackupPlanSpec defines the desired state of BackupBackupPlan
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProvider {
    /// Defines the configuration of Backups created via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupConfig"
    )]
    #[builder(default)]
    pub backup_config: Option<BackupBackupPlanForProviderBackupConfig>,
    /// Defines a schedule for automatic Backup creation via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupSchedule"
    )]
    #[builder(default)]
    pub backup_schedule: Option<BackupBackupPlanForProviderBackupSchedule>,
    /// The source cluster from which Backups will be created via this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// Reference to a Cluster in container to populate cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterRef"
    )]
    #[builder(default)]
    pub cluster_ref: Option<BackupBackupPlanForProviderClusterRef>,
    /// Selector for a Cluster in container to populate cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterSelector"
    )]
    #[builder(default)]
    pub cluster_selector: Option<BackupBackupPlanForProviderClusterSelector>,
    /// This flag indicates whether this BackupPlan has been deactivated.
    /// Setting this field to True locks the BackupPlan such that no further updates will be allowed
    /// (except deletes), including the deactivated field itself. It also prevents any new Backups
    /// from being created via this BackupPlan (including scheduled Backups).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub deactivated: Option<bool>,
    /// User specified descriptive string for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Description: A set of custom labels supplied by the user.
    /// A list of key->value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The region of the Backup Plan.
    pub location: String,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// RetentionPolicy governs lifecycle of Backups created under this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retentionPolicy"
    )]
    #[builder(default)]
    pub retention_policy: Option<BackupBackupPlanForProviderRetentionPolicy>,
}

/// Defines the configuration of Backups created via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfig {
    /// If True, include all namespaced resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allNamespaces"
    )]
    #[builder(default)]
    pub all_namespaces: Option<bool>,
    /// This defines a customer managed encryption key that will be used to encrypt the "config"
    /// portion (the Kubernetes resources) of Backups created via this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionKey"
    )]
    #[builder(default)]
    pub encryption_key: Option<BackupBackupPlanForProviderBackupConfigEncryptionKey>,
    /// This flag specifies whether Kubernetes Secret resources should be included
    /// when they fall into the scope of Backups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeSecrets"
    )]
    #[builder(default)]
    pub include_secrets: Option<bool>,
    /// This flag specifies whether volume data should be backed up when PVCs are
    /// included in the scope of a Backup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeVolumeData"
    )]
    #[builder(default)]
    pub include_volume_data: Option<bool>,
    /// This flag specifies whether Backups will not fail when
    /// Backup for GKE detects Kubernetes configuration that is
    /// non-standard or requires additional setup to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissiveMode"
    )]
    #[builder(default)]
    pub permissive_mode: Option<bool>,
    /// A list of namespaced Kubernetes Resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedApplications"
    )]
    #[builder(default)]
    pub selected_applications: Option<BackupBackupPlanForProviderBackupConfigSelectedApplications>,
    /// If set, include just the resources in the listed namespaces.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedNamespaces"
    )]
    #[builder(default)]
    pub selected_namespaces: Option<BackupBackupPlanForProviderBackupConfigSelectedNamespaces>,
}

/// This defines a customer managed encryption key that will be used to encrypt the "config"
/// portion (the Kubernetes resources) of Backups created via this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigEncryptionKey {
    /// Google Cloud KMS encryption key. Format: projects//locations//keyRings//cryptoKeys/
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKey"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key: Option<String>,
    /// Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKeyRef"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key_ref:
        Option<BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef>,
    /// Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKeySelector"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key_selector:
        Option<BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector>,
}

/// Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<
        BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<
        BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A list of namespaced Kubernetes Resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigSelectedApplications {
    /// A list of namespaced Kubernetes resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespacedNames"
    )]
    #[builder(default)]
    pub namespaced_names:
        Option<Vec<BackupBackupPlanForProviderBackupConfigSelectedApplicationsNamespacedNames>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigSelectedApplicationsNamespacedNames {
    /// The name of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The namespace of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
}

/// If set, include just the resources in the listed namespaces.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupConfigSelectedNamespaces {
    /// A list of Kubernetes Namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespaces: Option<Vec<String>>,
}

/// Defines a schedule for automatic Backup creation via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupSchedule {
    /// A standard cron string that defines a repeating schedule for
    /// creating Backups via this BackupPlan.
    /// This is mutually exclusive with the rpoConfig field since at most one
    /// schedule can be defined for a BackupPlan.
    /// If this is defined, then backupRetainDays must also be defined.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cronSchedule"
    )]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// This flag denotes whether automatic Backup creation is paused for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paused: Option<bool>,
    /// Defines the RPO schedule configuration for this BackupPlan. This is mutually
    /// exclusive with the cronSchedule field since at most one schedule can be defined
    /// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rpoConfig")]
    #[builder(default)]
    pub rpo_config: Option<BackupBackupPlanForProviderBackupScheduleRpoConfig>,
}

/// Defines the RPO schedule configuration for this BackupPlan. This is mutually
/// exclusive with the cronSchedule field since at most one schedule can be defined
/// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupScheduleRpoConfig {
    /// User specified time windows during which backup can NOT happen for this BackupPlan.
    /// Backups should start and finish outside of any given exclusion window. Note: backup
    /// jobs will be scheduled to start and finish outside the duration of the window as
    /// much as possible, but running jobs will not get canceled when it runs into the window.
    /// All the time and date values in exclusionWindows entry in the API are in UTC. We
    /// only allow <=1 recurrence (daily or weekly) exclusion window for a BackupPlan while no
    /// restriction on number of single occurrence windows.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionWindows"
    )]
    #[builder(default)]
    pub exclusion_windows:
        Option<Vec<BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindows>>,
    /// Defines the target RPO for the BackupPlan in minutes, which means the target
    /// maximum data loss in time that is acceptable for this BackupPlan. This must be
    /// at least 60, i.e., 1 hour, and at most 86400, i.e., 60 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetRpoMinutes"
    )]
    #[builder(default)]
    pub target_rpo_minutes: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindows {
    /// The exclusion window occurs every day if set to "True".
    /// Specifying this field to "False" is an error.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub daily: Option<bool>,
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week:
        Option<BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek>,
    /// Specifies duration of the window in seconds with up to nine fractional digits,
    /// terminated by 's'. Example: "3.5s". Restrictions for duration based on the
    /// recurrence type to allow some time for backup to happen:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// No recurrence. The exclusion window occurs only once and on this date in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "singleOccurrenceDate"
    )]
    #[builder(default)]
    pub single_occurrence_date: Option<
        BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate,
    >,
    /// Specifies the start time of the window using time of the day in UTC.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    #[builder(default)]
    pub start_time:
        Option<BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsStartTime>,
}

/// The exclusion window occurs on these days of each week in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek {
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week: Option<Vec<String>>,
}

/// No recurrence. The exclusion window occurs only once and on this date in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate {
    /// Day of a month.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of the date.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Specifies the start time of the window using time of the day in UTC.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderBackupScheduleRpoConfigExclusionWindowsStartTime {
    /// Hours of day in 24 hour format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Reference to a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanForProviderClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanForProviderClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanForProviderClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanForProviderClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanForProviderClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanForProviderClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanForProviderClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// RetentionPolicy governs lifecycle of Backups created under this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanForProviderRetentionPolicy {
    /// Minimum age for a Backup created via this BackupPlan (in days).
    /// Must be an integer value between 0-90 (inclusive).
    /// A Backup created under this BackupPlan will not be deletable
    /// until it reaches Backup's (create time + backup_delete_lock_days).
    /// Updating this field of a BackupPlan does not affect existing Backups.
    /// Backups created after a successful update will inherit this new value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupDeleteLockDays"
    )]
    #[builder(default)]
    pub backup_delete_lock_days: Option<f64>,
    /// The default maximum age of a Backup created via this BackupPlan.
    /// This field MUST be an integer value >= 0 and <= 365. If specified,
    /// a Backup created under this BackupPlan will be automatically deleted
    /// after its age reaches (createTime + backupRetainDays).
    /// If not specified, Backups created under this BackupPlan will NOT be
    /// subject to automatic deletion. Updating this field does NOT affect
    /// existing Backups under it. Backups created AFTER a successful update
    /// will automatically pick up the new value.
    /// NOTE: backupRetainDays must be >= backupDeleteLockDays.
    /// If cronSchedule is defined, then this must be <= 360 * the creation interval.
    /// If rpo_config is defined, then this must be
    /// <= 360 * targetRpoMinutes/(1440minutes/day)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetainDays"
    )]
    #[builder(default)]
    pub backup_retain_days: Option<f64>,
    /// This flag denotes whether the retention policy of this BackupPlan is locked.
    /// If set to True, no further update is allowed on this policy, including
    /// the locked field itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub locked: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProvider {
    /// Defines the configuration of Backups created via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupConfig"
    )]
    #[builder(default)]
    pub backup_config: Option<BackupBackupPlanInitProviderBackupConfig>,
    /// Defines a schedule for automatic Backup creation via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupSchedule"
    )]
    #[builder(default)]
    pub backup_schedule: Option<BackupBackupPlanInitProviderBackupSchedule>,
    /// The source cluster from which Backups will be created via this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// Reference to a Cluster in container to populate cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterRef"
    )]
    #[builder(default)]
    pub cluster_ref: Option<BackupBackupPlanInitProviderClusterRef>,
    /// Selector for a Cluster in container to populate cluster.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterSelector"
    )]
    #[builder(default)]
    pub cluster_selector: Option<BackupBackupPlanInitProviderClusterSelector>,
    /// This flag indicates whether this BackupPlan has been deactivated.
    /// Setting this field to True locks the BackupPlan such that no further updates will be allowed
    /// (except deletes), including the deactivated field itself. It also prevents any new Backups
    /// from being created via this BackupPlan (including scheduled Backups).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub deactivated: Option<bool>,
    /// User specified descriptive string for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Description: A set of custom labels supplied by the user.
    /// A list of key->value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// RetentionPolicy governs lifecycle of Backups created under this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retentionPolicy"
    )]
    #[builder(default)]
    pub retention_policy: Option<BackupBackupPlanInitProviderRetentionPolicy>,
}

/// Defines the configuration of Backups created via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfig {
    /// If True, include all namespaced resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allNamespaces"
    )]
    #[builder(default)]
    pub all_namespaces: Option<bool>,
    /// This defines a customer managed encryption key that will be used to encrypt the "config"
    /// portion (the Kubernetes resources) of Backups created via this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionKey"
    )]
    #[builder(default)]
    pub encryption_key: Option<BackupBackupPlanInitProviderBackupConfigEncryptionKey>,
    /// This flag specifies whether Kubernetes Secret resources should be included
    /// when they fall into the scope of Backups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeSecrets"
    )]
    #[builder(default)]
    pub include_secrets: Option<bool>,
    /// This flag specifies whether volume data should be backed up when PVCs are
    /// included in the scope of a Backup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeVolumeData"
    )]
    #[builder(default)]
    pub include_volume_data: Option<bool>,
    /// This flag specifies whether Backups will not fail when
    /// Backup for GKE detects Kubernetes configuration that is
    /// non-standard or requires additional setup to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissiveMode"
    )]
    #[builder(default)]
    pub permissive_mode: Option<bool>,
    /// A list of namespaced Kubernetes Resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedApplications"
    )]
    #[builder(default)]
    pub selected_applications: Option<BackupBackupPlanInitProviderBackupConfigSelectedApplications>,
    /// If set, include just the resources in the listed namespaces.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedNamespaces"
    )]
    #[builder(default)]
    pub selected_namespaces: Option<BackupBackupPlanInitProviderBackupConfigSelectedNamespaces>,
}

/// This defines a customer managed encryption key that will be used to encrypt the "config"
/// portion (the Kubernetes resources) of Backups created via this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigEncryptionKey {
    /// Google Cloud KMS encryption key. Format: projects//locations//keyRings//cryptoKeys/
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKey"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key: Option<String>,
    /// Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKeyRef"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key_ref:
        Option<BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef>,
    /// Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKeySelector"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key_selector:
        Option<BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector>,
}

/// Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy:
        Option<BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<
        BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution,
    >,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<
        BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve,
    >,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution
{
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<
        BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy,
    >,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution
{
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve
{
    Always,
    IfNotPresent,
}

/// A list of namespaced Kubernetes Resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigSelectedApplications {
    /// A list of namespaced Kubernetes resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespacedNames"
    )]
    #[builder(default)]
    pub namespaced_names:
        Option<Vec<BackupBackupPlanInitProviderBackupConfigSelectedApplicationsNamespacedNames>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigSelectedApplicationsNamespacedNames {
    /// The name of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The namespace of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
}

/// If set, include just the resources in the listed namespaces.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupConfigSelectedNamespaces {
    /// A list of Kubernetes Namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespaces: Option<Vec<String>>,
}

/// Defines a schedule for automatic Backup creation via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupSchedule {
    /// A standard cron string that defines a repeating schedule for
    /// creating Backups via this BackupPlan.
    /// This is mutually exclusive with the rpoConfig field since at most one
    /// schedule can be defined for a BackupPlan.
    /// If this is defined, then backupRetainDays must also be defined.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cronSchedule"
    )]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// This flag denotes whether automatic Backup creation is paused for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paused: Option<bool>,
    /// Defines the RPO schedule configuration for this BackupPlan. This is mutually
    /// exclusive with the cronSchedule field since at most one schedule can be defined
    /// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rpoConfig")]
    #[builder(default)]
    pub rpo_config: Option<BackupBackupPlanInitProviderBackupScheduleRpoConfig>,
}

/// Defines the RPO schedule configuration for this BackupPlan. This is mutually
/// exclusive with the cronSchedule field since at most one schedule can be defined
/// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupScheduleRpoConfig {
    /// User specified time windows during which backup can NOT happen for this BackupPlan.
    /// Backups should start and finish outside of any given exclusion window. Note: backup
    /// jobs will be scheduled to start and finish outside the duration of the window as
    /// much as possible, but running jobs will not get canceled when it runs into the window.
    /// All the time and date values in exclusionWindows entry in the API are in UTC. We
    /// only allow <=1 recurrence (daily or weekly) exclusion window for a BackupPlan while no
    /// restriction on number of single occurrence windows.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionWindows"
    )]
    #[builder(default)]
    pub exclusion_windows:
        Option<Vec<BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindows>>,
    /// Defines the target RPO for the BackupPlan in minutes, which means the target
    /// maximum data loss in time that is acceptable for this BackupPlan. This must be
    /// at least 60, i.e., 1 hour, and at most 86400, i.e., 60 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetRpoMinutes"
    )]
    #[builder(default)]
    pub target_rpo_minutes: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindows {
    /// The exclusion window occurs every day if set to "True".
    /// Specifying this field to "False" is an error.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub daily: Option<bool>,
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week:
        Option<BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek>,
    /// Specifies duration of the window in seconds with up to nine fractional digits,
    /// terminated by 's'. Example: "3.5s". Restrictions for duration based on the
    /// recurrence type to allow some time for backup to happen:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// No recurrence. The exclusion window occurs only once and on this date in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "singleOccurrenceDate"
    )]
    #[builder(default)]
    pub single_occurrence_date: Option<
        BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate,
    >,
    /// Specifies the start time of the window using time of the day in UTC.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    #[builder(default)]
    pub start_time:
        Option<BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsStartTime>,
}

/// The exclusion window occurs on these days of each week in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek {
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week: Option<Vec<String>>,
}

/// No recurrence. The exclusion window occurs only once and on this date in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate {
    /// Day of a month.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of the date.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Specifies the start time of the window using time of the day in UTC.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderBackupScheduleRpoConfigExclusionWindowsStartTime {
    /// Hours of day in 24 hour format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// Reference to a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderClusterRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanInitProviderClusterRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderClusterRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanInitProviderClusterRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanInitProviderClusterRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderClusterRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderClusterRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Cluster in container to populate cluster.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderClusterSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchControllerRef"
    )]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanInitProviderClusterSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderClusterSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanInitProviderClusterSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanInitProviderClusterSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderClusterSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanInitProviderClusterSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// RetentionPolicy governs lifecycle of Backups created under this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanInitProviderRetentionPolicy {
    /// Minimum age for a Backup created via this BackupPlan (in days).
    /// Must be an integer value between 0-90 (inclusive).
    /// A Backup created under this BackupPlan will not be deletable
    /// until it reaches Backup's (create time + backup_delete_lock_days).
    /// Updating this field of a BackupPlan does not affect existing Backups.
    /// Backups created after a successful update will inherit this new value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupDeleteLockDays"
    )]
    #[builder(default)]
    pub backup_delete_lock_days: Option<f64>,
    /// The default maximum age of a Backup created via this BackupPlan.
    /// This field MUST be an integer value >= 0 and <= 365. If specified,
    /// a Backup created under this BackupPlan will be automatically deleted
    /// after its age reaches (createTime + backupRetainDays).
    /// If not specified, Backups created under this BackupPlan will NOT be
    /// subject to automatic deletion. Updating this field does NOT affect
    /// existing Backups under it. Backups created AFTER a successful update
    /// will automatically pick up the new value.
    /// NOTE: backupRetainDays must be >= backupDeleteLockDays.
    /// If cronSchedule is defined, then this must be <= 360 * the creation interval.
    /// If rpo_config is defined, then this must be
    /// <= 360 * targetRpoMinutes/(1440minutes/day)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetainDays"
    )]
    #[builder(default)]
    pub backup_retain_days: Option<f64>,
    /// This flag denotes whether the retention policy of this BackupPlan is locked.
    /// If set to True, no further update is allowed on this policy, including
    /// the locked field itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub locked: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<BackupBackupPlanPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<BackupBackupPlanPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<BackupBackupPlanPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<BackupBackupPlanPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<BackupBackupPlanPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum BackupBackupPlanPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// BackupBackupPlanStatus defines the observed state of BackupBackupPlan.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatus {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "atProvider"
    )]
    #[builder(default)]
    pub at_provider: Option<BackupBackupPlanStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProvider {
    /// Defines the configuration of Backups created via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupConfig"
    )]
    #[builder(default)]
    pub backup_config: Option<BackupBackupPlanStatusAtProviderBackupConfig>,
    /// Defines a schedule for automatic Backup creation via this BackupPlan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupSchedule"
    )]
    #[builder(default)]
    pub backup_schedule: Option<BackupBackupPlanStatusAtProviderBackupSchedule>,
    /// The source cluster from which Backups will be created via this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub cluster: Option<String>,
    /// This flag indicates whether this BackupPlan has been deactivated.
    /// Setting this field to True locks the BackupPlan such that no further updates will be allowed
    /// (except deletes), including the deactivated field itself. It also prevents any new Backups
    /// from being created via this BackupPlan (including scheduled Backups).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub deactivated: Option<bool>,
    /// User specified descriptive string for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// for all of the labels present on the resource.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "effectiveLabels"
    )]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// etag is used for optimistic concurrency control as a way to help prevent simultaneous
    /// updates of a backup plan from overwriting each other. It is strongly suggested that
    /// systems make use of the 'etag' in the read-modify-write cycle to perform BackupPlan updates
    /// in order to avoid race conditions: An etag is returned in the response to backupPlans.get,
    /// and systems are expected to put that etag in the request to backupPlans.patch or
    /// backupPlans.delete to ensure that their change will be applied to the same version of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub etag: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/locations/{{location}}/backupPlans/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// Description: A set of custom labels supplied by the user.
    /// A list of key->value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The region of the Backup Plan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub location: Option<String>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The number of Kubernetes Pods backed up in the last successful Backup created via this BackupPlan.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "protectedPodCount"
    )]
    #[builder(default)]
    pub protected_pod_count: Option<f64>,
    /// RetentionPolicy governs lifecycle of Backups created under this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retentionPolicy"
    )]
    #[builder(default)]
    pub retention_policy: Option<BackupBackupPlanStatusAtProviderRetentionPolicy>,
    /// The State of the BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub state: Option<String>,
    /// Detailed description of why BackupPlan is in its current state.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stateReason"
    )]
    #[builder(default)]
    pub state_reason: Option<String>,
    /// The combination of labels configured directly on the resource
    /// and default labels configured on the provider.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terraformLabels"
    )]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// Server generated, unique identifier of UUID format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub uid: Option<String>,
}

/// Defines the configuration of Backups created via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupConfig {
    /// If True, include all namespaced resources.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allNamespaces"
    )]
    #[builder(default)]
    pub all_namespaces: Option<bool>,
    /// This defines a customer managed encryption key that will be used to encrypt the "config"
    /// portion (the Kubernetes resources) of Backups created via this plan.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "encryptionKey"
    )]
    #[builder(default)]
    pub encryption_key: Option<BackupBackupPlanStatusAtProviderBackupConfigEncryptionKey>,
    /// This flag specifies whether Kubernetes Secret resources should be included
    /// when they fall into the scope of Backups.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeSecrets"
    )]
    #[builder(default)]
    pub include_secrets: Option<bool>,
    /// This flag specifies whether volume data should be backed up when PVCs are
    /// included in the scope of a Backup.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "includeVolumeData"
    )]
    #[builder(default)]
    pub include_volume_data: Option<bool>,
    /// This flag specifies whether Backups will not fail when
    /// Backup for GKE detects Kubernetes configuration that is
    /// non-standard or requires additional setup to restore.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "permissiveMode"
    )]
    #[builder(default)]
    pub permissive_mode: Option<bool>,
    /// A list of namespaced Kubernetes Resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedApplications"
    )]
    #[builder(default)]
    pub selected_applications:
        Option<BackupBackupPlanStatusAtProviderBackupConfigSelectedApplications>,
    /// If set, include just the resources in the listed namespaces.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "selectedNamespaces"
    )]
    #[builder(default)]
    pub selected_namespaces: Option<BackupBackupPlanStatusAtProviderBackupConfigSelectedNamespaces>,
}

/// This defines a customer managed encryption key that will be used to encrypt the "config"
/// portion (the Kubernetes resources) of Backups created via this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupConfigEncryptionKey {
    /// Google Cloud KMS encryption key. Format: projects//locations//keyRings//cryptoKeys/
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gcpKmsEncryptionKey"
    )]
    #[builder(default)]
    pub gcp_kms_encryption_key: Option<String>,
}

/// A list of namespaced Kubernetes Resources.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupConfigSelectedApplications {
    /// A list of namespaced Kubernetes resources.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "namespacedNames"
    )]
    #[builder(default)]
    pub namespaced_names: Option<
        Vec<BackupBackupPlanStatusAtProviderBackupConfigSelectedApplicationsNamespacedNames>,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupConfigSelectedApplicationsNamespacedNames {
    /// The name of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The namespace of a Kubernetes Resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespace: Option<String>,
}

/// If set, include just the resources in the listed namespaces.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupConfigSelectedNamespaces {
    /// A list of Kubernetes Namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub namespaces: Option<Vec<String>>,
}

/// Defines a schedule for automatic Backup creation via this BackupPlan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupSchedule {
    /// A standard cron string that defines a repeating schedule for
    /// creating Backups via this BackupPlan.
    /// This is mutually exclusive with the rpoConfig field since at most one
    /// schedule can be defined for a BackupPlan.
    /// If this is defined, then backupRetainDays must also be defined.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cronSchedule"
    )]
    #[builder(default)]
    pub cron_schedule: Option<String>,
    /// This flag denotes whether automatic Backup creation is paused for this BackupPlan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paused: Option<bool>,
    /// Defines the RPO schedule configuration for this BackupPlan. This is mutually
    /// exclusive with the cronSchedule field since at most one schedule can be defined
    /// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rpoConfig")]
    #[builder(default)]
    pub rpo_config: Option<BackupBackupPlanStatusAtProviderBackupScheduleRpoConfig>,
}

/// Defines the RPO schedule configuration for this BackupPlan. This is mutually
/// exclusive with the cronSchedule field since at most one schedule can be defined
/// for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupScheduleRpoConfig {
    /// User specified time windows during which backup can NOT happen for this BackupPlan.
    /// Backups should start and finish outside of any given exclusion window. Note: backup
    /// jobs will be scheduled to start and finish outside the duration of the window as
    /// much as possible, but running jobs will not get canceled when it runs into the window.
    /// All the time and date values in exclusionWindows entry in the API are in UTC. We
    /// only allow <=1 recurrence (daily or weekly) exclusion window for a BackupPlan while no
    /// restriction on number of single occurrence windows.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exclusionWindows"
    )]
    #[builder(default)]
    pub exclusion_windows:
        Option<Vec<BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindows>>,
    /// Defines the target RPO for the BackupPlan in minutes, which means the target
    /// maximum data loss in time that is acceptable for this BackupPlan. This must be
    /// at least 60, i.e., 1 hour, and at most 86400, i.e., 60 days.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetRpoMinutes"
    )]
    #[builder(default)]
    pub target_rpo_minutes: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindows {
    /// The exclusion window occurs every day if set to "True".
    /// Specifying this field to "False" is an error.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub daily: Option<bool>,
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week:
        Option<BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek>,
    /// Specifies duration of the window in seconds with up to nine fractional digits,
    /// terminated by 's'. Example: "3.5s". Restrictions for duration based on the
    /// recurrence type to allow some time for backup to happen:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub duration: Option<String>,
    /// No recurrence. The exclusion window occurs only once and on this date in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "singleOccurrenceDate"
    )]
    #[builder(default)]
    pub single_occurrence_date: Option<
        BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate,
    >,
    /// Specifies the start time of the window using time of the day in UTC.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    #[builder(default)]
    pub start_time:
        Option<BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsStartTime>,
}

/// The exclusion window occurs on these days of each week in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsDaysOfWeek {
    /// The exclusion window occurs on these days of each week in UTC.
    /// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
    /// Structure is documented below.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "daysOfWeek"
    )]
    #[builder(default)]
    pub days_of_week: Option<Vec<String>>,
}

/// No recurrence. The exclusion window occurs only once and on this date in UTC.
/// Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsSingleOccurrenceDate
{
    /// Day of a month.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub day: Option<f64>,
    /// Month of a year.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub month: Option<f64>,
    /// Year of the date.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub year: Option<f64>,
}

/// Specifies the start time of the window using time of the day in UTC.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderBackupScheduleRpoConfigExclusionWindowsStartTime {
    /// Hours of day in 24 hour format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hours: Option<f64>,
    /// Minutes of hour of day.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub minutes: Option<f64>,
    /// Fractions of seconds in nanoseconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Seconds of minutes of the time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// RetentionPolicy governs lifecycle of Backups created under this plan.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct BackupBackupPlanStatusAtProviderRetentionPolicy {
    /// Minimum age for a Backup created via this BackupPlan (in days).
    /// Must be an integer value between 0-90 (inclusive).
    /// A Backup created under this BackupPlan will not be deletable
    /// until it reaches Backup's (create time + backup_delete_lock_days).
    /// Updating this field of a BackupPlan does not affect existing Backups.
    /// Backups created after a successful update will inherit this new value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupDeleteLockDays"
    )]
    #[builder(default)]
    pub backup_delete_lock_days: Option<f64>,
    /// The default maximum age of a Backup created via this BackupPlan.
    /// This field MUST be an integer value >= 0 and <= 365. If specified,
    /// a Backup created under this BackupPlan will be automatically deleted
    /// after its age reaches (createTime + backupRetainDays).
    /// If not specified, Backups created under this BackupPlan will NOT be
    /// subject to automatic deletion. Updating this field does NOT affect
    /// existing Backups under it. Backups created AFTER a successful update
    /// will automatically pick up the new value.
    /// NOTE: backupRetainDays must be >= backupDeleteLockDays.
    /// If cronSchedule is defined, then this must be <= 360 * the creation interval.
    /// If rpo_config is defined, then this must be
    /// <= 360 * targetRpoMinutes/(1440minutes/day)
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "backupRetainDays"
    )]
    #[builder(default)]
    pub backup_retain_days: Option<f64>,
    /// This flag denotes whether the retention policy of this BackupPlan is locked.
    /// If set to True, no further update is allowed on this policy, including
    /// the locked field itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub locked: Option<bool>,
}
