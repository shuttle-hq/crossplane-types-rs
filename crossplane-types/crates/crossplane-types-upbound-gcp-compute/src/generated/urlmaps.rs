// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// URLMapSpec defines the desired state of URLMap
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "URLMap", plural = "urlmaps")]
#[kube(status = "URLMapStatus")]
pub struct URLMapSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<URLMapDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: URLMapForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<URLMapInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<URLMapProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<URLMapPublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<URLMapWriteConnectionSecretToRef>,
}

/// URLMapSpec defines the desired state of URLMap
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProvider {
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
    /// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
    /// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
    /// is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapForProviderDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given rules match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<URLMapForProviderDefaultServiceRef>,
    /// Selector for a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<URLMapForProviderDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapForProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. The headerAction specified here take effect after
    /// headerAction specified under pathMatcher.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderHeaderAction>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<URLMapForProviderHostRule>>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<URLMapForProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The list of expected URL mapping tests. Request to update this UrlMap will
    /// succeed only if all of the test cases pass. You can specify a maximum of 100
    /// tests per UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<URLMapForProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
/// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
/// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
/// is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapForProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    /// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    /// by the Loadbalancer for a percentage of requests.
    /// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapForProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    /// the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapForProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapForProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    /// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    /// If not specified, will use the largest timeout among all backend services associated with the route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapForProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapForProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs.
    /// The weights determine the fraction of traffic that flows to their corresponding backend service.
    /// If all traffic needs to go to a single backend service, there must be one weightedBackendService
    /// with weight set to a non 0 number.
    /// Once a backendService is identified and before forwarding the request to the backend service,
    /// advanced routing actions like Url rewrites and header transformations are applied depending on
    /// additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapForProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
/// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
/// by the Loadbalancer for a percentage of requests.
/// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapForProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapForProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapForProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
/// the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapForProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
/// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
/// If not specified, will use the largest timeout among all backend services associated with the route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. The headerAction specified here take effect after
/// headerAction specified under pathMatcher.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderHostRule {
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid hostnames, except * will
    /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
    /// and must be followed in the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of the URL if the
    /// hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcher {
    /// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
    /// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
    /// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
    /// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapForProviderPathMatcherDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given paths match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<URLMapForProviderPathMatcherDefaultServiceRef>,
    /// Selector for a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<URLMapForProviderPathMatcherDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapForProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. HeaderAction specified here are applied after the
    /// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderPathMatcherHeaderAction>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<URLMapForProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<URLMapForProviderPathMatcherRouteRules>>,
}

/// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
/// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
/// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
/// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapForProviderPathMatcherDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapForProviderPathMatcherDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapForProviderPathMatcherDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapForProviderPathMatcherDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapForProviderPathMatcherDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapForProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. HeaderAction specified here are applied after the
/// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderPathMatcherHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderPathMatcherHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapForProviderPathMatcherPathRuleRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapForProviderPathMatcherPathRuleServiceRef>,
    /// Selector for a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapForProviderPathMatcherPathRuleServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapForProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapForProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapForProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapForProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherPathRuleServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherPathRuleServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<URLMapForProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapForProviderPathMatcherRouteRulesRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapForProviderPathMatcherRouteRulesServiceRef>,
    /// Selector for a BackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapForProviderPathMatcherRouteRulesServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapForProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<URLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<URLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<URLMapForProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
    /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<URLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
/// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
/// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
/// must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<URLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapForProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapForProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapForProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapForProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherRouteRulesServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherRouteRulesServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderPathMatcherRouteRulesServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapForProviderTestServiceRef>,
    /// Selector for a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapForProviderTestServiceSelector>,
}

/// Reference to a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderTestServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderTestServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderTestServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderTestServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderTestServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderTestServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderTestServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderTestServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapForProviderTestServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapForProviderTestServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapForProviderTestServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapForProviderTestServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderTestServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapForProviderTestServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProvider {
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
    /// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
    /// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
    /// is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapInitProviderDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given rules match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<URLMapInitProviderDefaultServiceRef>,
    /// Selector for a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<URLMapInitProviderDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapInitProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. The headerAction specified here take effect after
    /// headerAction specified under pathMatcher.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderHeaderAction>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<URLMapInitProviderHostRule>>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<URLMapInitProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The list of expected URL mapping tests. Request to update this UrlMap will
    /// succeed only if all of the test cases pass. You can specify a maximum of 100
    /// tests per UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<URLMapInitProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
/// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
/// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
/// is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapInitProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    /// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    /// by the Loadbalancer for a percentage of requests.
    /// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapInitProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    /// the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapInitProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapInitProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    /// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    /// If not specified, will use the largest timeout among all backend services associated with the route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapInitProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapInitProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs.
    /// The weights determine the fraction of traffic that flows to their corresponding backend service.
    /// If all traffic needs to go to a single backend service, there must be one weightedBackendService
    /// with weight set to a non 0 number.
    /// Once a backendService is identified and before forwarding the request to the backend service,
    /// advanced routing actions like Url rewrites and header transformations are applied depending on
    /// additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapInitProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
/// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
/// by the Loadbalancer for a percentage of requests.
/// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapInitProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
/// the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapInitProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
/// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
/// If not specified, will use the largest timeout among all backend services associated with the route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. The headerAction specified here take effect after
/// headerAction specified under pathMatcher.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderHostRule {
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid hostnames, except * will
    /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
    /// and must be followed in the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of the URL if the
    /// hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcher {
    /// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
    /// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
    /// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
    /// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapInitProviderPathMatcherDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given paths match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// Reference to a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceRef")]
    #[builder(default)]
    pub default_service_ref: Option<URLMapInitProviderPathMatcherDefaultServiceRef>,
    /// Selector for a BackendBucket in compute to populate defaultService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultServiceSelector")]
    #[builder(default)]
    pub default_service_selector: Option<URLMapInitProviderPathMatcherDefaultServiceSelector>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapInitProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. HeaderAction specified here are applied after the
    /// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderPathMatcherHeaderAction>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<URLMapInitProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<URLMapInitProviderPathMatcherRouteRules>>,
}

/// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
/// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
/// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
/// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapInitProviderPathMatcherDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapInitProviderPathMatcherDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapInitProviderPathMatcherDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapInitProviderPathMatcherDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapInitProviderPathMatcherDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapInitProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherDefaultServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherDefaultServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherDefaultServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherDefaultServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherDefaultServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate defaultService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherDefaultServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherDefaultServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. HeaderAction specified here are applied after the
/// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapInitProviderPathMatcherPathRuleRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapInitProviderPathMatcherPathRuleServiceRef>,
    /// Selector for a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapInitProviderPathMatcherPathRuleServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapInitProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapInitProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapInitProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef>,
    /// Selector for a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector>,
}

/// Reference to a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Reference to a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceRef")]
    #[builder(default)]
    pub backend_service_ref: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef>,
    /// Selector for a BackendService in compute to populate backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendServiceSelector")]
    #[builder(default)]
    pub backend_service_selector: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Reference to a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate backendService.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherPathRuleServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<URLMapInitProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapInitProviderPathMatcherRouteRulesRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapInitProviderPathMatcherRouteRulesServiceRef>,
    /// Selector for a BackendService in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapInitProviderPathMatcherRouteRulesServiceSelector>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapInitProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<URLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<URLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<URLMapInitProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
    /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<URLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
/// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
/// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
/// must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<URLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// Reference to a BackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherRouteRulesServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherRouteRulesServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendService in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderPathMatcherRouteRulesServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// Reference to a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRef")]
    #[builder(default)]
    pub service_ref: Option<URLMapInitProviderTestServiceRef>,
    /// Selector for a BackendBucket in compute to populate service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelector")]
    #[builder(default)]
    pub service_selector: Option<URLMapInitProviderTestServiceSelector>,
}

/// Reference to a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderTestServiceRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderTestServiceRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderTestServiceRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderTestServiceRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderTestServiceRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderTestServiceRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderTestServiceRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a BackendBucket in compute to populate service.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderTestServiceSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapInitProviderTestServiceSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapInitProviderTestServiceSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapInitProviderTestServiceSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapInitProviderTestServiceSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderTestServiceSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapInitProviderTestServiceSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapPublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<URLMapPublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<URLMapPublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapPublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<URLMapPublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapPublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<URLMapPublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<URLMapPublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapPublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum URLMapPublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapPublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// URLMapStatus defines the observed state of URLMap.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<URLMapStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProvider {
    /// Creation timestamp in RFC3339 text format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    #[builder(default)]
    pub creation_timestamp: Option<String>,
    /// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
    /// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
    /// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
    /// is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapStatusAtProviderDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given rules match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapStatusAtProviderDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Fingerprint of this resource. A hash of the contents stored in this object. This
    /// field is used in optimistic locking.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub fingerprint: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. The headerAction specified here take effect after
    /// headerAction specified under pathMatcher.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderHeaderAction>,
    /// The list of HostRules to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRule")]
    #[builder(default)]
    pub host_rule: Option<Vec<URLMapStatusAtProviderHostRule>>,
    /// an identifier for the resource with format projects/{{project}}/global/urlMaps/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The unique identifier for the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapId")]
    #[builder(default)]
    pub map_id: Option<f64>,
    /// The list of named PathMatchers to use against the URL.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<Vec<URLMapStatusAtProviderPathMatcher>>,
    /// The ID of the project in which the resource belongs.
    /// If it is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// The list of expected URL mapping tests. Request to update this UrlMap will
    /// succeed only if all of the test cases pass. You can specify a maximum of 100
    /// tests per UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub test: Option<Vec<URLMapStatusAtProviderTest>>,
}

/// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
/// like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
/// If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
/// is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see
    /// W3C Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapStatusAtProviderDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
    /// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
    /// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
    /// by the Loadbalancer for a percentage of requests.
    /// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
    /// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
    /// the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapStatusAtProviderDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapStatusAtProviderDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
    /// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
    /// If not specified, will use the largest timeout among all backend services associated with the route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapStatusAtProviderDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapStatusAtProviderDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match occurs.
    /// The weights determine the fraction of traffic that flows to their corresponding backend service.
    /// If all traffic needs to go to a single backend service, there must be one weightedBackendService
    /// with weight set to a non 0 number.
    /// Once a backendService is identified and before forwarding the request to the backend service,
    /// advanced routing actions like Url rewrites and header transformations are applied depending on
    /// additional settings specified in this HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapStatusAtProviderDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
/// As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
/// percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
/// by the Loadbalancer for a percentage of requests.
/// timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
/// Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
/// the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapStatusAtProviderDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time the request has been
/// fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
/// If not specified, will use the largest timeout among all backend services associated with the route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to the matched service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one that was
    /// supplied in the request. The value must be between 1 and 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https. If set to
    /// false, the URL scheme of the redirected request will remain the same as that of the
    /// request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
    /// true for TargetHttpsProxy is not permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one that was
    /// supplied in the request. pathRedirect cannot be supplied together with
    /// prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
    /// original request will be used for the redirect. The value must be between 1 and 1024
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
    /// retaining the remaining portion of the URL before redirecting the request.
    /// prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
    /// neither. If neither is supplied, the path of the original request will be used for
    /// the redirect. The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is removed prior
    /// to redirecting the request. If set to false, the query portion of the original URL is
    /// retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. The headerAction specified here take effect after
/// headerAction specified under pathMatcher.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderHostRule {
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// The list of host patterns to match. They must be valid hostnames, except * will
    /// match any string of ([a-z0-9-.]*). In that case, * must be the first character
    /// and must be followed in the pattern by either - or ..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hosts: Option<Vec<String>>,
    /// The name of the PathMatcher to use to match the path portion of the URL if the
    /// hostRule matches the URL's host portion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathMatcher")]
    #[builder(default)]
    pub path_matcher: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcher {
    /// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
    /// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
    /// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
    /// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
    /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRouteAction")]
    #[builder(default)]
    pub default_route_action: Option<URLMapStatusAtProviderPathMatcherDefaultRouteAction>,
    /// The backend service or backend bucket to use when none of the given paths match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultService")]
    #[builder(default)]
    pub default_service: Option<String>,
    /// When none of the specified hostRules match, the request is redirected to a URL specified
    /// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
    /// defaultRouteAction must not be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUrlRedirect")]
    #[builder(default)]
    pub default_url_redirect: Option<URLMapStatusAtProviderPathMatcherDefaultUrlRedirect>,
    /// An optional description of this resource. Provide this property when you create
    /// the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. HeaderAction specified here are applied after the
    /// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderPathMatcherHeaderAction>,
    /// The name to which this PathMatcher is referred by the HostRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The list of path rules. Use this list instead of routeRules when routing based
    /// on simple path matching is all that's required. The order by which path rules
    /// are specified does not matter. Matches are always done on the longest-path-first
    /// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
    /// irrespective of the order in which those paths appear in this list. Within a
    /// given pathMatcher, only one of pathRules or routeRules must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRule")]
    #[builder(default)]
    pub path_rule: Option<Vec<URLMapStatusAtProviderPathMatcherPathRule>>,
    /// The list of ordered HTTP route rules. Use this list instead of pathRules when
    /// advanced route matching and routing actions are desired. The order of specifying
    /// routeRules matters: the first rule that matches will cause its specified routing
    /// action to take effect. Within a given pathMatcher, only one of pathRules or
    /// routeRules must be set. routeRules are not supported in UrlMaps intended for
    /// External load balancers.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRules")]
    #[builder(default)]
    pub route_rules: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRules>>,
}

/// defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
/// advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
/// to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
/// Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
/// Only one of defaultRouteAction or defaultUrlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When none of the specified hostRules match, the request is redirected to a URL specified
/// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
/// defaultRouteAction must not be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherDefaultUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. HeaderAction specified here are applied after the
/// matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRule {
    /// The list of path patterns to match. Each must start with / and the only place a
    /// * is allowed is at the end following a /. The string fed to the path matcher
    /// does not include any text after the first ? or #, and those chars are not
    /// allowed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub paths: Option<Vec<String>>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapStatusAtProviderPathMatcherPathRuleUrlRedirect>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherPathRuleUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRules {
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderPathMatcherRouteRulesHeaderAction>,
    /// The rules for determining a match.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRules")]
    #[builder(default)]
    pub match_rules: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesMatchRules>>,
    /// For routeRules within a given pathMatcher, priority determines the order
    /// in which load balancer will interpret routeRules. RouteRules are evaluated
    /// in order of priority, from the lowest to highest number. The priority of
    /// a rule decreases as its number increases (1, 2, 3, N+1). The first rule
    /// that matches the request is applied.
    /// You cannot configure two or more routeRules with the same priority.
    /// Priority for each rule must be set to a number between 0 and
    /// 2147483647 inclusive.
    /// Priority numbers can have gaps, which enable you to add or remove rules
    /// in the future without affecting the rest of the rules. For example,
    /// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
    /// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
    /// future without any impact on existing rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub priority: Option<f64>,
    /// In response to a matching matchRule, the load balancer performs advanced routing
    /// actions like URL rewrites, header transformations, etc. prior to forwarding the
    /// request to the selected backend. If  routeAction specifies any
    /// weightedBackendServices, service must not be set. Conversely if service is set,
    /// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
    /// or urlRedirect must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAction")]
    #[builder(default)]
    pub route_action: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteAction>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
    /// When this rule is matched, the request is redirected to a URL specified by
    /// urlRedirect. If urlRedirect is specified, service or routeAction must not be
    /// set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRedirect")]
    #[builder(default)]
    pub url_redirect: Option<URLMapStatusAtProviderPathMatcherRouteRulesUrlRedirect>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRules {
    /// For satisfying the matchRule condition, the path of the request must exactly
    /// match the value specified in fullPathMatch after removing any query parameters
    /// and anchor that may be part of the original URL. FullPathMatch must be between 1
    /// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
    /// be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullPathMatch")]
    #[builder(default)]
    pub full_path_match: Option<String>,
    /// Specifies a list of header match criteria, all of which must match corresponding
    /// headers in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    #[builder(default)]
    pub header_matches: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatches>>,
    /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    #[builder(default)]
    pub ignore_case: Option<bool>,
    /// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
    /// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
    /// clients present node metadata. If a match takes place, the relevant routing
    /// configuration is made available to those proxies. For each metadataFilter in
    /// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
    /// filterLabels must match the corresponding label provided in the metadata. If its
    /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
    /// with corresponding labels in the provided metadata. metadataFilters specified
    /// here can be overrides those specified in ForwardingRule that refers to this
    /// UrlMap. metadataFilters only applies to Loadbalancers that have their
    /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFilters")]
    #[builder(default)]
    pub metadata_filters: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFilters>>,
    /// For satisfying the matchRule condition, the path of the request
    /// must match the wildcard pattern specified in pathTemplateMatch
    /// after removing any query parameters and anchor that may be part
    /// of the original URL.
    /// pathTemplateMatch must be between 1 and 255 characters
    /// (inclusive).  The pattern specified by pathTemplateMatch may
    /// have at most 5 wildcard operators and at most 5 variable
    /// captures in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateMatch")]
    #[builder(default)]
    pub path_template_match: Option<String>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies a list of query parameter match criteria, all of which must match
    /// corresponding query parameters in the request.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterMatches")]
    #[builder(default)]
    pub query_parameter_matches: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches>>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// If set to false, the headerMatch is considered a match if the match criteria
    /// above are met. If set to true, the headerMatch is considered a match if the
    /// match criteria above are NOT met. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "invertMatch")]
    #[builder(default)]
    pub invert_match: Option<bool>,
    /// For satisfying the matchRule condition, the request's path must begin with the
    /// specified prefixMatch. prefixMatch must begin with a /. The value must be
    /// between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
    /// regexMatch must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixMatch")]
    #[builder(default)]
    pub prefix_match: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The header value must be an integer and its value must be in the range specified
    /// in rangeMatch. If the header does not contain an integer, number or is empty,
    /// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
    /// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeMatch")]
    #[builder(default)]
    pub range_match: Option<URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
    /// The value of the header must end with the contents of suffixMatch. Only one of
    /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suffixMatch")]
    #[builder(default)]
    pub suffix_match: Option<String>,
}

/// The header value must be an integer and its value must be in the range specified
/// in rangeMatch. If the header does not contain an integer, number or is empty,
/// the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
/// not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
/// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
/// must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
    /// The end of the range (exclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeEnd")]
    #[builder(default)]
    pub range_end: Option<f64>,
    /// The start of the range (inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rangeStart")]
    #[builder(default)]
    pub range_start: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFilters {
    /// The list of label value pairs that must match labels in the provided metadata
    /// based on filterMatchCriteria  This list must not be empty and can have at the
    /// most 64 entries.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterLabels")]
    #[builder(default)]
    pub filter_labels: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels>>,
    /// Specifies how individual filterLabel matches within the list of filterLabels
    /// contribute towards the overall metadataFilter match. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterMatchCriteria")]
    #[builder(default)]
    pub filter_match_criteria: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The value of the label must match the specified value. value can have a maximum
    /// length of 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesMatchRulesQueryParameterMatches {
    /// The queryParameterMatch matches if the value of the parameter exactly matches
    /// the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
    /// must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exactMatch")]
    #[builder(default)]
    pub exact_match: Option<String>,
    /// The name of the query parameter to match. The query parameter must exist in the
    /// request, in the absence of which the request match fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// Specifies that the queryParameterMatch matches if the request contains the query
    /// parameter, irrespective of whether the parameter has a value or not. Only one of
    /// presentMatch, exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "presentMatch")]
    #[builder(default)]
    pub present_match: Option<bool>,
    /// The queryParameterMatch matches if the value of the parameter matches the
    /// regular expression specified by regexMatch. For the regular expression grammar,
    /// please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
    /// exactMatch and regexMatch must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "regexMatch")]
    #[builder(default)]
    pub regex_match: Option<String>,
}

/// In response to a matching matchRule, the load balancer performs advanced routing
/// actions like URL rewrites, header transformations, etc. prior to forwarding the
/// request to the selected backend. If  routeAction specifies any
/// weightedBackendServices, service must not be set. Conversely if service is set,
/// routeAction cannot contain any  weightedBackendServices. Only one of routeAction
/// or urlRedirect must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteAction {
    /// The specification for allowing client side cross-origin requests. Please see W3C
    /// Recommendation for Cross Origin Resource Sharing
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    #[builder(default)]
    pub cors_policy: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionCorsPolicy>,
    /// The specification for fault injection introduced into traffic to test the
    /// resiliency of clients to backend service failure. As part of fault injection,
    /// when clients send requests to a backend service, delays can be introduced by
    /// Loadbalancer on a percentage of requests before sending those request to the
    /// backend service. Similarly requests from clients can be aborted by the
    /// Loadbalancer for a percentage of requests. timeout and retry_policy will be
    /// ignored by clients that are configured with a fault_injection_policy.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "faultInjectionPolicy")]
    #[builder(default)]
    pub fault_injection_policy: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy>,
    /// Specifies the policy on how requests intended for the route's backends are
    /// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
    /// responses from the shadow service. Prior to sending traffic to the shadow
    /// service, the host / authority header is suffixed with -shadow.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestMirrorPolicy")]
    #[builder(default)]
    pub request_mirror_policy: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy>,
    /// Specifies the retry policy associated with this route.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    #[builder(default)]
    pub retry_policy: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicy>,
    /// Specifies the timeout for the selected route. Timeout is computed from the time
    /// the request is has been fully processed (i.e. end-of-stream) up until the
    /// response has been completely processed. Timeout includes all retries. If not
    /// specified, the default value is 15 seconds.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timeout: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionTimeout>,
    /// The spec to modify the URL of the request, prior to forwarding the request to
    /// the matched service
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRewrite")]
    #[builder(default)]
    pub url_rewrite: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionUrlRewrite>,
    /// A list of weighted backend services to send traffic to when a route match
    /// occurs. The weights determine the fraction of traffic that flows to their
    /// corresponding backend service. If all traffic needs to go to a single backend
    /// service, there must be one  weightedBackendService with weight set to a non 0
    /// number. Once a backendService is identified and before forwarding the request to
    /// the backend service, advanced routing actions like Url rewrites and header
    /// transformations are applied depending on additional settings specified in this
    /// HttpRouteAction.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightedBackendServices")]
    #[builder(default)]
    pub weighted_backend_services: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServices>>,
}

/// The specification for allowing client side cross-origin requests. Please see W3C
/// Recommendation for Cross Origin Resource Sharing
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionCorsPolicy {
    /// In response to a preflight request, setting this to true indicates that the
    /// actual request can include user credentials. This translates to the Access-
    /// Control-Allow-Credentials header. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    #[builder(default)]
    pub allow_credentials: Option<bool>,
    /// Specifies the content for the Access-Control-Allow-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    #[builder(default)]
    pub allow_headers: Option<Vec<String>>,
    /// Specifies the content for the Access-Control-Allow-Methods header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    #[builder(default)]
    pub allow_methods: Option<Vec<String>>,
    /// Specifies the regular expression patterns that match allowed origins. For
    /// regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
    /// An origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOriginRegexes")]
    #[builder(default)]
    pub allow_origin_regexes: Option<Vec<String>>,
    /// Specifies the list of origins that will be allowed to do CORS requests. An
    /// origin is allowed if it matches either allow_origins or allow_origin_regex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    #[builder(default)]
    pub allow_origins: Option<Vec<String>>,
    /// If true, specifies the CORS policy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub disabled: Option<bool>,
    /// Specifies the content for the Access-Control-Expose-Headers header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    #[builder(default)]
    pub expose_headers: Option<Vec<String>>,
    /// Specifies how long the results of a preflight request can be cached. This
    /// translates to the content for the Access-Control-Max-Age header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    #[builder(default)]
    pub max_age: Option<f64>,
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault injection,
/// when clients send requests to a backend service, delays can be introduced by
/// Loadbalancer on a percentage of requests before sending those request to the
/// backend service. Similarly requests from clients can be aborted by the
/// Loadbalancer for a percentage of requests. timeout and retry_policy will be
/// ignored by clients that are configured with a fault_injection_policy.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
    /// The specification for how client requests are aborted as part of fault
    /// injection.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub abort: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort>,
    /// The specification for how client requests are delayed as part of fault
    /// injection, before being sent to a backend service.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub delay: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay>,
}

/// The specification for how client requests are aborted as part of fault
/// injection.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
    /// The HTTP status code used to abort the request. The value must be between 200
    /// and 599 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpStatus")]
    #[builder(default)]
    pub http_status: Option<f64>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// The specification for how client requests are delayed as part of fault
/// injection, before being sent to a backend service.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
    /// Specifies the value of the fixed delay interval.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fixedDelay")]
    #[builder(default)]
    pub fixed_delay: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay>,
    /// The percentage of traffic (connections/operations/requests) on which delay will
    /// be introduced as part of fault injection. The value must be between 0.0 and
    /// 100.0 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub percentage: Option<f64>,
}

/// Specifies the value of the fixed delay interval.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the policy on how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait for
/// responses from the shadow service. Prior to sending traffic to the shadow
/// service, the host / authority header is suffixed with -shadow.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
}

/// Specifies the retry policy associated with this route.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicy {
    /// Specifies the allowed number retries. This number must be > 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numRetries")]
    #[builder(default)]
    pub num_retries: Option<f64>,
    /// Specifies a non-zero timeout per retry attempt.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    #[builder(default)]
    pub per_try_timeout: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout>,
    /// Specifies one or more conditions when this retry rule applies. Valid values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryConditions")]
    #[builder(default)]
    pub retry_conditions: Option<Vec<String>>,
}

/// Specifies a non-zero timeout per retry attempt.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// Specifies the timeout for the selected route. Timeout is computed from the time
/// the request is has been fully processed (i.e. end-of-stream) up until the
/// response has been completely processed. Timeout includes all retries. If not
/// specified, the default value is 15 seconds.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionTimeout {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations
    /// less than one second are represented with a 0 seconds field and a positive
    /// nanos field. Must be from 0 to 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
    /// inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<String>,
}

/// The spec to modify the URL of the request, prior to forwarding the request to
/// the matched service
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionUrlRewrite {
    /// Prior to forwarding the request to the selected service, the request's host
    /// header is replaced with contents of hostRewrite. The value must be between 1 and
    /// 255 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRewrite")]
    #[builder(default)]
    pub host_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected backend service, the matching
    /// portion of the request's path is replaced by pathPrefixRewrite. The value must
    /// be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefixRewrite")]
    #[builder(default)]
    pub path_prefix_rewrite: Option<String>,
    /// Prior to forwarding the request to the selected origin, if the
    /// request matched a pathTemplateMatch, the matching portion of the
    /// request's path is replaced re-written using the pattern specified
    /// by pathTemplateRewrite.
    /// pathTemplateRewrite must be between 1 and 255 characters
    /// (inclusive), must start with a '/', and must only use variables
    /// captured by the route's pathTemplate matchers.
    /// pathTemplateRewrite may only be used when all of a route's
    /// MatchRules specify pathTemplate.
    /// Only one of pathPrefixRewrite and pathTemplateRewrite may be
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTemplateRewrite")]
    #[builder(default)]
    pub path_template_rewrite: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServices {
    /// The default BackendService resource. Before
    /// forwarding the request to backendService, the loadbalancer applies any relevant
    /// headerActions specified as part of this backendServiceWeight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendService")]
    #[builder(default)]
    pub backend_service: Option<String>,
    /// Specifies changes to request and response headers that need to take effect for
    /// the selected backendService. headerAction specified here take effect before
    /// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerAction")]
    #[builder(default)]
    pub header_action: Option<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction>,
    /// Specifies the fraction of traffic sent to backendService, computed as weight /
    /// (sum of all weightedBackendService weights in routeAction) . The selection of a
    /// backend service is determined only for new traffic. Once a user's request has
    /// been directed to a backendService, subsequent requests will be sent to the same
    /// backendService as determined by the BackendService's session affinity policy.
    /// The value must be between 0 and 1000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub weight: Option<f64>,
}

/// Specifies changes to request and response headers that need to take effect for
/// the selected backendService. headerAction specified here take effect before
/// headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
    /// Headers to add to a matching request prior to forwarding the request to the
    /// backendService.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToAdd")]
    #[builder(default)]
    pub request_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the request
    /// prior to forwarding the request to the backendService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersToRemove")]
    #[builder(default)]
    pub request_headers_to_remove: Option<Vec<String>>,
    /// Headers to add the response prior to sending the response back to the client.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    #[builder(default)]
    pub response_headers_to_add: Option<Vec<URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd>>,
    /// A list of header names for headers that need to be removed from the response
    /// prior to sending the response back to the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToRemove")]
    #[builder(default)]
    pub response_headers_to_remove: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    #[builder(default)]
    pub header_name: Option<String>,
    /// The value of the header to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    #[builder(default)]
    pub header_value: Option<String>,
    /// If false, headerValue is appended to any values that already exist for the
    /// header. If true, headerValue is set for the header, discarding any values that
    /// were set for that header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub replace: Option<bool>,
}

/// When this rule is matched, the request is redirected to a URL specified by
/// urlRedirect. If urlRedirect is specified, service or routeAction must not be
/// set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderPathMatcherRouteRulesUrlRedirect {
    /// The host that will be used in the redirect response instead of the one
    /// that was supplied in the request. The value must be between 1 and 255
    /// characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostRedirect")]
    #[builder(default)]
    pub host_redirect: Option<String>,
    /// If set to true, the URL scheme in the redirected request is set to https.
    /// If set to false, the URL scheme of the redirected request will remain the
    /// same as that of the request. This must only be set for UrlMaps used in
    /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not
    /// permitted. The default is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsRedirect")]
    #[builder(default)]
    pub https_redirect: Option<bool>,
    /// The path that will be used in the redirect response instead of the one
    /// that was supplied in the request. pathRedirect cannot be supplied
    /// together with prefixRedirect. Supply one alone or neither. If neither is
    /// supplied, the path of the original request will be used for the redirect.
    /// The value must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRedirect")]
    #[builder(default)]
    pub path_redirect: Option<String>,
    /// The prefix that replaces the prefixMatch specified in the
    /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
    /// redirecting the request. prefixRedirect cannot be supplied together with
    /// pathRedirect. Supply one alone or neither. If neither is supplied, the
    /// path of the original request will be used for the redirect. The value
    /// must be between 1 and 1024 characters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prefixRedirect")]
    #[builder(default)]
    pub prefix_redirect: Option<String>,
    /// The HTTP Status code to use for this RedirectAction. Supported values are:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCode")]
    #[builder(default)]
    pub redirect_response_code: Option<String>,
    /// If set to true, any accompanying query portion of the original URL is
    /// removed prior to redirecting the request. If set to false, the query
    /// portion of the original URL is retained.
    /// This field is required to ensure an empty block is not set. The normal default value is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stripQuery")]
    #[builder(default)]
    pub strip_query: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct URLMapStatusAtProviderTest {
    /// Description of this test case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Host portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub host: Option<String>,
    /// Path portion of the URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub path: Option<String>,
    /// The backend service or backend bucket link that should be matched by this test.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service: Option<String>,
}

