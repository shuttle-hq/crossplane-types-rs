// WARNING: generated by kopium - manual changes will be overwritten
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use typed_builder::TypedBuilder;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::HashMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// InstanceSpec defines the desired state of Instance
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
#[kube(group = "compute.gcp.upbound.io", version = "v1beta2", kind = "Instance", plural = "instances")]
#[kube(status = "InstanceStatus")]
pub struct InstanceSpec {
    /// DeletionPolicy specifies what will happen to the underlying external
    /// when this managed resource is deleted - either "Delete" or "Orphan" the
    /// external resource.
    /// This field is planned to be deprecated in favor of the ManagementPolicies
    /// field in a future release. Currently, both could be set independently and
    /// non-default values would be honored if the feature flag is enabled.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    #[builder(default)]
    pub deletion_policy: Option<InstanceDeletionPolicy>,
    #[serde(rename = "forProvider")]
    pub for_provider: InstanceForProvider,
    /// THIS IS A BETA FIELD. It will be honored
    /// unless the Management Policies feature flag is disabled.
    /// InitProvider holds the same fields as ForProvider, with the exception
    /// of Identifier and other resource reference fields. The fields that are
    /// in InitProvider are merged into ForProvider when the resource is created.
    /// The same fields are also added to the terraform ignore_changes hook, to
    /// avoid updating them after creation. This is useful for fields that are
    /// required on creation, but we do not desire to update them after creation,
    /// for example because of an external controller is managing them, like an
    /// autoscaler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initProvider")]
    #[builder(default)]
    pub init_provider: Option<InstanceInitProvider>,
    /// THIS IS A BETA FIELD. It is on by default but can be opted out
    /// through a Crossplane feature flag.
    /// ManagementPolicies specify the array of actions Crossplane is allowed to
    /// take on the managed and external resources.
    /// This field is planned to replace the DeletionPolicy field in a future
    /// release. Currently, both could be set independently and non-default
    /// values would be honored if the feature flag is enabled. If both are
    /// custom, the DeletionPolicy field will be ignored.
    /// See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    /// and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementPolicies")]
    #[builder(default)]
    pub management_policies: Option<Vec<String>>,
    /// ProviderConfigReference specifies how the provider that will be used to
    /// create, observe, update, and delete this managed resource should be
    /// configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerConfigRef")]
    #[builder(default)]
    pub provider_config_ref: Option<InstanceProviderConfigRef>,
    /// PublishConnectionDetailsTo specifies the connection secret config which
    /// contains a name, metadata and a reference to secret store config to
    /// which any connection details for this managed resource should be written.
    /// Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsTo")]
    #[builder(default)]
    pub publish_connection_details_to: Option<InstancePublishConnectionDetailsTo>,
    /// WriteConnectionSecretToReference specifies the namespace and name of a
    /// Secret to which any connection details for this managed resource should
    /// be written. Connection details frequently include the endpoint, username,
    /// and password required to connect to the managed resource.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsTo. Currently, both could be set independently
    /// and connection details would be published to both without affecting
    /// each other.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretToRef")]
    #[builder(default)]
    pub write_connection_secret_to_ref: Option<InstanceWriteConnectionSecretToRef>,
}

/// InstanceSpec defines the desired state of Instance
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceDeletionPolicy {
    Orphan,
    Delete,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceForProviderAdvancedMachineFeatures>,
    /// If you try to update a property that requires stopping the instance without setting this field, the update will fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    #[builder(default)]
    pub allow_stopping_for_update: Option<bool>,
    /// Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    #[builder(default)]
    pub attached_disk: Option<Vec<InstanceForProviderAttachedDisk>>,
    /// The boot disk for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    #[builder(default)]
    pub boot_disk: Option<InstanceForProviderBootDisk>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs.
    /// This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceForProviderConfidentialInstanceConfig>,
    /// Enable deletion protection on this instance. Defaults to false.
    /// Note: you must disable deletion protection before removing the resource (e.g.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    #[builder(default)]
    pub deletion_protection: Option<bool>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired status of the instance. Either
    /// "RUNNING" or "TERMINATED".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    #[builder(default)]
    pub desired_status: Option<String>,
    /// Enable Virtual Displays on this instance.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    #[builder(default)]
    pub enable_display: Option<bool>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    /// Note: GPU accelerators can only be used with on_host_maintenance option set to TERMINATE.
    /// Note: This field uses attr-as-block mode to avoid
    /// breaking users during the 0.12 upgrade. To explicitly send a list
    /// of zero objects you must use the following syntax:
    /// example=[]
    /// For more details about this behavior, see this section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceForProviderGuestAccelerator>>,
    /// A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.
    /// Valid format is a series of labels 1-63 characters long matching the regular expression [a-z]([-a-z0-9]*[a-z0-9]), concatenated with periods.
    /// The entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hostname: Option<String>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within the instance. Ssh keys attached in the Cloud Console will be removed.
    /// Add them to your config in order to keep them attached to your instance.
    /// A list of predefined metadata keys (e.g. ssh-keys) can be found here
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// An alternative to using the
    /// startup-script metadata key, except this one forces the instance to be recreated
    /// (thus re-running the script) if it is changed. This replaces the startup-script
    /// metadata key on the created instance and thus the two mechanisms are not
    /// allowed to be used simultaneously.  Users are free to use either mechanism - the
    /// only distinction is that this separate attribute will cause a recreate on
    /// modification.  On import, metadata_startup_script will not be set - if you
    /// choose to specify it you will see a diff immediately after import causing a
    /// destroy/recreate operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// Networks to attach to the instance. This can
    /// be specified multiple times. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceForProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceForProviderNetworkPerformanceConfig>,
    /// Additional instance parameters.
    /// .
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub params: Option<InstanceForProviderParams>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceForProviderReservationAffinity>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceForProviderScheduling>,
    /// Scratch disks to attach to the instance. This can be
    /// specified multiple times for multiple scratch disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    #[builder(default)]
    pub scratch_disk: Option<Vec<InstanceForProviderScratchDisk>>,
    /// Service account to attach to the instance.
    /// Structure is documented below.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceForProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceForProviderShieldedInstanceConfig>,
    /// A list of network tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// The zone that the machine should be created in. If it is not provided, the provider zone is used.
    pub zone: String,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization  enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// he number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderAttachedDisk {
    /// Name with which the attached disk will be accessible
    /// under /dev/disk/by-id/google-*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// A 256-bit [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    /// encoded in RFC 4648 base64
    /// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    #[builder(default)]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceForProviderAttachedDiskDiskEncryptionKeyRawSecretRef>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
    /// If you have a persistent disk with data that you want to share
    /// between multiple instances, detach it from any read-write instances and
    /// attach it to one or more instances in read-only mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the disk to attach to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// A 256-bit [customer-supplied encryption key]
/// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
/// encoded in RFC 4648 base64
/// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderAttachedDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The boot disk for the instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDisk {
    /// Whether the disk will be auto-deleted when the instance
    /// is deleted. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// A 256-bit [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    /// encoded in RFC 4648 base64
    /// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw
    /// may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    #[builder(default)]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceForProviderBootDiskDiskEncryptionKeyRawSecretRef>,
    /// Parameters for a new disk that will be created
    /// alongside the new instance. Either initialize_params or source must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    #[builder(default)]
    pub initialize_params: Option<InstanceForProviderBootDiskInitializeParams>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the existing disk (such as those managed by
    /// google_compute_disk) or disk image. To create an instance from a snapshot, first create a
    /// google_compute_disk from a snapshot and reference it here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// A 256-bit [customer-supplied encryption key]
/// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
/// encoded in RFC 4648 base64
/// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw
/// may be set.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Parameters for a new disk that will be created
/// alongside the new instance. Either initialize_params or source must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskInitializeParams {
    /// Whether this disk is using confidential compute mode.
    /// Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
    /// The image from which to initialize this disk. This can be
    /// one of: the image's self_link, projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}. If referred by family, the
    /// images names must include the family name. If they don't, use the
    /// google_compute_image data source.
    /// For instance, the image centos-6-v20180104 includes its family name centos-6.
    /// These images can be referred by family name here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub image: Option<String>,
    /// Reference to a Image in compute to populate image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRef")]
    #[builder(default)]
    pub image_ref: Option<InstanceForProviderBootDiskInitializeParamsImageRef>,
    /// Selector for a Image in compute to populate image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageSelector")]
    #[builder(default)]
    pub image_selector: Option<InstanceForProviderBootDiskInitializeParamsImageSelector>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Indicates how many IOPS to provision for the disk.
    /// This sets the number of I/O operations per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
    /// you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// Indicates how much throughput to provision for the disk.
    /// This sets the number of throughput mb per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of throughput every 4 hours. To update your hyperdisk more
    /// frequently, you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    #[builder(default)]
    pub provisioned_throughput: Option<f64>,
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
    /// The URL of the storage pool in which the new disk is created.
    /// For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    #[builder(default)]
    pub storage_pool: Option<String>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Reference to a Image in compute to populate image.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskInitializeParamsImageRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderBootDiskInitializeParamsImageRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskInitializeParamsImageRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderBootDiskInitializeParamsImageRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderBootDiskInitializeParamsImageRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderBootDiskInitializeParamsImageRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderBootDiskInitializeParamsImageRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Image in compute to populate image.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskInitializeParamsImageSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderBootDiskInitializeParamsImageSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderBootDiskInitializeParamsImageSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderBootDiskInitializeParamsImageSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderBootDiskInitializeParamsImageSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderBootDiskInitializeParamsImageSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderBootDiskInitializeParamsImageSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet. Omit to ensure that the instance
    /// is not accessible from the Internet.g. via
    /// tunnel or because it is running on another cloud instance on that network).
    /// This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceForProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceForProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceForProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Either network or subnetwork must be provided. If network isn't provided it will
    /// be inferred from the subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<InstanceForProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<InstanceForProviderNetworkInterfaceNetworkSelector>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// The name or self_link of the subnetwork to attach this
    /// interface to. Either network or subnetwork must be provided. If network isn't provided
    /// it will be inferred from the subnetwork. The subnetwork must exist in the same region this
    /// instance will be created in. If the network resource is in
    /// legacy mode, do not specify this field. If the
    /// network is in auto subnet mode, specifying the subnetwork is optional. If the network is
    /// in custom subnet mode, specifying the subnetwork is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The project in which the subnetwork belongs.
    /// If the subnetwork is a self_link, this field is ignored in favor of the project
    /// defined in the subnetwork self_link. If the subnetwork is a name and this
    /// field is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<InstanceForProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<InstanceForProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceAccessConfig {
    /// If the instance has an access config, either the given external ip (in the nat_ip field) or the ephemeral (generated) ip (if you didn't provide one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. This range may be a single IP address
    /// (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceIpv6AccessConfig {
    /// The first IPv6 address of the external IPv6 range associated
    /// with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig.
    /// To use a static external IP address, it must be unused and in the same region as the instance's zone.
    /// If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    #[builder(default)]
    pub external_ipv6: Option<String>,
    /// The prefix length of the external IPv6 range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    #[builder(default)]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable.
    /// Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Additional instance parameters.
/// .
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderParams {
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceForProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderScheduling {
    /// Specifies if the instance should be
    /// restarted if it was terminated by Compute Engine (not a user).
    /// Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<InstanceForProviderSchedulingLocalSsdRecoveryTimeout>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceForProviderSchedulingMaxRunDuration>,
    /// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceForProviderSchedulingNodeAffinities>>,
    /// Describes maintenance behavior for the
    /// instance. Can be MIGRATE or TERMINATE, for more info, read
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceForProviderSchedulingOnInstanceStopAction>,
    /// Specifies if the instance is preemptible.
    /// If this field is set to true, then automatic_restart must be
    /// set to false.  Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

/// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
/// The local_ssd_recovery_timeout block supports:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderScratchDisk {
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The disk interface to use for attaching this disk; either SCSI or NVME.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
}

/// Service account to attach to the instance.
/// Structure is documented below.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderServiceAccount {
    /// The service account e-mail address.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailRef")]
    #[builder(default)]
    pub email_ref: Option<InstanceForProviderServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailSelector")]
    #[builder(default)]
    pub email_selector: Option<InstanceForProviderServiceAccountEmailSelector>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Reference to a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceForProviderServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceForProviderServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceForProviderServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceForProviderServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceForProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

/// THIS IS A BETA FIELD. It will be honored
/// unless the Management Policies feature flag is disabled.
/// InitProvider holds the same fields as ForProvider, with the exception
/// of Identifier and other resource reference fields. The fields that are
/// in InitProvider are merged into ForProvider when the resource is created.
/// The same fields are also added to the terraform ignore_changes hook, to
/// avoid updating them after creation. This is useful for fields that are
/// required on creation, but we do not desire to update them after creation,
/// for example because of an external controller is managing them, like an
/// autoscaler.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceInitProviderAdvancedMachineFeatures>,
    /// If you try to update a property that requires stopping the instance without setting this field, the update will fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    #[builder(default)]
    pub allow_stopping_for_update: Option<bool>,
    /// Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    #[builder(default)]
    pub attached_disk: Option<Vec<InstanceInitProviderAttachedDisk>>,
    /// The boot disk for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    #[builder(default)]
    pub boot_disk: Option<InstanceInitProviderBootDisk>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs.
    /// This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceInitProviderConfidentialInstanceConfig>,
    /// Enable deletion protection on this instance. Defaults to false.
    /// Note: you must disable deletion protection before removing the resource (e.g.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    #[builder(default)]
    pub deletion_protection: Option<bool>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired status of the instance. Either
    /// "RUNNING" or "TERMINATED".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    #[builder(default)]
    pub desired_status: Option<String>,
    /// Enable Virtual Displays on this instance.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    #[builder(default)]
    pub enable_display: Option<bool>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    /// Note: GPU accelerators can only be used with on_host_maintenance option set to TERMINATE.
    /// Note: This field uses attr-as-block mode to avoid
    /// breaking users during the 0.12 upgrade. To explicitly send a list
    /// of zero objects you must use the following syntax:
    /// example=[]
    /// For more details about this behavior, see this section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceInitProviderGuestAccelerator>>,
    /// A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.
    /// Valid format is a series of labels 1-63 characters long matching the regular expression [a-z]([-a-z0-9]*[a-z0-9]), concatenated with periods.
    /// The entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hostname: Option<String>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within the instance. Ssh keys attached in the Cloud Console will be removed.
    /// Add them to your config in order to keep them attached to your instance.
    /// A list of predefined metadata keys (e.g. ssh-keys) can be found here
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// An alternative to using the
    /// startup-script metadata key, except this one forces the instance to be recreated
    /// (thus re-running the script) if it is changed. This replaces the startup-script
    /// metadata key on the created instance and thus the two mechanisms are not
    /// allowed to be used simultaneously.  Users are free to use either mechanism - the
    /// only distinction is that this separate attribute will cause a recreate on
    /// modification.  On import, metadata_startup_script will not be set - if you
    /// choose to specify it you will see a diff immediately after import causing a
    /// destroy/recreate operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// Networks to attach to the instance. This can
    /// be specified multiple times. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceInitProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceInitProviderNetworkPerformanceConfig>,
    /// Additional instance parameters.
    /// .
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub params: Option<InstanceInitProviderParams>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceInitProviderReservationAffinity>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceInitProviderScheduling>,
    /// Scratch disks to attach to the instance. This can be
    /// specified multiple times for multiple scratch disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    #[builder(default)]
    pub scratch_disk: Option<Vec<InstanceInitProviderScratchDisk>>,
    /// Service account to attach to the instance.
    /// Structure is documented below.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceInitProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceInitProviderShieldedInstanceConfig>,
    /// A list of network tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization  enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// he number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderAttachedDisk {
    /// Name with which the attached disk will be accessible
    /// under /dev/disk/by-id/google-*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// A 256-bit [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    /// encoded in RFC 4648 base64
    /// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    #[builder(default)]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceInitProviderAttachedDiskDiskEncryptionKeyRawSecretRef>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
    /// If you have a persistent disk with data that you want to share
    /// between multiple instances, detach it from any read-write instances and
    /// attach it to one or more instances in read-only mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the disk to attach to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// A 256-bit [customer-supplied encryption key]
/// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
/// encoded in RFC 4648 base64
/// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderAttachedDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// The boot disk for the instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDisk {
    /// Whether the disk will be auto-deleted when the instance
    /// is deleted. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// A 256-bit [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
    /// encoded in RFC 4648 base64
    /// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw
    /// may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeyRawSecretRef")]
    #[builder(default)]
    pub disk_encryption_key_raw_secret_ref: Option<InstanceInitProviderBootDiskDiskEncryptionKeyRawSecretRef>,
    /// Parameters for a new disk that will be created
    /// alongside the new instance. Either initialize_params or source must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    #[builder(default)]
    pub initialize_params: Option<InstanceInitProviderBootDiskInitializeParams>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the existing disk (such as those managed by
    /// google_compute_disk) or disk image. To create an instance from a snapshot, first create a
    /// google_compute_disk from a snapshot and reference it here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// A 256-bit [customer-supplied encryption key]
/// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
/// encoded in RFC 4648 base64
/// to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw
/// may be set.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskDiskEncryptionKeyRawSecretRef {
    /// The key to select.
    pub key: String,
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// Parameters for a new disk that will be created
/// alongside the new instance. Either initialize_params or source must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskInitializeParams {
    /// Whether this disk is using confidential compute mode.
    /// Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
    /// The image from which to initialize this disk. This can be
    /// one of: the image's self_link, projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}. If referred by family, the
    /// images names must include the family name. If they don't, use the
    /// google_compute_image data source.
    /// For instance, the image centos-6-v20180104 includes its family name centos-6.
    /// These images can be referred by family name here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub image: Option<String>,
    /// Reference to a Image in compute to populate image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRef")]
    #[builder(default)]
    pub image_ref: Option<InstanceInitProviderBootDiskInitializeParamsImageRef>,
    /// Selector for a Image in compute to populate image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageSelector")]
    #[builder(default)]
    pub image_selector: Option<InstanceInitProviderBootDiskInitializeParamsImageSelector>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Indicates how many IOPS to provision for the disk.
    /// This sets the number of I/O operations per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
    /// you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// Indicates how much throughput to provision for the disk.
    /// This sets the number of throughput mb per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of throughput every 4 hours. To update your hyperdisk more
    /// frequently, you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    #[builder(default)]
    pub provisioned_throughput: Option<f64>,
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
    /// The URL of the storage pool in which the new disk is created.
    /// For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    #[builder(default)]
    pub storage_pool: Option<String>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Reference to a Image in compute to populate image.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskInitializeParamsImageRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderBootDiskInitializeParamsImageRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskInitializeParamsImageRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderBootDiskInitializeParamsImageRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderBootDiskInitializeParamsImageRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderBootDiskInitializeParamsImageRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderBootDiskInitializeParamsImageRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Image in compute to populate image.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskInitializeParamsImageSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderBootDiskInitializeParamsImageSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet. Omit to ensure that the instance
    /// is not accessible from the Internet.g. via
    /// tunnel or because it is running on another cloud instance on that network).
    /// This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceInitProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceInitProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceInitProviderNetworkInterfaceIpv6AccessConfig>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Either network or subnetwork must be provided. If network isn't provided it will
    /// be inferred from the subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// Reference to a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkRef")]
    #[builder(default)]
    pub network_ref: Option<InstanceInitProviderNetworkInterfaceNetworkRef>,
    /// Selector for a Network in compute to populate network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkSelector")]
    #[builder(default)]
    pub network_selector: Option<InstanceInitProviderNetworkInterfaceNetworkSelector>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// The name or self_link of the subnetwork to attach this
    /// interface to. Either network or subnetwork must be provided. If network isn't provided
    /// it will be inferred from the subnetwork. The subnetwork must exist in the same region this
    /// instance will be created in. If the network resource is in
    /// legacy mode, do not specify this field. If the
    /// network is in auto subnet mode, specifying the subnetwork is optional. If the network is
    /// in custom subnet mode, specifying the subnetwork is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The project in which the subnetwork belongs.
    /// If the subnetwork is a self_link, this field is ignored in favor of the project
    /// defined in the subnetwork self_link. If the subnetwork is a name and this
    /// field is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
    /// Reference to a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRef")]
    #[builder(default)]
    pub subnetwork_ref: Option<InstanceInitProviderNetworkInterfaceSubnetworkRef>,
    /// Selector for a Subnetwork in compute to populate subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkSelector")]
    #[builder(default)]
    pub subnetwork_selector: Option<InstanceInitProviderNetworkInterfaceSubnetworkSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceAccessConfig {
    /// If the instance has an access config, either the given external ip (in the nat_ip field) or the ephemeral (generated) ip (if you didn't provide one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. This range may be a single IP address
    /// (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceIpv6AccessConfig {
    /// The first IPv6 address of the external IPv6 range associated
    /// with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig.
    /// To use a static external IP address, it must be unused and in the same region as the instance's zone.
    /// If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    #[builder(default)]
    pub external_ipv6: Option<String>,
    /// The prefix length of the external IPv6 range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    #[builder(default)]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

/// Reference to a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceNetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderNetworkInterfaceNetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceNetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderNetworkInterfaceNetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderNetworkInterfaceNetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceNetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceNetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Network in compute to populate network.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceNetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderNetworkInterfaceNetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceNetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderNetworkInterfaceNetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderNetworkInterfaceNetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceNetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceNetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Reference to a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceSubnetworkRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderNetworkInterfaceSubnetworkRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceSubnetworkRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderNetworkInterfaceSubnetworkRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderNetworkInterfaceSubnetworkRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceSubnetworkRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceSubnetworkRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a Subnetwork in compute to populate subnetwork.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceSubnetworkSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderNetworkInterfaceSubnetworkSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable.
    /// Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Additional instance parameters.
/// .
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderParams {
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceInitProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderScheduling {
    /// Specifies if the instance should be
    /// restarted if it was terminated by Compute Engine (not a user).
    /// Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<InstanceInitProviderSchedulingLocalSsdRecoveryTimeout>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceInitProviderSchedulingMaxRunDuration>,
    /// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceInitProviderSchedulingNodeAffinities>>,
    /// Describes maintenance behavior for the
    /// instance. Can be MIGRATE or TERMINATE, for more info, read
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceInitProviderSchedulingOnInstanceStopAction>,
    /// Specifies if the instance is preemptible.
    /// If this field is set to true, then automatic_restart must be
    /// set to false.  Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

/// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
/// The local_ssd_recovery_timeout block supports:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderScratchDisk {
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The disk interface to use for attaching this disk; either SCSI or NVME.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
}

/// Service account to attach to the instance.
/// Structure is documented below.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderServiceAccount {
    /// The service account e-mail address.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// Reference to a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailRef")]
    #[builder(default)]
    pub email_ref: Option<InstanceInitProviderServiceAccountEmailRef>,
    /// Selector for a ServiceAccount in cloudplatform to populate email.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailSelector")]
    #[builder(default)]
    pub email_selector: Option<InstanceInitProviderServiceAccountEmailSelector>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Reference to a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderServiceAccountEmailRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderServiceAccountEmailRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderServiceAccountEmailRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderServiceAccountEmailRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderServiceAccountEmailRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderServiceAccountEmailRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderServiceAccountEmailRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Selector for a ServiceAccount in cloudplatform to populate email.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderServiceAccountEmailSelector {
    /// MatchControllerRef ensures an object with the same controller reference
    /// as the selecting object is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchControllerRef")]
    #[builder(default)]
    pub match_controller_ref: Option<bool>,
    /// MatchLabels ensures an object with matching labels is selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    #[builder(default)]
    pub match_labels: Option<HashMap<String, String>>,
    /// Policies for selection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceInitProviderServiceAccountEmailSelectorPolicy>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderServiceAccountEmailSelectorPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceInitProviderServiceAccountEmailSelectorPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceInitProviderServiceAccountEmailSelectorPolicyResolve>,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderServiceAccountEmailSelectorPolicyResolution {
    Required,
    Optional,
}

/// Policies for selection.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceInitProviderServiceAccountEmailSelectorPolicyResolve {
    Always,
    IfNotPresent,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceInitProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

/// ProviderConfigReference specifies how the provider that will be used to
/// create, observe, update, and delete this managed resource should be
/// configured.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceProviderConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstanceProviderConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceProviderConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstanceProviderConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstanceProviderConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceProviderConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstanceProviderConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// PublishConnectionDetailsTo specifies the connection secret config which
/// contains a name, metadata and a reference to secret store config to
/// which any connection details for this managed resource should be written.
/// Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstancePublishConnectionDetailsTo {
    /// SecretStoreConfigRef specifies which secret store config should be used
    /// for this ConnectionSecret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    #[builder(default)]
    pub config_ref: Option<InstancePublishConnectionDetailsToConfigRef>,
    /// Metadata is the metadata for connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<InstancePublishConnectionDetailsToMetadata>,
    /// Name is the name of the connection secret.
    pub name: String,
}

/// SecretStoreConfigRef specifies which secret store config should be used
/// for this ConnectionSecret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstancePublishConnectionDetailsToConfigRef {
    /// Name of the referenced object.
    pub name: String,
    /// Policies for referencing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub policy: Option<InstancePublishConnectionDetailsToConfigRefPolicy>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstancePublishConnectionDetailsToConfigRefPolicy {
    /// Resolution specifies whether resolution of this reference is required.
    /// The default is 'Required', which means the reconcile will fail if the
    /// reference cannot be resolved. 'Optional' means this reference will be
    /// a no-op if it cannot be resolved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolution: Option<InstancePublishConnectionDetailsToConfigRefPolicyResolution>,
    /// Resolve specifies when this reference should be resolved. The default
    /// is 'IfNotPresent', which will attempt to resolve the reference only when
    /// the corresponding field is not present. Use 'Always' to resolve the
    /// reference on every reconcile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub resolve: Option<InstancePublishConnectionDetailsToConfigRefPolicyResolve>,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstancePublishConnectionDetailsToConfigRefPolicyResolution {
    Required,
    Optional,
}

/// Policies for referencing.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum InstancePublishConnectionDetailsToConfigRefPolicyResolve {
    Always,
    IfNotPresent,
}

/// Metadata is the metadata for connection secret.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstancePublishConnectionDetailsToMetadata {
    /// Annotations are the annotations to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.annotations".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<HashMap<String, String>>,
    /// Labels are the labels/tags to be added to connection secret.
    /// - For Kubernetes secrets, this will be used as "metadata.labels".
    /// - It is up to Secret Store implementation for others store types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Type is the SecretType for the connection secret.
    /// - Only valid for Kubernetes Secret Stores.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// WriteConnectionSecretToReference specifies the namespace and name of a
/// Secret to which any connection details for this managed resource should
/// be written. Connection details frequently include the endpoint, username,
/// and password required to connect to the managed resource.
/// This field is planned to be replaced in a future release in favor of
/// PublishConnectionDetailsTo. Currently, both could be set independently
/// and connection details would be published to both without affecting
/// each other.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceWriteConnectionSecretToRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// InstanceStatus defines the observed state of Instance.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "atProvider")]
    #[builder(default)]
    pub at_provider: Option<InstanceStatusAtProvider>,
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest metadata.generation
    /// which resulted in either a ready state, or stalled due to error
    /// it can not recover from without human intervention.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    #[builder(default)]
    pub observed_generation: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProvider {
    /// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedMachineFeatures")]
    #[builder(default)]
    pub advanced_machine_features: Option<InstanceStatusAtProviderAdvancedMachineFeatures>,
    /// If you try to update a property that requires stopping the instance without setting this field, the update will fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStoppingForUpdate")]
    #[builder(default)]
    pub allow_stopping_for_update: Option<bool>,
    /// Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachedDisk")]
    #[builder(default)]
    pub attached_disk: Option<Vec<InstanceStatusAtProviderAttachedDisk>>,
    /// The boot disk for the instance.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootDisk")]
    #[builder(default)]
    pub boot_disk: Option<InstanceStatusAtProviderBootDisk>,
    /// Whether to allow sending and receiving of
    /// packets with non-matching source or destination IPs.
    /// This defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canIpForward")]
    #[builder(default)]
    pub can_ip_forward: Option<bool>,
    /// Enable Confidential Mode on this VM. Structure is documented below
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceConfig")]
    #[builder(default)]
    pub confidential_instance_config: Option<InstanceStatusAtProviderConfidentialInstanceConfig>,
    /// The CPU platform used by this instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuPlatform")]
    #[builder(default)]
    pub cpu_platform: Option<String>,
    /// The current status of the instance. This could be one of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see Instance life cycle.`,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentStatus")]
    #[builder(default)]
    pub current_status: Option<String>,
    /// Enable deletion protection on this instance. Defaults to false.
    /// Note: you must disable deletion protection before removing the resource (e.g.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionProtection")]
    #[builder(default)]
    pub deletion_protection: Option<bool>,
    /// A brief description of this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    /// Desired status of the instance. Either
    /// "RUNNING" or "TERMINATED".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredStatus")]
    #[builder(default)]
    pub desired_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveLabels")]
    #[builder(default)]
    pub effective_labels: Option<HashMap<String, String>>,
    /// Enable Virtual Displays on this instance.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDisplay")]
    #[builder(default)]
    pub enable_display: Option<bool>,
    /// List of the type and count of accelerator cards attached to the instance. Structure documented below.
    /// Note: GPU accelerators can only be used with on_host_maintenance option set to TERMINATE.
    /// Note: This field uses attr-as-block mode to avoid
    /// breaking users during the 0.12 upgrade. To explicitly send a list
    /// of zero objects you must use the following syntax:
    /// example=[]
    /// For more details about this behavior, see this section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestAccelerator")]
    #[builder(default)]
    pub guest_accelerator: Option<Vec<InstanceStatusAtProviderGuestAccelerator>>,
    /// A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.
    /// Valid format is a series of labels 1-63 characters long matching the regular expression [a-z]([-a-z0-9]*[a-z0-9]), concatenated with periods.
    /// The entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hostname: Option<String>,
    /// an identifier for the resource with format projects/{{project}}/zones/{{zone}}/instances/{{name}}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    /// The server-assigned unique identifier of this instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceId")]
    #[builder(default)]
    pub instance_id: Option<String>,
    /// The unique fingerprint of the labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelFingerprint")]
    #[builder(default)]
    pub label_fingerprint: Option<String>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// The machine type to create.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineType")]
    #[builder(default)]
    pub machine_type: Option<String>,
    /// Metadata key/value pairs to make available from
    /// within the instance. Ssh keys attached in the Cloud Console will be removed.
    /// Add them to your config in order to keep them attached to your instance.
    /// A list of predefined metadata keys (e.g. ssh-keys) can be found here
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<HashMap<String, String>>,
    /// The unique fingerprint of the metadata.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataFingerprint")]
    #[builder(default)]
    pub metadata_fingerprint: Option<String>,
    /// An alternative to using the
    /// startup-script metadata key, except this one forces the instance to be recreated
    /// (thus re-running the script) if it is changed. This replaces the startup-script
    /// metadata key on the created instance and thus the two mechanisms are not
    /// allowed to be used simultaneously.  Users are free to use either mechanism - the
    /// only distinction is that this separate attribute will cause a recreate on
    /// modification.  On import, metadata_startup_script will not be set - if you
    /// choose to specify it you will see a diff immediately after import causing a
    /// destroy/recreate operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataStartupScript")]
    #[builder(default)]
    pub metadata_startup_script: Option<String>,
    /// Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as
    /// Intel Haswell or Intel Skylake. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minCpuPlatform")]
    #[builder(default)]
    pub min_cpu_platform: Option<String>,
    /// Networks to attach to the instance. This can
    /// be specified multiple times. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkInterface")]
    #[builder(default)]
    pub network_interface: Option<Vec<InstanceStatusAtProviderNetworkInterface>>,
    /// os-features, and network_interface.0.nic-type must be GVNIC
    /// in order for this setting to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPerformanceConfig")]
    #[builder(default)]
    pub network_performance_config: Option<InstanceStatusAtProviderNetworkPerformanceConfig>,
    /// Additional instance parameters.
    /// .
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub params: Option<InstanceStatusAtProviderParams>,
    /// The ID of the project in which the resource belongs. If it
    /// is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<String>,
    /// Specifies the reservations that this instance can consume from.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reservationAffinity")]
    #[builder(default)]
    pub reservation_affinity: Option<InstanceStatusAtProviderReservationAffinity>,
    /// - A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePolicies")]
    #[builder(default)]
    pub resource_policies: Option<Vec<String>>,
    /// The scheduling strategy to use. More details about
    /// this configuration option are detailed below.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scheduling: Option<InstanceStatusAtProviderScheduling>,
    /// Scratch disks to attach to the instance. This can be
    /// specified multiple times for multiple scratch disks. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scratchDisk")]
    #[builder(default)]
    pub scratch_disk: Option<Vec<InstanceStatusAtProviderScratchDisk>>,
    /// The URI of the created resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfLink")]
    #[builder(default)]
    pub self_link: Option<String>,
    /// Service account to attach to the instance.
    /// Structure is documented below.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    #[builder(default)]
    pub service_account: Option<InstanceStatusAtProviderServiceAccount>,
    /// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
    /// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shieldedInstanceConfig")]
    #[builder(default)]
    pub shielded_instance_config: Option<InstanceStatusAtProviderShieldedInstanceConfig>,
    /// A list of network tags to attach to the instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    /// The unique fingerprint of the tags.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsFingerprint")]
    #[builder(default)]
    pub tags_fingerprint: Option<String>,
    /// The combination of labels configured directly on the resource and default labels configured on the provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terraformLabels")]
    #[builder(default)]
    pub terraform_labels: Option<HashMap<String, String>>,
    /// The zone that the machine should be created in. If it is not provided, the provider zone is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub zone: Option<String>,
}

/// Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderAdvancedMachineFeatures {
    /// Defines whether the instance should have nested virtualization  enabled. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNestedVirtualization")]
    #[builder(default)]
    pub enable_nested_virtualization: Option<bool>,
    /// he number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "threadsPerCore")]
    #[builder(default)]
    pub threads_per_core: Option<f64>,
    /// The number of physical cores to expose to an instance. visible cores info (VC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "visibleCoreCount")]
    #[builder(default)]
    pub visible_core_count: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderAttachedDisk {
    /// Name with which the attached disk will be accessible
    /// under /dev/disk/by-id/google-*
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The RFC 4648 base64
    /// encoded SHA-256 hash of the [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    #[builder(default)]
    pub disk_encryption_key_sha256: Option<String>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
    /// If you have a persistent disk with data that you want to share
    /// between multiple instances, detach it from any read-write instances and
    /// attach it to one or more instances in read-only mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the disk to attach to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// The boot disk for the instance.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderBootDisk {
    /// Whether the disk will be auto-deleted when the instance
    /// is deleted. Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoDelete")]
    #[builder(default)]
    pub auto_delete: Option<bool>,
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The RFC 4648 base64
    /// encoded SHA-256 hash of the [customer-supplied encryption key]
    /// (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskEncryptionKeySha256")]
    #[builder(default)]
    pub disk_encryption_key_sha256: Option<String>,
    /// Parameters for a new disk that will be created
    /// alongside the new instance. Either initialize_params or source must be set.
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initializeParams")]
    #[builder(default)]
    pub initialize_params: Option<InstanceStatusAtProviderBootDiskInitializeParams>,
    /// The self_link of the encryption key that is
    /// stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link
    /// and disk_encryption_key_raw may be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeySelfLink")]
    #[builder(default)]
    pub kms_key_self_link: Option<String>,
    /// The mode in which to attach this disk, either READ_WRITE
    /// or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mode: Option<String>,
    /// The name or self_link of the existing disk (such as those managed by
    /// google_compute_disk) or disk image. To create an instance from a snapshot, first create a
    /// google_compute_disk from a snapshot and reference it here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub source: Option<String>,
}

/// Parameters for a new disk that will be created
/// alongside the new instance. Either initialize_params or source must be set.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderBootDiskInitializeParams {
    /// Whether this disk is using confidential compute mode.
    /// Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
    /// The image from which to initialize this disk. This can be
    /// one of: the image's self_link, projects/{project}/global/images/{image},
    /// projects/{project}/global/images/family/{family}, global/images/{image},
    /// global/images/family/{family}, family/{family}, {project}/{family},
    /// {project}/{image}, {family}, or {image}. If referred by family, the
    /// images names must include the family name. If they don't, use the
    /// google_compute_image data source.
    /// For instance, the image centos-6-v20180104 includes its family name centos-6.
    /// These images can be referred by family name here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub image: Option<String>,
    /// A map of key/value label pairs to assign to the instance.
    /// Note: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field 'effective_labels' for all of the labels present on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub labels: Option<HashMap<String, String>>,
    /// Indicates how many IOPS to provision for the disk.
    /// This sets the number of I/O operations per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
    /// you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedIops")]
    #[builder(default)]
    pub provisioned_iops: Option<f64>,
    /// Indicates how much throughput to provision for the disk.
    /// This sets the number of throughput mb per second that the disk can handle.
    /// For more details,see the Hyperdisk documentation.
    /// Note: Updating currently is only supported for hyperdisk skus via disk update
    /// api/gcloud without the need to delete and recreate the disk, hyperdisk allows
    /// for an update of throughput every 4 hours. To update your hyperdisk more
    /// frequently, you'll need to manually delete and recreate it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionedThroughput")]
    #[builder(default)]
    pub provisioned_throughput: Option<f64>,
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
    /// The URL of the storage pool in which the new disk is created.
    /// For example:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    #[builder(default)]
    pub storage_pool: Option<String>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Enable Confidential Mode on this VM. Structure is documented below
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderConfidentialInstanceConfig {
    /// Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: SEV, SEV_SNP, TDX. on_host_maintenance can be set to MIGRATE if confidential_instance_type is set to SEV and min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM. If SEV_SNP, currently min_cpu_platform has to be set to "AMD Milan" or this will fail to create the VM. TDX is only available in beta.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confidentialInstanceType")]
    #[builder(default)]
    pub confidential_instance_type: Option<String>,
    /// Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, on_host_maintenance can be set to MIGRATE if min_cpu_platform is set to "AMD Milan". Otherwise, on_host_maintenance has to be set to TERMINATE or this will fail to create the VM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConfidentialCompute")]
    #[builder(default)]
    pub enable_confidential_compute: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderGuestAccelerator {
    /// The number of the guest accelerator cards exposed to this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub count: Option<f64>,
    /// The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderNetworkInterface {
    /// Access configurations, i.e. IPs via which this
    /// instance can be accessed via the Internet. Omit to ensure that the instance
    /// is not accessible from the Internet.g. via
    /// tunnel or because it is running on another cloud instance on that network).
    /// This block can be repeated multiple times. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessConfig")]
    #[builder(default)]
    pub access_config: Option<Vec<InstanceStatusAtProviderNetworkInterfaceAccessConfig>>,
    /// An
    /// array of alias IP ranges for this network interface. Can only be specified for network
    /// interfaces on subnet-mode networks. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aliasIpRange")]
    #[builder(default)]
    pub alias_ip_range: Option<Vec<InstanceStatusAtProviderNetworkInterfaceAliasIpRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalIpv6PrefixLength")]
    #[builder(default)]
    pub internal_ipv6_prefix_length: Option<f64>,
    /// An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
    /// specified, then this instance will have no external IPv6 Internet access. Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessConfig")]
    #[builder(default)]
    pub ipv6_access_config: Option<Vec<InstanceStatusAtProviderNetworkInterfaceIpv6AccessConfig>>,
    /// One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet.
    /// This field is always inherited from its subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6AccessType")]
    #[builder(default)]
    pub ipv6_access_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Address")]
    #[builder(default)]
    pub ipv6_address: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The name or self_link of the network to attach this interface to.
    /// Either network or subnetwork must be provided. If network isn't provided it will
    /// be inferred from the subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub network: Option<String>,
    /// The private IP address to assign to the instance. If
    /// empty, the address will be automatically assigned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkIp")]
    #[builder(default)]
    pub network_ip: Option<String>,
    /// The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nicType")]
    #[builder(default)]
    pub nic_type: Option<String>,
    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueCount")]
    #[builder(default)]
    pub queue_count: Option<f64>,
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stackType")]
    #[builder(default)]
    pub stack_type: Option<String>,
    /// The name or self_link of the subnetwork to attach this
    /// interface to. Either network or subnetwork must be provided. If network isn't provided
    /// it will be inferred from the subnetwork. The subnetwork must exist in the same region this
    /// instance will be created in. If the network resource is in
    /// legacy mode, do not specify this field. If the
    /// network is in auto subnet mode, specifying the subnetwork is optional. If the network is
    /// in custom subnet mode, specifying the subnetwork is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub subnetwork: Option<String>,
    /// The project in which the subnetwork belongs.
    /// If the subnetwork is a self_link, this field is ignored in favor of the project
    /// defined in the subnetwork self_link. If the subnetwork is a name and this
    /// field is not provided, the provider project is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkProject")]
    #[builder(default)]
    pub subnetwork_project: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderNetworkInterfaceAccessConfig {
    /// If the instance has an access config, either the given external ip (in the nat_ip field) or the ephemeral (generated) ip (if you didn't provide one).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natIp")]
    #[builder(default)]
    pub nat_ip: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderNetworkInterfaceAliasIpRange {
    /// The IP CIDR range represented by this alias IP range. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses reserved by
    /// system or used by other network interfaces. This range may be a single IP address
    /// (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipCidrRange")]
    #[builder(default)]
    pub ip_cidr_range: Option<String>,
    /// The subnetwork secondary range name specifying
    /// the secondary range from which to allocate the IP CIDR range for this alias IP
    /// range. If left unspecified, the primary range of the subnetwork will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetworkRangeName")]
    #[builder(default)]
    pub subnetwork_range_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderNetworkInterfaceIpv6AccessConfig {
    /// The first IPv6 address of the external IPv6 range associated
    /// with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig.
    /// To use a static external IP address, it must be unused and in the same region as the instance's zone.
    /// If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6")]
    #[builder(default)]
    pub external_ipv6: Option<String>,
    /// The prefix length of the external IPv6 range.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIpv6PrefixLength")]
    #[builder(default)]
    pub external_ipv6_prefix_length: Option<String>,
    /// A unique name for the resource, required by GCE.
    /// Changing this forces a new resource to be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    /// The service-level to be provided for IPv6 traffic when the
    /// subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkTier")]
    #[builder(default)]
    pub network_tier: Option<String>,
    /// The domain name to be used when creating DNSv6
    /// records for the external IPv6 ranges..
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicPtrDomainName")]
    #[builder(default)]
    pub public_ptr_domain_name: Option<String>,
}

/// os-features, and network_interface.0.nic-type must be GVNIC
/// in order for this setting to take effect.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderNetworkPerformanceConfig {
    /// The egress bandwidth tier to enable.
    /// Possible values: TIER_1, DEFAULT
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalEgressBandwidthTier")]
    #[builder(default)]
    pub total_egress_bandwidth_tier: Option<String>,
}

/// Additional instance parameters.
/// .
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderParams {
    /// A tag is a key-value pair that can be attached to a Google Cloud resource. You can use tags to conditionally allow or deny policies based on whether a resource has a specific tag. This value is not returned by the API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceManagerTags")]
    #[builder(default)]
    pub resource_manager_tags: Option<HashMap<String, String>>,
}

/// Specifies the reservations that this instance can consume from.
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderReservationAffinity {
    /// Specifies the label selector for the reservation to use..
    /// Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specificReservation")]
    #[builder(default)]
    pub specific_reservation: Option<InstanceStatusAtProviderReservationAffinitySpecificReservation>,
    /// The type of reservation from which this instance can consume resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    #[builder(default)]
    pub r#type: Option<String>,
}

/// Specifies the label selector for the reservation to use..
/// Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderReservationAffinitySpecificReservation {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// The scheduling strategy to use. More details about
/// this configuration option are detailed below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderScheduling {
    /// Specifies if the instance should be
    /// restarted if it was terminated by Compute Engine (not a user).
    /// Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automaticRestart")]
    #[builder(default)]
    pub automatic_restart: Option<bool>,
    /// Describe the type of termination action for VM. Can be STOP or DELETE.  Read more on here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTerminationAction")]
    #[builder(default)]
    pub instance_termination_action: Option<String>,
    /// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
    /// The local_ssd_recovery_timeout block supports:
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localSsdRecoveryTimeout")]
    #[builder(default)]
    pub local_ssd_recovery_timeout: Option<InstanceStatusAtProviderSchedulingLocalSsdRecoveryTimeout>,
    /// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRunDuration")]
    #[builder(default)]
    pub max_run_duration: Option<InstanceStatusAtProviderSchedulingMaxRunDuration>,
    /// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minNodeCpus")]
    #[builder(default)]
    pub min_node_cpus: Option<f64>,
    /// Specifies node affinities or anti-affinities
    /// to determine which sole-tenant nodes your instances and managed instance
    /// groups will use as host systems. Read more on sole-tenant node creation
    /// here.
    /// Structure documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinities")]
    #[builder(default)]
    pub node_affinities: Option<Vec<InstanceStatusAtProviderSchedulingNodeAffinities>>,
    /// Describes maintenance behavior for the
    /// instance. Can be MIGRATE or TERMINATE, for more info, read
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onHostMaintenance")]
    #[builder(default)]
    pub on_host_maintenance: Option<String>,
    /// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onInstanceStopAction")]
    #[builder(default)]
    pub on_instance_stop_action: Option<InstanceStatusAtProviderSchedulingOnInstanceStopAction>,
    /// Specifies if the instance is preemptible.
    /// If this field is set to true, then automatic_restart must be
    /// set to false.  Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preemptible: Option<bool>,
    /// Describe the type of preemptible VM. This field accepts the value STANDARD or SPOT. If the value is STANDARD, there will be no discount. If this   is set to SPOT,
    /// preemptible should be true and automatic_restart should be
    /// false. For more info about
    /// SPOT, read here
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningModel")]
    #[builder(default)]
    pub provisioning_model: Option<String>,
}

/// io/docs/providers/google/guides/provider_versions.html) Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour. Structure is documented below.
/// The local_ssd_recovery_timeout block supports:
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderSchedulingLocalSsdRecoveryTimeout {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

/// The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in instance_termination_action. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderSchedulingMaxRunDuration {
    /// Span of time that's a fraction of a second at nanosecond
    /// resolution. Durations less than one second are represented with a 0
    /// seconds field and a positive nanos field. Must be from 0 to
    /// 999,999,999 inclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub nanos: Option<f64>,
    /// Span of time at a resolution of a second. Must be from 0 to
    /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
    /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seconds: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderSchedulingNodeAffinities {
    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub key: Option<String>,
    /// The operator. Can be IN for node-affinities
    /// or NOT_IN for anti-affinities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub operator: Option<String>,
    /// Corresponds to the label values of a reservation resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub values: Option<Vec<String>>,
}

/// Specifies the action to be performed when the instance is terminated using max_run_duration and STOP instance_termination_action. Only support true discard_local_ssd at this point. Structure is documented below.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderSchedulingOnInstanceStopAction {
    /// Whether to discard local SSDs attached to the VM while terminating using max_run_duration. Only supports true at this point.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsd")]
    #[builder(default)]
    pub discard_local_ssd: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderScratchDisk {
    /// Name with which attached disk will be accessible.
    /// On the instance, this device will be /dev/disk/by-id/google-{{device_name}}.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    #[builder(default)]
    pub device_name: Option<String>,
    /// The disk interface to use for attaching this disk; either SCSI or NVME.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub interface: Option<String>,
    /// The size of the image in gigabytes. If not specified, it
    /// will inherit the size of its base image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<f64>,
}

/// Service account to attach to the instance.
/// Structure is documented below.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderServiceAccount {
    /// The service account e-mail address.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
    /// A list of service scopes. Both OAuth2 URLs and gcloud
    /// short names are supported. To allow full access to all Cloud APIs, use the
    /// cloud-platform scope. See a complete list of scopes here.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}

/// Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.
/// Note: shielded_instance_config can only be used with boot images with shielded vm support. See the complete list here.
/// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
#[derive(Serialize, Deserialize, Clone, Debug, TypedBuilder, JsonSchema)]
#[builder(field_defaults(setter(strip_option(ignore_invalid))))]
pub struct InstanceStatusAtProviderShieldedInstanceConfig {
    /// - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIntegrityMonitoring")]
    #[builder(default)]
    pub enable_integrity_monitoring: Option<bool>,
    /// - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSecureBoot")]
    #[builder(default)]
    pub enable_secure_boot: Option<bool>,
    /// - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
    /// Note: allow_stopping_for_update must be set to true or your instance must have a desired_status of TERMINATED in order to update this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableVtpm")]
    #[builder(default)]
    pub enable_vtpm: Option<bool>,
}

